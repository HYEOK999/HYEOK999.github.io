{"meta":{"title":"HYEOK999's Blog","subtitle":"HYEOK999's Daily Develop","description":null,"author":"Jun Hyeok Kim","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"linux-study-02","slug":"linux-study-02","date":"2019-09-30T08:23:37.000Z","updated":"2019-09-30T08:23:55.744Z","comments":true,"path":"2019/09/30/linux-study-02/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-02/","excerpt":"","text":"[Input/Output] IO Redirection Output : 출력 redirection -&gt; 출력위치를 변경할 수 있다. (보통은 모니터)​ 예) ls -l &gt; result.txt = ls -l의 결과(Standard Output)를 result.txt에 저장한다. ​ 총 2가지의 Output 이 존재한다. Success : 성공했을 경우의 Output Error : 실패했을 경우의 Output Standard Output으로 redirection 하는 방법 : 1&gt; Error Output으로 redirection 하는 방법 : 2&gt; ex) rm rename2.tex 1&gt;result.txt 2&gt;result.txt Input : 입력 redirectionStandard Input : keyboard 예) hello.txt 안에는 hello 라는 텍스트가 저장되어있다. 만약에 hello.txt파일 안의 내용을 cat으로 출력하고 싶다면 다음과 같이 작성한다. cat &lt; hello.txt cat hello.txt IO Redirection Ouput Appendls -al &gt; result.txt 할 경우 result.txt로 결과가 저장된다. 그 후 ls -a &gt; result.txt할 경우 result.txt로 결과가 덮어씌우게 된다 만약 추가를 하고 싶다면 다음과 같이 사용해야만 한다. ls -al &gt;&gt; result.txt","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux-study-01","slug":"linux-study-01","date":"2019-09-30T06:44:47.000Z","updated":"2019-09-30T08:23:17.371Z","comments":true,"path":"2019/09/30/linux-study-01/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-01/","excerpt":"","text":"리눅스 명령어 리눅스의 특징 : command line interface ls : 파일보기 ​ 옵션 -l : 파일권한, 소유자,생성시간등의 자세한 정보를 추가로 나열해준다. pwd : 현재 놓여있는 디렉토리를 파악한다. mkdir : 폴더생성 touch [파일명] : 파일생성 cd [디렉토리명] : 현재 디렉토리 위치 변경 ​ 디렉토리 변경시 2가지 방법이 있다. 절대경로 예) cd /home/ubuntu. =&gt; / : root를 의미한다. 상대경로 예) cd .. =&gt; 상대경로는 내 위치에 따라서 위치를 조정하는것. rm [파일 명] : 파일 삭제 명령어 rm -r [파일명] : 폴더 삭제 명령어 모든 명령어 뒤 –version : 해당 명령어의 버전을 알려준다. 모든 명령어 뒤 –help : 명령에 무슨 옵션이 있는지, 어떠한 기능을 하는지 설명 도움말을 보여준다. man [명령어명] : 예) man ls man 내부 상세 단어 검색 : 예) /sort : sort라는 단어 검색 -&gt; 넘기는 방법은 n키 누르면 됨. 돌아가는 방법은 b키 누르면 됨. man과 –help의 차이 : help는 간결하게 명령어의 기능및 옵션 / man은 상세하게 보여준다. mkdir -p [파일명] : 예) mkdir -p dir1/dir2/dir3/dir4 -&gt; 부모 디렉토리를 만들수 있다. 옵션 -는 축약형 –는 기본형 ex) mkdir -p / mkdir –parent 숨긴파일은 파일명 앞에 . 이 붙는다. 숨긴파일을 보는 방법은 ls -a / ls –all 옵션으로 보면 된다. mv [원본파일] [이동위치 또는 변경할 파일명] cp [원본파일] [대상위치] 명령어 검색방법구글에서 검색한다. 예) 구글에서 create a directory in linux sudo : 임시로 권리자 권한을 빌려온다. sudo는 super user do 의 약자로 권리자 권한을 의미함. 제일 심각한 명령어 : sudo rm -rf / =&gt; 묻지도 따지지않고 루트디렉토리 전부 삭제 sudo [command] 권한만 빌림. su - : root계정으로 전환함. Package manager ( 리눅스 apt / yum)​ 보통 권한이 필요하기 때문에 sudo를 사용해야만 한다. sudo apt-get update : 현재 사용할 수 있는 패키지들의 목록을 최신상태로 업데이트한다. sudo apt-get install [패키지명] : 패키지를 다운로드 받는다. sudo apt-get upgrade [패키지명] : 패키지를 최신상태로 업데이트 한다. 패키지명 생략시 모든 패키지를 업데이트 한다. sudo apt-get remove [패키지명]: 패키지를 삭제한다. sudo apt-cache search [패키지명]: [패키지명]와 관련된 패키지 목록을 보여준다. homebrew ( 맥용 )​ 맥에서 주로 사용하는 패키지 매니저 brew search [패키지명] : [패키지명]과 관련된 패키지 목록을 보여준다. brew install [패키지명] : [패키지명]과 관련된 패키지를 다운받는다. brew list : 로컬에서 homebrew를 통해 설치한 패키지목록을 표시해준다. brew uninstall [패키지명] : [패키지명]을 삭제한다. brew upgrade [패키지명] : [패키지명]을 업데이트한다. brew update : homebrew로 사용가능한 패키지들의 목록을 업데이트한다. 리눅스 명령어 기반에서 다운로드 받는 방법 : wget​ 다운로드 받을 프로그램이 필요하다. ( wget 이용 ) wget url주소 : 파일명 그대로 받게됨. wget -O [파일명] url주소 오픈소스 다운로드 방법 : git​ 맘에 드는 git 주소 들어가서 git clone~","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"VSCode-hotkey","slug":"VSCode-hotkey","date":"2019-09-30T06:44:10.000Z","updated":"2019-09-30T08:38:58.732Z","comments":true,"path":"2019/09/30/VSCode-hotkey/","link":"","permalink":"http://yoursite.com/2019/09/30/VSCode-hotkey/","excerpt":"","text":"VS 단축키(MAC은 command = ctrl / option = alt) shift + option + f : 전체 줄 정리 option + command + 화살표 : 다중 커서 라인 생성 option + command + g : 개별 약어 랩핑 ctrl + n : 파일 생성 ctrl + s : 저장 ctrl + b : 사이드 바 열기 ctrl + p : 시작 팔레트 ctrl + shift + P : 명령 팔레트 ctrl + shift + k : 그 줄 삭제 ctrl + F : 찾기(검색) ctrl + H : 찾기(검색)/바꾸기(대체) ctrl + / : 주석 Alt + Up : 해당 코드 줄 위로 이동 Alt + Down : 해당 코드 줄 아래로 이동 shift + alt + DownArrow : 아래 줄 복사 tab : 들여쓰기 shift + tab : 내어쓰기 ctrl + PageUp : 이전 편집기 열기(좌측 창으로 전환) ctrl + PageDown : 다음 편집기 열기 (우측 창으로 전환) ctrl + \\ : 편집기 분할(백슬래쉬) ctrl + 숫자 : 숫자 번째 분할된 편집기 그룹에 포커스 ctrl + W : 편집기 닫기 ! + enter : 기본적인 HTML","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"TIL","slug":"Develop/TIL","permalink":"http://yoursite.com/categories/Develop/TIL/"},{"name":"Algorism","slug":"Develop/TIL/Algorism","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/"},{"name":"HTML","slug":"Develop/TIL/Algorism/HTML","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/"},{"name":"CSS","slug":"Develop/TIL/Algorism/HTML/CSS","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/CSS/"},{"name":"Javascript","slug":"Develop/TIL/Algorism/HTML/CSS/Javascript","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/CSS/Javascript/"},{"name":"Etc","slug":"Develop/TIL/Algorism/HTML/CSS/Javascript/Etc","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/CSS/Javascript/Etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"CSS-inline-block","slug":"CSS-inline-block","date":"2019-09-30T06:43:15.000Z","updated":"2019-09-30T06:43:15.357Z","comments":true,"path":"2019/09/30/CSS-inline-block/","link":"","permalink":"http://yoursite.com/2019/09/30/CSS-inline-block/","excerpt":"","text":"","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"TIL","slug":"Develop/TIL","permalink":"http://yoursite.com/categories/Develop/TIL/"},{"name":"Algorism","slug":"Develop/TIL/Algorism","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/"},{"name":"HTML","slug":"Develop/TIL/Algorism/HTML","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/"},{"name":"CSS","slug":"Develop/TIL/Algorism/HTML/CSS","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/CSS/"},{"name":"Javascript","slug":"Develop/TIL/Algorism/HTML/CSS/Javascript","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/CSS/Javascript/"},{"name":"Etc","slug":"Develop/TIL/Algorism/HTML/CSS/Javascript/Etc","permalink":"http://yoursite.com/categories/Develop/TIL/Algorism/HTML/CSS/Javascript/Etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"html-css-study-13","slug":"html-css-study-13","date":"2019-09-28T08:01:51.000Z","updated":"2019-09-28T12:40:57.038Z","comments":true,"path":"2019/09/28/html-css-study-13/","link":"","permalink":"http://yoursite.com/2019/09/28/html-css-study-13/","excerpt":"","text":"HTML Study 13 css : filter ( 흑백처리 , blur 효과 등등 ) tab-index margin 겹침 현상 background size 중앙 정렬 처리하는 방법 (수직 정렬등) aria-label , aria-labelby ( vs title ) aria-expended , aria-haspopup iframe 사용시 주의점 fr 단위 반응형 디자인을 할때는 px보다는 em, rem같은 단위를 써야 유연해지기에 좋다. grid에서는 fr단위로 쉽게 조절이 가능하다. 수직중앙정렬시 translateY : -50%를 이용한다. iframe은 퍼올때부터 대부분 사이즈가 지정이 되어있으므로 유동적인 사이즈를 맞추려면 div로 한번더 감싼다. css : filter ( 흑백처리 , blur 효과 등등 ) filter 기능은 이미지를 흑백처리하거나 blur, 반전, 밝기 조절등의 효과를 넣는 것을 말한다. 포토샵만큼 디테일하게 효과를 줄 수는 없으나, CSS로 간단한 효과정도는 줄 수 있다. 12345678910/* 사용 방법 : 선택자 &#123;filter:효과이름(값)&#125; */ .blur &#123;filter:blur(20px);-webkit-filter:blur(20px);&#125; .grayscale &#123;filter:grayscale(100%);-webkit-filter:grayscale(100%);&#125; .sepia &#123;filter:sepia(100%);-webkit-filter:sepia(100%);&#125; .saturate &#123;filter:saturate(10);-webkit-filter:saturate(10);&#125; .hue-rotate &#123;filter:hue-rotate(100deg);-webkit-filter:hue-rotate(100deg);&#125; .invert &#123;filter:invert(10);-webkit-filter:invert(10);&#125; .opacity &#123;filter:opacity(0.5);-webkit-filter:opacity(0.5);&#125; .brightness &#123;filter:brightness(5);-webkit-filter:brightness(5);&#125; tab-index 처리 div, span 와 같은 focus 초점을 받지 못하는 요소나 혹은 foucs를 받는 요소에게 fouc를 빼앗는 역할을 부여 할 수 있다. tabindex=”1” : 문서 안에서 가장 먼저 초점을 받게 할 수 있다. (주의점 : 마크업 순서를 거스르기 때문에, autofocusr가 더 적합) tabindex=”0” : 키보드 초점을 받지 못하는 요소들( div, span 등등) 도 초점을 받도록 해준다. tabindex=”-1” : 키보드 초점을 받는 요소에게서 초점을 받지 못하도록 만든다. 123&lt;div class=\"test\" tabindex=\"0\"&gt; 초점을 받을 수 있게 된다.&lt;/div margin 겹침 현상 기본적으로 형제 사이에서 일어난다. (이 현상은 오직 세로 margin값에서 일어난다.) 부모 ~ 자식 간에서도 겹침 현상이 발생한다. (둘 중 하나 이상 inline block일때는 겹치지 않는다.) 이를 가장 쉽게 해결하는 방법은 부모에게 글자추가, border 혹은 padding,와 같은 시각적효과를 적용하면 해결된다. position:absolute / float / grid 와 같은 레이아웃 작업은 margin이 발생하지 않는다. background-size​ background에 url 형태로 이미지를 불러들였을 경우, 만약 이미지 크기가 맞지 않다면 background-size를 상자 크기에 맞게 조절하면 된다. ( 보통 100% 로 조절. ) 중앙 정렬 처리하는 방법가로 정렬은 보통 text-align , vertical-align 등을 통해 쉽게 배치가 가능하다. 하지만 가운데 정렬은 배치를 하기 위해서는 padding 값이나 margin값을 정적으로 계산해야만 한다. 하지만 위와 같은 방법을 이용한다면 쉽게 배치가 가능하다. 보통 absolute를 이용하여 많이 배치한다. 12345.header&#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; aria-label / aria-labelledbyaria-label 속성은 값에 ‘간결한’ 설명(string)을 직접 제공한다. 마치 해당 태그가 무슨 역할을 하는지 설명하듯 설명문을 적어주는것과 같다. 예를들면 다음과 같다. 12345&lt;!-- O: 참조할 설명이 없는 경우 --&gt;&lt;form&gt; &lt;input type=\"search\" aria-label=\"웹툰 검색\"&gt; &lt;button&gt;검색&lt;/button&gt;&lt;/form&gt; aria-labelledby 속성은 ID(s) 값을 이용하여 ‘간결한’ 내용을 참조(연결)하는 방식으로 설명한다. 보통 h1, h2, h3, h4, h5, h6, a, button 요소를 참조하면 적절하다. aria-label 속성과 함께 선언하는 경우 aria-labelledby 속성이 우선순위가 높기 때문에 보조기기는 aria-labelledby 속성을 설명한다. 예를들면 다음과 같다. 123456789101112&lt;!-- O: 설명 참조 --&gt;&lt;section aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;h2 id=\"LZ-PATH\"&gt;레진패스란?&lt;/h2&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/section&gt;&lt;!-- O: 잘못된 참조 --&gt;&lt;a id=\"LZ-PATH\" href=\"#LZ-PATH-TEXT\"&gt;레진패스란?&lt;/a&gt;&lt;!-- 숨긴처리된 설명은 참조해서는 안된다. --&gt;&lt;div id=\"LZ-PATH-TEXT\" aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/div&gt; aria-labelledby 속성으로 숨김 처리한 설명을 참조하면 안 됩니다. 참조가 불가능한 설명은 aria-label 속성을 사용한다. 자세한 설명을 참조하면 안 된다다. 자세한 설명은 aria-descibedby 속성을 사용. aria-expanded 애플리케이션에서 제공되는 메뉴가 하위 메뉴를 포함하고 있 을 경우 현재 하위 메뉴가 접힌 상태인지 펼쳐진 상태인지 스크린리더 사용자에게 정보를 제공 해야 할 경우가 있다. 이때 aria-expanded 속성을 사용하여 접힌 상태라면 false 값을 펼쳐진 상태라면 true 값을 지정할 수 있다. aria-haspopup레진 블로그 설명 aria-haspopup 속성은 요소에 연결되어 있는 팝업(메뉴, 대화상자 등) 정보를 제공한다. 팝업은 다른 내용 위에 표시하는 블럭을 의미한다. iframe 사용시 주의점 iframe 태그는 하나의 html 로 생각해야만 한다. 따라서 iframe 태그 자체를 width, height등을 이용해 유연한 배치를 할 수 없다. 만약에 iframe 의 크기를 조절하고 싶다면 div태그로 1번더 감싸야만 한다. 그리고서 해당 div에 absolute를 거는 방식을 이용한다. 12345678910111213141516171819202122232425&lt;style&gt; .responsive-container&#123; position: relative; width: 100%; height: 0 !important; &#125; .responsive-iframe&#123; position: absolute; top:0; left:0; width: 100%; height: 100%; border: 0 none; &#125; .responsive-iframe-43&#123; padding-top: 75%; &#125; .responsive-iframe-169&#123; padding-top: 56.25%; &#125;&lt;/style&gt;&lt;div class=\"responsive-container responsive-iframe-169\"&gt; &lt;iframe aria-labelledby=\"video-subject\" class=\"responsive-iframe\" src=\"https://www.youtube.com/embed/umfaXctbqOs\"allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt; fr 단위fr이란 유연한 크기를 갖는 단위이다.grid 컨테이너 내의 공간 비율을 분수(fraction)로 나타낸다. 다만, 지원 브라우저가 낮다. 사용자가 계산해야 할 부분을 fr을 통해서 쉽고 유연하게 사용할 수 있다. 1234.grid &#123; display: grid; grid-template-columns: auto 100px 1fr 2fr;&#125; 1번 열은 auto를 사용한다. 해당 Element 내부 콘텐츠에 맞게 사이즈가 조정된다. 2번 열은 100px을 할당한다. 100픽셀 크기만큼의 폭을 차지한다. 3번 열은 1fr 크기를 할당한다. 1fr이란 남은 자유 공간의 1/3(총fr)만큼의 크기를 할당한다. 4번 열은 2fr 크기를 할당한다. 2fr이란 남은 자유 공간의 2/3(총fr)만큼의 크기를 할당한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-12","slug":"html-css-study-12","date":"2019-09-24T16:56:09.000Z","updated":"2019-09-24T17:15:40.643Z","comments":true,"path":"2019/09/25/html-css-study-12/","link":"","permalink":"http://yoursite.com/2019/09/25/html-css-study-12/","excerpt":"","text":"HTML Study 12 webfont 정리 flex 재정리 white-space 속성 - pre , pre-wrap, pre-line 프로젝트 하면서 느낀점 9월 24일 webfont 정리 웹폰트를 사용하기 위해서는 다음과 같은 코드들이 일부 필요하다. 123456789101112131415@font-face &#123; font-family: NanumSquareWeb; src: local(NanumSquareR), local(NanumSquare), url(NanumSquareR.eot?#iefix) format('embedded-opentype'), url(NanumSquareR.woff) format('woff'), url(NanumSquareR.ttf) format('truetype'); font-style: normal; font-weight: normal; unicode-range: U+0-10FFFF;&#125; h1 &#123; font-family: NanumSquareWeb, sans-serif;&#125; 내가 사용할 웹폰트 패밀리명을 NanumSquareWeb으로 하겠다. 라고 선언한 예이다. 반드시는 아니지만, font-family 명과 사용할 폰트명을 동일시하게 하는 것 이 좋다. 로컬에 이미 설치 된 폰트의 경로를 적는 local() 속성과 다운로드 할 웹폰트의 주소를 적는 url() 속성이다. 위 코드는 local(NanumSquareR) → local(NanumSquare) → url(NanumSquareR.eot) → url(NanumSquareR.woff) → url(NanumSquareR.ttf) 순으로 폰트를 찾는다. format 속성을 사용하면 브라우저에서 지원 가능한 파일만 다운로드 받을 수 있습니다. 사용할 유니코드의 범위를 정한다. flex 재정리 (TCP 스쿨 내용 재정리)flex-direction 속성flex-direction 속성은 플렉스 컨테이너 안에서 플렉스 요소가 배치될 방향을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. row : 기본 설정으로, 플렉스 요소는 왼쪽에서 오른쪽으로, 그리고 위쪽에서 아래쪽으로 배치됩니다. row-reverse : 만약에 direction 속성값이 ltr(left-to-right)이면, 플렉스 요소는 반대로 오른쪽에서 왼쪽으로 배치됩니다. column : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 위쪽에서 아래쪽으로 배치됩니다. column-reverse : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 아래쪽에서 위쪽으로 배치됩니다. justify-content 속성justify-content 속성은 플렉스 요소의 수평 방향 정렬 방식을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. flex-start : 기본 설정으로, 플렉스 요소는 플렉스 컨테이너의 앞쪽에서부터 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 뒤쪽에서부터 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에서부터 배치됩니다. space-between : 플렉스 요소는 요소들 사이에만 여유 공간을 두고 배치됩니다. space-around : 플렉스 요소는 앞, 뒤, 그리고 요소들 사이에도 모두 여유 공간을 두고 배치됩니다. align-items 속성align-items 속성은 플렉스 요소의 수직 방향 정렬 방식을 설정합니다. 이 속성은 한 줄만을 가지는 플렉스 박스에서는 효과가 없으며, 두 줄 이상을 가지는 플렉스 박스에서만 효과가 있습니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 요소의 높이가 플렉스 컨테이너의 높이와 같게 변경된 뒤 연이어 배치됩니다. flex-start : 플렉스 요소는 플렉스 컨테이너의 위쪽에 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 아래쪽에 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에 배치됩니다. baseline : 플렉스 요소는 플렉스 컨테이너의 기준선(baseline)에 배치됩니다. flex-wrap 속성flex-wrap 속성은 플렉스 라인에 더 이상의 여유 공간이 없을 때, 플렉스 요소의 위치를 다음 줄로 넘길지를 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. nowrap : 기본 설정으로, 플렉스 요소가 다음 줄로 넘어가지 않습니다. 대신에 플렉스 요소의 너비를 줄여서 한 줄에 모두 배치시킵니다. wrap : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. wrap-reverse : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. 단, 아래쪽이 아닌 위쪽으로 넘어갑니다. align-content 속성align-content 속성은 flex-wrap 속성의 동작을 변경할 수 있습니다. 이 속성은 align-items 속성과 비슷한 동작을 하지만, 플렉스 요소를 정렬하는 대신에 플렉스 라인을 정렬합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 라인의 높이가 남는 공간을 전부 차지하게 됩니다. flex-start : 플렉스 라인은 플렉스 컨테이너의 앞쪽에 뭉치게 됩니다. flex-end : 플렉스 라인은 플렉스 컨테이너의 뒤쪽에 뭉치게 됩니다. center : 플렉스 라인은 플렉스 컨테이너의 가운데에 뭉치게 됩니다. space-between : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. space-around : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. 단, 양쪽 끝에 약간의 공간을 남겨둡니다. 플렉스 요소(flex item)의 flex 속성flex 속성을 이용하면 같은 플렉스 컨테이너 안에 있는 플렉스 요소의 너비를 상대적으로 설정할 수 있습니다. 다음 예제에서 첫 번째 플렉스 요소는 전체 너비의 3/5을 차지하며, 나머지 두 요소는 각각 전체 너비의 1/5씩을 차지하게 됩니다. 123.item:nth-child(1) &#123; -webkit-flex: 3; flex: 3; &#125;.item:nth-child(2) &#123; -webkit-flex: 1; flex: 1; &#125;.item:nth-child(3) &#123; -webkit-flex: 1; flex: 1; &#125; white-space 속성 - pre , pre-wrap, pre-line normal : 기본값. 공백을 여러개 넣어도 공백 1개만 인정. 자동줄바꿈. nowrap : 공백 1개만 인정. 텍스트가 길어도 줄바꿈이 안됨. pre : 공백을 마크업 그대로 표시. 코드에 줄바꿈이 없다면 줄바꿈이 안됨. pre-wrap : 공백을 마크업 그대로 표시함. 코드에 줄바꿈이 없어서 코드따라 줄바꿈됨. pre-line : 공백을 여러개 넣어도 1개만 표시. 코드에 불바꿈이 없어도 자동 줄바꿈이 됨. 프로젝트 하면서 느낀점 9월 24일 내가 모르는 태그들이 정말로 많다. layout 작업시 큰 틀에 대한 width를 전부 지정해주어야한다. 작은 틀을 맞추고 싶다면 width값을 100%로 큰틀에 대해 맞춘다. 최대한 그려가면서 레이아웃 작업을 진행해야 될 것 같음. 조언을 아끼지 말아라. (구하는 조언도, 모르는 조언도) 남들보다 1개더 안다면 1개더 배풀고 더 모른다면 알 떄까지 노력할 것. 암기보다 이해가 먼저고 이해가 정 안될 경우 암기한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-11","slug":"html-css-study-11","date":"2019-09-23T17:25:10.000Z","updated":"2019-09-23T17:37:53.432Z","comments":true,"path":"2019/09/24/html-css-study-11/","link":"","permalink":"http://yoursite.com/2019/09/24/html-css-study-11/","excerpt":"","text":"HTML Study 11 fontello 사용법 letter, word spacing transition 사용 주의점 프로젝트 하면서 느낀점 9월 23일 fontello 사용법 fontello 사용법 fontello 접속 마음에 드는 fontello 아이콘들 선택(라이센스 주의) 다운로드 다운로드 된 압출파일을 해제 해제된 폴더를 프로젝트에 붙여넣는다.(가급적이면 폴더 네임수정 - 지저분함) CSS파일에 다음과 같이 넣어준다. 12345678@import url('./fontello/css/fontello.css'); /*import*//*사용 방법*/.header::after&#123; content: '\\e805'; font-family: \"fontello\";&#125; letter , word spacing 글자 사이의 간격은 letter-spacing으로, 단어 사이의 간격은 word-spacing으로 정한다. 값이 커지면 간격이 커진다. 값에는 음수를 넣을 수 있다. ( 마이크로소프트 엣지나 인터넷 익스플로러에서는 단어 사이의 간격을 음수로 정해도 글자가 겹치지 않을 정도로만 간격이 줄어든다.) 음수를 값으로 하는 경우 글자가 겹칠 수 있다. 글자 사이의 간격을 변화시키면 단어 사이의 간격도 변한다. 단어 사이의 간격을 변화시켜도 글자 사이의 간격은 변하지 않는다. transition 사용 주의점​ transition 사용시 초(s) 단위를 붙일 경우, 0일떄 s를 생략하면 작동을 안한다. ​ 꼭 유의 하고 사용할 것. 프로젝트 하면서 느낀점 막히면 차분히 무엇이 문제인지 돌아보고 꼭 구조적으로 해결하기 보다는 작은부분부터 수정해 나가기. 개발 도중 정적이니 동적이니 반응형이니 고정형이니 생각하지 말고 현재 주어진 디자인만 생각하기. 레이아웃 설계는 가능한 그리면서 진행하기. (나중에 레이아웃을 뒤엎는 경우가 생긴다.) flex , float , absolute , grid 특성에 대해서 다시 한번 공부하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"CSS-Selector-Organize","slug":"CSS-Selector-Organize","date":"2019-09-22T16:12:32.000Z","updated":"2019-09-22T16:15:18.155Z","comments":true,"path":"2019/09/23/CSS-Selector-Organize/","link":"","permalink":"http://yoursite.com/2019/09/23/CSS-Selector-Organize/","excerpt":"","text":"CSS 선택자 정리 Etc 참고 : CSS 선택자 총 정리 사이트","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://yoursite.com/tags/Selector/"}]},{"title":"html-css-study-10","slug":"html-css-study-10","date":"2019-09-21T10:58:02.000Z","updated":"2019-09-21T22:59:52.963Z","comments":true,"path":"2019/09/21/html-css-study-10/","link":"","permalink":"http://yoursite.com/2019/09/21/html-css-study-10/","excerpt":"","text":"HTML Study 10 viewport VS % calc flex-basis 반응형 웹페이지 flex 이용 반응형 콘텐츠 -&gt; 이미지&amp;비디오 , iframe grid 이용 오늘의 학습 깨달음 레이아웃 구성 시 여라가지 flex 나 grid시스템을 사용할 수 있지만, 브라우저의 지원 유형을 잘 생각해보아야 한다. padding의 %는 width 기준이다. 즉, 가로의 %기준 만큼 패딩이 늘어난다. iframe은 이미지처럼 max-width 옵션이 작동안한다. 최대 넓이가 1600px 이상 넘어갔을 경우 화면 중앙으로 오게하는 방법 12max-width: 1600px;margin: 0 auto; viewport VS % viewport 는 화면대비 %비율이라 생각하면 편하고, %는 부모영역대비의 %비율이라 생각하면 편하다. 한, 예로 %는 부모영역보다 크게 %를 주어도 부모영역을 벗어날수는 없지만 viewport는 자식요소에 더 큰 viewport값을 줄 경우 부모요소를 넘어갈 수 있다. 초록색 영역이 %비율이고, 보라색 영역이 viewport 이다. calc 단순하게 생각하여, 사칙연산을 실행하고 계산값을 돌려주는 함수이다. calc(100vh - 100px); 와 같이 사용한다. flex-basis flex item이 된 컨텐츠들에게 적용할 수 있는 flex속성이다. flex-basis각 적용될 경우 기본 width값은 무의미하다. flex item이 적용된 width , height를 사용하고 싶다면 flex:auto 를 지정해주어야한다. flex-basis를 생략해면 flex-basis:auto 가 된다. flex-basis:0 과 flex-basis:auto의 차이는 auto는 width 만큼 item을 관리하며, flex-basis는 진짜 item 사이즈를 0으로 만든다. 단, 텍스트같은 콘텐츠가 있을 경우 콘텐츠 크기 만큼 줄게된다. flex-grow는 기본값이 0 / flex-shrink는 기본값이 1이다. 반응형 웹페이지 반응형 웹페이지는 말 그대로 유동적으로 변화가 가능한 웹페이지를 의미한다. 현재 시대는 모바일 , 테블릿 , 데스크탑 과 같은 여러가지 화면을 다루고 있기 때문에 유동적으로 각 기기에 맞는 화면을 송출할 줄 알아야만 한다. 반응형 웹페이지 제작시 주로 다음과 같이 이용한다. @media screen and (길이){ ​ 변할값 } 123456@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; width : 850px; &#125;&#125; 위 웹페이지의 fontsize가 16px이라 가정을 지었을 경우. 799px에서 800px로 넘어가는 순간 header 부분의 width가 850px로 넘어간다. 보통의 웹페이지는 flex,grid같은 시스템을 이용하여 min-width:800px (50em) / min-width:1024px (64em) / min-width:1600px (100em) [font-size : 16px기준] 로 설정해서 반응형을 많이 구축한다. flex 이용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* 모바일 스타일 */ /* 모바일 헤더 */ .header&#123; /* grow shrink basis */ flex-basis: 100%; height: 50px; &#125; /* 모바일 네비게이션 */ .navigation&#123; height: 50px; flex-basis: 100%; &#125; /* 모바일 메인 콘텐츠 */ .main-content&#123; height: calc(100vh - 200px); flex-basis: 100%; &#125; /* 모바일 광고 */ .ad&#123; flex-basis: 100%; height: 50px; &#125; /* 모바일 푸터 */ .footer&#123; flex-basis:100%; height: 50px; &#125;/* 테블릿 스타일 *//* 50em -&gt; 50글자까지 , 폰트사이즈 16px일경우 800px까지 */@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; flex-basis: 70%; &#125; /* 800 네비게이션 */ .navigation&#123; flex-basis:30%; &#125; /* 800 메인 콘텐츠 */ .main-content&#123; flex-basis:100%; height: calc(100vh - 150px); &#125; /* Tablet 레이아웃 순서 */ .header, .navigation, .ad&#123; order: -1; &#125;&#125;/* 랩탑 스타일 */@media screen and (min-width:64em)&#123; /* 랩탑 순서 */ .navigation&#123; order: -2; &#125; /* 랩탑 헤더 */ .header&#123; flex-basis: 100%; &#125; /* Laptop 내비게이션 */ .navigation&#123; flex-basis: 100%; &#125; /* 랩탑 메인 콘텐츠 */ .main-content&#123; flex-basis: 70%; &#125; /* 랩탑 광고 */ .ad&#123; flex-basis: 30%; height: calc(100vh - 150px); &#125;&#125;/* 와이드 랩탑 스타일 */@media screen and (min-width:100em)&#123; /* 와이드 랩탑 헤더 */ .navigation, .ad&#123; order: 0; &#125; .navigation, .main-content, .ad&#123; height: calc(100vh - 100px); &#125; /* 와이드 네비게이션 */ .navigation&#123; flex-basis: 30%; &#125; /* wide 메인 콘텐츠 */ .main-content&#123; flex-basis: 50%; &#125; /* wide 광고 */ .ad&#123; flex-basis: 20%; &#125;&#125; 반응형 콘텐츠 : 이미지&amp;비디오이미지 소스(비디오도 동작방식은 같다.) 1234567891011121314151617181920@charset \"utf-8\";/* 반응형 이미지 */.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; flex-basis: 50%; border: 10px solid #aaa; box-sizing: border-box; margin: 0; padding: 0;&#125;.rwd-img&#123; max-width: 100%; height: auto;&#125; 반응형 콘텐츠 : iframeiframe은 비디오와는 다르게 화면 비율에 대해 신경을 써주어야만 한다. 1234567891011121314151617181920212223242526 &lt;div class=\"container\"&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rNDmpbs4JTc\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\"width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nSHs3241p7E\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Vtj-T2c6jf0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/G-12mgNUwh0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233@charset \"utf-8\";.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; border: 10px solid teal; box-sizing: border-box; margin: 0; padding : 0; flex-basis: 30%; flex-grow : 1;&#125;.rwd-iframe-container&#123; width: 100%; padding-top: 56.25%; height: 0 !important; background: yellow; position: relative;&#125;.rwd-iframe&#123; /* iframe은 이미지처럼 max-width 옵션이 작동안한다. */ max-width: 100%; height: auto; position: absolute; top : 0; left : 0; width: 100%; height: 100%;&#125; grid 이용grid시스템 이용시 Chrome 보다는 firefox에서 확인한는게 더 편한다. 부모요소에서 display: grid; 를 쓰면서 시작할 수 있다. repeat함수 -&gt; repaet(반복할횟수, 크기[1 2) 크기 1개만 적을시 1개만 횟수만큼, 크기 1 2 다적을 시 배열식으로 적용한다.fr = fraction 분수단위 grid에서 순서를 지정해주고 싶다면 order를 쓰면 된다. 모든 기본 order값은 0이다. grid-auto-rows : 크기 / 콘텐츠 갯수만큼 자동적으로 적은 크기의 행을 만들어준다. grid-template-columns : 크기 / 크기 갯수만큼 적어 열을 생성한다. grid-template-rows : 크기 / 크기 갯수만큼 적어 행을 생성한다. grid-column-gap: 크기 / 각 콘텐츠 사이에 적은 크기의 마진을 발생시킨다. 라인 넘버 지정방법. 123456789101112131415.container&#123; display: grid grid-template-columns: 1fr 3fr 1fr; /* 3개의 열을 각각 5분의 1,3,1크기로 선언한다. */ grid-template-rows: repeat(3, 50px); /* 3개의 행을 50px크기로 선언한다.*/ &#125; .header&#123; /* grid-row : 1/2; grid-column : 1/4; */ /* row시작점 column시작점 row끝나는점 column끝나는점*/ grid-area: 1/1/2/4; &#125; /* 위에 구문은 병합 span으로도 아래처럼 사용이 가능하다. */.header&#123; grid-ared : 1/1/span 1/span 3; &#125; area 지정방법. 123456789101112131415161718192021222324252627282930313233343536@media screen and (min-width:50em)&#123; .container&#123; margin : 0 auto; max-width: 1600px; grid-template-columns: 1fr 3fr 1fr; grid-auto-rows: minmax(50px,auto); /* 최소 높이 50px이고 글자(텍스트 -콘텐츠)가 늘어남에 따라 auto로 상자가 늘어남. */ /* 아래에서 grid-area: 이름 ; 으로 지정한 것을 grid-template-areas에 각각 넣어준다. */ grid-template-areas: \"header header header\" \"navigation content ad\" \"footer footer footer\"; &#125;&#125; .container&#123; display: grid;&#125;.header&#123; grid-area: header;&#125;.navigation&#123; grid-area: navigation;&#125;.content&#123; grid-area: content;&#125;.ad&#123; grid-area: ad;&#125;.footer&#123; grid-area: footer;&#125; gird 시스템 이용시 짧게 사용할 경우 area:이름 기법이 훨씬 간편하지만, 열과 행이 많을 경우에는 line기법이 수월하다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-09","slug":"html-css-study-09","date":"2019-09-19T17:38:10.000Z","updated":"2019-09-19T17:38:48.225Z","comments":true,"path":"2019/09/20/html-css-study-09/","link":"","permalink":"http://yoursite.com/2019/09/20/html-css-study-09/","excerpt":"","text":"HTML Study 09 q , blockqueto 태그 + cite 속성 small 태그 address 태그 flex 속기법 + order, grow , shrink flex-basis aside 태그 CSS animation : transition background 속기법 태그들이 공통으로 사용가능한 속성 오늘의 학습 깨달음 의미없는 구분자들은 마크업 하지 않는다. 만약 의미없는 img 태그들을 사용해야할 경우 alt값은 비워둔다 ( alt = “” ) img 태그를 사용할 것인지, 일반적인 태그를 이용하고 SEO적인 내용을 붙인 후 CSS 배경처리를 할 지 고민이 필요함. 사이트를 마무리하는 영역인 footer에서는 heading 태그를 사용하지 않는다. header 태그의 대신 역할 role=”banner” 와 footer 태그의 대신 역할 role=”content-info”등은 article 태그나 section태그 내에서 사용하면 안된다!!!! 반드시, body 태그의 직계 자식 요소로 사용되는 태그들의 역할 모델이 되어야만 한다. button 태그 사이의 띄어쓰기는 요소검사로 잡기 힘드니 button 태그가 나란히 사용되었을 때, 간격이 있다면 확인할 것. 레이아웃 작업 시, 가능한 노말플로우를 유지하라. 레이아웃 작업 시, 더 간단하고 쉽게 적용가능한 방법들을 모색하라. q , blockqueto 태그 인용임을 나타내는 태그에는 q와 blockquote가 있다. q는 문단 안에서 인용할 때 사용하는 인라인 요소이고, blockquote는 새로운 문단에서 인용하는 블록 요소 이다. 12345678q&#123; quotes: \"[[\" \"]]\"; &#125; /* 사용한 태그의 앞과 뒤에 [[ 과 ]] 이 생긴다.*//*혹은 한쪽만 선택하고 싶을경우 다음처럼도 이용함.*/q::after&#123; content: \"\";&#125; 인용문 출처는 cite 속성 을 이용한다. 1&lt;q cite=\"https://www.codingfactory.net/\"&gt;consectetur adipiscing&lt;/q&gt; small 태그 small 태그는 저작권, 면책조항, 주의사항, 법적 제한 사항, 주석표시에 사용한다. small 태그는 부가 정보를 나타내는 주석표시이므로, 여러 단락이나 광범위한 텍스트가 포함된 섹션에서는 사용하지 않는다. 1&lt;small class=\"copyright\"&gt; Copyright since &amp;copy; 2010 by Web Cafe &lt;/small&gt; address 태그 address는 소유자 또는 작성자의 연락처를 나타내는 태그. body 태그 안에 있으면 문서의 소유자 또는 작성자의 연락처를 나타냄. article 태그 안에 있으면 기사의 소유자 또는 작성자의 연락처를 나타냄. 기본 모양은 기울임꼴. 12345&lt;address class=\"address\"&gt; &lt;span&gt;서울시 강남구 성수동 &lt;/span&gt; &lt;span&gt;전화 : 02-1234-5678 &lt;/span&gt; &lt;span&gt;email : iasg2004@gmail.com&lt;/span&gt;&lt;/address&gt; &lt;!-- span을 준 이유 : 간격을 관리가 편해서 --&gt; flex 속기법 + order, grow , shrink flex : flex-grow flex-shrink flex-basis Flex 한국어 정리 사이트 order Item의 순서를 설정.Item에 숫자를 지정하고 숫자가 클수록 순서가 밀린다.음수가 허용. flex-grow Item의 증가 너비 비율을 설정.숫자가 크면 더 많은 너비를 가짐.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-shrink Item이 감소하는 너비의 비율을 설정.숫자가 크면 더 많은 너비가 감소.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-basisItem의 (공간 배분 전) 기본 너비를 설정.값이 auto일 경우 width, height 등의 속성으로 Item의 너비를 설정할 수 있다.하지만 단위 값이 주어질 경우 설정할 수 없다. 값 의미 기본값 auto 가변 Item과 같은 너비 auto 단위 px, em, cm 등 단위로 지정 flex 속성에서 설명한 것 같이 단축 속성 내에서 flex-basis를 생략하면 값이 0이 되는 것을 주의합시다. aside 태그&lt;aside&gt; 컨텐츠는 추가되어야 할 요소이지만, 메인 컨텐츠를 이해하기 위해 필수적인 것은 아니다. 예를 들어, 각주는 추가적인 정보를 제공하지만 필수적이지 않다. 그리고 발췌문은 필수적인 컨텐츠인 반면, 메인 컨텐츠에서 인용된 카피 문구이다. 하지만, &lt;aside&gt;는 관련성이 있어야 한다는 사실을 명심해야 한다. 사이트의 사이드바를 &lt;body&gt;의 자식요소로&lt;aside&gt;에 넣는 것은 좋다. 하지만 사이트 전반에 걸친 정보를 &lt;article&gt;의 자식요소로서 &lt;aside&gt; 안에 보여져서는 안되는 것. 그리고 &lt;aside&gt; 요소가 그 부모 섹셔닝 요소에 관련만 있으면, 광고에도 적합하다. 123456789&lt;aside&gt; &lt;p&gt; &lt;em&gt;섹셔닝 루트&lt;/em&gt; 요소에는 &lt;blockquote&gt;, &lt;body&gt;, &lt;details&gt;, &lt;fieldset&gt;, &lt;figure&gt;,&lt;td&gt;가 있다. &lt;/p&gt; &lt;/aside&gt; &lt;p&gt; &lt;header&gt;와 &lt;footer&gt;는 현재 속해 있는 섹셔닝 요소 또는 '섹셔닝 루트' 요소에만 적용된다.&lt;/p&gt; CSS animation : transition​ CSS transition은 :hover , :focus 와 같은 이벤트에 CSS 장면전환을 주기 위한 옵션이다. 12345678910.list&#123; transition : height 3s 0s, padding 3s 0s, background 2s 3s; /* 속성 지속시간 딜레이 */&#125;.list:hover, .list:focus&#123; padding : 10px; background: yellow; height : 100px;&#125; 위 구문은 list 클래스에 마우스가 올라가거나 , 키보드로 선택이 되었을 경우 3초에 동안 높이가 100픽셀 , 패딩이 10픽셀 늘어난다. 3초 기다린 후 2초동안 점점 노란색으로 배경색이 변경된다. background 속기법123456789101112/* background-image background-position [/background-size] repeat-style attachement box background-color */ h1 &#123; background: url('img.jpg') 0 50% /8em no-repeat fixed border-box blue; &#125;/* background-image repeat-style background-position attachement */ h2&#123; background: url(./images/bg_flower.png) no-repeat 50% 0 fixed, #eee linear-gradient(#ccc,#eee,#fff) repeat 0 0 fixed;&#125; /* 배경 이중 중첩, 먼저 나온 배경이 위로.*/ 태그들이 공통으로 사용이 가능한 속성 title id style class lang data-*","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-08","slug":"html-css-study-08","date":"2019-09-18T17:58:58.000Z","updated":"2019-09-19T16:22:04.218Z","comments":true,"path":"2019/09/19/html-css-study-08/","link":"","permalink":"http://yoursite.com/2019/09/19/html-css-study-08/","excerpt":"","text":"HTML Study 08 position : sticky / fixed counter cursor : pointer calc( ) 함수 tabindex 일자로 요소를 나열하는 4가지 방법( 크게 ) position : sticky / fixed레진 fixed/sticky 참고 sticky sticky는 평소에는 기본 상태였다가 스크롤을 내리면서 임계점에 다했을 시 fixed처럼 요소가 게속 남아있는 형태를 말한다. 필수로 top, right, bottom, left 속성이 필수이다. fixed fixed는 스크롤 유무에 관계의 상관없이 뷰포트에 고정을 하는 것이다. 다만, sticky는 브라우저의 제한이 걸려있다.(아래참조) sticky와 fixed의 차이점은 fixed는 스크롤의 상관없이 뷰포트 자리 고정!, sticky는 스크롤이 다야 적용이된다는 것이다. counter​ css로 요소에 일일이 접근하지 않고 연속적인 리스트등에게 일렬번호등을 붙일 수 있다. 예를들어보자, 1234567891011ol&#123; counter-reset: chapter 0; /* counter-reset으로 초가화 : 카운터명 증가값(생략시 1씩 증가,0도 1씩증가)*/&#125;ol li&#123; counter-increment : chapter;&#125;ol li::before&#123; content : counter(chapter);&#125; cursor여러가지 커서 모양들 cursor : pointer는 마우스가 올라갈시 a링크를 hover한것처럼 마우스 커서가 손가락 표시 모양으로 바뀌게 된다. 그외 추가적인 커서 모양들은 위 링크를 참조하라. calc( ) 함수calc( ) 관련 블로그 CSS3에 새롭게 추가된 기능 중 calc()라는 것이 있다. 계산을 해주는 속성인데 기존에 자바스크립트로 하던 계산을 상당 부분 덜어준다. 예를 들어, 모든 문단을 “100% 너비에서 20픽셀(px)만큼 뺀 너비”로 설정하고 싶다면 다음과 같이 작성한다. 123456p &#123; width : 95%; /* 구식 브라우저를 위한 대비책(fallback) */ width : -webkit-calc(100% - 20px); /* for Chrome, Safari */ width : -moz-calc(100% - 20px); /* for Firefox */ width : calc(100% - 20px); /* for IE */&#125; calc() 내부에 입력할 수 있는 표현식은 +, -, *, / 등의 사칙 연산이 가능하다. 주의할 부분은 사칙 연산시 + 또는 - 는 반드시 기호 양쪽으로 공백을 삽입해야 한다는 것. 속성에 따라 값이 - 로 내려갈 수도 없는 경우가 있다.( width : calc(5px - 10px); = width: 0px; ) tabindex어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법이다. 어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법으로 사용된다. 크게 3가지 속성값을 이용할 수 있다. 0 값 - tabindex=”0” 양수 - tabindex=”1~32768” 음수 - tabindex=”-1” 속성 값이 0인 경우는 탭을 눌렀을 때 포커스가 가지 않는 엘리먼트에게 포커스를 줄 수 있다. 예를 들어, div영역에도 포커스를 줄 수 있다는 의미이다. 속성 값이 -1인 경우는 반대로 탭을 눌렀을 때 포커스가 가는 엘리먼트에게 포커스를 잃게 할 수 있다. 예를 들어, 링크 엘리먼트에 포커스를 잃게 한다는 의미다. 속성 값이 양수인 경우에는 우선순위를 지정해주는 것이다. 예를들어 , h3 tabindex=”6” 이라는 태그가 h3 tabindex=”3” 보다 먼저 나왔어도 키보드 탭 포커스는 3을 먼저 보여주고, 6을 보여줄 것이다. 일자로 요소를 나열하는 4가지 방법( 크게 )123456&lt;ol class=\"favorite-list\"&gt; &lt;li class=\"no1\"&gt; &lt;a href=\"#\"&gt;W3C&lt;/a&gt; &lt;em class=\"up\"&gt;상승&lt;/em&gt; &lt;/li&gt; &lt;/ol&gt; 위 그림과 같이 일자로 구성된 요소가 있다고 가정했을 떄. 만드는 방법은 크게 4가지가 존재한다. 1. flex flex는 가장 쉬운 방법이다. 다만, 브라우저 지원을 잘 확인해야만 한다. 12345678910.favorite-list li&#123; display : flex; align-items: center; /*y축 중간 매치*/ &#125; .favorite-list em &#123; margin-left: auto; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/&#125; 2. float float의 단점은 일자로 나열하고 하는 요소들의 높이가 모두 같다면 크게 문제가 없지만 높이의 차이가 존재한다면 억지로 높이를 맞춰주어야만 한다. 12345678910.favorite-list li::before&#123; float : left; &#125;.favorite-list a&#123; float : left;&#125;.favorite-list em &#123; float : right;&#125; /* 높이의 차이 때문에 억지로 크게를 맞춰주어야한다.*/ 3. position 부모요소에 relative를 주고 왼쪽부터 작성되는 html 특성을 고려하여 가장 오른쪽 상승,하락 그림만 absolute를 이용하여 오른쪽에 배치하는 기법이다. 12345678910111213141516171819.favorite-list li&#123; position: relative;&#125; .favorite-list li::before&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list a&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list em &#123; position : absolute; margin-top : -5px; /*absolute를 이용함으로서 상승,수직 이미지를 오른쪽으로 붙어버린다.*/ top : 50%; /* top과 margin은 글씨가 많아서 칸이 넘어가도 상승 좌표도 덩달아 움직이게 하기 위함이다.*/ right : 0;&#125; 4. inline-block inline-block에서 margin-left를 이용하여 em요소를 오른쪽으로 보내버리는 방법이다. inline-block에서의 특징은 반드시 정렬하고자는 요소들은 모두 width값들이 명시가 되어야만 한다. 그래야 컴퓨터가 maring-left : auto 값을 계산하여 em요소를 오른쪽에 배치시킬수 있다. 1234567891011121314151617.favorite-list li::before&#123; display: inline-block; vertical-align: middle; width: 20px;&#125;.favorite-list a&#123; display: inline-block; width: 120px; vertical-align: middle;&#125;.favorite-list em &#123; display: inline-block; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/ margin-left: auto; vertical-align: middle;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-07","slug":"html-css-study-07","date":"2019-09-16T18:12:39.000Z","updated":"2019-09-17T12:20:16.921Z","comments":true,"path":"2019/09/17/html-css-study-07/","link":"","permalink":"http://yoursite.com/2019/09/17/html-css-study-07/","excerpt":"","text":"HTML Study 07 article태그 강조 태그 ( em , strong ) font weight 가중치 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 agent-style 시 확인해야할 점들. float 대신에 inline-block 사용시 주의점. 밑줄 gradient 만드는 방법들. 애니메이션 방법들 article 태그 article 요소는 독립적이고 재배포하며 재사용 가능한 , 홀로 설 수 있는 내용들을 위주로 담는다. article 내부에는 header태그,footer등을 삽입할 수 있다. 주로 블로그 글, 포럼 글, 뉴스 기사, RSS피드 등이 article에 해당된다. 강조 태그 강조하는 태그 em em보다 더 큰 강조를 하는 strong 의미없이 글자크기만 굵게 하는 b태그 의미없이 기울이는 i태그 주로, 작품명(그림명, 책명, 영화명 등)을 표시하거나 인용할 때 사용 시멘틱점 관점으로 strong이 em보다 강조도가 높다. 디자인적 요소로는 em은 기울임, b와 strong은 굵게 표시한다. cite태그는 작품명 ,인용시 사용한다. b태그는 단순히 의미는없고 굵게만 표시한다. i태그는 단순히 의미없고 기울이게만 표시한다. font-weight 가중치웹 폰트 파헤치기 웹 폰트는 그룹화가 가능하다. 예를 들어보면, 다음과 같다. 12345678910111213141516171819@font-face &#123; font-family: Ngothic-Regular; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Bold; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-ExtraBold; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 나눔고딕 보통, 굵게 , 아주굵게, 이탤릭 을 사용한다고 가정시 보통 웹폰트의 이름을 모두 다르게 붙이고 필요에 따라 각 스타일을 호출한다. 이와 같이 같은 나눔고딕들을 묶어서 사용하는 방법이 바로 font-weight 다. 다음 코드를 보자. 123456789101112131415161718192021222324@font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 700; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 800; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; font-style: italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 위와 같이 font-family는 나눔고딕이라는 그룹으로 맺고 각 weight와 style을 통해 각 글꼴을 선택할 수 있게된다. 123456body &#123; font-family: \"Nanum Gothic\" &#125; h1 &#123; font-weight: 400 &#125; /* NanumGothic-Regular.woff */h2 &#123; font-weight: 700 &#125; /* NanumGothic-Bold.woff */h3 &#123; font-weight: 800 &#125; /* NanumGothic-ExtraBold.woff */h4 &#123; font-weight: 400; font-style: italic &#125; /* NanumGothic-Italic.woff */ 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 글자 위에 이미지로 해당 글자를 가려야 할 경우. 사용하는 기법들. 글자를 안사용하고 바로 이미지만 넣을 수는 있으나 SEO관점에서 불리하다. 따라서 글자는 적되 이미지를 특정기법을 이용하여 덮음으로써 SEO관점과 시각적 요소 모두 챙긴다. padding을 활용한 IR 기법 기본적인 방법. 높이를 0으로 줘서 그림 아래로 텍스트를 내려버린다. 그 후 overflow:hidden 속성을 이용하여 텍스트를 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 12345678910111213@charset \"utf-8\";/* padding을 활용한 IR 기법 */.brand1&#123; background:yellow url(../images/title.png) no-repeat; height: 0; width: 290px; padding-top: 195px; overflow: hidden;&#125;/* 위 2가지 트릭의 단점 -&gt; 네트워크의 오류로 인해 이미지가 안날라올경우 문제가 있다. */ text-indent를 이용한 IR 기법 넓이를 지정해놓고 , 들여쓰기를 넓이만큼 준다. 개행 금지 속성을 이용하여 텍스트가 다음 줄로 못내려가게 막고 화면을 넘어가버린 텍스트는 overflow:hidden 속성을 통해 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 123456789/* text-indent 트릭을 이용한 IR 기법 */.brand2&#123; background:pink url(../images/title.png) no-repeat; height: 195px; width: 290px; text-indent: 290px; white-space: nowrap; overflow: hidden;&#125; position 트릭 가상요소를 이용하여 텍스트는 자리 그대로 유지하고 absolute한 가상요소 이미지로 덮어씌운다. 네트워크 에러시 이미지가 안날라와도 가려져있던 텍스트가 보이게 됨으로써 무슨 텍스트인지 유추가 가능하다. 123456789101112131415161718192021222324/* 한줄일때만 이용 가능한 트릭. position트릭. 네트워크 오류로 이미지가 안날라올경우 가상요소는 안보이고 덮어쓰기 전의 내용이 보인다. */.brand3&#123; background: lime; height: 195px; line-height: 195px; width: 290px; text-align: center; font-size : 16px; font-weight: 400; position : relative;&#125;.brand3::after&#123; content: \"\"; position: absolute; background: orange url(../images/title.png); width: 100%; height : 100%; top: 0; left : 0;&#125; agent-style 시 확인해야할 점들. box 모델 겹침 문제 오타 상속 이슈 레이아웃 (margin, padding, position , display , float …) inline-block 으로 레이아웃 작업시 문제점들 inline-block으로 레이아웃시 다음과 같은 문제가 발생한다. 주의 깊게 봐야되는 점은 묻고답하기 오른쪽에 존재하는 Border 선과의 사아아알짝 떨어진 여백이다. 보통 li태그를 일자로 나열하는 방법으로 inline-block으로 지정하고서 구분선을 주기 위해 border를 주게되면 위와 같은 여백이 생기게 된다. 이 부분을 아래와 같이 margin값을 -로 주면서 해결을 할 수 있다. 1margin-left: -6px; /*극단적이게 큰 값을 줌.*/ 웬만해서는 float형태나 다른 레이아웃을 권장한다. 밑줄 gradient 만드는 방법들. 가상 요소 absolute 를 이용한 방법. 밑줄을 그리고 싶은 곳에 가상요소를 하나 띄우고 absolute화 한후 높이와 넓이를 맞춰서 대치하는 방법. 123456789.news::before&#123; content: \"\"; background: red linear-gradient(to right,#aaa,#fff); position : absolute; top : 30px; left : 0; width: 80%; height: 1px;&#125; border 선 자체에 gradient를 설정 하는 방법 123456789101112.news-heading&#123; margin : 20px 0; padding : 0 0 15px 0; width : 80%; font-size : 1.5rem; color: #bb7b13; border-style: solid; border-image: linear-gradient(to right, rgb(168, 167, 167), rgb(228, 228, 228)); border-image-slice: 0 0 1 0; border-image-width: 0 0 1px 0; border-left: none;&#125; 애니메이션 방법들 CSS 애니메이션 사용하기 참고 123456789101112131415161718192021/* 1번 Fade Slide In From Top */ @keyframes fade-slide-in-from-top &#123; 0% &#123; transform: translateY(-4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.app-header &#123; opacity: 0; animation: fade-slide-in-from-top 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 2번 Fade Slide In From Left */@keyframes fade-slide-in-from-left &#123; 0% &#123; transform: translateX(-4rem); /*right는 transform: translatxX(4rem);*/ opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.brand &#123; opacity: 0; animation: fade-slide-in-from-left 0.35s 0.4s ease-out forwards; &#125; 12345678910111213141516171819202122232425262728293031323334353637/* 3번 Fade In &amp; out */@keyframes fade-in &#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;button[title=\"메뉴 열기\"] &#123; opacity: 0; animation: fade-in /* name */ 0.35s /* duration */ 0.4s /* delay */ ease-out /* timing function */ forwards; /* fill mode */&#125;@keyframes fade-out &#123; 0% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125;.button[title=\"메뉴 열기\"] &#123; animation: fade-out 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 4번 Fade Slide In From Bottom */@keyframes fade-slide-in-from-bottom &#123; 0% &#123; transform: translateY(4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.ediya-menu__item &#123; opacity: 0; animation: fade-slide-in-from-bottom 0.35s 0.4s ease-out forwards; &#125; 1234567891011121314/* 5번 Motion Sequnce Animation */.ediya-menu__item &#123; /* 0% */ opacity: 0; transform: translateY(4rem); /* 100% */ animation: transform-none 0.3s 0.85s cubic-bezier(0.6, 0.01, 0.16, 1) forwards;&#125; /* 시간 차 애니메이션 */.ediya-menu__item:nth-child(1) &#123; animation-duration: 0.8s &#125;.ediya-menu__item:nth-child(2) &#123; animation-duration: 1.2s &#125;.ediya-menu__item:nth-child(3) &#123; animation-duration: 1.6s &#125;.ediya-menu__item:nth-child(4) &#123; animation-duration: 2.0s &#125; 그외 사이트 참조 Effective Management 애니메이션 코드 수 줄이고 관리하기. Text Sequencing Motion Stop &amp; Play Animation for Everyone (애니메이션 껏다 켜기 버튼기능)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"java-tips02","slug":"java-tips02","date":"2019-09-13T16:12:50.000Z","updated":"2019-09-13T16:24:19.741Z","comments":true,"path":"2019/09/14/java-tips02/","link":"","permalink":"http://yoursite.com/2019/09/14/java-tips02/","excerpt":"","text":"####1. String == 와 equals의 차이점 String으로 = =을 비교시 주소를 비교하는것이다. 따라서 내부 값을 비교하기 위해서는 equals를 쓰도록한다. 참고로 문자열말고 문자는 그냥 ==으로 하여도 무방함. ex) char A == ‘6’; 123456789101112131415// 둘다 똑같은 값을 가지고 있으니까 참 new String(\"test\").equals(\"test\") // --&gt; true // new String으로 새로운 객체를 생성하고 \"test\"는 다른 객체여서 falsenew String(\"test\") == \"test\" // --&gt; false // \"test\"라는 값을 가진 객체를 둘다 각자 생성해서 falsenew String(\"test\") == new String(\"test\") // --&gt; false // \"test\" \"test\"를 컴파일러는 같은 객체로 봐서 참 \"test\" == \"test\" // --&gt; true // checks for nulls and calls .equals()Objects.equals(\"test\", new String(\"test\")) // --&gt; trueObjects.equals(null, \"test\") // --&gt; false 02. charAt() , toCharArray() charAt() : 문자열타입에 저장된 값들을 배열형태로 인식하여 반환하는 함수. to.CharArray() : 문자열에 있는 모든 내용을 문자배열로 반환하는 함수. 12345678910111213141516 String a=\"001100111\";char[] x = a.toCharArray();for(int i=0;i&lt;a.length();i++)&#123;if(a.charAt(i)=='0')&#123; System.out.print(\"영\");&#125;else&#123; System.out.print(\"일\");&#125;&#125;System.out.println();for(int i=0;i&lt;a.length();i++)&#123;System.out.print(x[i]);&#125; System.out.println(); 03_1. 형변환 (요약) Integer.parseInt( ) -&gt; 문자열 -&gt; 정수 String.valueOf( ) -&gt; 정수 -&gt; 문자열 12345int a = 0;String s = \"55\";int a = Integer.parseInt(s); //a=55String s = String.valueOf(a+10); //s=\"65\" 03_2. 형변환 (목록) ①. 문자열에서 정수형으로 변환 (String to int) - int i = Integer.parseInt(String str); ②. 정수형을 문자열로 변환 (int to String) - String str = Integer.toString(int i); - String str = String.valueOf(int i); ③. 형식에 맞춰서 변수들을 문자열로 변환 (c언어의 printf 동일) - int i; float f; String str = String.format(“%d %f”,i,f); ④. 문자열에서 다른 숫자형태로 변환 - float f = Float.parseFloat(String str); // String to float - double d = Double.parseDouble(String str); // String to double - byte b = Byte.parseByte(String str); // String to byte - long l = Long.parseLong(String str); // String to long - short s = Short.parseShort(String str); // String to short ⑤. 다른 숫자형태에서 문자열로 변환 - String str = String.valueOf(boolean b); // true 또는 false가 str에 저장됨. - String str = String.valueOf(char c); // char to String - String str = String.valueOf(char[] data); // char array to String - String str = String.valueOf(double d); // double to String - String str = String.valueOf(float f); // float to String - String str = String.valueOf(long l); // long to String - String str = String.valueOf(Object o); // Object to String , o == null이면 “null” 이 되고 o!= null이면 o.toString()함수의 반환값은 str - String str = String.valueOf(char[] data, int offset, int count); // offset 의 index부터 count 개의 문자로 부분문자열 생성","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"java-tips01","slug":"java-tips01","date":"2019-09-13T16:06:51.000Z","updated":"2019-09-13T16:24:10.915Z","comments":true,"path":"2019/09/14/java-tips01/","link":"","permalink":"http://yoursite.com/2019/09/14/java-tips01/","excerpt":"","text":"####1. charAt(i) charAt(i)는 문자열(String)을 대상으로 한다. 문자열의 i-1번째에 위치한 문자열을 char형으로 반환한다 12String n = \"abcda\";n.charAt(0) // char형으로 a를 의미. 즉, 'a'을 반환. 2. indexOf(문자열) indexOf(“문자열” || ‘문자’)은 문자열(String)을 대상으로 한다. (“문자열” || ‘문자’)가 해당 문자열(String)내에 존재할 경우 존재하는 위치를 값으로 반환한다. 만약 존재하지 않을 경우 -1을 반환한다. *주의점 1 : 첫 위치만 반환한다. *주의점 2 : 문자열을 대상으로한다. char형은 대상이 아니다. *주의점 3 : 매개변수는 문자(char형)도 가능하다. 12String n = \"abcda\";n.indexOf(\"a\") // 0을 반환한다. 4번째에도 a가 있지만 처음에 있는 위치만 반환한다. 3. replace(),replaceAll(), replaceFirst() replace 관련 함수를 이용하여 치환 혹은 제거가 가능하다. replace(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거 replaceAll(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거. replace와 다른 점은 정규식도 사용 가능. repaceFirst(“찾는 문자열”,”바꿀 문자열”) -&gt; 조건에 있는 첫 문자열을 치환 혹은 제거. * 주의점 1 : 바꿀 문자열을 “”으로 줄 경우 제거가 됨. * 주의점 2 : 반드시 반환 대상이 있어야 됨. 자기 자신으로라도 반환을 해주어야함.(당연한 것) 12345678910111213141516171819202122String s = \"봉숭아 학당! 봉숭아 학당!\"; // 원본 문자열String s2; // (1) s2 = s.replace(\"숭아\", \"맹구\"); System.out.println(\"치환(1): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (2) s2 = s.replaceFirst(\"숭아\", \"맹구\"); System.out.println(\"치환(2): \" + s2); // 출력 결과: 봉맹구 학당! 봉숭아 학당! // (3) s2 = s.replaceAll(\"숭아\", \"맹구\"); System.out.println(\"치환(3): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (4) s2 = s.replace(\"숭아\", \"\"); System.out.println(\"치환(4): \" + s2);// 출력 결과: 봉 학당! 봉 학당! 04. char형 아스키코드를 이용한 알파벳배열 초기화. 아스키 코드를 이용하여 알파벳 배열을 만들 수 있다. 이런식으로 아스키코드를 이용한 조건을 만들 수도 있다. 123456char[] alphabet = new char[25];for(int i=0;i&lt;25;i++)&#123; alphabet[i] = (char) (i+65);&#125; // A - 65System.out.println(alphabet[0]); //'A' 출력됨.","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/categories/JAVA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"html-markup","slug":"html-markup01","date":"2019-09-12T16:01:04.000Z","updated":"2019-09-12T16:28:46.582Z","comments":true,"path":"2019/09/13/html-markup01/","link":"","permalink":"http://yoursite.com/2019/09/13/html-markup01/","excerpt":"","text":"123456789101112131415161718192021&lt;section class=\"news\"&gt; &lt;h2 class=\"news-heading\"&gt; 새소식 &lt;/h2&gt; &lt;a href=\"#\" class=\"news-link\"&gt; &lt;dl class=\"news-list\"&gt; &lt;dt class=\"news-title\"&gt; &lt;span&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/span&gt; &lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; &lt;/dt&gt; &lt;dd class=\"news-description\"&gt; 디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다. &lt;/dd&gt; &lt;/dl&gt; &lt;figure class=\"news-thumbnail\"&gt; &lt;img class=\"news-thumbnail-image\" src=\"./images/news.gif\" alt=\"W3C 리뉴얼\"&gt; &lt;figcation class=\"news-thumbnail-title\"&gt;W3C 리뉴얼&lt;/figcation&gt; &lt;/figure&gt; &lt;/a&gt; &lt;a href=\"#\" class=\"icon-plus news-more\" title=\"새소식 더보기\" aria-labelledby=\"news-link\"&gt;더보기&lt;/a&gt;&lt;/section&gt; webcafe.html 부분 새소식 영역 마크업 및 html 구성","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"MarkUP","slug":"MarkUP","permalink":"http://yoursite.com/tags/MarkUP/"}]},{"title":"html-css-study-06","slug":"html-css-study-06","date":"2019-09-12T13:15:38.000Z","updated":"2019-09-13T16:03:08.519Z","comments":true,"path":"2019/09/12/html-css-study-06/","link":"","permalink":"http://yoursite.com/2019/09/12/html-css-study-06/","excerpt":"","text":"HTML Study 06 MarkUp 짤 때 고민해야하는 점. fieldset 태그의 버그 button태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?) vertical-align / text-align time 태그 block 태그 안에서 여백을 주는 여러가지 방법들. 글자 수 숨기기 (… 처리하기) fontello aria-labelledby MarkUp 짤 때 고민해야하는 점.​ MarkUp시 너무 많은 버튼에 대한 고민을 해야만 한다. 예를들어보자, 위와 같은 공지사항과 자료실에 대한 게시물 리스트를 모아놓은 영역을 마크업 해야할 때, 보통의 경우라면, 다음과 같이 생각할것 같다. 공지사항 , 자료실은 서로 다른 영역이다. 게시물 목록을 나열한다. 더보기 버튼을 나눈다. 결론적으로, 공지사항 - 목록 - 더보기 | 자료실 - 목록 - 더보기 구성이 되겠다. 문제는 이와같은 구성시 너무 많은 탭을 요구하게 된다. 비장애의 영역에서는 시각을 통해 여러가지 정보를 한번에 확인을 할 수 있지만, 장애 또는 봇의 영역에서는 눈대신 청각에 의존해야한다. 스크린 리더기가 모든 게시물 제목을 하나하나 전부 읽는다는 것은 너무 힘들고 듣는다는것도 힘들것이다. ! 해결법은 무엇인가?​ 해결법이야 여러가지 방법이 존재하겠지만, 그 중 대표적인 예를 들어보면 - 공지사항,자료실 같은 수많은 포커스가 되는 영역에서는 방향키 화살표를 통해 읽고 싶은 요소만 선택하게 하는것이다. 공지사항 자료실 세션 1 목록 더보기 세션2 목록 더보기 [이를 적용한 대한항공 사이트] https://www.koreanair.com/content/koreanair/global/en.html/ fieldset 태그의 버그​ fieldset 태그는 보통 form 태그 내부에서 쓰인다. form - fieldset + legend + label + input 형식으로 많이 사용하는데, 여기서 fieldset 태그에 flex를 주게 될 경우, 크롬에서는 버그를 일으키게된다. ( 보통, form태그에 display:flex를 주면 크롬은 flex가 적용이 안되는 버그를 일으킨다. ) 해결법으로는 form - fieldset + legend + label + input 과 같은 형식에서 form - fieldset - div + legend + label + input 과 같이 태그로 1번더 그룹핑한다. 그리고 div에 flex관련 css 스타일을 주면 해결할 수 있다. [flex 관련 이슈] https://naradesign.github.io/article/flex-browser-compatibility.html button 태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?)​ button 태그는 브라우저마다 padding , margin 영역이 다른 특성을 가지고 있다. 따라서 a 태그와 WAI-ARIA를 이용하고 role=”button” 을 주어 이 부분을 해결할 수 있다. vertical-align / text-align vertical-align 은 inline 요소를 수직으로 정렬해주는 기능을 담고 있다. text-align 은 block 요소를 정렬해주는 기능으로 block 요소 안에있는 inline 요소들(텍스트나 이미지)등도 같이 정렬해준다. inline 관련 태그에 직접 text-align 속성을 지정해줘도 작동하지 않는다. time 태그​ 이 태그의 용도는 문서 내용 안에 어떤 날짜나 시간을 나타내는 표현이 있을 때 그 부분에 사용하여 알맞은 날짜나 시간을 컴퓨터가 인식할 수 있게 의미적으로 나타내는 데 사용한다. 1&lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; block 태그 안에서 여백을 주는 여러가지 방법들.​ 여백을 주는 각 방법들마다 차이가 있으니 확인하고 써야 할 것. 특히 %, auto , 정적px에 대한 차이를 이해하는것이 중요하다. padding ?%; ?px; margin ?%; ?px; width : ?px; width : ?%; margin : auto; calc -&gt; 반응형 글자 수 숨기기 (… 처리하기)​ block 박스에서 글자수가 일정 이상 넘어가서 …을 처리하고 싶다먼 아래 style을 모두 구성해주어야한다. 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; fontello​ 이전에 설명한 fontello를 html문서에서 class 형태로 주어 icon이미지를 생성하면 그 태그 앞에 가상클래스를 자동으로 만들어주고 이미지를 넣게된다. 12&lt;li class=\"icon-dot-circled\"&gt; &lt;!-- li클래스 앞에 가상클래스를 만들고 이미지를 넣는것을 자동으로 해줌. --&gt; ​ fontello.css 에 있는 내용 중… 1.icon-dot-circled:before &#123; content: '\\f192'; &#125; aria-labelledby1 &lt;a href=\"#\" class=\"icon-plus notice-more more\" title=\"공지사항\" aria-labelledby=\"notice\"&gt;더보기&lt;/a&gt; 위 a링크는 aria-labelledby=”notice” 로 인해 id가 “notice”인것을 연결해준다. 1&lt;a href=\"#\" class=\"tab\" role=\"button\" id=\"notice\"&gt;공지사항&lt;/a&gt; JavaScript 맛보기[defer 및 async] https://blog.asamaru.net/2017/05/04/script-async-defer/ 12&lt;script src=\"./js/jquery.min.js\" defer&gt;&lt;/script&gt;&lt;script src=\"./js/webcafe.js\" defer&gt;&lt;/script&gt; 1234567891011var section = $('.board section'); //jqeury lib에서 지원하는 선택 객체var tab = $('.tab');// .on('이벤트명')// tab.on('click keyup',function(e)&#123;tab.on('click', function(e)&#123; e.preventDefault();// 기본 이벤트를 취소함. 예를들면 a의 속성 href의 이벤트를 취소함. // if((e.type === 'keyup' &amp;&amp; e.keyCode === 13) || e.type === 'click')&#123; section.removeClass('tab-act'); $(this).parent().parent().addClass('tab-act');&#125;)//멀티 이벤트 바인딩 예-&gt; 클릭, 마우스온 등 다양한 환경 대응 board라는 이름을 가진 클래스의 section태그의 내용을 section이라는 이름의 변수로 선언. tab이라는 이름을 가진 클래스의 정보를 tab이라는 이름의 변수로 선언. tab이 클릭 되었을 때, 다음과 같은 기능을 수행한다. tab이라는 이름을 가진 클래스의 태그가 가진 기본적인 이벤트 기능을 모두 취소(제거) 한다. board라는 이름을 가진 클래스의 section태그 내부에서 tab-act라고 불리는 클래스를 제거한다. tab이라는 이름을 가진 클래스의 태그의 부모의 부모에게 tab-act라는 클래스네임을 붙여준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-05","slug":"html-css-study-05","date":"2019-09-10T16:48:58.000Z","updated":"2019-09-10T17:05:18.609Z","comments":true,"path":"2019/09/11/html-css-study-05/","link":"","permalink":"http://yoursite.com/2019/09/11/html-css-study-05/","excerpt":"","text":"HTML Study 05 MarkUp 짜기 로그인창 HTML ~CSS 구성해보기 form 태그 dt dl dd 태그 a태그의 속성 들여쓰기 방법들 line-height 마크업시 생각나는 고민들!div -&gt; 의미없는 정보 section -&gt; 1장 1절 같은 정보 , header 태그가 없으면 경고를 띄운다. article -&gt; 독립된 완결된 정보, RSS , header 태그가 없으면 경고를 띄운다. margin은 겹침현상이 발생한다. box-shadow 도 인접 태그의 margin에 영향을 주지 않는다.(즉, 겹친다.) title은 id, class, style같은 대표속성이며 태그에 사용시 마우스를 올렸을 경우 글박스를 띄운다. text-indent 는 첫줄 들여쓰기를 넣어주는 속성이며, 박스에 영향을 주지않는다. 단, 개행시 유효하지 않은 속성이 된다. 반응형 이미지들은 반드시 등으로 랩핑하는것이 좋다. 이유 : 이미지가 유동적으로 커짐과 줄어듬 MarkUp 짜기​ 간단해보이지만 HTML중 가장 어려운 구간이다. 어떠한 태그를 좋게 사용하느냐, 논리적인 순서를 지켰느냐의 위주로 짜야하며 반드시 디자인적 관점으로 구성하면 안된다! 논리적 순서를 가려낸다. 시멘틱하게 이름 정하기 코드 짜기 대표적인 네이버의 로그인창 예제. 보통 마크업 순서라면 아이디 -&gt; 비밀번호 -&gt; 로그인 -&gt; 로그인 상태 유지 일것이다. 하지만! 논리적으로 계산해보면 로그인 하기전에 로그인상태유지 버튼을 체크하거나 해제하는것이 맞지 않을까? 로그인창 HTML ~CSS 구성해보기 form 태그form 관련 요소 -&gt; 정보를 보내고 받는 값들의 입력 서식을 모아놓은 모음들. https://formspree.io/ : form 정보를 내 이메일로 보내게끔 서비스하는 사이트 . 무료,유료 나뉜다. form , fieldset, legend ==&gt; XHTML 관점에서 다 있어야만 한다. HTML4에서는 form만 있어도 되고 HTML5에서는 둘다 허용이된다. 따라서 form, fieldset , legend, label, input 모두 사용하는 것이 좋다. fieldset은 폼서식을 그룹화하는 것. legend는 그룹화한 폼서식에 대한 제목이다. 하나의 form안에 fieldset은 여러개 들어가도 상관없다. required -&gt; 논리적 검사 예 ) input 태그 안에 required를 적게 되면 이메일 값을 안적을 경우 경고창을 띄운다. form 안 에서 값을 그냥 입력하면 안되고 반드시 1:1로 값을 대입해줘여한다. 아이디 은 입력서식에 대한 이름 이고 는 정보를 입력받는 창이다. placeholder 속성은 입력서식에 대한 예시다. dl dt dd 태그용어를 설명하는 정의형 목록을 만든다. dt -&gt; 용어의 제목을 의미하며 dd는 용어를 설명하는 내용이다. dl dt dd는 정의형 목록을 의미하며 각 태그당 한개씩만 사용하는것이 좋다. dl 안에 태그를 삽입해도 되지만, 아래와 같은 유형만 추천한다. 1234567&lt;dl&gt; &lt;div&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/div&gt;&lt;/dl&gt; &lt;!--가능한 구문. 단, div가 dt나 dd쪽에 들어가서는 안된다.--&gt; a태그하이퍼링크를 걸어주는 태그. 1&lt;a href=\"#\" target=\"_self | _blank | _parent | _top | 프레임명\" &gt;&lt;/a&gt; self -&gt; 기본값 생략가능. target=”_blank”. -&gt; 새창을 열음 parent -&gt; 부모페이지로, iframe에서 사용. top -&gt; 최상위페이지로, iframe에서 사용. 프레임명 : 직접 명시 들여쓰기 방법들 padding margin text-indent line-height1line-height: normal | length | number | percentage | initial | inherit | 숫자값 normal : 웹브라우저에서 정한 기본값. 보통 1.2 length : 길이로 줄 높이를 정한다. number : 글자 크기의 몇 배인지로 줄 높이를 정한다. percentage : 글자 크기의 몇 %로 줄 높이로 정한다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 예) 글자크기가 40px일 때 line-height의 값을 1.5로 하면, 줄 높이는 40의 1.5배인 60px가 된다. 줄 높이는 60px인데 글자 크기는 40px이므로, 글자 위와 아래에 각각 10px의 여백이 생긴다. 줄 높이가 글자 크기보다 작으면 세로 방향으로 글자가 겹치게 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-04","slug":"html-css-study-04","date":"2019-09-09T11:33:31.000Z","updated":"2019-09-09T17:59:41.138Z","comments":true,"path":"2019/09/09/html-css-study-04/","link":"","permalink":"http://yoursite.com/2019/09/09/html-css-study-04/","excerpt":"","text":"HTML Study 04 HTML5 콘텐츠 모델 CSS 셀렉터 html5 표준확인 CSS 구체성점수 Shadow Entity list opcacity 시나리오 작성 z-index background 애니메이션( @keyframes, + 곡선도 ) position, float 다시 정리 float 객체에 강제로 높이 를 알려주는법(overflow, 가상요소 clear:both) float, position:absolute -&gt; display를 block화 시킨다. 오늘의 팁 position : absolute , float는 강제로 display:block 화시킨다. 1에서 한 absolute의 경우 display는 block이 맞지만 마치 inline 형태의 display를 띄고 있으며, absolute 선언 시, block 레벨 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정해야만 하며, 부조 또는 조상요소가 static일 경우, 최종으로는 document의 body태그를 기준으로 위치하게된다. 태그의 링크 클릭 반경을 넓히고 싶다면 padding 을 늘려야 한다. 간단하게 여백을 주는 방법으로는 대표적으로 margin, padding 등이 있다. float화 된 상태에서 부모의 자식들 요소가 모두 float화 되었다면 그 부모요소는 높이를 잃어버리게 된다. 이에 잃어버린 높이를 찾는 3가지 방법이 있다. height = 45px : 높이를 직접 입력 [비추천] &lt;부모&gt; overflow:hidden/auto : overflow 자체는 흘러넘치는 콘텐츠를 다루는 태그지만 overflow태그는 잠재적으로 잃어버린 높이를 일깨워주는 역할을 하기 때문에 사용할 수 있다. clear:both : 가장 좋은 방법. float화된 요소 마지막에 가상자식요소를 생성하여 clear:both를 선언. clear:both는 float요소 중에 높이가 제일 긴 것을 찾아서 강제로 margin을 추가하여 높이가 늘어나 잃어버린 높이를 찾아낸다. 123456.menu::after&#123; content:\"\"; clear: both; /* clear는 display:block 에서만 사용 가능. right, left 등도 있다. */ display: block; &#125; display 숨김처리 12345678910.a11y-hidden &#123; background-color: red; position: absolute; width: 1px; height: 1px; overflow: hidden; margin: -1px; clip: rect(0,0,0,0); white-space: nowrap;&#125; HTML5 콘텐츠 모델 CSS 셀렉터​ 대표적으로 id 셀렉터인 # , 클래스 셀렉터인 점(.) , 전체 선택자인 * 외에도 수많음 셀렉터가 있다. 자세한 내용은 아래 블로그가 정리를 정말 잘 해놓았기에 링크로 남겨둔다. https://code.tutsplus.com/ko/tutorials/the-30-css-selectors-you-must-memorize--net-16048 html 5 표준확인 google에 html w3c 검색 [html5 mulder21c : 블로그] https://mulder21c.github.io/html/ [html5 한글명세서] https://mulder21c.github.io/html/ CSS 구체성 점수​ css 셀렉터에 id, class, tag 이름이 갖는 점수를 계산하여 점수가 높은 selector가 우선순위를 갖는 가상 개념. 대표적으로 id &gt; class &gt; tag 순이며, 제일 높은 html 태그 내부에 적용하는 css가 제일 높은 우선순위를 지닌다. 착각하면 안되는 것!! -&gt; class가 10개 쓰인다고 해서 id보다 높을 수 없다. 체급차이가 다르다고 생각하면됨. 123&lt;div style=\"padding : 20px\"&gt; 이것은 div 태그에 style이 적용된 예입니다.&lt;/div&gt; 추가 important 1234&gt; .menu-act .btn-menu&#123;&gt; color:yellow important;&gt; &#125;&gt; important는 우선순위를 무력화시킬 수 있다. 즉, important 는 지정한 스타일이 안먹는다고 생각햇을떄. 추적할때. 파악용도 클래스가 동적으로 추가될 가능성이 있을떄; 다른 사람이 수정해서 내 소스의 상속이 깨질 우려가 있을 경우. Shadow 그림자를 나타내는 태그는 크게 박스와 텍스트가 있다. 1box-shadow: none | x-position y-position blur spread color | inset | initial | inherit; none : 그림자 효과를 없앤다.. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어진다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어진다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려짐. spread : 양수면 그림자를 확장하고, 음수면 축소. color : 그림자 색을 정한다, inset : 그림자를 요소의 안쪽에 만든다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 1text-shadow: offset-x offset-y blur-radius color | none | initial | inherit offset-x : 그림자의 수평 거리를 정한다. (필수) offset-y : 그림자의 수직 거리를 정한다. (필수) blur-radius : 흐림 정도를 정한다. (선택 : 값을 정하지 않으면 0) color : 색을 정한다. (선택 : 값을 정하지 않으면 브라우저 기본값) none : 글림자 효과를 없앤다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. Entity list​ CSS에서 사용할 수 있는 특수문자 리스트. html에서 &amp;&amp;를 그냥 입력하면 안되기 때문에 아래의 리스트를 이용한다. [사용가능한 특수문자 코드 리스트] https://www.w3schools.com/cssref/css_entities.asp Opacity1opacity: number | initial | inherit number : 0.0부터 1.0까지의 수를 넣는다. (투명도 0 -&gt; 불투명 / 1-&gt; 투명) initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 시나리오 작성 CSS의 style을 작성할 때, 시나리오를 작성하며 차근차근 하는것을 익숙해지도록 한다. 예) 글씨가 왼쪽 -&gt; 오른쪽으로 날라옴. : 이동효과 [padding, margin, position-relative, position-absolute] 글자의 투명도를 추가 해야함 . [color: rgba 또는 opacity] 글자 크기의 번화 [font-size] z-index요소들의 배치가 자유로워지면서, 때떄로 서로의 위치를 겹치게 하는 경우가 생긴다. 그 때 사용하는것이 z-index. z-index 값을 지정하기 위해서는 해당 요소의 position 속성이 relative, absolute, fixed 중 하나여야만 한다. [z-index 를 잘 설명한 블로그] http://dev.epiloum.net/904 backgroundbackground-color : yellow 같은 기본 코드 외에도, background는 말 그대로 배경에 대한 색 , 이미지등의 콘텐츠를 다루는 요소 css이다. 123456789/*background-image : url로 2개의 이미지를 불러낸다. */background-image: url('./images/ani_flower_01.png'),url('./images/ani_flower_02.png');/*해당 이미지들은 처음에는 일정 간격마다 반복 되어있기에 반복을 제거한다.*/background-repeat : no-repeat;/*해당 이미지들에 대한 위치값을 지정해준다.*/background-position: 0 -10px, 670px 0; /*x축 y축을 의미*//*위 내용 한꺼번에 입력하기. */background : url('./images//ani_flower_01.png') no-repeat 0 -10px, url('./images/ani_flower_02.png') no-repeat 670px 0; 애니메이션[애니메이션 정리 잘된 블로그] https://brunch.co.kr/@99-life/3 애니 메이션을 사용하기 위해서는 먼저 2가지 조건을 충족시켜야 한다. animation-name : 키프레임 이름 *필수 animation-duration : 시간(s,ms 등등) *필수 animation-fill-mode : forwards; 먼저 keyframes를 선언한다12345678910111213141516171819@keyframes text-ani&#123; 0%&#123; font-size: 12px; color : rgba(0,0,0,0); transform: translate(0,0); /* top: 0; left: 0; *//* margin : 0; *//* padddig : 75px 0 0 400px */ &#125; /* from */ 100%&#123; font-size : 24px; color : rgba(0,0,0,1); transform: translate(400px,75px) /* top : 75px; left:400px; *//*padding:75px 0 0 400px*//*margin:75px 0 0 400px; */ &#125; /* to */&#125;@keyframes bg-ani&#123; 0%&#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125; transform 은 좌표공간을 변형함으로써 일반적인 문서 흐름을 방해하지 않고 콘텐츠의 형태와 위치를 바꾼다. 그 중, transform : translate는 요소의 위치를 이동 시키는 함수이다. 구버전의 browser는 사용이 안된다. animation-duration지속성을 의미한다. 필수조건. 기본적으로 s , ms단위의 시간을 입력한다. 1animation-duration: 5s; animation-fill-mode 속성 및 내용1animation-fill-mode: none | forwards | backwards | both | inherit; none 애니메이션이 끝난 후 상태를 설정하지 않습니다. forwards 애니메이션이 끝난 후 그 지점에 그대로 있습니다. backwards 애니메이션이 끝난 후 시작점으로 돌아옵니다. both 애니메이션이의 앞 뒤 결과를 조합하여 설정합니다. inherit 애니메이션의 상태를 상위 요소한테 상속받습니다. 추가내용 123456789101112/*animation-name: bg-ani;animation-duration: 2000ms;animation-iteration-count: infinite;animation-direction: alternate;animation-timing-function: paused; *//* 위 내용을 짧게 줄인 short 표기법 *//* short표기법 : 이름 듀레이션 딜레이 반복 방향 반복곡선도 */animation: bg-ani 2000ms 1000ms infinite alternate ease-in-out; animation-timing-function에 관한 내용 중 cubic-bezier 에 관한 내용 https://kutar37.tistory.com/entry/CSS-cubic-bezier%EB%9E%80 cubic-bezier 설정하는 곳 https://cubic-bezier.com/#.17,.67,.83,.67","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-03","slug":"html-css-study-03","date":"2019-09-07T12:52:07.000Z","updated":"2019-09-07T12:53:15.444Z","comments":true,"path":"2019/09/07/html-css-study-03/","link":"","permalink":"http://yoursite.com/2019/09/07/html-css-study-03/","excerpt":"","text":"HTML Study 03 가상 요소 nth:child WAI-ARIA a11y-hidden / aria-hidden : 태그 숨김처리 role Web Font - 이미지 아이콘 CSS 단위 float 그림자 gradiunt CSS 색상값 단위 {참고} 가상 요소[가상요소] https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements 가상 요소는 존재하지 않는 요소를 존재하는 것처럼 부여하여 문서의 특정부분을 선택하게 할 수 있다. 대표적인 가상 요소 ::before -&gt; 해당 css의 요소박스 전에 같은 형식의 태그요소를 가상으로 만든다. ::after -&gt; 해당 css의 요소박스 후에 같은 형식의 태그요소를 가상으로 만든다. nth:child[nth:child] http://nthmaster.com/ nth-child는 형제 요소 중에서 특정 순서 요소를 선택하고 싶을 때 사용한다. 1234567.member li:nth-child(n+2)::before&#123;content: '\\f142'; /*가상요소 before 와 after에게 필수*/font-family:'fontello';width: 1em;&#125;/* nth-child를 이용하여 member 하위의 &lt;li&gt;중 2번째 요소부터 끝까지 각 요소 앞에 가상 요소를 생성하고 내용은 '\\f142'를 입력하고 font 와 width를 적용한다.*/ WAI-ARIA [설명] https://www.biew.co.kr/36 WAI-ARIA는 ‘Web-Accessibility Initiative’의 약자로 W3C에서 웹 접근성을 담당하는 조직. ARIA는 리치 인터넷을 위한 W3C의 접근 명세. [W3C에서 제공하는 명세서를 보기 좋게 기술로 변화시킨 레진의 ARIA] https://tech.lezhin.com/2018/04/20/wai-aria a11y-hidden / aria-hidden : 태그 숨김처리a11y-hidden 화면상에서는 안보이나 스크린 리더기 혹은 보조기등에서 보이게 끔 하기 위하여 개안된 CSS스타일. 헷갈리면 안되는것이 WAI-ARIA 에서 재정된 aria-hidden은 클래스명이 아니라 하나의 속성이다! 결국 다른거임. 추가로 off-screen / readable-hidden 등도 있다. aria-hidden 시각장애인, 검색봇, 스크린리더 사용자가 홈페이지에 더 쉽게 접근하기 위해서 읽을 필요없는 요소나 내용을 감춰준다. 외에도 여러가지 태그 숨긴 방법이 있지만, 대표적으로 위와 같은 형태를 권장한다. display:none , visibilitty , hidden 은 비권장. 1234567891011121314/* a11y-hidden */.a11y-hidden&#123; position: absolute; width: 1px; height: 1px; margin: -1px; overflow: hidden; /* 넘치는 부분을 감쳐준다 */ clip: rect(0,0,0,0); /* 선행조건 : position:absolute 해당 화면을 잘라내서 보여줌 */ white-space: nowrap; /* 줄바꿈을 하지않음. */ opacity: 0; /* 투명도 */&#125;/* aria-hidden */&lt;span class=\"line\" aria-hidden=\"true\"&gt;내용&lt;/span&gt; role​ 다른태그에 role로 규정한 태그의 역할? 혹은 기능을 넣을 수 있다. 역시 WAI-ARIA에저 정의한 기술로 https://webdir.tistory.com/89 에 정리가 되어있다. 대표적인 예로는 button이 있으며 , 시멘틱 관점에서도 중요한 역할을 지닌다. role = header,main,contentinfo 는 각각 를 의미한다. 1&lt;a href=\"#\" class=\"btn-menu\" role=\"button\"&gt;CSS에 대해&lt;/a&gt; Web Font - 이미지 아이콘 로컬에 있는 폰트를 쓰는게 아닌 웹에서 폰트를 받았다가 사용함. 저작권에 주의 대표적 : [Font Awesome] https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use [Fontello] http://fontello.com/ Fontello 적용 방법. 다운받은 압축파일을 해제하고 들어가보면 font폴더와 css폴더가 존재한다. 다운받은 font폴더에서 모두 복사하여 하고있는 프로젝트 font폴더에 붙여넣기를 한다.(단, css내부의 font폴더가 아니다.) 다운받은 css폴더에서 fontello.css를 복사하여 하고있는 프로젝트 css폴더에 붙여넣기를 한다. import 시키기 12/* css 파일 */@import url('./fontello.css'); 사용방법은 html 내부 , css 내부 가 있다. 123456789101112&lt;!-- html 내부 --&gt;&lt;!-- class 명으로 선언하여 사용하는 방법. class 명은 다운받은 css폴더에서 확인이 가능하다. --&gt;&lt;a href=\"#\"&gt;&lt;span class=\"icon-ellipsis-vert\"&gt;로그인&lt;/span&gt; &lt;style&gt;/* 사용하고자 하는곳에서 숫자값과 font-family를 선언. 숫자값은 css폴더에서 확인이 가능하다. */ .member li:nth-child(n+2)::before&#123; content: '\\f142'; font-family:'fontello'; width: 1em; &#125;&lt;/style&gt; CSS 단위https://github.com/HYEOK999/TIL/blob/master/HTML-CSS/study01/CSS-7%EA%B0%80%EC%A7%80-%EB%8B%A8%EC%9C%84.md float float는 css에서 정렬하기 위해 사용되는 속성이다. 떠잇다는 의미로 float태그 걸려있는 요소를 띄워서 표시한다. float는 display:block 형태의 태그에만 적요이 가능하다. … float는 글씨가 겹칠수 없는 속성을 가지고 있는 float가 정의된 요소가 공중에 뜬다면 그 다음 글씨는 옆으로 밀어낸다. 만약 float가 정의된 모든 요소가 공중에 떳을 경우, 해당 요소는 크기를 잃기때문에 그 다음 태그 이어지게 보일 수 있다. 따라서 강제적으로 크기를 주거나 overflow:hidden 같은 기능을 이용하여 height 값을 간접적으로 알려줘야만한다. 1234567891011121314151617.box&#123; background-color: lime; /* height: 50px; --- 강제로 높이를 주어 float로 잃어버린 높이를 깨워넴(안쓰는게 좋음) overflow:hidden 은 원래 넘치는 content를 감추는 역할인데 이 속성은 잊혀진 높이등을 일깨워 준다.따라서 float로 잃어버린 높이를 일깨워서 heading3를 밑으로 내린다. */ overflow: hidden; /*넘치는 값을 지워주세요.*/ &#125; .box2&#123; position: relative; top:10px; &#125; .box [class^=\"box\"]&#123; /* border: 1px solid red; */ float: left; &#125; float 는 position: relative와는 겹칠수 있으나 absolute선언시 float는 자동으로 none 값이 된다. clear : both , left , right 각각 float가 걸려있는 요소의 양쪽, 왼쪽, 오른쪽에 있는 요소들에게 clear값을 취소하는것. 이는 반드시 display : block이여만 한다. 그림자 box-shadow: none | x-position y-position blur spread color | inset | initial | inherit none : 그림자 효과를 없앱니다. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어집니다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어집니다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려집니다. spread : 양수면 그림자를 확장하고, 음수면 축소합니다. color : 그림자 색을 정합니다. inset : 그림자를 요소의 안쪽에 만듭니다. initial : 기본값으로 설정합니다. inherit : 부모 요소의 속성값을 상속받습니다. 12 text-shadow: 1px 0 0 black, -1px 0 0 black, 0 1px 0 black, 0px -1px 0 black;/* 그림자를 각각 위 아래 오른쪽 왼쪽 을 줌으로서 글씨 주변으로 박스 쳐진것처럼 보이게 할수 있다. */ gradient[gradient 가공 사이트] “https://www.colorzilla.com/gradient-editor/&quot; 123456789/* gradient 적용하기- 위 사이트에서 그라디언트 만든 후 복사 후 적용. 단, background를 background-image로 수정.*/.menu&#123;background-image: linear-gradient(to bottom, #f4c730 0%,#f7aa2e 35%,#f7aa2e 70%,#f4c730 100%);/* background-image: linear-gradient(to bottom, red, green,red); 시작 빨간색,끝 - 녹색 */&#125; [++ 추가 사이트] “https://codepen.io/FelixRilling/pen/qzfoc&quot; CSS 색상값 단위 (참고)[CSS 색상 값단위] https://aboooks.tistory.com/279","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"git-gui-study02","slug":"git-gui-study02","date":"2019-09-06T14:38:43.000Z","updated":"2019-09-06T14:39:35.390Z","comments":true,"path":"2019/09/06/git-gui-study02/","link":"","permalink":"http://yoursite.com/2019/09/06/git-gui-study02/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 -\\1. GIT Hubhttp://github.com Build software better, togetherGitHub is where people build software. More than 28 million people use GitHub to discover, fork, and contribute to over 85 million projects.github.com ▷ 버전관리 시스템인 Git을 이용하는 프로젝트들을 위한 원격저장소를 제공하는 서비스▷ 오픈소스는 무료, 비공개 프로젝트는 유료 정책▷ 저장소 크기의 제한이 없다.▷ 로컬 버전관리 시스템이 없이도 많은 작업을 웹상에서 할 수 있으며 따로 설치가 필요없다.▷ 사람 중심의 서비스 구성이기 때문에 특정 저장소에 접근하려면 ‘아이디/저장소명’으로 해야 한다.EX) HYEOK999/TEST01 \\2. Git 사용하기1 ( 저장소 생성 , 첫 버전파일 생성 ) ▷ Source Tree를 처음 실행하여 계정 등록의 절차를 걸치고 난 후에 뜨는 화면입니다.▷ 1번 Local 현재 자신의 pc 저장소를 의미합니다.▷ 2번 Remote는 원격저장소를 의미합니다.SourceTree에 타 원격저장소 Git HUB , Git lab등과 같은 저장소를 이용할때 사용되는 탭입니다.▷ 3번은 클론저장소 입니다.협업 프로젝트 진행 할 때 개발되어진 소스를 처음에 전부 가지고와야될 경우 사용합니다.▷ 4번은 자신의 PC에 이미 생성된 저장소를 불러올경우 사용되는 탭입니다.Git으로 인해 버전관리가 되어진 폴더의 경우에만 사용이 가능합니다.▷ 5번은 버전관리에 사용될 저장소를 생성합니다. ▷ 5번 탭에서 새로운 버전관리 저장소를 만듭니다.test_git 이라는 새로운 폴더를 만들어주고 해당 폴더에 간단한 html문서를 하나 생성하고test01.html 이라고 저장을 하도록 하겠습니다. 그럴경우 소스트리에서 변화가 생겼습니다.우선 왼쪽 상단의 파일 상태 탭을 보면 2가지 창으로 분류 되어있는 것을 볼수 있습니다.아래쪽의 창을 Working Copy 라고 부르고위쪽의 창을 Staging Area 혹은 Index라고 부릅니다. 그리고 Working Copy를 자세히 볼 경우? 라고 되어 있는 곳에 아까 생성한 html 파일명이 있는 것을 확인할 수 있습니다.우선 ? 라는 표시의 의미는 git이 모르는 파일 .즉, 관리가 안되고 있는 파일 혹은 관리를 처음으로 시작해야하는 파일을 의미합니다.해당 파일을 Stage selected 나 all을 누를경우 스테이징 에어리어에 test01.html 파일이 올라갑니다.그리고나면 왼쪽의 아이콘은 +로 바뀌는데 이것은 해당 파일을 버전관리에 추가함을 의미합니다. 그 후 코멘트를 작성 한 후 Commit을 누를경우 처음으로 버전관리가 되어집니다.여기서 코멘트는 무조건 작성해야 합니다. 만약 작성을 안할경우 Commit이 불가능합니다.왜냐하면 버전관리의 의도는 해당 버전이 무엇인 변경되었는지 어떠한 코드가 추가되었는지알 수 있도록 해야하기 위함이기 때문입니다. Commit을 누를 경우 왼쪽에서 Branches 라는 탭을 보면 master라고 뜨면서 오른쪽 창에는제가 적은 코멘트와 함께 버전이 올아와있습니다.여기서 master는 저 자신 즉, 본인을 의미하고 왼쪽하단에는 코멘트와 날짜와 같은 정보,오른쪽 하단에는 추가된 내용이 있습니다. \\2. Git 사용하기2 ( 추가 버전 생성 ) 이제 다시 HTML 로 돌아와서 간단하게 내용을 추가하도록 하겠습니다. 태그 안에 ‘Git 테스트 공부!’ 라는 내용을 추가하고 저장을 하겠습니다. 그럴경우 master BRANCHES에서 변화가 생깁니다.Uncommitted changes라는 문구와 함께 새로운 버전이 올라와 있습니다.왼쪽에 나타난 쿠키모양의 아이콘은 버전관리중인 파일을 의미합니다. 그리고 하단을 보면 Working copy와 Staging Area 창이 보입니다.Working copy에 있는 파일을 눌러보면 오른쪽창에 무엇이 변경되었는지 확인할 수 있습니다.해당 파일을 Staging Area에 올려놓도록 하겠습니다. 해당 파일을 Staging Area에 올려놓고 오른쪽 클릭을 하면 Commit이 있습니다.해당 버튼을 클릭하면 오른쪽 그림처럼 코멘트를 입력할 수 있는 창이 뜨게 됩니다.해당 창에 ‘ 태그 내용 추가’라고 입력하고 Commit하도록 하겠습니다. 그러면 최종적으로 이제 새로운 버전이 추가된 것을 알 수 있습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://yoursite.com/categories/Etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"git-gui-study01","slug":"git-gui-study01","date":"2019-09-06T14:36:10.000Z","updated":"2019-09-06T14:37:34.821Z","comments":true,"path":"2019/09/06/git-gui-study01/","link":"","permalink":"http://yoursite.com/2019/09/06/git-gui-study01/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 - 1. Git의 개요 GIT이란? 프로젝트를 실행하면서 문제가 생길경우 문제를 찾기 위해 해매거나 수시로 과거의 파일을 뒤지면서 결국 예전 상태로 돌아가려는 행위를 한적이 있을 것이다. Git은 문제가 발생하여 프로젝트에 이상이 생길 경우 과거의 상태로 쉽게 돌아가게 해준다. 결과적으로서 실패에 대한 부담감이 확연히 줄어들고(그냥 과거로 백하면 되기떄문) 이것저것 시도를 할 수 있게 해주는 효과를 제공한다. 현재 Git은 버전관리, 백업, 협업과 같은 중대한 장점을 제공한다. 2. Git 설치 www.git-scm.com여기서 git을 받을 수 있다. GitAbout The advantages of Git compared to other source control systems. Documentation Command reference pages, Pro Git book content, videos and other material. Downloads GUI clients and binary releases for all major platforms. Community Get involved! Bug reporting, mailing list, chat, development andwww.git-scm.com △Git 다운로드 완료시 시작버튼에 Git에 관련된 아이콘들이 추가되어 있는 것을 확인 할 수 있다.▽Git Bash를 실행시키고 “git” 이라고 입력시 제대로 설치되었는지 확인할 수 있다. 이 Bash 창을 통해 Git을 유닉스 나 리눅스의 환경처럼 다룰수도 있고 명령어를 이용한 관리가 가능하다. 3. Git을 GUI 형태로 이용할 Source Tree( 소스트리 )설치 Git은 원래 명령어를 가지고 이용을 하는 버전관리 프로그램이다.하지만 이 기능이 너무 어렵고 GUI에 익숙해진 우리들로서는 너무너무 불편하다!따라서 GUI 기능을 가진 SW인 소스트리를 추가적으로 설치하자. 설치는 이곳에서 가능하다.https://www.sourcetreeapp.com/그 외 설치방법은 이 블로그의 포스트를 참조하자.http://codedragon.tistory.com/4907 Sourcetree | Free Git GUI for Mac and WindowsA Git GUI that offers a visual representation of your repositories. Sourcetree is a free Git client for Windows and Mac.www.sourcetreeapp.com SourceTree(소스트리) 설치하기SourceTree(소스트리) 설치파일 다운받기 http://codedragon.tistory.com/4906 SourceTree(소스트리) 설치하기 다운받은 설치파일을 실행합니다. [계속] 계정이 이미 있다면 [Use an existing account] 클릭 o..codedragon.tistory.com 다운로드 완료시 SourceTree 실행화면","categories":[{"name":"Etc","slug":"Etc","permalink":"http://yoursite.com/categories/Etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"html-css-study-02","slug":"html-css-study-02","date":"2019-09-05T16:15:15.000Z","updated":"2019-09-05T16:17:44.733Z","comments":true,"path":"2019/09/06/html-css-study-02/","link":"","permalink":"http://yoursite.com/2019/09/06/html-css-study-02/","excerpt":"","text":"HTML Study 02 display flex layout a 태그 position font css 개발 방법론 외부 css 적용 방법 ( reset CSS 와 normalize CSS ) 오늘의 중요점!css 문제가 생길시 홈페이지를 열어서 검사를 하고 항상 작은 단위부터 큰단위로 확인하다.( 특히 상속,겹침,우선순위 ) box-sizing 방식은 통일하는게 나중의 유지보수에 좋다. 123456&gt; *, *::before, *::after&#123;&gt; &gt; box-sizing: border-box;&gt; &gt; &#125; /*import 바로 아래*/&gt; 부모가 css box 레이아웃을 결정하면 자식도 그것을 따라감.(상속 - 무조건은 아니다. margin , padding 등등) display 요소(즉 태그)는 inline과 block 요소로 나뉜다. inline : 줄 속에 넣는 요소. 줄바꿈이 되지 않고 글자수에 따라 크기 자체가 줄고 늘어난다. block : 좀 더 넓은 범위를 지정할 때 사용하는 요소. 가로화면을 100% 다차지. 줄바꿈이 됨. display : inline - block과 다르게 줄바꿈이 안되고, width와 height가 적용되지 않는다. 오로지 적용된 글자 수에 따라서 크기가 결정된다. display : block - 가로 화면을 다 차지함. 줄바꿈 O display : none - 박스 생성x, 공간 차지x display : flex - 새로 생긴 display. 따라서 특정 버전이 낮은 브라우저에서는 실행X Flex layout flex 모델은 크기 수치를 잘못입력하여도 레이아웃이 크게 깨지지 않는다. 이유는 전체길이에 대해서 비율로 따져서 스스로 값을 정해주기 떄문. display: flexIE 10 or 그 이상 버전에서 사용 가능. flex 설정된 노드의 자식도 flex item을 가지고 모두 flex display가 된다. flex-direction (부모노드)flex-direction은 flex설정시 어떤 방향으로 제기 될것인가를 나열한다. 기본 flex-direction=row 이다. x축 , y축 으로 기준을 나눈다. row = x축 column = y축 flex-basis (자식 노드)flex-item의 크기를 결정합니다. 각 축에 해당하는 (width / height) 의 값을 설정. JUSTIFY-CONTENT: 메인 축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 space-between , flex-item들의 사이를 동일하게 비워줌. space-around, flex-item들의 사이를 비워줌. space-evenly : 익스플로러 지원x ALIGN-ITEMS: 교차축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 order : item 간에 순서를 지정합니다. flex-grow : item들 끼리 크기에 대한 비율을 결정합니다. ex) a-1 b-2 c-1 flex-shrink : flex-item의 크기가 flex-container보다 클때 다른 items의 크기들을 축소시키고 그만큼 해당 item크기를 확대 시킨다. a 태그1&gt; 하이퍼링크 태그인 &lt;a&gt; 는 상황에 따른 css 스타일을 지정할 수 있다. 1234a:link&#123; &#125; /* 선택 안했을 때의 css */a:visited&#123; &#125; /* 선택해서 들어갔을때 */a:hover&#123; &#125; /* 마우스 올라갔을때 글자색 변경 */a:active&#123; &#125; /* 마우스로 클릭한 순간의 상태 */ position static : MarkUp 순서대로 배치, top-bottom-left-right 의 속성값이 적용되지 않는다. absolute : 상위 요소(상위는 반드시 static이 아닌 다른 값)를 기준으로 위치를 설정. relative : 상위 요소(상위는 반드시 static)를 기준으로 위치를 설정. fixed : 요소의 위치를 사용자의 브라우저 기준으로 설정. ( 광고, 상단바, 하단바 등등) font em : 상위요소의 크기에 대해서 비율로 계산한다. rem : 최상위 요소(root)의 크기에 대해서 비율로 계산한다. line-height : 1.15 추천 SpoqaHanSans-kr 본고딕 ( 어도비 배포 ) 1@import url('https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css'); Noto Sans KR 본고딕( 구글 배포 ) 12345&lt;link href=\"https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap\" rel=\"stylesheet\"&gt;&lt;style&gt;@import url('https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap');&lt;/style&gt; CSS 개발 방법론 쉬운 유지보수 코드의 재사용 확장 가능 직관적인 네이밍 BEM OOCSS SMACSS [ CSS 개발 방법론 ] https://gomdoreepooh.github.io/notes/smacss-bem-oocss 외부 CSS 적용 방법 대표적 외부 CSS normalize CSS : 개발 초기 필요한 정도만 초기화 후 사용. Reset CSS : 개발 초기 불필요한 margin, padding 같은 크기들을 모두 초기화. ​ [nomalize css] https://github.com/necolas/normalize.css/ ​ [Reset css] https://meyerweb.com/eric/tools/css/reset/ 적용방법 ( 예 - nomalize ) 123456&lt;link rel=\"stylesheet\"href=\"https://necolas.github.io/normalize.css/latest/normalize.css\"&gt; &lt;style&gt;@import url('https://necolas.github.io/normalize.css/latest/normalize.css');&lt;/style&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-01","slug":"html-css-study-01","date":"2019-09-04T12:47:07.000Z","updated":"2019-09-05T12:40:33.967Z","comments":true,"path":"2019/09/04/html-css-study-01/","link":"","permalink":"http://yoursite.com/2019/09/04/html-css-study-01/","excerpt":"","text":"HTML Study 01 DTD 소개 및 사용 방법 html 영역의 언어 선택 head 영역 안 인코딩 선언 타이틀 요소를 이용한 좋은 제목을 만드는 방법 HTML의 구조 설계 CSS 레이아웃 박스 모델 WEB은 디자인관점이 아닌 콘텐츠 관점으로 보아야 한다.SEO 관점으로 페이지를 작성해야만 한다.문서와 구조와 표현을 분리 해놓는 것이 중요하다.DTD 소개 및 사용 방법 문서타입을 정의 한다. 브라우져에게 해당 HTML이 어떤 표준에 따른 것인지를 알려주는 것을 DTD(Document Type Definition)이라고 한다.DTD는 문서의 제일 위에 위치한다. &lt;! DOCTYPE html&gt; html 영역의 언어 선택 속성 lang=”언어” 식으로 한다. (영어 en, 한국 ko-KR) 언어를 지정해주는 이유는 SEO관점으로서 브라우저에서 검색엔진에 따른 효율성을 높이기 위함이다. head 영역 안 인코딩 선언 meta 태그는 빈요소이다. meta의 속성 charset은 인코딩 형식을 지원한다. 반드시 타이틀보다 먼저 등장해야만 한다. 1&lt;meta charset=\"UTF-8\"&gt; meta의 속성 http-equiv=”X-UA-Compatible” content=”ie=edge” 는 브라우저 사용자 호환성 모드를 의미한다. ( 예, 지원하는 렌더링 모드가 11인데 깔려있는 브라우저 렌더링 버전이 8일경우 11의 렌더링을 8로 호환하여 열어준다.) content는 기본 호환성 브라우저 렌더링 모드를 지정할수있다. 사용자의 브라우저가 edge브라우저를 지원한다면 해당 모드로 연다. 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; 타이틀 요소를 이용한 좋은 제목을 만드는 방법​ SEO 관점에 따라 타이틀 요소를 제대로 적는 것이 중요하다.​​ &gt; 검색 엔진 최적화 (영어: search engine optimization, SEO)는 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다.​​ 12​ &lt;title&gt;웹카페-HTML5,CSS3,웹표준,웹접근성&lt;/title&gt;​ ​​ ###​​​​ ### HTML의 구조 설계​​​​ ## 웹페이지 분석 -&gt; Mark Up -&gt; Naming​​ #### 분석 : 웹페이지는 주로 삼단 구조를 가진다.​​ &gt; 머리말(헤더)​ &gt;​ &gt; 본문(콘텐츠)​ &gt;​ &gt; 꼬리말(푸터)​​​​ #### Web. Cafe. 페이지 분석(삼단 ++)​​ &gt;머리말(헤더)​ &gt;​ &gt;+비주얼(광고등으로 활용가능성)​ &gt;​ &gt;본문(콘텐츠)​ &gt;​ &gt;+슬로건 (커피잔 , 명언)​ &gt;​ &gt;꼬리말(푸터)​​​​ #### Mark Up 단계​​ &gt; body 태그 안​ &gt;​ &gt; ​ header - 머리말​ &gt;​ &gt; ​ div - 비주얼​ &gt;​ &gt; ​ main - 본문​ &gt;​ &gt; ​ article - RSS, 슬로건​ &gt;​ &gt; ​ footer - 꼬리말​​​​ #### Naming 단계 ( Naming : 컴퓨터가 이해할 수 있도록 이름을 지어준다. )​​ &gt; ### { top , bottom 같은 위치 기반 이름은 정말로 안좋음!!! }​ &gt;​ &gt; 이름 주는 방법​ &gt;​ &gt; class : 여러번 사용가능.​ &gt;​ &gt; id : 고유하게 정할 때 사용.​​​​ ### CSS 레이아웃​​ &gt; 정통방식 : float , position, display:inline, display:inline-block​ &gt;​ &gt; 모던방식 : display:inline, display:inline-block, flex, glid​​ ### 박스 모델​​ 12​ box-sizing: content-box | border-box | initial | inherit​ ​​ - content-box : 콘텐트 영역을 기준으로 크기를 정합니다.​ - border-box : 테두리를 기준으로 크기를 정합니다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/tags/TIL/"}]},{"title":"백준 TEST07_문자열 사용하기","slug":"Algorism-for-java07","date":"2019-09-04T10:26:52.000Z","updated":"2019-09-04T11:07:17.131Z","comments":true,"path":"2019/09/04/Algorism-for-java07/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java07/","excerpt":"","text":"백준 TEST07_문자열 사용하기필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 아스키코드1234567891011121314class TEST07_01&#123; public TEST07_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int a = n.charAt(0); // n에 담겨진 첫번째 문자(0번쨰)를 캐릭터형으로 변환후 다시 정수형으로 변환. bw.write(a +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (이클립스 상 답이 맞지만 어째서인지 오답처리됨.)123456789101112131415161718192021222324252627282930313233343536373839404142434445class TEST07_02_t&#123; public TEST07_02_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; int null_num = -1; String S = null; String str = \"abcdefghijklmnopqrstuvwxyz\"; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(int i=0;i&lt;str.length();i++)&#123; int a = 0; for(int j=0;j&lt;S.length();j++)&#123; if(j &gt;= 1 &amp;&amp; S.charAt(j-1) == S.charAt(j))&#123; continue; &#125; if(str.charAt(i) == S.charAt(j))&#123; bw.write(j + \" \"); a++; &#125; &#125; if(a==0)&#123; bw.write(null_num + \" \"); &#125; &#125; bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (정답)123456789101112131415161718192021222324252627282930class TEST07_02_A&#123; public TEST07_02_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; String S = null; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(char alphabet = 'a'; alphabet &lt;= 'z'; alphabet++) &#123; bw.write(S.indexOf(alphabet) + \" \"); &#125; //String.indexOf() 메소드는 원하는 값을 문자열 내에서 원하는 값을 찾아 인덱스 값을 반환한다. 단, 원하는 값이 없으면 -1 을 반환한다. bw.flush(); bw.close(); &#125;&#125; 문자열 반복123456789101112131415161718192021222324class TEST07_03&#123; public TEST07_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = Integer.parseInt(br.readLine()); String a = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\$%*+-./:\"; int b = 0; for(int i=0;i&lt;n;i++)&#123; String xx = br.readLine(); for(int z=2;z&lt;xx.length();z++)&#123; for(int j=0;j&lt;Integer.parseInt(xx.substring(0, 1));j++)&#123; bw.write(xx.charAt(z)); &#125; &#125; bw.write(\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (시간초과 ㅜㅜㅜㅜㅜㅜㅜㅜ)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class TEST07_04_t&#123; public TEST07_04_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String a = null; String A = null; ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); int[] num; while(true)&#123; int count = 0; a = br.readLine(); A = a.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 num = new int[A.length()]; //입력받은 문자의 갯수만큼 정수형 배열을 생성. if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! array.add(String.valueOf(chrInput)); &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end //각각 자신의 개수를 비교하기 시작. for (int i = 0; i &lt; A.length()-1; i++) &#123; for(int j=i+1;j&lt;A.length();j++)&#123; if(array.get(i).equals(array.get(j)))&#123; num[i]++; &#125;//if end &#125;//for-2 end &#125;//for-1 end int temp = 0; String chr_tmp = \"\"; for(int i=0;i&lt;A.length()-1;i++)&#123; for(int j=i+1;j&lt;A.length();j++) if(num[i]&gt;num[j])&#123; temp = num[i]; chr_tmp = array.get(i); num[i] = num[j]; array.set(i,array.get(j)); num[j] = temp; array.set(j,chr_tmp); &#125; &#125; /* for(int i=0;i&lt;A.length();i++)&#123; bw.write(array.get(i)+\" \"); &#125; bw.write(\"\\n\\n\"); for(int i=0;i&lt;A.length();i++)&#123; bw.write(num[i]+\" \"); &#125; bw.write(\"\\n\\n\"); */ if(num.length == 1)&#123; bw.write(array.get(0)); &#125; else if(num[A.length()-1] == num[A.length()-2])&#123; bw.write(\"?\\n\"); &#125; else&#123; bw.write(array.get(A.length()-1)); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (정답)123456789101112131415161718192021222324252627282930313233343536373839404142class TEST07_04_A&#123; public TEST07_04_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String A = null; int[] num = new int[26]; int max = 0; char answer = 0; while(true)&#123; int count = 0; A = br.readLine(); A = A.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end for(int i=0;i&lt;A.length();i++)&#123; num[A.charAt(i)-65]++; if(num[A.charAt(i)-65]&gt;max)&#123; //최초 max는 0 answer = A.charAt(i); max = num[A.charAt(i)-65]; //max값이 증가한다. &#125; else if((num[A.charAt(i)-65]==max))&#123; answer = '?'; &#125; &#125; bw.write(answer); bw.flush(); bw.close(); &#125;&#125; 그룹 단어 체커1234567891011121314151617181920212223242526272829303132333435363738394041class TEST07_05&#123; public TEST07_05()throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String str = null; int count = 0; // a-97 z-122 while(true)&#123; int n = Integer.parseInt(br.readLine()); count = n; int i=0; if(n&lt;=100)&#123; for(i=0;i&lt;n;i++)&#123; int[] num = new int[26]; str = br.readLine(); num[str.charAt(0)-97] = -1; //맨 처음 문자 값은 -1 if(str.length()&gt;1) &#123; for(int j=1;j&lt;str.length();j++)&#123; if(num[str.charAt(j)-97] == -1 &amp;&amp; str.charAt(j) != str.charAt(j-1))&#123; count--; //초기값으로 -1을 지정하였고 그 다음에는 서로 붙어있는지 비교함. 만약 안 붙어있다면 카운트-- break; &#125;//if end num[str.charAt(j) - 97] = -1; // 초기값을 -1로 초기화 시켜나감. &#125;//for-j end &#125;//if end &#125;//for-i end bw.write(count+\"\"); &#125;//if end if(i == n) &#123; break; &#125; &#125;//while end bw.flush(); bw.close(); &#125; &#125; 6단계 - 1차원배열 사용하기 1번문제 임. (전 포스팅 참조)상수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class TEST07_07&#123; public TEST07_07() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] num; while(true)&#123; num = br.readLine().split(\" \"); int w_count = 0; if(num[0].length() &gt; 3 &amp;&amp; num[0].length() &lt; 0)&#123; continue; &#125; if(num[1].length() &gt; 3 &amp;&amp; num[1].length() &lt; 0)&#123; continue; &#125; for(int i=0;i&lt;2;i++)&#123; w_count = 0; for(int j=0;j&lt;num[i].length();j++) if(num[i].charAt(j) == '0')&#123; w_count++; break; &#125; &#125; if(w_count &gt;= 1 )&#123; continue; &#125; int A = Integer.parseInt(num[0]); int B = Integer.parseInt(num[1]); if(A != B)&#123; break; &#125; &#125; int a = 0; int[] sum = new int[2]; for(int i=0;i&lt;2;i++)&#123; for(int j=2;j&gt;=0;j--)&#123; switch(j)&#123; case 2 : a = num[i].charAt(j) - '0'; a = a*100; break; case 1 : a = num[i].charAt(j) - '0'; a = a*10; break; case 0 : a = num[i].charAt(j) - '0'; break; &#125;// charAt(i) - '0' -&gt; char형을 int형으로 변환 sum[i] = sum[i] + a; &#125; &#125; if(sum[0] &gt; sum[1])&#123; bw.write(sum[0] + \"\"); &#125; else&#123; bw.write(sum[1] + \"\"); &#125; bw.flush(); bw.close(); &#125;&#125; 다이얼1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST07_08&#123; public TEST07_08() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String num; int count = 0; while(true)&#123; num = br.readLine(); int w_count = 0; if(num.length()&lt;2 &amp;&amp; num.length()&gt;15)&#123; continue; &#125; for(int i=0;i&lt;num.length();i++)&#123; if(num.charAt(i) &lt; 64 &amp;&amp; num.charAt(i) &gt; 91)&#123; w_count++; break; &#125; &#125;//대문자로만 입력 if(w_count == 0)&#123; break; &#125; &#125; for(int i=0;i&lt;num.length();i++)&#123; switch(num.charAt(i))&#123; case 'A': case 'B': case 'C' : count += 3; break; case 'D': case 'E': case 'F' : count += 4; break; case 'G': case 'H': case 'I' : count += 5; break; case 'J': case 'K': case 'L' : count += 6; break; case 'M': case 'N': case 'O' : count += 7; break; case 'P': case 'Q': case 'R' : case 'S' : count += 8; break; case 'T': case 'U': case 'V' : count += 9; break; case 'W': case 'X': case 'Y' : case 'Z' : count += 10; break; &#125; &#125; bw.write(count + \"\"); bw.flush(); bw.close(); &#125;&#125; 크로아티아 알파벳12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TEST07_09&#123; public TEST07_09() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String c_alpha2[] = &#123;\"c=\",\"c-\",\"d-\",\"lj\",\"nj\",\"s=\",\"z=\"&#125;; String c_alpha3 = \"dz=\"; String croa; while(true)&#123; croa = br.readLine(); int w_count = 0; if(croa.length()&lt;1 &amp;&amp; croa.length()&gt;100)&#123; continue; &#125; for(int i=0;i&lt;croa.length();i++)&#123; if(croa.charAt(i) &lt; 97 || croa.charAt(i) &gt; 122)&#123; if (croa.charAt(i) == '-'|| croa.charAt(i) == '=' )&#123; continue; &#125; w_count++; break; &#125; //소문자 혹은 '-' '=' 가 아닐경우 무한반복 &#125; if(w_count == 0)&#123; break; &#125; &#125; int count = croa.length(); while(true)&#123; if(croa.indexOf(c_alpha3) &gt; -1)&#123; count = count - 2; croa = croa.replaceFirst(c_alpha3,\" \"); &#125; else&#123; break; &#125; &#125;//\"dz=\" 이라는 문자가 존재시 해당 문자를 빼머리고 전체값에서 -2 후 공백으로 변환. for(int k=0;k&lt;7;k++)&#123; while(true)&#123; if(croa.indexOf(c_alpha2[k]) &gt; -1)&#123; count = count - 1; croa = croa.replaceFirst(c_alpha2[k],\" \"); &#125; else&#123; break; &#125; &#125; &#125;//for-k end bw.write(count + \" \"); bw.flush(); bw.close(); &#125;&#125; Main123456789101112131415public class TEST07 &#123; //Main&#123; public static void main(String[] args) throws IOException&#123; // TEST07_01 test07_01 = new TEST07_01(); // TEST07_02_t test07_02_t = new TEST07_02_t(); // TEST07_02_A test07_02_A = new TEST07_02_A(); // TEST07_03 test07_03 = new TEST07_03(); // TEST07_04_t test07_04_t = new TEST07_04_t(); //시간초과 // TEST07_04_A test07_04_A = new TEST07_04_A(); //정답 // TEST07_05 test07_05 = new TEST07_05(); //6번 문제는 1차원배열사용하기 - 1번문제 // TEST07_07 test07_07 = new TEST07_07(); // TEST07_08 test07_08 = new TEST07_08(); TEST07_09 test07_09 = new TEST07_09(); &#125;&#125;","categories":[{"name":"Algorism","slug":"Algorism","permalink":"http://yoursite.com/categories/Algorism/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST06_1차원 배열 사용하기","slug":"Algorism-for-java06","date":"2019-09-04T10:26:50.000Z","updated":"2019-09-04T11:05:10.989Z","comments":true,"path":"2019/09/04/Algorism-for-java06/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java06/","excerpt":"","text":"백준 TEST06_1차원 배열 사용하기 필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 단어의개수123456789101112131415161718192021222324252627282930313233class TEST06_01 &#123; public TEST06_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int count=1; for(int i=0;i&lt;n.length();i++)&#123; char chrInput = n.charAt(i); if(n.charAt(i) ==' ')&#123; count++; &#125; if (chrInput &lt; 0x61 &amp;&amp; chrInput &gt; 0x7A) &#123; break; &#125; // 영문(소문자)가 아닐경우 무한 반복! else if (chrInput &lt; 0x41 &amp;&amp; chrInput &gt; 0x5A) &#123; break; &#125; // 영문(대문자)가 아닐 경우 무한 반복! &#125;// for end //count++; if(n.charAt(0)==' ' &amp;&amp; n.charAt(n.length()-1)==' ')&#123; count--; count--; &#125; else if(n.charAt(0)==' ' || n.charAt(n.length()-1)==' ')&#123; count--; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 숫자의 개수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TEST06_02&#123; public TEST06_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int[] num = new int[10]; int A = Integer.parseInt(br.readLine()); int B = Integer.parseInt(br.readLine()); int C = Integer.parseInt(br.readLine()); //bw.write( A * B * C +\"\\n\"); String sum = A * B * C +\"\"; //bw.write(sum); char[] a = sum.toCharArray(); for(int i=0;i&lt;a.length;i++)&#123; switch(a[i])&#123; case '0' : num[0]++; break; case '1' : num[1]++; break; case '2' : num[2]++; break; case '3' : num[3]++; break; case '4' : num[4]++; break; case '5' : num[5]++; break; case '6' : num[6]++; break; case '7' : num[7]++; break; case '8' : num[8]++; break; case '9' : num[9]++; break; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; bw.write(num[i]+\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; OX퀴즈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST06_03&#123; public TEST06_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int t_case = Integer.parseInt(br.readLine()); int[] num = new int[t_case]; String[] ox = new String[t_case]; // O- 0x4F X-0x58 while(true)&#123; int i = 0; for(i=0;i&lt;t_case;i++)&#123; int j = 0; ox[i] = br.readLine(); char[] chrInput= ox[i].toCharArray(); if(ox[i].length() &gt; 80 || ox[i].length() &lt; 0)&#123; break; //MAIN FOR BREAK &#125; for(j=0;j&lt;ox[i].length();j++)&#123; if(chrInput[j] == 'O' ||chrInput[j] == 'X') continue; else break; //SUB FOR BREAK &#125; if(j!=ox[i].length()) break; //MAIN FOR BREAK &#125; if(i==t_case) break; //O혹은 X가 아닐경우 처음 부터 다시 &#125;//while end for(int i=0;i&lt;t_case;i++)&#123; char[] sub = ox[i].toCharArray(); int score = 0; for(int j=0;j&lt;ox[i].length();j++)&#123; if(sub[j] == 'O')&#123; score++; num[i] += score; &#125; else score = 0; &#125;// for - j end bw.write(num[i] + \"\\n\"); &#125;//for - i end bw.flush(); bw.close(); &#125;&#125; 음계1234567891011121314151617181920212223242526272829303132333435363738class TEST06_04&#123; public TEST06_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] m = br.readLine().split(\" \"); String[] x = new String[8]; String[] y = new String[8]; int count = 0 ; for(int i=0;i&lt;m.length;i++)&#123; x[i] = String.valueOf(i+1); y[i] = String.valueOf(8-i); if(x[i].equals(m[i]))&#123; count++; &#125; if(y[i].equals(m[i]))&#123; count--; &#125; &#125; // bw.write(m.length+\"\\n\"); // bw.write(x[3]+\"\\n\"); if(m[0].equals(\"1\") &amp;&amp; count == 8)&#123; bw.write(\"ascending\"); &#125; else if(m[0].equals(\"8\") &amp;&amp; count == -8)&#123; bw.write(\"descending\"); &#125; else&#123; bw.write(\"mixed\"); &#125; bw.flush(); bw.close(); &#125;&#125; 평균 점수12345678910111213141516171819202122232425262728class TEST06_05&#123; public TEST06_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int sum = 0; while(true)&#123; int i=0; for(i=0;i&lt;5;i++)&#123; int n = Integer.parseInt(br.readLine()); if(n&lt;0 || n%5!=0)&#123; break; &#125; if(n&lt;40) n=40; sum += n; &#125;//main for end if(i==5)&#123; break; &#125; &#125;//while end bw.write(sum/5 +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; Main123456789public class TEST06 &#123; public static void main(String[] args) throws IOException&#123; // TEST06_01 test06_01 = new TEST06_01(); // TEST06_02 test06_02 = new TEST06_02(); // TEST06_03 test06_03 = new TEST06_03(); // TEST06_04 test06_04 = new TEST06_04(); TEST06_05 test06_05 = new TEST06_05(); &#125;&#125;","categories":[{"name":"Algorism","slug":"Algorism","permalink":"http://yoursite.com/categories/Algorism/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST05_함수 사용하기","slug":"Algorism-for-java05","date":"2019-09-04T10:26:48.000Z","updated":"2019-09-04T11:01:07.377Z","comments":true,"path":"2019/09/04/Algorism-for-java05/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java05/","excerpt":"","text":"## 필요 패키지 및 외부 클래스 123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 셀프넘버12345678910111213141516171819202122232425262728293031323334class hamsu&#123; public int d(int num)&#123; int xxxx = num/1000; int xxx = (num/100)%10; int xx = (num/10)%10; int x = num%10; num = num + xxxx + xxx + xx + x; return num; &#125;&#125;class TEST05_01 extends hamsu&#123; public TEST05_01()&#123;// ArrayList array = new ArrayList(); int i = 0; int[] fin = new int[10000]; //배열 10000개 선언 알아서 0으로 초기화함. for(i=0;i&lt;10000;i++)&#123; if(d(i)&lt;10000)&#123; fin[d(i)] = 1; &#125; if(fin[i] == 0)&#123; System.out.println(i); &#125; &#125; &#125; &#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_01 test05_01 = new TEST05_01(); &#125;&#125; 한수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST05_02 &#123; public TEST05_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int count = 0; int xxxx,xxx,xx,x = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000)&#123; break; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i&lt;100)&#123; count++; &#125; if(i&gt;=100)&#123; xxx = i/100; xx = (i/10)%10; x = i%10; if(xx-x==xxx-xx)&#123; count++; &#125; &#125; if(i&gt;=1000)&#123; xxxx = i/1000; xxx = (i/100)%10; xx = (i/10)%10; x = i%10; if(xxxx-xxx == xxx-xx) if(xx-x == xxx-xx)&#123; count++; &#125; &#125; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_02 test05_02 = new TEST05_02(); &#125;&#125; 별찍기 - 11 별찍기에 대해서 초반에 어떻게 문제를 풀어야하는지 감이 너무 오질 않았다. 따라서 강의를 보면서 이해하는 형식으로 진행하였다. 해당 강의는 C를 기반으로 진행하였으므로 나는 자바의 형식에 맞게 수정을 해주었다. https://youtu.be/WjmEVp-Lgns 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class TEST05_03 &#123; static char[][] arr; public TEST05_03() throws IOException&#123; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = input_num(); arr = new char[n][2*n-1]; //예제 y축 24칸, x축 47칸임(맨 아래 밑변). //배열 선언은 while문 아래가 될 수 없다. for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;2*n-1; j++) &#123; arr[i][j] = ' '; &#125; &#125;//초기화 구문, 자바에서 미선언시 char은 널값으로 초기화됨. 따라서 모두 공백으로 미리 초기화. solution(n,n-1,0);// n은 몇층까지 를 의미, n-1은 첫 시작의 별 위치 -&gt; x축, 0은 첫줄을 의미한다. -&gt;y축 for(int i=0; i&lt;n; i++) &#123; bw.write(arr[i]); bw.write('\\n'); &#125; //이차원배열로 선언되었기 때문에 a[i]번째 줄에 저장된 모든 값을 출력. bw.flush(); bw.close(); &#125; public int input_num() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = 0; int count = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); for(int k=0;k&lt;=10;k++)&#123; if(n==3*(Math.pow(2, k)))&#123; count = 1; &#125; //제대로 된 수를 입력할 때 까지 무한반복 N은 3*2^k승. &#125; if(count == 1) break; &#125; return n; &#125; // 제대로된 n값을 입력하였느지 확인. 제대로된 값이 아니라면 무한반복. public void solution(int n,int x,int y)&#123; if (n == 3) &#123; arr[y][x] = '*'; //첫 별 * arr[y + 1][x - 1] = '*'; //두번 째 별 1 * * arr[y + 1][x + 1] = '*'; //두번째 별 2 arr[y + 2][x - 2] = '*'; //세번째 별 1 ***** arr[y + 2][x - 1] = '*'; //세번째 별 2 ***** arr[y + 2][x] = '*'; //세번째 별 3 ***** arr[y + 2][x + 1] = '*'; //세번째 별 4 ***** arr[y + 2][x + 2] = '*'; //세번째 별 5 ***** return; &#125; //n이 3일때 별을 그려주는 로직 시작. // n이 3이 최소임. solution(n/2, x, y); // 첫 큰 삼각형 solution(n/2, x-(n/2) , y+(n/2)); // 왼쪽 큰 삼각형 solution(n/2, x+(n/2) , y+(n/2)); // 오른쪽 큰 삼각형 &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_03 test05_03 = new TEST05_03(); &#125;&#125;","categories":[{"name":"Algorism","slug":"Algorism","permalink":"http://yoursite.com/categories/Algorism/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST04_if문 사용해보기","slug":"Algorism-for-java04","date":"2019-09-04T10:26:47.000Z","updated":"2019-09-04T10:57:31.653Z","comments":true,"path":"2019/09/04/Algorism-for-java04/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java04/","excerpt":"","text":"백준 TEST04_if문 사용해보기 기본 필요 패키지 및 외부클래스123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 시험성적1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST04_01&#123; public TEST04_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&gt;= 0 &amp;&amp; n&lt;101)&#123; break; &#125; &#125; switch (n/10) &#123; case 10 : case 9 : bw.write(\"A\\n\"); bw.flush(); break; case 8 : bw.write(\"B\\n\"); bw.flush(); break; case 7 : bw.write(\"C\\n\"); bw.flush(); break; case 6 : bw.write(\"D\\n\"); bw.flush(); break; default : bw.write(\"F\\n\"); bw.flush(); break; &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_01 test04_01 = new TEST04_01(); &#125;&#125; 세 수 - 버전112345678910111213141516171819202122232425262728293031323334class TEST04_02_01&#123; public TEST04_02_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); if ((A&gt;=B)&amp;&amp;(A&lt;=C)||(A&gt;=C)&amp;&amp;(A&lt;=B))&#123; bw.write(A+\"\\n\"); bw.flush(); bw.close(); &#125; else if((B&gt;=C)&amp;&amp;(B&lt;=A)||(B&gt;=A)&amp;&amp;(B&lt;=C))&#123; bw.write(B+\"\\n\"); bw.flush(); bw.close(); &#125; else&#123; bw.write(C+\"\\n\"); bw.flush(); bw.close(); &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_01 test04_02_01 = new TEST04_02_01(); &#125;&#125; 세 수 - 버전2 (정렬이용)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TEST04_02_02&#123; public TEST04_02_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; int tmp; ArrayList&lt;Integer&gt; num = new ArrayList&lt;&gt;(); String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); num.add(A); num.add(B); num.add(C); //버블정렬 for(int i=1;i&lt;num.size();i++)&#123; for(int j=0;j&lt;num.size()-i;j++)&#123; if(num.get(j)&gt;=num.get(j+1))&#123; //num.get(1);//확인. num.set(1,temp);//수정. tmp = num.get(j); num.set(j, num.get(j+1)); num.set(j+1, tmp); &#125; &#125; &#125; /* //선택정렬 for(int i=0;i&lt;num.size()-1;i++)&#123; for(int j=i+1;j&lt;num.size();j++)&#123; if(num.get(i) &gt;= num.get(j)) &#123; tmp = num.get(j); num.set(j,num.get(i)); num.set(i,tmp); &#125; &#125; &#125; */ bw.write(num.get(1)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_02 test04_02_02 = new TEST04_02_02(); &#125;&#125; X보다 작은 수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST04_03&#123; public TEST04_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int i = 0; int x = 0; while(true)&#123; String[] a = br.readLine().split(\" \"); n = Integer.parseInt(a[0]); x = Integer.parseInt(a[1]); if(x&gt;=1 &amp;&amp; x&lt;=10000 &amp;&amp; n&gt;=1 &amp;&amp; n&lt;=10000)&#123; break; &#125; &#125; String[] A = br.readLine().split(\" \"); while(true)&#123; for(i=0;i&lt;n;i++)&#123; int y = Integer.parseInt(A[i]); if(y&lt;=0 &amp;&amp; y&gt;=10000)&#123; break; &#125; if(y&lt;x)&#123; bw.write(y+\" \"); &#125; &#125; if(i==n)&#123; break; &#125; &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_03 test04_03 = new TEST04_03(); &#125;&#125; 평균1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TEST04_04&#123; public TEST04_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); //정수형을 값을 저장할 리스트 공간 int n,i,tmp = 0; //n은 과목수 , i는 조건을 위한 수 , tmp는 임시저장소 , sum 최종합 double sum = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000) break; &#125; while(true)&#123; String[] a = br.readLine().split(\" \"); for(i=0;i&lt;n;i++)&#123; tmp = Integer.parseInt(a[i]); array.add(Integer.parseInt(a[i])); if(tmp&gt;100 &amp;&amp; tmp&lt;=0)&#123; break; &#125; &#125; if(i==n)&#123; break; &#125; &#125; for(i=0;i&lt;array.size()-1;i++)&#123; for(int j=i+1;j&lt;array.size();j++)&#123; if(array.get(i)&gt;array.get(j))&#123; tmp = array.get(i); array.set(i, array.get(j)); array.set(j,tmp); &#125; &#125; &#125;//선택정렬 이용 for(i = 0;i&lt;array.size();i++)&#123; sum += array.get(i); &#125; bw.write((double)(sum/array.size()/array.get(array.size()-1)*100.0)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_04 test04_04 = new TEST04_04(); &#125;&#125; 텍스트 추가 \\05. 평균은 넘겠지 텍스트 추가 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TEST04_05&#123; public TEST04_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Double&gt; number = new ArrayList&lt;&gt;(); int C = Integer.parseInt(br.readLine()); int j = 0; double hap = 0; while(true)&#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); double num = 0; int sum = 0; double avg = 0; String[] x = br.readLine().split(\" \"); if(Integer.parseInt(x[0])&lt;1 &amp;&amp; Integer.parseInt(x[0])&gt;1000)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); for(int i=0;i&lt;=Integer.parseInt(x[0]);i++)&#123; array.add(Integer.parseInt(x[i])); if(Integer.parseInt(x[i])&lt;0 &amp;&amp; Integer.parseInt(x[i])&gt;100)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); &#125; sum = 0; for(int i=1;i&lt;array.size();i++)&#123; sum = sum + array.get(i); &#125; avg = sum/array.get(0); for(int i=1;i&lt;array.size();i++)&#123; if(array.get(i)&gt;avg)&#123; num++; &#125; &#125; hap = num/array.get(0); number.add((num/array.get(0))*100); j++; if(j==C)&#123; break; &#125; &#125; for(int i=0;i&lt;C;i++)&#123; System.out.printf(\"%.3f\",number.get(i)); System.out.println(\"%\"); &#125; /* for(int i=0;i&lt;C;i++)&#123; bw.write(number.get(i)+\"%\"+\"\\n\"); &#125; bw.flush(); bw.close(); */ &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_05 test04_05 = new TEST04_05(); &#125;&#125; 더하기 사이클123456789101112131415161718192021222324252627282930313233343536373839404142class TEST04_06&#123; public TEST04_06() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int xx = 0; int x = 0; int fin = 0; int cycle_num = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); fin = n; if(n&gt;=0 &amp;&amp; n&lt;=99)&#123; break; &#125;// 아닐경우 무한반복 &#125; while(true)&#123; xx = n/10; x = n%10; n = (xx + x)%10; n = (x*10)+n; cycle_num++; if(fin == n)&#123; break; &#125; &#125; bw.write(cycle_num+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_06 test04_06 = new TEST04_06(); &#125;&#125;","categories":[{"name":"Algorism","slug":"Algorism","permalink":"http://yoursite.com/categories/Algorism/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST03_for문 사용해보기","slug":"Algorism-for-java03","date":"2019-09-04T10:26:45.000Z","updated":"2019-09-04T10:53:41.997Z","comments":true,"path":"2019/09/04/Algorism-for-java03/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java03/","excerpt":"","text":"백준_TEST03_for문 사용해보기N찍기123456789101112131415161718192021import java.util.*;class TEST03_01&#123; public TEST03_01()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_01 test03_01 = new TEST03_01(); &#125;&#125; 기찍 N123456789101112131415161718192021import java.util.*;class TEST03_02&#123; public TEST03_02()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=N;i&gt;=1;i--)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_02 test03_02 = new TEST03_02(); &#125;&#125; 구구단12345678910111213141516171819202122import java.util.*;class TEST03_03&#123; public TEST03_03()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=9;i++)&#123; System.out.println(N+\" * \"+i+\" = \"+N*i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_03 test03_03 = new TEST03_03(); &#125;&#125; 별찍기-1123456789101112131415161718192021222324import java.util.*;class TEST03_04&#123; public TEST03_04()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_04 test03_04 = new TEST03_04(); &#125;&#125; 별찍기-21234567891011121314151617181920212223242526272829303132333435import java.util.*;class TEST03_05&#123; public TEST03_05()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); // int K = N-1; for(int i=1;i&lt;=N;i++)&#123; /* for(int x=K;x&gt;=1;x--)&#123; System.out.print(\" \"); &#125; */ for(int j=1;j&lt;=N-i;j++)&#123; System.out.print(\" \") ; &#125; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; //K--; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_05 test03_05 = new TEST03_05(); &#125;&#125; 별찍기-3123456789101112131415161718192021222324252627import java.util.*;class TEST03_06&#123; public TEST03_06()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=N-i+1;j&gt;=1;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_06 test03_06 = new TEST03_06(); &#125;&#125; 별찍기-4123456789101112131415161718192021222324252627import java.util.*;class TEST03_07&#123; public TEST03_07()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;i;j++)&#123; System.out.print(\" \"); &#125; for(int j=N-i;j&gt;0;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_07 test03_07 = new TEST03_07(); &#125;&#125; ###2007년 -&gt; 해결은 하였으나 더 간단하게 푸는 방법이 존재함. -&gt; 1번=직접 해결한 소스. 2번=해답 소스 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1번import java.util.*;class TEST03_08&#123; public TEST03_08()&#123; Scanner scan = new Scanner(System.in); int x,y,z = 0; //z는 일주일 7을 의미. while(true)&#123; x = scan.nextInt(); if(x&gt;=1 &amp;&amp; x&lt;=12)&#123; break; &#125; &#125; while(true)&#123; y = scan.nextInt(); if(y&gt;=1 &amp;&amp; y&lt;=31)&#123; break; &#125; &#125; // x = 월, y = 일을 입력받는다. //ArrayList&lt;String&gt; month = new ArrayList&lt;&gt;(); //month.add(\"SUN\");month.add(\"MON\"); //한개씩은 위처럼 한번에는 아래처럼 이용. Array.asList ArrayList&lt;String&gt; week = new ArrayList&lt;&gt;(Arrays.asList(\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\",\"SUN\")); for(int i=1;i&lt;=12;i++)&#123; if(i==1 || i==3 || i==5|| i==7 || i==8 || i==10 || i==12)&#123; for(int j=1;j&lt;=31;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 1,3,5,7,8,10,11,12 월 for문 end &#125; else if(i==2)&#123; for(int j=1;j&lt;=28;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 2월 for문 end &#125; else&#123; for(int j=1;j&lt;=30;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 4,6,9,11 월 for문 end &#125; // if end &#125;//for-i end &#125; &#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_08 test03_08 = new TEST03_08(); &#125;&#125; 12345678910111213141516171819202122//2번 - 해답import java.util.Scanner; public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int month = sc.nextInt(); int day = sc.nextInt(); sc.close(); int[] daysInMonth = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; String[] dayOfTheWeeks = &#123;\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"&#125;; int totalDays = day; for (int i = 0; i &lt; month - 1; ++i) &#123; totalDays += daysInMonth[i]; &#125; System.out.println(dayOfTheWeeks[totalDays % 7]); &#125;&#125; 합123456789101112131415161718192021import java.util.*;class TEST03_09&#123; public TEST03_09()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int sum = 0; for(int i=1;i&lt;=n;i++)&#123; sum += i; &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_09 test03_09 = new TEST03_09(); &#125;&#125; 숫자의 합 &lt;미해결&gt;-&gt; 미해결한 이유 : Scanner 메서드로는 숫자를 1개씩 입력 받는건 불가능하다. 123456789101112131415161718192021222324252627import java.util.*;class TEST03_10_1&#123; public TEST03_10_1()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int a = 0; int sum = 0; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=n;i++)&#123; a = scan.nextInt(); array.add(a); &#125; for(int i=1;i&lt;=n;i++)&#123; sum += array.get(i-1); &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_1 test03_10_1 = new TEST03_10_1(); &#125;&#125; 숫자의 합 &lt;해결&gt;-&gt; 해결법 : 문자열로 받아서 끊어서 하나하나 더하거나 아스키코드를 이용한다. -&gt; 여기서는 끊어서 사용하는 substring() 함수를 이용. 12345678910111213141516171819202122232425import java.util.*;class TEST03_10_2&#123; public TEST03_10_2()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); String a = scan.next(); scan.close(); int sum = 0; for(int i=0;i&lt;n;i++)&#123; sum += Integer.parseInt(a.substring(i, i + 1)); &#125; //Integer.parseInt() 인트형으로 형변환 메서드 //substring(a,b); a=현재위치 b=까지 System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_2 test03_10_2 = new TEST03_10_2(); &#125;&#125; 열 개씩 끊어 출력하기1234567891011121314151617181920212223import java.util.*;class TEST03_11&#123; public TEST03_11()&#123; Scanner scan = new Scanner(System.in); String n = scan.next(); scan.close(); for(int i=1;i&lt;=n.length();i++)&#123; System.out.print(n.charAt(i-1)); if(i%10==0)&#123; System.out.println(\"\"); &#125; &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_11 test03_11 = new TEST03_11(); &#125;&#125; 빠른 A+B (BufferedReader , BufferedWriter)1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;class TEST03_12&#123; public TEST03_12() throws IOException&#123; //버퍼드리더와 버퍼드라이터를 쓰기 위한 조건 : throws NumberFormatException, IOException BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));//선언 int test_case = Integer.parseInt(br.readLine()); // 몇개 입력? //readline은 버퍼에 입력하는것. for(int i=0; i&lt;test_case;i++) &#123; //ex) 5개라 입력했으면 총 5줄의 입력을 받음. String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. bw.write(\"현재 입려숫자는 각각\"+a[0]+\" \"+a[1]+\"\\n\"); int answer = Integer.parseInt(a[0]) + Integer.parseInt(a[1]); bw.write(answer+\"\\n\"); // write는 버퍼에 해당 값을 저장하는것. // flush는 버퍼에 있는 내용을 printf하는것이다. // 여기서 한번 flush를 해버리면 버퍼의 내용을 출력과 동시에 비운다. &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_12 test03_12 = new TEST03_12(); &#125;&#125;","categories":[{"name":"Algorism","slug":"Algorism","permalink":"http://yoursite.com/categories/Algorism/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준_TEST02_사칙연산 도전하기","slug":"Algorism-for-java02","date":"2019-09-04T10:26:42.000Z","updated":"2019-09-04T10:48:19.364Z","comments":true,"path":"2019/09/04/Algorism-for-java02/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java02/","excerpt":"","text":"백준 TEST02_사칙연산 도전하기A*B123456789101112131415161718192021import java.util.*;//1번 2번은 TEST01단계에서 해결했음. A+B , A-Bclass TEST02_03&#123; public TEST02_03()&#123; // 생성자 Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.println(a*b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_03 test02_03 = new TEST02_03(); &#125;&#125; A / B (오차범위 10-9까지)1234567891011121314151617181920import java.util.*;class TEST02_04&#123; public TEST02_04()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.printf(\"%.9f\",a/b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자// TEST02_03 test02_03 = new TEST02_03(); TEST02_04 test02_04 = new TEST02_04(); &#125;&#125; 사칙연산1234567891011121314151617181920212223import java.util.*;class TEST02_05&#123; public TEST02_05()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;=1 &amp;&amp; b&lt;=10000)&#123; System.out.println((int)a+(int)b); System.out.println((int)a-(int)b); System.out.println((int)a*(int)b); System.out.println((int)a/(int)b); System.out.println((int)a%(int)b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_05 test02_05 = new TEST02_05(); &#125;&#125; 나머지1234567891011121314151617181920212223import java.util.*;class TEST02_06&#123; public TEST02_06()&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); int c = scan.nextInt(); if(a&gt;=2 &amp;&amp; a&lt;=10000 &amp;&amp; b&gt;=2 &amp;&amp; b&lt;=10000 &amp;&amp; c&gt;=2 &amp;&amp; c&lt;=10000)&#123; System.out.println((a+b)%c); System.out.println((a%c + b%c)%c); System.out.println((a*b)%c); System.out.println((a%c * b%c)%c); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_06 test02_06 = new TEST02_06(); &#125;&#125; A+B-2 백준 TEST01 단계의 A+B 동일 문제. 따라서 넘어감. 설탕 배달 알고리즘1234567891011121314151617181920212223242526272829303132import java.util.*;class TEST02_08&#123; public TEST02_08()&#123; Scanner scan = new Scanner(System.in); int box = 0 ; int sugar_kg = scan.nextInt(); if(sugar_kg &gt;=3 &amp;&amp; sugar_kg &lt;= 5000)&#123; if(sugar_kg/5 != 0)&#123; for(box = sugar_kg/5;box&gt;=0;box--)&#123; if((sugar_kg - box*5)%3==0)&#123; box += (sugar_kg - box*5)/3; break; &#125; &#125; &#125; else if(sugar_kg == 3)&#123; box = 1; &#125; else&#123; box = -1; &#125; &#125; System.out.println(box); &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_08 test02_08 = new TEST02_08(); &#125;&#125;","categories":[{"name":"Algorism","slug":"Algorism","permalink":"http://yoursite.com/categories/Algorism/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST01_입/출력 받아보기","slug":"Algorism-for-java01","date":"2019-09-04T10:26:38.000Z","updated":"2019-09-04T10:41:52.410Z","comments":true,"path":"2019/09/04/Algorism-for-java01/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java01/","excerpt":"","text":"# # 백준 TEST01_입/출력 받아보기 Hello World12345public class TEST01_01 &#123; public static void main(String args[])&#123; System.out.println(\"Hellow World\"); &#125;&#125; A+B12345678910import java.util.*;public class TEST01_02&#123; public static void main(String args[])&#123; Scanner scan = new Scanner(System.in); int a, b; a = scan.nextInt(); b = scan.nextInt(); System.out.println(a + b); &#125;&#125; A-B1234567891011import java.util.*;public class TEST01_03 &#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); System.out.println(a-b); &#125;&#125; 등록텍스트 추가 123456public class TEST01_04 &#123; public static void main(String[] args)&#123; System.out.println(\"맞은갯수\"); System.out.println(\"아이디명\"); &#125;&#125; 개텍스트 추가 1234567891011public class TEST01_05 &#123; public static void main(String[] args)&#123; System.out.println(\"|\\\\_/|\"); //역슬래쉬를 print로 표시하고 싶으면 \\\\로 사용. System.out.println(\"|q p| /&#125;\"); System.out.println(\"( 0 )\\\"\\\"\\\"\\\\\"); //따옴표를 print로 표시하고 싶으면 \\\"로 사용. System.out.println(\"|\\\"^\\\"` |\"); System.out.println(\"||_/=\\\\\\\\__|\"); &#125;&#125; We love kriii12345public class TEST01_06 &#123; public static void main(String[] args)&#123; System.out.printf(\"강한친구 대한육군\\n강한친구 대한육군\\n\"); &#125;&#125; 그대로 출력하기 (연습)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. charAt(i) =&gt; str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. substring(i,j) =&gt; i부터 j-1까지. 문제점 -&gt; 0~100줄까지 전부 입력을 해야하는데 빈줄이 주어지지않는다. 라는 점에서 문제가 있다고 생각함. 만족 조건은 입력 최대 100줄과 각 줄이 100줄을 넘을 경우 잘라내는 기능 까지만 구현이 완료됬음. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;public class TEST01_07 &#123; public static boolean checkInputOnlyNumberAndAlphabet(String str) &#123; char chrInput = str.charAt(0); for (int i = 0; i &lt; str.length(); i++) &#123; chrInput = str.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 // charAt(i) = str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; // 영문(소문자) OK! &#125; else if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; // 영문(대문자) OK! &#125; else if (chrInput &gt;= 0x30 &amp;&amp; chrInput &lt;= 0x39) &#123; // 숫자 OK! &#125; else &#123; return false; // 영문자도 아니고 숫자도 아님! &#125; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); for (int n = 0; n &lt; 100; n++) &#123; String str = scan.nextLine(); if (str.length() &gt; 100) &#123; str = str.substring(0, 100); &#125; // substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. // substring(i,j) =&gt; i부터 j-1까지. if (checkInputOnlyNumberAndAlphabet(str)) &#123; System.out.println(str); &#125;//줄에 영문,숫자를 제외한 다른글자가 포함되어있을 경우 출력을 안함. &#125; // for문 끝 &#125; &#125; 그대로 출력하기 (답)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. 고친점 : 너무 어렵게 생각하고 있었음. 굳이 함수를 따로 생성하지 않고 hasNextLine()을 이용해 엔터를 치면서 게속해서 글을 작성하도록 변경 그 외 함수를 추가적으로 이용하였음. ArryList에 제네릭을 이용하여 String만 받기로 함. -함수-각 줄은 100글자를 넘지 않으며: word.length() &gt; 100 빈 줄은 주어지지 않는다: word.isEmpty() 각 줄은 공백으로 시작하지 않고: word.startsWith(“ “) 공백으로 끝나지 않는다: word.endsWith(“ “) 1234567891011121314151617181920212223242526272829303132333435import java.util.*; public class TEST01_07_ANS &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.startsWith(\" \") || word.endsWith(\" \") || word.length()&gt;100 || word.isEmpty()) &#123; break; &#125; array.add(word); &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); &#125; &#125; &#125; /*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break빈 줄은 주어지지 않는다: word.isEmpty()-&gt; 빈줄일경우 break각 줄은 공백으로 시작하지 않고: word.startsWith(\" \")-&gt; 첫글자가 공백 일경우 break공백으로 끝나지 않는다: word.endsWith(\" \")-&gt; 마지막 글자가 공백 일 경우 break */ 그대로 출력하기2* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄이 있을 수도 있다. * 각 줄은 공백으로 시작할수도 있고, 공백으로 끝날수도 있다. 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Scanner;public class TEST01_08 &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.length()&gt;100 ) &#123; break; &#125; if(word.equals(\"BYE\"))&#123; //BYE를 입력해서 WHILE 탈출 break; &#125; array.add(word); //현재 줄의 입력내용을 Array배열에 추가. &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); // 각 Array배열의 내용을 출력. &#125; &#125;&#125;/*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break*/","categories":[{"name":"Algorism","slug":"Algorism","permalink":"http://yoursite.com/categories/Algorism/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"ETC-test","slug":"ETC-test","date":"2019-09-04T05:04:06.000Z","updated":"2019-09-04T05:04:22.950Z","comments":true,"path":"2019/09/04/ETC-test/","link":"","permalink":"http://yoursite.com/2019/09/04/ETC-test/","excerpt":"","text":"","categories":[{"name":"Etc","slug":"Etc","permalink":"http://yoursite.com/categories/Etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-03T13:04:58.334Z","updated":"2019-09-03T13:08:10.424Z","comments":true,"path":"2019/09/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"20190903-personal-study-html","slug":"20190903-personal-study-html","date":"2019-09-03T12:54:57.000Z","updated":"2019-09-03T13:07:52.686Z","comments":true,"path":"2019/09/03/20190903-personal-study-html/","link":"","permalink":"http://yoursite.com/2019/09/03/20190903-personal-study-html/","excerpt":"","text":"20190903-Test-web-page Study파일 구조 style.css1234567891011121314151617181920212223242526272829303132body&#123;overflow: hidden;&#125;.image&#123;position:relative;float: left;height: 200px;width:300px;margin : 2px;border: 1px solid white;z-index:0;&#125;.image-selected&#123; border: 1px solid black;background-color:white;&#125;.image-selected &gt; img&#123;opacity: 0.5;&#125;.image &gt; img&#123;height:100%;&#125;.image-magnified&#123;z-index:1;&#125;.image-magnified &gt; img&#123;height:400px;width:600px;margin-left:-150px;margin-top:-100px;opacity:0.95;&#125; image_list.json1234567891011121314[\"./images/1.jpg\",\"./images/2.jpg\",\"./images/3.jpg\",\"./images/4.jpg\",\"./images/5.jpg\",\"./images/6.jpg\",\"./images/7.jpg\",\"./images/8.jpg\",\"./images/9.jpg\",\"./images/10.jpg\",\"./images/11.jpg\",\"./images/12.jpg\"] index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;title&gt;Select the Gallery&lt;/title&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Show\" onclick=\"slideShow(this)\"&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; script.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var req = new XMLHttpRequest();req.open(\"GET\", \"./json/image_list.json\");req.onreadystatechange = function()&#123;if(this.readyState == 4)&#123;var data = JSON.parse(this.response);for(var i= 0; i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125;div.onmouseover = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000);&#125;div.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125;var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);&#125;&#125;&#125;req.send();function selectAll(btn)&#123;var img = document.getElementsByClassName(\"image\");for(var i=0; i&lt;img.length; i++)&#123;if(btn.value == \"UnSelect All\")&#123;img[i].classList.remove(\"image-selected\");&#125;else&#123;img[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"UnSelect All\")&#123;btn.value = \"Select All\";&#125;else&#123;btn.value = \"UnSelect All\";&#125;&#125;function slideShow(btn)&#123;var img = document.getElementsByClassName(\"image\");var index = 0;img[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;img[index].classList.remove(\"image-magnified\");index ++;if(index &lt; img.length)&#123;img[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝낫습니다.\");&#125;&#125;,1000);&#125; 프로젝트에 images 폴더 추가 프로젝트에 json 폴더 추가 프로젝트에 css 파일 추가 script 파일 생성 html 태그 안에 script 파일 및 css 파일 연결 1234&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt; script 파일 작성 시작 1 Ajax 사용하여 비동기방식으로 json 데이터를 요청하고 응답한 값을 가지고 것 임. 123456789101112131415161718192021222324252627var req = new XMLHttpRequest(); // 1. Ajax를 이용하기 위한 객체를 생성req.open(\"GET\",\"./json/image_list.json\"); // 2. 요청방식과 URL 설정// 3. onreadystatechange : 서버로부터 응답시 할 행동을 작성req.onreadystatechange = function()&#123; // 4. 4번 -&gt; 모든 응답이 제대로 받았을 겅우를 의미if(this.readyState == 4)&#123; // 5. 응답데이터(문자열)를 javascript 객체로 변환하고 div태그를 생성하여 데이터를 대입해줍니다.// div 태그의 속성은 class = \"image\" 로 설정합니다.var data = JSON.parse(this.response); for(var i=0;i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");// 6. img 태그를 생성하고 각 데이터를 img태그에 넣습니다. // img 태그는 div태그의 자손으로, div태그는 dody태그의 자손으로 삽입합니다.var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);//밑에서 추가 진행함&#125; &#125; &#125;req.send(); // 요청합니다. script 파일 작성 시작 2 생성된 div 태그에 기능을 추가합니다. 기능은 총 3가지입니다. 클릭 (onclick) 1234567891011121314// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성// 1. 생성된 태그에 클릭 이벤트를 넣어줍니다. // 선택 및 취소 했을 경우 스타일 달리지도록 만듭니다.// 선택시 image-selected , 미선택시 imagediv.setAttribute(\"class\",\"image\");div.onclick = function()&#123;if(this.getAttribute(\"class\").indexOf(\"image-selected\") == -1)&#123;this.setAttribute(\"class\",\"image image-selected\");&#125;else&#123;this.setAttribute(\"class\",\"image\");&#125;&#125; 위 문의 if문과 else 문은 classList 함수를 이용하여 짧게 가능.1234// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125; 마우스 오버 (onmouseover) 123456789// 2. 생성된 태그에 마우스오버 이벤트를 넣어줍니다.// div 위에 마우스가 올라갈 경우 시간만큼 스타일이 달라지도록 만듭니다.// 사용할 css style : image-magnifieddiv.onmouseove = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000); //1초&#125; 마우스 아웃 (onmouseout) 12345678// 3. 생성된 태그에 마우스아웃 이벤트를 넣어줍니다.// div 위에 마우스가 빠져나갈 경우 적용된 스타일을 제거하고 시간을 초기화 하도록 만듭니다.// 제거할 css style : image-magnifieddiv.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125; html 파일 안 태그 안에 2개의 버튼을 생성하고 click 이벤트를 연결합니다. 모두 선택 및 해제 기능 각 이미지가 1번씩 크게 보여지는 슬라이드 쇼 기능 123456&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Slidshow\" onclick=\"slideShow(this)\"&gt; &lt;!-- 사용될 함수에서 해당 button 객체의 value값을 이용하기 위해 인자로 this를 넘겨줍니다. --&gt;&lt;hr&gt; &lt;!-- 한줄 띄어줍니다. --&gt;&lt;/body&gt; script 파일 작성 : 모두 선택 기능 추가. 1234567891011121314151617function selectAll(btn)&#123;var images = document.getElementsByClassName(\"image\"); //div class명이 image입니다.for(var i=0; i&lt;images.length ; i++)&#123;if(btn.value == \"Unselect All\")&#123;images[i].classList.remove(\"image-selected\");&#125;else&#123;images[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"Unselect All\")&#123;btn.value = \"Selcet All\";&#125;else&#123;btn.value = \"Unselect All\";&#125;&#125; script 파일 작성 : 슬라이드쇼 기능 추가. 12345678910111213141516function slideShow(btn)&#123;var images = document.getElementsByClassName(\"image\");var index = 0;images[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;images[index].classList.remove(\"image-magnified\");index++;if(index &lt; images.length)&#123;images[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝났습니다.\");&#125;&#125;,1000);","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"20190902-start-git","slug":"20190902-start-git","date":"2019-09-02T12:52:11.000Z","updated":"2019-09-03T13:02:10.385Z","comments":true,"path":"2019/09/02/20190902-start-git/","link":"","permalink":"http://yoursite.com/2019/09/02/20190902-start-git/","excerpt":"","text":"20190902-start-git* git 개발은 항상 끊어서 커밋 해야만 한다. 그리고 영어로 쓰는 것을 습관화들여라! *Git CLI 기본 설정. ( 설정이 완료되있다면 git 시작하기 1 or 2부터 시작 ) * git config –list ( git 설저한 내용 확인 ) git config –global user.name “HYEOK999”. git config –list (위에서 입력한 내용 확인). git config –global user.email “iasg2004@naver.com“. git config –global editor “vim”. git 시작하기1 ( local -&gt; remote ) 가장 중요한 명령어 : 현재 상태 확인 git status 폴더생성 및 폴더 진입 git init git diff git status(현재 상태) 파일 생성 및 내용 작성 git add 파일명.확장자 github 계정 페이지에 접속 후 레파지토리에서 new를 누르고 저장소를 만든다. 저장소 명은 폴더명과 같게끔 설정할것. 만든후 주소 복사. git remote add [origin] 주소복붙 등록 확인 -&gt; git remote git commit 편집모드( i ) 들어가서 첫줄이 제목 (엔터치기 전까지) 다음줄이 내용! commit 제목은 현재형 구나 절로 적는다! / 내용은 자세하게 적는다. feat : 협업 docs : 문서작업 bugfix : 버그를 수정했을 때 hotfix : 빠르게, 급하게 수정했을 때 release : 개발 git push -u [origin] master -u : 로컬 브랜치를 새로 만든 후 원격저장소에 해당 브랜치를 push하고자 할 때 처음 이후의 Git Commit 파일 및 폴더 내용 수정 및 추가 git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용 “ git push [origin] master git 시작하기2 ( remote -&gt; local ) 가장 중요한 명령어 : 현재 상태 확인 git status 저장소 생성 ( public , gitignore:Node , LICENSE:MIT ). 저장소 주소 복사 git clone 주소복붙. 파일 및 폴더 내용 수정 및 추가. git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용” git push [origin] master.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"20190902-study-terminal","slug":"20190902-study-terminal","date":"2019-09-02T12:52:11.000Z","updated":"2019-09-03T13:09:42.076Z","comments":true,"path":"2019/09/02/20190902-study-terminal/","link":"","permalink":"http://yoursite.com/2019/09/02/20190902-study-terminal/","excerpt":"","text":"20190902-study-termianl 기본적인 리눅스 리눅스 : 커널 또는 GNU를 포함한 라오픈 라이브러리와 도구가 포함된 운영체제. 여러종류의 쉘을 제공함. Shell : 운영체제의 커널과 사용자를 이어주는 소프트웨어 CLI . ( Shell 사용할 경우 GUI보다 효율성이 높다. )Kenal : 컴퓨터와 소프트웨어를 이어 주는 시스템소프트웨어 터미널 리눅스(유닉스) 명령어 명령어 의미 예 ctr+c키 명령어 취소 ~ 접속시 나오는 폴더를 의미 ls 현재 폴더에서 접속가능한 폴더 리스트를 나열함. -a 숨긴파일도 표시 -l 파일의 추가정보를 나열하며 한줄씩 표시 cd Change Directory 의 약자. 폴더 이동 .. 상위 폴더를 의미 mkdir MaKe DIRectory 의 약자. 폴더 생성 mv {1} {2} MoVe의 약자.{1}을 {2}로 이동 mv {1} {2} (같은 위치에 있을경우) {1}을 {2}로 이름바꾸기 cp {1} {2} CoPy의 약자. {1}을 {2}로 이동 rm {1} ReMove의 약자. 파일을 삭제. rm -r {1} {1}이 폴더 일 경우. 폴더를 삭제. touch 파일 생성 ( 생성할떄 파일명 앞에 . 을 붙이면 히든파일생성) chmod {권한} {폴더 및 파일} {폴더 및 파일}을 {권한}으로 권한 레벨 변경. chmod 555 study.html Vim 명령어 vi {1} : {1}을 vim으로 열기. (vim은 에디트)ext : 어떠한 모드에서 기본모드로 돌아감. 모드 3가지 ( 기본, I , : )기본 명령어 의미 예 Y 커서가 놓인 줄 복사 P 커서가 놓인 줄 아래에 붙여넣기 dd 커서가 놓인 줄 잘라내기 x 커서놓인 곳 한글자 삭제. i 커서가 놓은 곳 앞에 i 모드 돌입. o 커서가 놓인 줄 아래에 i 모드 돌입. O 커서 놓은 줄 위에 i 모드 돌입. Insert 편집 모드 ( key - i ) 명령어 의미 예 exc키 노멀모드로 돌아감. 명령어 모드 ( key - : ) 명령어 의미 예 q quit의 약자. vim 편집기를 나감. !q 저정하지않고 나감. wq 저장하면서 나감. exc키 가본 모드로 돌아감.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"post-test","slug":"post-test","date":"2019-09-01T12:28:38.000Z","updated":"2019-09-03T13:10:54.463Z","comments":true,"path":"2019/09/01/post-test/","link":"","permalink":"http://yoursite.com/2019/09/01/post-test/","excerpt":"","text":"","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]}]}