{"meta":{"title":"HYEOK999's Blog","subtitle":"HYEOK999's Daily Develop","description":null,"author":"Jun Hyeok Kim","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"daily_algorithm12","slug":"daily-algorithm12","date":"2019-10-12T10:40:30.000Z","updated":"2019-10-12T10:41:44.759Z","comments":true,"path":"2019/10/12/daily-algorithm12/","link":"","permalink":"http://yoursite.com/2019/10/12/daily-algorithm12/","excerpt":"","text":"문제 출저 : poiema 알고리즘 연습 문제 1. 짝수와 홀수evenOrOdd 함수는 정수 num을 매개변수로 받는다. num은 1이상의 정수이며, num이 음수인 경우는 없다. num이 짝수일 경우 ‘Even’을 반환하고 홀수인 경우 ‘Odd’를 반환하도록 evenOrOdd 함수를 완성하라. 단, if문을 사용한 답과 삼항 조건 연산자를 사용한 답 두가지를 제시하여야 한다. 1234567891011121314151617181920// if문function evenOrOdd(num) &#123; if(num % 2 == 0) &#123; return \"Even\"; &#125; return \"Odd\";&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even// 3항 연산자function evenOrOdd(num) &#123; return num % 2 == 0 ? 'Even' : 'Odd';&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even 2. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라. 단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다. (hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n] 12345678910111213141516function getCount8 () &#123; let count8 = 0; let countNum; for(let i = 1; i &lt; 10001; i++) &#123; countNum = String(i); for(let j = 0; j &lt; countNum.length; j++ )&#123; if(countNum[j] == '8')&#123; count8++; &#125; &#125; &#125; return count8;&#125;console.log(getCount8()); 3. 문자열 다루기alphaString46 함수는 문자열 s를 매개변수로 입력받는다. s의 길이가 4 ~ 6이고, 숫자로만 구성되어 있는지 확인하는 alphaString46 함수를 완성하라. 예를 들어 s가 ‘a234’이면 false를 리턴하고 ‘1234’라면 true를 리턴한다. 123456789101112131415161718function alphaString46(s) &#123; if (s == undefined) &#123; return false; &#125; if (s.length &gt; 3 &amp;&amp; s.length &lt; 7) &#123; if (NaN || +s) &#123; return true; &#125; return false; &#125; return false;&#125;console.log(alphaString46('1234')); // trueconsole.log(alphaString46('9014')); // trueconsole.log(alphaString46('723')); // falseconsole.log(alphaString46('a234')); // falseconsole.log(alphaString46('')); // falseconsole.log(alphaString46()); // false 4. 문자열 내 p와 y의 개수numPY함수는 대문자와 소문자가 섞여있는 문자열 s를 인수로 전달받는다. s에 존재하는 ‘p’의 개수와 ‘y’의 갯수를 비교해 같으면 true, 다르면 false를 리턴하도록 함수를 완성하라. 대소문자를 구별하지 않으며 ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 true를 리턴한다. 예를 들어 s가 ‘pPoooyY’면 true를 리턴하고 ‘Pyy’라면 false를 리턴한다. 123456789101112131415161718192021function numPY(s) &#123; let countP = 0; let countY = 0; if (s == undefined) return true; for (let i = 0; i &lt; s.length; i++) &#123; if ( s[i] == 'p' || s[i] == 'P') &#123; countP++; &#125; if ( s[i] == 'y' || s[i] == 'Y') &#123; countY++; &#125; &#125; return Boolean(countP == countY);&#125;console.log(numPY('pPoooyY')); // trueconsole.log(numPY('Pyy')); // falseconsole.log(numPY('ab')); // trueconsole.log(numPY('')); // trueconsole.log(numPY()); // true 5. 이상한 문자 만들기toWeirdCase함수는 문자열을 인수로 전달받는다. 문자열 s에 각 단어의 짝수번째 인덱스 문자는 대문자로, 홀수번째 인덱스 문자는 소문자로 바꾼 문자열을 리턴하도록 함수를 완성하라. 예를 들어 s가 ‘hello world’라면 첫번째 단어는 ‘HeLlO’, 두번째 단어는 ‘WoRlD’로 바꿔 ‘HeLlO WoRlD’를 리턴한다. 주의) 문자열 전체의 짝/홀수 인덱스가 아니라 단어(공백을 기준)별로 짝/홀수 인덱스를 판단한다. 1234567891011121314151617181920212223242526272829function toWeirdCase(s) &#123; const strArray = s.split(' '); let fullStr = ''; function UpCase(str) &#123; return str.toUpperCase(); &#125; function LowCase(str) &#123; return str.toLowerCase(); &#125; for (let i = 0; i &lt; strArray.length; i++) &#123; for (let j = 0; j &lt; strArray[i].length; j++) &#123; if (j % 2 == 0) &#123; fullStr += UpCase(strArray[i][j]); &#125; else &#123; fullStr += LowCase(strArray[i][j]); &#125; &#125; fullStr += ' '; &#125; return fullStr;&#125;console.log(toWeirdCase('hello world')); // 'HeLlO WoRlD'console.log(toWeirdCase('my name is lee')); // 'My NaMe Is LeE'","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-07","slug":"javascript-study-07","date":"2019-10-11T04:15:31.000Z","updated":"2019-10-12T06:04:11.527Z","comments":true,"path":"2019/10/11/javascript-study-07/","link":"","permalink":"http://yoursite.com/2019/10/11/javascript-study-07/","excerpt":"","text":"JavaScript Study 07 용어 함수 용어 - ( 러버덕 ) 원시값 변경 가능한 값 값에 의한 전달 객체 변경 불가능한 값 참조에 의한 전달 함수 함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것. 프로그래밍 언어의 함수는 입력을 받아서 출력을 내보낸다. 이때 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다. 또한 함수는 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다. 파라미터(Parameter) = 매개변수 , 멤버변수, 인자 아구멘트(Argument) = 인수 함수의 정의 및 호출​ 함수는 정의 를 통해 생성한다. ( 함수선언식의 경우, 호이스팅 되어 런타임 이전에 이미 정의가 완료된다. ) 1234// 함수 정의function add(x, y) &#123; return x + y;&#125; ​ 함수는 정의만 해서는 해당 코드가 실행되지는 않는다. 호출을 해야 비로서 실행되고 결과를 반환한다. 12345// 함수 호출var result = add(2, 5);// 함수 add에 인수 2, 5를 전달하면서 호출하면 7을 반환한다.console.log(result); // 7 ​ 함수 내부에서 선언된 변수들은 *함수가 호출되면 *실행된다. 123456function add(x) &#123; var y = 20; return x + y;&#125;console.log( add(10) ); // 함수를 호출하면서 변수 y의 선언-초기화-할당이 진행된다. argument(인수) 와 parameter(매개 변수)는 일치하는게 이상적인 함수 코딩이다. 1234function add(x, y) &#123; return x + y;&#125;add(2, 5); // 7 함수 호출문은 값으로 평가되는 표현식 이다. 12345function add(x, y) &#123; return x + y;&#125;var result = add(2, 5); console.log(result) // 7 함수 사용 이유 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 함수 리터럴 그룹 연산자 ( )안에 들어오는 것은 피연산자이다. 피연산자로 들어오는 것은 리터럴 , 값이어야만 함다. 결국, ( function foo( ) { } )는 리터럴 및 값이 되는것이다. 함수 리터럴을 이름을 가질수도 있고, 안가질수도 있다.함수 리터럴의 식별자는 자신의 몸체 내부에서만 유효 하다. 그룹 연산자 () 내에 있는 것은 함수 선언문이 아니다. 다시 말해, 자바스크립트 엔진은 그룹 연산자 () 내에 있는 문을 함수 선언문이 아닌 함수 리터럴로 해석한다. 그룹 연산자의 피연산자는 값으로 평가할 수 있는 표현식이다. 따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다. 123var foo = function bar () &#123; &#125;; 함수 만드는 방법 4가지Function 생성자 함수 생성자 함수란 ? 객체를 생성하는 함수 따라서 Function 생성자 함수 는 함수라는 객체를 생성하는 함수다. 1234// 첫번째 인수, 두번째 인수, 마지막 인수는 반환값var add = new Function('x', 'y', 'return x + y');console.log(add(2, 5)); // 7 화살표 함수​ ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다. 화살표 함수는 대부분을 콜백 함수에 이용한다. 1234// 화살표 함수const add = (x, y) =&gt; x + y;console.log(add(2, 5)); // 7 함수 선언문 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수 명인 것이다.아래 예제를 예를들어보면 함수 명 add로 호출한 것이 아닌 함수선언문이 호이스팅 되면 생성된 암묵적 변수 add를 호출한 것이다. 123456789101112// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 참조// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.console.dir(add); // ƒ add(x, y)// 함수 호출console.log(add(2, 5)); // 7 함수의 매개변수는 가능한 적은게 좋다 (최대 3개까지 맞추는게 ㅈ호다) 만약, 함수 매개변수가 4개이상이면 객체로 넘기는것이 좋다. 123456$.ajax(&#123; method: 'POST', url: '/user', data: &#123; id: 1, name: 'Lee' &#125;, cache: false&#125;); 위는 jQuery의 ajax 메소드이다. 해당 함수의 인수는 1개다. (객체)그리고 객체의 프로퍼티는 총 4개다. ( 또한, 객체의 프로퍼티는 순서가 필요없고 이름에만 의미가 있다. ) 또한 위 코드에서 함수 내부에 객체를 선언한 이유는다른 식별자들이 참조할 수 없게 만들기 때문이다. 해당 함수만 저 객체를 독점 사용하기 위해서이다.(보안적이유)만약 다른 식별자들이 저 객체를 참조한다고 함수를 실행했을 때 변해버린 값이 반환될수도 있기 때문이다. 외부 상태의 변경과 함수형 프로그래밍함수의 매개변수에 값을 전달하는 방식을 값에 의한 호출(Call by value), 참조에 의한 호출(Call by reference)로 구별하는 부르는 경우도 있으나 동작 방식은 값에 의한 전달, 참조에 의한 전달과 동일하다. 아래 예제를 살펴보자. 1234567891011121314151617181920function changeVal(primitive, obj) &#123; primitive += 100; obj.name = 'Kim';&#125;// 외부 상태var num = 100;var person = &#123; name: 'Lee' &#125;;console.log(num); // 100console.log(person); // &#123;name: \"Lee\"&#125;// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.changeVal(num, person);// 원시 값은 원본이 훼손되지 않는다.console.log(num); // 100// 객체는 원본이 훼손된다.console.log(person); // &#123;name: \"Kim\"&#125; 위와 같은 방식의 코딩은 객체의 추척을 어렵게 만든다. (즉, 값이 바뀌었는지 않바뀌었는지;;;) 이와 같은 함수를 비순수함수 라 칭한다. 순수 함수 : 함수 내부(지역 스코프)만 영향을 준다. 비순수 함수 : 함수 외부까지도 영향을 준다. JS는 상태를 변환하는게 에러의 원인이라고 판단한다. 따라서 비순수함수를 최대한 억제 및 줄이고 순수함수를 사용하도록 노력해야만 한다. 반환문​ 함수는 return 키워드와 반환밧으로 이루어진 반환문을 사용하여 실행 결과를 반환 할 수 있다. 함수는 실행시 return을 만나면 함수 실행을 중단하고 몸체를 빠져나간다.(즉, 중단한다.) return의 생략 return 키워드는 생략이 가능하다. 다만, 생략시 return undefined를 결과로 반환한다. return 값도 생략이 가능하다. 역시 생략시 return undefined를 결과로 반환한다. 다양한 함수의 형태즉시 실행 함수 ( IIFE ) 단 한번만 호출되며 다시는 호출 할 수 없다. 즉시 실행 함수는 익명 즉시 실행 함수를 사용하는 것이 일반적이다. 123456// 익명 즉시 실행 함수(function () &#123; var a = 3; var b = 5; return a * b;&#125;()); 재귀함수 자기 자신을 호출하는 함수 재귀 함수는 무한 호출되며 stack overflow에러를 유발할 위험이 다분하다. 따라서 최대한 적게 이용하고 대부분은 재귀함수는 while, for( + if )등으로 대체가 가능하다. 1234567891011121314// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.// n! = 1 * 2 * ... * (n-1) * nfunction factorial(n) &#123; // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다. if (n &lt;= 1) return 1; return factorial(n - 1) * n;&#125;console.log(factorial(0)); // 0! = 1console.log(factorial(1)); // 1! = 1console.log(factorial(2)); // 2! = 1 * 2 = 2console.log(factorial(3)); // 3! = 1 * 2 * 3 = 6console.log(factorial(4)); // 4! = 1 * 2 * 3 * 4 = 24console.log(factorial(5)); // 5! = 1 * 2 * 3 * 4 * 5 = 120 중첩함수 * 함수 내부에 함수가 있을 수 있다. 이를 중첩 함수(nested function) 또는 내부 함수(Inner function)라 한다. 12345678910111213141516function outer() &#123; var x = 1; // 중첩 함수 function inner() &#123; var y = 2; // 외부 함수의 변수를 참조할 수 있다. console.log(x + y); // 3 &#125; inner(); // 중첩 함수의 변수를 참조할 수 없다. console.log(x + y); // ReferenceError: y is not defined&#125;outer(); 콜백함수 ** 중요 콜백함수는 고차함수에 인수(Argument) 로써 사용되는 함수를 뜻한다. 고차함수는 매개변수를 함수로 받는 함수를 말한다. 1234567891011121314151617// outer는 고차함수다. - 이유는 매개변수를 함수로 받고 있다.function outer(fn) &#123; var x = 1; var y = 2; return fn(x, y);// 3&#125; // 일반함수function inner(x, y) &#123; var dd = x + y; return dd;&#125;console.log( // outer라는 고차함수에 inner을 넣음으로 inner는 콜백함수가 되었다. outer(inner));","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm11","slug":"daily-algorithm11","date":"2019-10-11T01:59:53.000Z","updated":"2019-10-11T02:00:27.128Z","comments":true,"path":"2019/10/11/daily-algorithm11/","link":"","permalink":"http://yoursite.com/2019/10/11/daily-algorithm11/","excerpt":"","text":"문제 출저 : 프로그래머스 가운데 글자 가져오기문제 설명단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다. 재한사항 s는 길이가 1 이상, 100이하인 스트링입니다. 입출력 예 s return abcde c qwer 1234567891011function solution(s) &#123; var answer = ''; if(s.length%2 == 1) &#123; answer = s.slice(s.length/2, s.length/2+1); &#125; else&#123; answer = s.slice(s.length/2-1, s.length/2+1); &#125; console.log(answer); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-12","slug":"javascript-preview-12","date":"2019-10-10T16:58:26.000Z","updated":"2019-10-10T18:05:50.403Z","comments":true,"path":"2019/10/11/javascript-preview-12/","link":"","permalink":"http://yoursite.com/2019/10/11/javascript-preview-12/","excerpt":"","text":"JacaScript 12강 예습 12강 : 스코프 스코프란? 비순수 함수 스코프 위치에 따른 값 코드의 문맥과 환경 var 키워드로 선언한 변수의 중복 선언 let, const 스코프의 종류 전역과 전역 스코프 지역과 지역 스코프 스코프 체인 스코프 체인에 의한 변수 검색 스코프 체인에 의한 함수 검색 함수 레벨 스코프 렉시컬 스코프 암묵적 전역 변수 12강스코프 스코프란? 유효범위를 뜻하는 스코프는 JS를 포함한 모든 프로그래밍 언어즤 기본적이면 중요한 개념이다. *모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. * *이를 스코프(Scope, 유효범위)라 한다. * 즉, 스코프는 식별자가 유효한 범위를 말한다. 12345678var num = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.function increase() &#123; return ++num; // 외부 상태를 변경한다.&#125;console.log(increase()); // 1console.log(increase()); // 2 num은 전역 변수이기 때문에 increase 함수를 통해 값이 늘어난다. 비순수 함수​ increase 함수처럼 함수 내부의 상태(함수 내부에서 선언한 변수 또는 원시 타입의 매개 변수)만이 아니라 함수 외부 상태(num)까지 변경하는 함수를 비순수 함수(impure function)라고 한다. 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수(pure function)를 사용하는 것이 좋다. 스코프 위치에 따른 값12345678910var x = 'global';function foo() &#123; var x = 'local'; console.log(x); // ① local&#125;foo();console.log(x); // ② global 위 예제에서 JS엔진은 스코프를 통해 어떤 변수를 참조하고 출력해야할지 결정한다. 여기서 스코프란, JS엔진이 식별자를 검색할 때 사용하는 규칙이라고 할 수 있다. 코드의 문맥과 환경 “코드가 어디서 실행되며 주변에 어떤 코드들이 있는지”를 환경(Environment)이라고 부른다. 즉, 코드의 문맥(Context)은 환경으로 이루어진다. 이를 구현한 것이 “실행 컨텍스트(Execution context)”이며 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 스코프는 실행 컨텍스트와 깊은 관련이 있다. 만약 스코프란 개념이 없다면 같은 네이밍을 가진 변수들끼리 충동을 일으키기 때문에 모든 변수는 고유한 네이밍을 가져야 할것이다. 만약 그럴경우, 소스가 길어지게 될 경우 변수 네이밍을 전부다 기억해야되는 불상사가 생길수도 있다. 따라서, 스코프를 이용하여 이러한 충돌을 방지하고 같은 네이밍을 쓸 수 있다. var 키워드로 선언한 변수의 중복 선언 var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다. 12345678function foo() &#123; var x = 1; // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다. // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. var x = 2; console.log(x); // 2&#125;foo(); let , const 하지만 let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다. 123456function bar() &#123; let x = 1; // let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다. let x = 2; // SyntaxError: Identifier 'x' has already been declared&#125;bar(); 스코프의 종류스코프는 전역(global)과 지역(local)으로 나뉜다. 구분 설명 스코프 변수 전역 코드의 가장 바깥 영역 전역 스코프 전역 변수 지역 함수 몸체 내부 지역 스코프 지역 변수 전역과 전역 스코프 전역 : 코드의 가장 바깥 영역을 의미. 전역은 전역 스코프를 만든다. 전역 변수는 어디서든지 참조할 수 있다. 지역과 지역 스코프 지역 : 함수 몸체 내부를 의미. 지역은 지역 스코프를 만든다. 지역 변수는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조가 가능하다. 스코프 체인​ 함수 몸체 내부에서 정의한 함수를 ‘중첩 함수(nested function)’, 중첩 함수를 포함하는 함수를 ‘외부 함수(outer function)’라고 부른다. ​ 여기서 생기는 함수들의 중첩은 곧 함수의 지역 스코프도 중첩이 될 수 있다는 것을 의미하며,스코프는 곧 함수의 중첩에 의해 계층적 구조를 지닌다는 것을 알 수 있다. 또한 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이러한 스코프들간의 계층적인 연결을 스코프 체인이라 부른다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 스코프 체인에 의한 변수 검색 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다. 스코프 체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이루어진 상속(Inheritance)과 유사하다. 상속을 통해 부모의 자산을 자식이 자유롭게 사용할 수 있지만 자식의 자산을 부모가 사용할 수는 없다. 스코프 체인도 마찬가지 개념이다. 스코프 체인에 의한 함수 검색123456789101112131415// 전역 함수function foo() &#123; console.log('global function foo');&#125;function bar() &#123; // 중첩 함수 function foo() &#123; console.log('local function foo'); &#125; foo(); // ①&#125;bar(); 자바스크립트 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 따라서 위 예제의 모든 함수는 자바스크립트 엔진에 의해 암묵적으로 선언된 함수 이름과 동일한 이름의 변수에 할당된다. 이처럼 함수도 변수에 할당되기 때문에 스코프를 갖는다. 사실 함수는 변수에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바가 없다. 따라서 스코프를 “변수를 검색할 때 사용하는 규칙”이라고 표현하기 보다는 “식별자를 검색하는 규칙”이라고 표현하는 것이 보다 적합하다. 함수 레벨 스코프 var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프(Function level scope)라 한다. let , const 키워드는 블록 레벨 스코프(함수 몸체 만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든 것)를 지원한다. 123456789var i = 10;// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.for (var i = 0; i &lt; 5; i++) &#123; console.log(i); // 0 1 2 3 4&#125;// 의도치 않게 변수의 값이 변경되었다.console.log(i); // 5 렉시컬 스코프12345678910111213var x = 1;function foo() &#123; var x = 10; bar();&#125;function bar() &#123; console.log(x);&#125;foo(); // ?bar(); // ? 상위 스코프를 결정 짓는 방식은 2가지가 있다. 동적 스코프 : 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다. 렉시컬(정적) 스코프 : 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. JS는 렉시컬 스코프를 따른다. 위 예제에서 bar( ) 함수의 정의는 전역이다. 따라서 bar( )의 상위 스코프는 전역으로 결정이된다. 전역 변수 x의 값이 1이므로 foo( ) 와 bar( ) 모두 정답은 1이다. 렉시컬 스코프는 클로저 와 관계 깊다. (추후 학습) 암묵적 전역 변수12345678function foo() &#123; // 선언하지 않은 변수에 값을 할당하면 암묵적 전역 변수가 된다. x = 10;&#125;foo();console.log(x); // 10 선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역 변수를 선언하고 값을 할당한다. 위는 소스에서 JS엔진은 다음과 같이 동작한다. 함수 foo의 스코프에서 변수 x에 관한 선언을 찾는다. 못찾을 경우, 상위 스코프(전역) 으로 이동해 변수 x에 관한 선언을 찾는다. 역시 못찾을 경우, 참조 에러를 발생 시켜야 겠지만, JS엔진은 암묵적으로 변수 x를 선언한다. 이러한 변수를 암묵적 전역 변수라 한다. 12345// x.jsfunction foo() &#123; i = 0; // 암묵적 전역 변수 // ...&#125; 12345678// y.js// var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다.// 따라서 for문에서 선언한 i는 전역 변수이다.// 이미 암묵적 전역 변수 i가 있으므로 변수 i는 중복 선언된다.for (var i = 0; i &lt; 5; i++) &#123; foo(); console.log(i);&#125; 서로 분리된 x.js와 y.js 라는 서로 다른 파일이 존재한다고 가정하자. 여기서 HTML이 위 두 파일을 다음처럼 로드할 경우, 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script src='x.js'&gt;&lt;/script&gt; &lt;script src='y.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/htm HTML에서 로드한 자바스크립트 파일은 여러 개로 분리되어 있다해도 하나의 전역 스코프를 공유한다. 다시 말해 자바스크립트는 파일마다 독립적인 파일 스코프를 갖지 않는다. 따라서 자바스크립트 파일을 여러 개로 분리하여도 결국 하나의 자바스크립트 파일로 통합된 것처럼 동작한다. 이러한 특징은 자바스크립트에 모듈이라는 개념이 없기 때문이다. 위 예제에서는 결국 나중에 선언된 y.js의 i값이 x.js의 i값을 덮어씌우게 된다. 결국, JS는 변수의 중복 선언을 허용하기 때문에 어떠한 에러도 발생시키지 않고 무한 반복 상태에 빠져들게 될 것이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-11","slug":"javascript-preview-11","date":"2019-10-10T16:56:43.000Z","updated":"2019-10-10T16:59:12.823Z","comments":true,"path":"2019/10/11/javascript-preview-11/","link":"","permalink":"http://yoursite.com/2019/10/11/javascript-preview-11/","excerpt":"","text":"JacaScript 11강 예습 11강 : 함수 함수란? 함수정의 함수호출 함수의 사용 이유 함수 리터럴 함수와 일반 객체의 공통점 및 차이점 함수 정의 4가지 함수 만드는 방법 및 호이스팅 함수 선언문 함수 표현식 함수 생성 시점과 함수 호이스팅 Function 생성자 함수 화살표 함수 : ES6 함수 호출 매개변수와 인수 인수 확인 매개변수의 개수 외부 상태의 변경과 함수형 프로그래밍 반환문 다양한 함수의 형태 즉시 실행 함수 재귀 함수 중첩 함수 콜백 함수 11강​ 함수 함수란? 자바스크립트의 핵심 오브 핵심 “입력(input)”을 받아서 “출력(output)”을 내보내는 일련의 과정을 정의한 것 \u0010 ​ 함수는 함수 정의(Function Definition)을 통하여 생성한다. 아래는 수학적 함수를 프로그래밍적 함수로 보여준 &lt;예&gt; 이다. 1234567// f(x, y) = x + yfunction add(x, y) &#123; return x + y;&#125;// f(2, 5) = 7add(2, 5); // 7 함수 정의(Function Definition)와 함수 호출(Function call/invoke)을 통해서 보여진다. 함수 정의1234// 함수 정의function add(x, y) &#123; return x + y;&#125; 함수 호출12345// 함수 호출var result = add(2, 5);// 함수 add에 인수 2, 5를 전달하면서 호출하면 7을 반환한다.console.log(result); // 7 함수의 사용 이유 함수는 필요시 여러 번 호출이 가능하다.이는 결국, 동일한 작업을 반복적으로 해야만 한다면 정의된 함수를 재사용하는 것이 효율적일 것이다. 코드 수정 및 추가 또한 함수부분만 수정 및 추가를 하면 되므로 코드의 유지보수 및 편의성을 높이게 된다.함수는 식별자를 붙일 수 있다. 따라서, 함수 명을 좋은 이름으로 하여여 코드의 가독성을 높일 수 있을 것이다. 함수 리터럴​ 객체 리터럴 표기법으로 객체를 만들수 있듯이( var obj = { }),함수도 함수 리터럴 표기법을 이용해 함수를 생성할 수 있다. 함수는 객체라는 사실을 잊어서는 안된다.자바스크립트의 함수는 일급 객체이다. = 값으로 사용 가능하다는 소리 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록 그리고 함수 몸체로 구성된다. 1234// 변수에 함수 리터럴을 할당var add = function add(x, y) &#123; return x + y;&#125;; 함수 리터럴의 구성 요소에 대한 설명은 아래와 같다. 함수 이름 함수 이름은 식별자이다. 따라서 식별자 네이밍 규칙을 준수해야 한다. 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. 함수 이름은 생략할 수 있다. 함수 이름이 있는 함수를 기명 함수(named function), 함수 이름이 없는 함수를 익명 함수(anonymous function)라 한다. 매개변수 목록 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분한다. 매개변수에는 인수가 할당된다. 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다. 함수 몸체 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. 함수 몸체는 함수 호출에 의해 실행된다. 함수 와 일반 객체의 공통점 및 차이점 - 일반 객체 함수 공통점 데이터타입 : 객체 데이터타입 : 객체 차이점 - 호출 호출불가 호출가능 차이점 - 프로퍼티 일반 프로퍼티 소유 고유 프로퍼티 소유 함수 정의 4가지함수를 정의하는 방법은 4가지가 있다. 함수 선언문(Function Declaration/Function Statement) 123function add(x, y) &#123; return x + y;&#125; 함수 표현식(Function Expression) 123var add = function (x, y) &#123; return x + y;&#125;; Function 생성자 함수(Function Constructor) 1var add = new Function('x', 'y', 'return x + y'); 화살표 함수(Arrow Function): ES6 1var add = (x, y) =&gt; x + y; 함수는 정의? 선언? ​ 함수는 선언하다고 안하고 정의한다고 표현 한다.이유는 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.따라서 ECMAScript 사양에서도 변수에는 선언, 함수는 정의라고 표현한다. 함수 만드는 방법 및 호이스팅함수 선언문함수 선언문은 함수 리터럴 표기법과 형태가 동일하다. 단, 함수 선언문은 함수 이름을 생략할 수 없다. 123456789101112// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 참조// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.console.dir(add); // ƒ add(x, y)// 함수 호출console.log(add(2, 5)); // 7 위에서 “함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다” 라고 한적이 있다. 이 뜻은 함수를 생성시 함수 객체를 생성한다.이 때 생성된 함수 객체를 할당할 변수가 필요하다. 함수 객체를 변수에 할당하지 않으면 생성된 함수 객체를 사용할 수 없고 아무도 참조하고 있지 않는 함수 객체는 결국 가비지 컬렉터에 의해 메모리에서 해제된다. 즉, JS엔진은 함수 명과 동일한 명의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 123456// function add(x, y)var add = function add(x, y) &#123; return x + y;&#125;;console.log(add(2, 5)); // 7 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수 add인 것이다. 결론 : JS엔진은 함수 선언문을 함수 표현식으로 반환하여 함수 객체를 생성함. 함수 표현식자바스크립트의 객체는 값처럼 변수에 할당 할 수도 있고 프로퍼티의 값이 될 수도 있으며 배열의 요소가 될 수도 있다.이러한 객체를 일급 객체(first-class object)라 한다. 자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. 함수표현식은 함수를 값처럼 사용하여 변수에 할당하는 방식이다. 123456// 함수 표현식var add = function (x, y) &#123; return x + y;&#125;;console.log(add(2, 5)); // 7 또 여기서 함수 표현식은 함수명이 필요 없는 익명 함수를 사용이 가능하다. 함수명은 함수 내부에서만 접근이 가능하기에 외부에서는 당연히 접근불가 이다. 1234567891011// 기명 함수 표현식var add = function foo (x, y) &#123; return x + y;&#125;;// 함수 객체를 가리키는 변수로 호출console.log(add(2, 5)); // 7// 함수 이름으로 호출하면 ReferenceError가 발생한다.// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.console.log(foo(2, 5)); // ReferenceError: foo is not defined 함수 생성 시점과 함수 호이스팅 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(Function Hoisting)이라 한다. 함수 표현식은 호이스팅이 안된다. 함수 호이스팅은 변수 호이스팅과는 미묘한 차이가 있다. 변수 호이스팅은 선언 단계와 초기화 단계가 동시에 진행되며 다른 코드가 실행되기 이전에 자바스크립트 엔진에 의해 암묵적으로 수행된다. 하지만 함수 선언문의 함수 호이스팅은 선언 단계와 초기화 단계, 그리고 할당 단계(암묵적으로 선언된 변수에 함수 객체를 할당)까지 동시에 진행된다. 함수 표현식은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 1234567891011121314151617// 함수 참조console.dir(add); // ƒ add(x, y)console.dir(sub); // undefined// 함수 호출console.log(add(2, 5)); // 7console.log(sub(2, 5)); // TypeError: sub is not a function// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 표현식var sub = function (x, y) &#123; return x - y;&#125;; 함수 호이스팅은 함수 호출 전에 반드시 함수를 선언하여야 한다는 당연한 규칙을 무시한다. 따라서 코드의 구조를 엉성하게 만들 수 있다. 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있다. Function 생성자 함수 Function 생성자 함수는 매개변수 목록과 함수 몸체를 문자열로 전달받는다. new 연산자와 함께 호출하며 생성된 함수 객체를 반환한다. (사실 new 연산자 없이 호출하여도 결과는 동일하다.) 123var add = new Function('x', 'y', 'return x + y');console.log(add(2, 5)); // 7 생성자 함수로 함수를 생성하는 방식 일반적이지 않고 바람직 하지도 않다. 생성자 함수는 함수 선언식, 표현식과는 다르게 동작하고 클로저를 생성하지 않는다. ( 추후에 더 이야기 ) 123456789101112131415var add1 = (function () &#123; var a = 10; return function (x, y) &#123; return x + y + a; &#125;;&#125;());console.log(add1(1, 2)); // 13var add2 = (function () &#123; var a = 10; return new Function('x', 'y', 'return x + y + a;');&#125;());console.log(add2(1, 2)); // ReferenceError: a is not defined 화살표 함수 : ES6​ ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다. 123456789// 화살표 함수 const add = function (x,y)&#123; return x + y;&#125;const add = (x, y) =&gt; x + y;console.log(add(2, 5)); // 7 함수 호출​ 함수는 함수를 참조하는 변수와 한 쌍의 소괄호( )인 함수 호출 연산자로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다. 이 인수는 매개변수에 할당할 수 있는 값이어야 한다. 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘긴다. 이때 매개변수에 인수가 할당되고 함수 몸체의 문들이 실행되기 시작한다. 매개변수와 인수함수외부 -&gt; 함수내부 접근시 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다.인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다. 1234567function add(x, y) &#123; return x + y;&#125;var result = add(2, 5);console.log(result); // 7 매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 변수와 마찬가지로 undefined로 초기화된 이후 인수가 할당된다. 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다. 함수는 매개변수의 개수와 인수(argument)의 개수를 체크하지 않는다. 인수가 부족한 경우, 매개변수의 값은 undefined이다. 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 *에러가 발생하지는 않는다. * 1234567function add(x, y) &#123; return x + y;&#125;console.log(add(2)); // NaN// y에는 인수가 전달이 안되었으므로 y = undefined가 되있다.// 2 + undefined = NaN이다. 또 다른 경우에는, 인수가 더 많을 경우이다. 이 경우, 초과되는 인수는 무시한다. ( 완전 무시가 아닌, 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. ) 12345function add(x, y) &#123; return x + y;&#125;console.log(add(2, 5, 10)); // 답 7 , 10을 받을 매개변수는 존재하지 않기에 무시한다. 인수 확인​ 아래 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실행할 것이다. 이러한 상황이 발생한 이유는 아래와 같다. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 자바스크립트는 동적 타입 언어이다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정하지 않는다. 1234567// 1 + 2 를 하여 숫자 3의 결과를 얻고 싶다.function add(x, y) &#123; return x + y;&#125;console.log(add(2)); // NaNconsole.log(add('a', 'b')); // 'ab' ​ 자바스크립트는 동적 타이핑이라는 기능으로 인하여 어떤 타입의 인수를 전달해야하는지, 어떤 타입의 값을 반환해야하는지를 설명해주지 않는다. 따라서 이를 해결하기 위하여 적절한 인수가 전달되는지를 체크해야한다. 12345678910function add(x, y) &#123; if (typeof x !== 'number' || typeof y !== 'number') &#123; throw new TypeError('매개변수에 숫자 타입이 아닌 값이 할당되었습니다.'); &#125; return x + y;&#125;console.log(add(2)); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.console.log(add('a', 'b')); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다. 매개변수의 개수 매개변수는 순서에 의미가 있다. 따라서 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 함수의 사용 방법을 어렵게 만들고 실수를 발생시킬 가능성을 높인다. 또한 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 변경되므로 함수를 사용하는 코드 전체가 영향을 받는다. *함수의 매개변수는 코드 이해에 방해가 되는 요소이므로 이상적인 매개변수 개수는 0개이며 적을 수록 좋다. * 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다. 아래는 jQuery의 ajax 메소드에 객체를 인수로 전달하는 예제이다. 123456$.ajax(&#123; method: 'POST', url: '/user', data: &#123; id: 1, name: 'Lee' &#125;, cache: false&#125;); 하지만 주의할 것은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부작용이 발생한다는 것이다. 외부 상태의 변경과 함수형 프로그래밍원시 값은 값에 의한 전달(Pass by value), 객체는 참조에 의한 전달(Pass by reference) 방식으로 동작. 매개변수는 값에 의한 호출(Call by value) , 참조에 의한 호출(Call by reference) 로 구별하기도 하나, 동작 방식은 값에 의한 전달, 참조에 의한 전달과 동일하다. 1234567891011121314151617181920function changeVal(primitive, obj) &#123; primitive += 100; obj.name = 'Kim';&#125;// 외부 상태var num = 100;var person = &#123; name: 'Lee' &#125;;console.log(num); // 100console.log(person); // &#123;name: \"Lee\"&#125;// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.changeVal(num, person);// 원시 값은 원본이 훼손되지 않는다.console.log(num); // 100// 객체는 원본이 훼손된다.console.log(person); // &#123;name: \"Kim\"&#125; 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경하여도 원본은 훼손되지 않는다.다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 원시값의 원본을 변경하는 어떠한 부수 효과(side-effect)도 발생하지 않는다. 객체 타입 인수는 참조값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조값으로 참조한 객체를 변경할 경우 원본이 훼손된다.다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본 객체가 변경되는 **부수 효과가 발생한다. ​ 외부의 상태(위 예제의 경우, 참조 타입의 변수 person)를 변경시키는 것은 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. ​ 이런 문제는 객체가 변경할 수 없는 값이며 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용이다. 참조에 의한 전달 방식을 통해 참조값이 공유되어 있는 객체는 언제든지 변경될 수 있다. 복잡한 코드에서 객체의 변경을 추척하는 일은 매우 어려운일이다. 따라서 객체의 변경을 추척하려면 Observer 패턴등을 이용해 추가 대응을 해야한다. Observer 패턴 중 하나는, 객체를 불변 객체로 만들어서 사용하는 방법이 있다.이는 객체를 마치 원시값처럼 변경 불가능한 값으로 동작하게 만드는 것인데, 객체의 상태 변경이 필요한 경우에만 참조가 아닌 객체의 방어적 복사를 통해 원본 객체를 완전히 복제(deep copy)하고 새로운 객체를 생성해 변경한다. 함수형 프로그래밍에서는 어떤 외부 상태도 변경시키지 않는, 즉 부수 효과가 없는 함수를 순수 함수(Pure function), 외부 상태를 변경시키는 즉, 부수 효과가 있는 함수를 비순수 함수(Impure function)라고 부른다. 위 예제같은 비순수 함수는 코드의 복잡성을 증가시키며, 이를 최대한 억제하는 프로그래밍을 해야한다. 함수형 프로그래밍은 변수의 사용을 억제하여 상태 변경을 피하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임이다. 변수 값은 누군가에 의해 언제든지 변경될 수 있고, 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 만들어 가독성을 해치고 오류 발생의 근본적 원인이 될 수 있기 때문이다. 함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수 있다. 반환문 함수는 return키워드를 이용하여 실행 결과를 값으로 반환이 가능하다. 반환문은 다음과 같은 3가지의 역할을 한다. 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다. 반환문은 return 키워드 뒤에 지정한 값을 반환한다. return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. 반환문은 생략이 가능하며 생략 시 함수를 전부 실행하고 암묵적으로 undefined 를 반환한다. 다양한 함수의 형태1. 즉시 실행 함수 함수 정의와 동시에 즉시 호출되는 실행함수. 그룹 연산자 ( )로 묶어주어야만 하며, 안묶으면 에러를 발생한다. 1회성이며, 1번 호출시 다시는 호출할 수없다. 기본적으로 익명 즉시 실행함수를 사용하는것이 일반적이다.(함수 이름이 있어도 사용은 가능하나 재호출 불가) 123456789101112131415// 익명 즉시 실행 함수(function () &#123; var a = 3; var b = 5; return a * b;&#125;());// 기명 즉시 실행 함수... 사용은 가능하나 재호출이 불가능하다.(function foo() &#123; var a = 3; var b = 5; return a * b;&#125;());foo(); // ReferenceError: foo is not defined 즉시 함수를 여러가지 방법. ( 1번쨰가 제일 일반적이다. ) 123456789101112131415(function () &#123; // ...&#125;());(function () &#123; // ...&#125;)();!function () &#123; // ...&#125;();+function () &#123; // ...&#125;(); 즉시함수 예제, 12345678910111213var res = (function () &#123; var a = 3; var b = 5; return a * b;&#125;());console.log(res); // 15res = (function (a, b) &#123; return a * b;&#125;(3, 5));console.log(res); // 15 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름이 충돌하는 것을 방지할 수 있다. 이를 위한 목적으로 즉시 실행 함수를 사용하기도 한다. 2. 재귀함수 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀 호출을 하는 함수를 재귀 함수라 칭한다. 재귀함수는 반드시 탈출구를 만들어야 하며 만들지 않을 경우 무한루프에 빠지게된다. 재귀함수의 대표적인 예 - 팩토리얼 1234567891011121314// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.// n! = 1 * 2 * ... * (n-1) * nfunction factorial(n) &#123; // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다. if (n &lt;= 1) return 1; return factorial(n - 1) * n;&#125;console.log(factorial(0)); // 0! = 1console.log(factorial(1)); // 1! = 1console.log(factorial(2)); // 2! = 1 * 2 = 2console.log(factorial(3)); // 3! = 1 * 2 * 3 = 6console.log(factorial(4)); // 4! = 1 * 2 * 3 * 4 = 24console.log(factorial(5)); // 5! = 1 * 2 * 3 * 4 * 5 = 120 재귀 함수는 stack overflow 와 같은 에러를 유발할수 있기 때문에 가급적이면 사용을 자제해야한다. 3. 중첩 함수 함수 내부에 정의된 함수를 중첩함수 또는 내부 함수라 한다. 자신을 포함하는 외부함수를 돕는 헬퍼함수의 역할을 한다. 외부 함수는 중첩 함수의 변수에 접근이 불가능하다. 반면에 중첩 함수는 외부 함수의 변수에 접근이 가능하다. 12345678910111213141516function outer() &#123; var x = 1; // 중첩 함수 function inner() &#123; var y = 2; // 외부 함수의 변수를 참조할 수 있다. console.log(x + y); // 3 &#125; inner(); // 중첩 함수의 변수를 참조할 수 없다. console.log(x + y); // ReferenceError: y is not defined&#125;outer(); 콜백 함수 자바스크립트는 1급 객체이므로 함수의 매개변수에 함수를 전달이 가능하다. 123456789101112131415161718// 콜백 함수를 전달받는 함수function print(f) &#123; var string = 'Hello'; // 콜백 함수를 전달받는 함수가 콜백 함수의 호출 시기를 결정하고 호출 return f(string);&#125;// print 함수에 콜백 함수를 전달하면서 호출var res1 = print(function (str) &#123; return str.toUpperCase();&#125;);// print 함수에 콜백 함수를 전달하면서 호출var res2 = print(function (str) &#123; return str.toLowerCase();&#125;);console.log(res1, res2); // HELLO hello ​ print 함수는 함수를 인수로 전달받는다. print 함수에 인수로 전달된 함수는 print 함수가 호출할 시기를 결정하여 호출한다. 이때 print 함수에 인수로 전달된 함수를 콜백 함수(Callback function)라고 한다. 콜백 함수는 콜백 함수를 인수로 전달 받은 함수가 호출 시점을 결정하여 호출한다. 콜백 함수가 콜백 함수를 전달받는 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 인수로 곧바로 전달하는 것이 일반적이다. 이때 콜백 함수로서 전달된 함수 리터럴은 콜백 함수를 전달받은 함수가 호출될 때 평가되어 생성된다. 중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수는 함수에 전달되어 헬퍼 함수의 역할을 한다. 단, 중첩 함수는 고정되어 있어서 교체할 수 없지만 콜백 함수는 함수 외부에서 인수로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 12345678910111213141516171819202122232425262728// 콜백 함수를 사용하지 않으면 함수를 분리해야 한다.function printToUpperCase() &#123; var string = 'Hello'; return string.toUpperCase();&#125;console.log(printToUpperCase()); // HELLOfunction printToLowerCase() &#123; var string = 'Hello'; return string.toLowerCase();&#125;console.log(printToLowerCase()); // hello// 콜백 함수를 외부에서 전달하면 콜백 함수에 따라 다양한 동작을 하는 함수를 만들 수 있다.function print(f) &#123; var string = 'Hello'; return f(string);&#125;console.log(print(function (str) &#123; return str.toUpperCase();&#125;)); // HELLOconsole.log(print(function (str) &#123; return str.toLowerCase();&#125;)); // hello 콜백 함수는 비동기 처리를 위해 사용하는 일반적인 패턴이다. 주로 이벤트 처리나 Ajax 통신에 많이 이용된다. 또, 고차 함수(Higher-order Function)에서도 사용하는 패턴으로 사용 빈도가 매우 높고 중요한 패턴이다. 12345678910111213// 콜백 함수를 사용하는 고차 함수 mapvar res = [1, 2, 3].map(function (item) &#123; return item * 2;&#125;);console.log(res); // [ 2, 4, 6 ]// 콜백 함수를 사용하는 고차 함수 filterres = [1, 2, 3].filter(function (item) &#123; return item % 2;&#125;);console.log(res); // [ 1, 3 ]","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm10","slug":"daily-algorithm10","date":"2019-10-10T10:20:11.000Z","updated":"2019-10-10T10:20:47.606Z","comments":true,"path":"2019/10/10/daily-algorithm10/","link":"","permalink":"http://yoursite.com/2019/10/10/daily-algorithm10/","excerpt":"","text":"문제 출저 : 프로그래머스 2016년정답을 맞추었으나 너무 코드 가독성이 떨어짐 추후 다시 풀 것.문제 설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요. 제한 조건 2016년은 윤년입니다. 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function solution(a, b) &#123; var answer = ''; var dayOfTheWeek = [ 'FRI','SAT','SUN', 'MON', 'TUE', 'WED', 'THU']; var j = 0; for(var month=1;month&lt;=a;month++)&#123; switch(month)&#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: for(var x=1;x &lt;= 31; x++)&#123; if(month == a &amp;&amp; x == b)&#123; answer = dayOfTheWeek[j]; break; &#125; else&#123; j++; if( j == 7)&#123; j = 0; &#125; &#125; &#125; break; case 4: case 6: case 9: case 11: for(var x=1;x &lt;= 30; x++)&#123; if(month == a &amp;&amp; x == b)&#123; answer = dayOfTheWeek[j]; break; &#125;else &#123; j++; if( j == 7)&#123; j = 0; &#125; &#125; &#125; break; default : for(var x=1; x &lt;= 29; x++)&#123; if(month == a &amp;&amp; x == b)&#123; answer = dayOfTheWeek[j]; break; &#125; else&#123; j++; if( j == 7)&#123; j = 0; &#125; &#125; &#125; break; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-06","slug":"javascript-study-06","date":"2019-10-10T04:30:16.000Z","updated":"2019-10-10T10:11:11.248Z","comments":true,"path":"2019/10/10/javascript-study-06/","link":"","permalink":"http://yoursite.com/2019/10/10/javascript-study-06/","excerpt":"","text":"JavaScript Study 06 용어 단축평가 사용 용도 객체 객체를 만드는 방법 인스턴스 프로퍼티 프로퍼티 접근 방법 프로퍼티 동적 생성 프로퍼티 삭제 ES6 객체 리터럴 확장 기능 프로퍼티 축약 표현 메소드 축약 표현 원시값과 객체의 비교 원시값 const vs var/let Scope ( 변수의 생명주기 - 식별자의 생명주기 ) 문자열과 불변성 유사배열 객체 ( = 문자열 ) 값에 의한 전달 객체 변경 가능한 값 참조에 의한 전달 복사 : 얕은 복사( Shallow Copy ) / 깊은 복사 ( Deep Copy ) 얕은 복사( Shallow Copy ) 깊은 복사 ( Deep Copy ) 용어 - ( 러버덕 ) 원시값 변경 가능한 값 값에 의한 전달 객체 변경 불가능한 값 참조에 의한 전달 단축평가 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 언제나 피연산자 중 어는 한쪽 값을 반환한다. 1'Cat' &amp;&amp; 'Dog' // 'Dog' 어느 쪽 값을 출력할지는 최종 평가 결과를 결정할 피연산자를 출력한다. &amp;&amp; 은 선 피연산자가 true 라면 후 피연산자를 출력한다. 이유는 첫 피연산자가 true라면 후 피연산자를 통해 해당 값이 true 인지 false 인지 최종 결정이 나기 때문이다. 1'문자열' &amp;&amp; 0 // 0 &amp;&amp; 은 선 피연산자가 false 라면 그냥 선 피연산자를 출력한다. 이유는 첫 피연산자가 false라면 어차피 &amp;&amp; 연산을 통해 해당 값이 false 로 최종 결정이 나기 때문이다. 10 &amp;&amp; '문자열' // 0 || 은 선 피연산자가 true 라면 그냥 선 피연산자를 출력한다. 이유는 첫 피연산자가 true라면 어차피 || 연산을 통해 해당 값이 true 로 최종 결정이 나기 때문이다. 1'Cat' || 'Dog' // 'Cat' || 은 선 피연산자가 false 라면 후 피연산자를 출력한다. 이유는 첫 피연산자가 false라면 후 피연산자를 통해 해당 값이 true 인지 false 인지 최종 결정이 나기 때문이다. 1'' || 'Dog' // 'Dog' 사용 용도 객체가 null인지 확일할 때 1234var elem = null;console.log(elem.value); //1번, TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); //2번, null 변수 elem에 null값으로 초기화를 해주었는데 elem에 대한 value프로퍼티를 참조하게 될 경우 1번처럼 error를 유발한다. 1번의 경우, error가 날 경우 개발자 도구를 통해서 알 수 있지만, 브라우저 상에서는 알기가 힘들다. 따라서 2번처럼 에러 확인코드를 추가하여 일어날 수 있는 에러를 방지 해주어야만 한다. 함수 매개변수에 기본값을 설정할 때 12345678910111213141516// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) &#123; str = str || ''; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') &#123; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다. 이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다. 객체 자바스크립트의 객체는 자바처럼 클래스를 필요로 하지 않는다. 객체는 재산( property )을 가지고 있다. 프로퍼티는 콤마 ( , ) 로 구분한다. 그래서 이것을 객체 리터럴이라고 한다. 객체 리터럴은 평가 될 떄 할당된다. 1234var person = &#123; name: 'Lee', //재산(프로퍼티) - 객체 리터럴 gender: 'male' //재산(프로퍼티) - 객체 리터럴&#125;; 객체를 선언할 떄 사용하는 { } 는 코드 블록이 아니다. 증거 코드 블록이 끝나고서 ; 을 붙인다. 코드 블록 내용에 ;이 들어가지 않는다. 객체의 프로퍼티는 키와 값으로 구성되어 있다. 객체의 프로퍼티 키는 식별자가 아니기 때문에, 식별자 네이밍 규칙을 따르지 않는다. 값은 단순한 숫자, 문자열부터 함수(일급 객체)도 담을 수 있다. ( 7가지의 데이터 타입이 모두 올 수 있다. ) 여기서 프로퍼티의 키와 값을 프로퍼티 ( 정적 : state )(그대로 부름) 프로퍼티의 키와 함수를 메소드 ( 동적 : behavior )라 칭한다. 객체를 만드는 방법들 객체 리터럴 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스 (ES6) 1var o = &#123;&#125;; //객체 리터럴, 생성방법 o는 빈프로퍼티를 가지며 자동 상속을 받는다. 인스턴스 타언어에서 클래스에 의해 생성되어 메모리에 저장된 실체를 의미한다. 하지만 자바스크립트에서는 new혹은 Object 객체로 만들어낸 객체를 인스턴스라고 부른다. 프로퍼티​ 객체는 프로퍼티(Property)들의 집합이며 프로퍼티는 키(key)과 값(value)으로 구성된다. 프로퍼티를 나열할 때는 쉼표(,)로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나 사용해도 좋다. 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값 + 숫자( 강제 문자열 변환 ) 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 여기서 프로퍼티 키 는 식별자 네이밍 규칙을 따를 필요가 없다하지만, 식별자 네이밍 규칙을 따르는 키와 따르지 않는 키는 서로 선언하는데 차이가 있다. 예를들어 보자, 123456var person = &#123; first_name: 'Ung-mo', // 식별자 네이밍 규칙을 따르는 이름 'last-name': 'Lee' // 식별자 네이밍 규칙을 않은 이름&#125;;console.log(person); // &#123;first_name: \"Ung-mo\", last-name: \"Lee\"&#125; 즉, 식별자 네이밍 규칙을 따르지 않는 키는 반드시 &#39;&#39; 로 묶어 주어야 제대로 동작한다. 프로퍼티 접근 방법프로퍼티 접근 방법 마침표 표기법 : 식별자 네이밍 규칙을 준수하는 키만 접근이 가능. ( 추천 ) 대괄호 표기법 : 모두 접근이 가능. 단, [ ] 안에는 반드시 &#39;&#39;가 들어가야 한다. ( 비추천 ) 123456789101112131415161718192021222324var person = &#123; name: 'Lee', 'last-name': 'Hyeok', 1: 10&#125;;// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Lee// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Leeconsole.log(person[name]); // ReferenceError: name is not defined. 에러유발// 식별자 네이밍을 지키지 않은 키에 접근할 때console.log(person.'last-name'); // SyntaxError: Unexpected stringconsole.log(person.last-name); // NaN;console.log(person[last-name]); // ReferenceError: last is not definedconsole.log(person['last-name']); // Hyeok// 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 따옴표를 생략 가능하다.console.log(person.1); // SyntaxError: missing ) after argument listconsole.log(person.'1'); // SyntaxError: Unexpected stringconsole.log(person[1]); // 10 : person[1] -&gt; person['1']console.log(person['1']); // 10 여기서 이 부분에 대해서 더 자세하게 보도록 하겠다. 1234567var person = &#123; 'last-name': 'Hyeok',&#125;;// 식별자 네이밍을 지키지 않은 키에 접근할 때console.log(person.last-name); // NaN;console.log(name); // 아무것도 출력이 안됨. 즉 빈문자열임 왜 NaN이 뜨고 name은 빈문자열이 뜨는걸까? ( 아래 해설 참조 ) 만약 window 객체의 프로터피가 아닌 다른 것을 참조한다면 다음과 같이 뜬다. 12345var person = &#123; 'last-names': 'Lee'&#125;;console.log(person.last-names); // ReferenceError: names is not defined 이유 : names 는 window 객체의 프로퍼티도 아니고 선언조차 되어있지 않는 존재하지 않는 변수이기 때문에 정의 Error를 유발한다. 프로퍼티 동적 생성존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다. 123456789var person = &#123; name: 'Lee'&#125;;// person 객체에는 address 프로퍼티가 존재하지 않는다.// 따라서 person 객체에 address 프로퍼티가 동적으로 생성되고 값이 할당된다.person.address = 'Seoul';console.log(person); // &#123;name: \"Lee\", address: \"Seoul\"&#125; 프로퍼티 삭제delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다. 12345678910111213141516var person = &#123; name: 'Lee'&#125;;// 프로퍼티 동적 추가person.address = 'Seoul';// person 객체에 address 프로퍼티가 존재한다.// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 있다.delete person.address;// person 객체에 age 프로퍼티가 존재하지 않는다.// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.delete person.age;console.log(person); // &#123;name: \"Lee\"&#125; ES6 객체 리터럴 확장 기능프로퍼티 축약 표현객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다. 123456789// ES5var x = 1, y = 2;var obj = &#123; x: x, y: y&#125;;console.log(obj); // &#123;x: 1, y: 2&#125; ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략(Property shorthand)할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다. 1234567// ES6let x = 1, y = 2;// 프로퍼티 축약 표현const obj = &#123; x, y &#125;;console.log(obj); // &#123;x: 1, y: 2&#125; 메소드 축약 표현ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당한다. 123456789// ES5var obj = &#123; name: 'Lee', sayHi: function() &#123; console.log('Hi! ' + this.name); &#125;&#125;;obj.sayHi(); // Hi! Lee ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다. 12345678910// ES6const obj = &#123; name: 'Lee', // 메소드 축약 표현 sayHi() &#123; // &lt;-&gt; sayHi: function() &#123; console.log('Hi! ' + this.name); &#125;&#125;;obj.sayHi(); // Hi! Lee ES6의 메소드 축약 표현으로 정의한 메소드는 프로퍼티에 할당한 함수와 다르게 동작한다. 원시 값과 객체의 비교원시값 원시 타입(primitive type)의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. (read-only) 변수의 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 원시 값의 이러한 특성을 불변성(immutability)이라 한다. 변수는 최대한 재할당을 하지 않고 상수처럼 쓰는 것이 좋다. ( scope - 식별자의 생명주기 ) const VS var/let값을 변경할 수 없다는 것은 재할당을 할 수 없다는 의미인데 변수는 새로운 값을 재할당하는 것으로 변수값을 변경할 수 있다. 변수에 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수이다. 단, 변수는 언제든지 재할당을 통해 변수값을 변경할 수 있지만 상수는 단 한번만 할당이 허용된다. 따라서 상수와 변경 불가능한 값을 동일시하는 것은 곤란하다. Scope(변수의 생명주기 - 식별자의 생명주기)변수는 빨리 써서 버려져야 메모리에 무리가 없기 때문에 변수의 생명주기를 고려하여 함수나 변수가 들어가는 코드 블록은 되도록이면 짧은걸 권장한다. 하지만, 전역변수는 자바스크립트가 실행하는 초반부터 실행되고 자바스크립트가 끝날때까지 소멸되지 않는다. 그러므로 전역변수는 되도록 조금 사용하는걸 권장한다. 문자열과 불변성 문자열은 0개 이상인 문자들의 집합을 말하며 1개의 문자는 2Byte의 메모리 공간에 저장된다. 따라서, 문자열 타입의 값은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 다르다. 숫자는 1도 , 100000000000도 동일한 8byte가 필요하지만 문자열 타입은 1개의 문자로 이루어진 문자열은 2byte , 10개의 문자로 이루어진 문자열은 20byte가 필요하다. 문자열또한 원시값 인것을 명시해야만 한다. 12var str = 'Hello';str = 'World'; 유사 배열 객체 ( = 문자열 ) 유사 배열 객체는 마치 배열처럼 인덱스 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체를 의미한다. 따라서, 문자열은 원시값이면서 유사 배열 객체이다. 유사배열객체는 프로퍼티 키에 length 가 있느냐, 없느냐 로 따라서 체크가 가능하다. 123456789101112// 유사 배열 객체 체크방법var name = \"Kim\";console.log(name.length); // 3var str = 'string';// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.// 하지만 문자열은 원시 타입인 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.str[0] = 'S';console.log(str); // string 값에 의한 전달 변수에 변수를 할당하는 경우, 할당되는 변수(score)가 원시값을 갖는 변수라면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 12345var score = 80;var copy = score;copy = 100;console.log(score); // 80 객체 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. 객체는 변경 가능한 값(mutable value)이다. 이를 참조 값(Reference value)을 갖는다고 한다. 객체는 다른변수에 할당할때 참조에 의한 전달(Pass by reference)을 한다. 객체 리터럴은 평가 될 떄 할당된다. 변경 가능한 값​ 원시값은 메모리마다 할당이 되어있기 때문에 값의 변경 유무를 추척하기가 쉽다.반면에 참조값은 실제값의 주소를 참조하고 있기 때문에 값의 변경 유무 추적이 정말 어렵다. 원시 값을 할당한 변수는 재할당을 통해서만 변경이 가능하다.반면에, 변수가 참조하고 있는 객체의 경우, 동적으로 프로퍼티 추가나 변경,삭제 등등 변경할 수 있는 값이다. 1234567891011var person = &#123; name: 'Lee'&#125;;// 프로퍼티 키 name 의 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 추가 person.gender = 'male';console.log(person); // &#123;name: \"Kim\", gender: \"male\"&#125; ​ 객체를 변경할 때 마다 원시 값처럼 이전 값을 복사하여 새롭게 생성한다면 명확하고 깔끔하겠지만 객체는 크기가 매우 클 수도 있고 프로퍼티 값이 객체일 수도 있어서 복사(Deep copy)하고 생성하는 비용이 많이 든다. 다시 말해, 메모리의 효율적 소비가 어렵고 퍼포먼스가 나빠진다. 따라서, 객체는 이러한 구조적 단점에 따른 부작용(Side effect)이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. 참조에 의한 전달​ 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 123456var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사var copy = person; 원본 person와 사본 copy 모두 동일한 객체를 가리키고 있다. 이것은 두개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 어떤 한쪽에서 객체를 변경(객체의 프로퍼티 값 변경 또는 추가, 삭제)이 하면 서로 영향을 주고 받는다. 1234567891011121314151617181920var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사. copy와 person은 동일한 객체를 참조한다.var copy = person;// copy와 person은 같은 참조 값을 갖는다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Kim';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 같은 동일한 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125;console.log(copy); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 복사 : 얕은 복사( shallow copy ) / 깊은 복사 ( deep copy )copy에는 두 가지가 있다. shallow copy(얕은 복사)와 deep copy(깊은 복사)이다. shallow copy는 가장 상위 객체만 메모리에 새로 생성되고 내부 객체들은 참조 관계인 경우를 의미한다. deep copy는 내부 객체까지 모두 새로 생성된 것을 의미한다. shallow copyshallow copy의 가장 큰 예는 그냥 객체를 재할당 하는 것이다. 하지만, 그외의 방법에 대해 소개한다. slice 메서드 이용 - Array.prototype.slice.call(변수명) 변수명.slice[0] 혹은 Array.prototype.slice.call(변수명) 을 이용한다 Array.prototype.slice.call(변수명) 대신 변수명.slice(0)을 해도 되지만, arguments 같은 것(유사배열)을 복사할 때를 생각하면 Array.prototype.slice.call로 통일하는 게 좋다. 12345678var array = [&#123; name: 'a' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;];var shallow = Array.prototype.slice.call(array);shallow[0].name = 'd';shallow[1] = 'e';console.log(array); // [&#123; name: 'd' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;]console.log(shallow); // [&#123; name: 'd' &#125;, 'e' , &#123; name: 'c' &#125;] 위 예제를 보면 array 변수를 얕은 복사를 한 shallow라는 변수는 array 변수가 가리키는 객체(배열) 안에 있는 각 객체들 중 첫번째 객체의 name값을 공유하고 있기 때문에 ‘d’라고 변경시 array의 프로퍼티 값은 공유가 되어 변경이 되었다. 하지만 shallow의 두번째 배열 인덱스의 e값을 직접 변경할 경우 메모리에 직접 생성되었기에 array변수와 공유가 되어있지 않다. deep copydeep copy를 하기 위한 가장 기본적인 방법은 객체를 별도로 생성 복사할 객체의 프로퍼티에 각각 접근 (반복문을 이용) 복사 후, 복사할 객체에 프로퍼티를 생성하고 복사. deep copy는 비용이 매우 비싸기 때문에 라이브러리를 쓰는게 좋다. lodash의 cloneDeep( ) 그 중 lodash 의 Library에 있는 deep copy를 사용하는 것을 추천한다. 123456const original = &#123; a : &#123;b : 2&#125;&#125;;let copy = _.cloneDeep(original);copy.a.b = 100; console.log(original.a.b); // 2console.log(copy.a.b); // 100 JSON 객체의 메소드를 이용 123function cloneObject(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; JSON.stringify는 자바스크립트 오브젝트를 스트링 포멧으로 변환하는 메소드이다.JSON.parse는 스트링 포멧을 자바스크립트 오브젝트로 변환하는 메소드이다. 스트링으로 변환하였다가 다시 오브젝트로 변환하기 때문에 이전 객체에 대한 참조가 없어지지만 JSON 메소드 자체가 성능면에서 다른 방법에 비해 굉장히 느리기 때문에 주의해야한다.이 방법은 객체를 깊은 복사(Deep Copy)한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-10","slug":"javascript-preview-10","date":"2019-10-09T08:31:55.000Z","updated":"2019-10-10T10:14:38.767Z","comments":true,"path":"2019/10/09/javascript-preview-10/","link":"","permalink":"http://yoursite.com/2019/10/09/javascript-preview-10/","excerpt":"","text":"JacaScript 10강 예습 10강 : 원시 값과 객체의 비교 원시값 변경 불가능한 값 문자열과 불변성 유사 배열 객체 값에 의한 전달 객체 (참조값) 변경 가능한 값 참조에 의한 전달 복사 : 얕은 복사( shallow copy ) / 깊은 복사 ( deep copy ) shallow copy deep copy 10강​ 데이터 타입의 구분 12- 원시타입 : 변경 불가능한 값. 원시값 - 숫자, 문자열, 불리언, null, undefined, symbol- 객체타입 : 변경 가능한 값. 참조값 - Object 원시 타입 객체 타입 변경 유무 변경 불가능한 값 변경 가능한 값 값 원시값 참조값 종류 숫자,문자열,불리언,null,undefined,symbo 객체타입( Object) 저장 방법 실제값 저장 참조값이 저장 타 변수 할당 원본의 원식 값이 복사되어 전달(Pass by value) 원본의 참조값이 복사되어 전달(Pass by reference) 원시값 변경 불가능한 값 원시값은 오직 읽을 수 만 있는(Read Only)한 값이므로 변경할 수 없다. ​ 변경 불가능 하다는 것은 변수를 변경이 불가능하다는 것이 아니라 값을 변경 불가능하다는 이야기이다. ( 참고로, 상수는 재할당이 금지된 변수라는 뜻이므로 상수 내부에 있는 객체 프로퍼티의 값은 변경이 가능하다. ) 변수의 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 원시 값의 이러한 특성을 불변성(immutability)이라 한다. 문자열과 불변성 문자열은 0개 이상인 문자들의 집합을 말하며 1개의 문자는 2Byte의 메모리 공간에 저장된다. 따라서, 문자열 타입의 값은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 다르다. 숫자는 1도 , 100000000000도 동일한 8byte가 필요하지만문자열 타입은 1개의 문자로 이루어진 문자열은 2byte , 10개의 문자로 이루어진 문자열은 20byte가 필요하다. 문자열또한 원시값 인것을 명시해야만 한다. 12var str = 'Hello';str = 'World'; 유사 배열 객체 유사 배열 객체는 마치 배열처럼 인덱스 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체를 의미한다. 따라서, 문자열은 원시값이면서 유사 배열 객체이다. 1234567var str = 'string';// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.// 하지만 문자열은 원시 타입인 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.str[0] = 'S';console.log(str); // string 값에 의한 전달 변수에 변수를 할당하는 경우, 할당되는 변수(score)가 원시값을 갖는 변수라면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 1234var score = 80;// 변수 copy에는 변수 score의 원시값 80이 복사되어 할당된다.var copy = score; 객체 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. 자바는 클래스를 통해 미리 프로퍼티의 내용과 값을 지정해두는 방식을 기반하여 객체를 생성한다. 하지만, 자바스크립트의 대부분은 객체의 프로퍼티 값의 위치를 메모리에 저장하기 위해 해시 함수 기반의 유사딕셔너리구조(dictionary-like structure)를 사용한다. 유사 딕셔너리 구조(dictionary-like structure)는 클래스없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메소드를 추가할 수 있다. 이는 비효율적이라서 자바스크립트에서는 자바와 같은 객체 관리 방식처럼 비용을 줄이기 위해 히든 클래스라는 방식을 이용한다. 변경 가능한 값123var person = &#123; name: 'Lee'&#125;; 아래 그림에서 person의 주소 0x000000F2에 저장된 값이 참조값이다. 참조값을 평가하면 참조값에 적힌 메모리주소에 있는 객체를 반환한다. 객체를 할당한 변수를 평가하면 메모리에 저장되어 있는 참조 값을 반환하는 것이 아니라 참조 값을 통해 실제 객체에 접근해 그 객체를 반환한다. 원시 값을 할당한 변수의 경우, “변수는 ◯값을 갖는다.” 또는 “변수의 값은 ◯이다.”라고 표현한다. 객체를 할당한 변수의 경우, “변수는 객체를 참조하고 있다” 또는 “변수는 객체를 가리키고(point) 있다”라고 표현한다. 원시 값을 할당한 변수는 재할당을 통해서만 변경이 가능하다. 반면에, 변수가 참조하고 있는 객체의 경우, 동적으로 프로퍼티 추가나 변경,삭제 등등 변경할 수 있는 값이다. 1234567891011var person = &#123; name: 'Lee'&#125;;// 프로퍼티 키 name 의 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 추가 person.gender = 'male';console.log(person); // &#123;name: \"Kim\", gender: \"male\"&#125; 객체를 변경할 때 마다 원시 값처럼 이전 값을 복사하여 새롭게 생성한다면 명확하고 깔끔하겠지만 객체는 크기가 매우 클 수도 있고 프로퍼티 값이 객체일 수도 있어서 복사(Deep copy)하고 생성하는 비용이 많이 든다. 다시 말해, 메모리의 효율적 소비가 어렵고 퍼포먼스가 나빠진다. 따라서, 객체는 이러한 구조적 단점에 따른 부작용(Side effect)이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. 참조에 의한 전달​ 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 123456var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사var copy = person; 원본 person와 사본 copy 모두 동일한 객체를 가리키고 있다. 이것은 두개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 어떤 한쪽에서 객체를 변경(객체의 프로퍼티 값 변경 또는 추가, 삭제)이 하면 서로 영향을 주고 받는다. 1234567891011121314151617181920var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사. copy와 person은 동일한 객체를 참조한다.var copy = person;// copy와 person은 같은 참조 값을 갖는다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Kim';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 같은 동일한 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125;console.log(copy); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 복사 : 얕은 복사( shallow copy ) / 깊은 복사 ( deep copy )copy에는 두 가지가 있다. shallow copy(얕은 복사)와 deep copy(깊은 복사)이다. shallow copy는 가장 상위 객체만 메모리에 새로 생성되고 내부 객체들은 참조 관계인 경우를 의미한다. deep copy는 내부 객체까지 모두 새로 생성된 것을 의미한다. +++객체를 복사하는 방법들 shallow copy1. slice 메서드 이용 - Array.prototype.slice.call(변수명) 변수명.slice[0] 혹은 Array.prototype.slice.call(변수명) 을 이용한다 Array.prototype.slice.call(변수명) 대신 변수명.slice(0)을 해도 되지만, arguments 같은 것(유사배열)을 복사할 때를 생각하면 Array.prototype.slice.call로 통일하는 게 좋다. 123456var array = [&#123; name: 'a' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;];var shallow = Array.prototype.slice.call(array);shallow[0].name = 'd';shallow[1] = 'e';console.log(array); // [&#123; name: 'd' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;]console.log(shallow); // [&#123; name: 'd' &#125;, 'e' , &#123; name: 'c' &#125;] 위 예제를 보면 array 변수를 얕은 복사를 한 shallow라는 변수는 array 변수가 가리키는 객체(배열) 안에 있는 각 객체들 중 첫번째 객체의 name값을 공유하고 있기 때문에 ‘d’라고 변경시 array의 프로퍼티 값은 공유가 되어 변경이 되었다. 하지만 shallow의 두번째 배열 인덱스의 e값을 직접 변경할 경우 메모리에 직접 생성되었기에 array변수와 공유가 되어있지 않다. deep copy1. 자바스크립트 재귀 사용 12345678910function cloneObject(obj) &#123; var clone = &#123;&#125;; for(var i in obj) &#123; if(typeof(obj[i])==\"object\" &amp;&amp; obj[i] != null) clone[i] = cloneObject(obj[i]); else clone[i] = obj[i]; &#125; return clone;&#125; 오브젝트의 프로퍼티들을 순회하여 빈 오브젝트에 더한다. 그 과정에서 원본 오브젝트의 프로퍼티가 오브젝트일 경우 재귀적으로 함수를 실행한다.이 방법은 객체를 깊은 복사(Deep Copy)한다. 2. JSON 객체의 메소드를 이용 123function cloneObject(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; JSON.stringify는 자바스크립트 오브젝트를 스트링 포멧으로 변환하는 메소드이다.JSON.parse는 스트링 포멧을 자바스크립트 오브젝트로 변환하는 메소드이다. 스트링으로 변환하였다가 다시 오브젝트로 변환하기 때문에 이전 객체에 대한 참조가 없어지지만 JSON 메소드 자체가 성능면에서 다른 방법에 비해 굉장히 느리기 때문에 주의해야한다.이 방법은 객체를 깊은 복사(Deep Copy)한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm09","slug":"daily-algorithm09","date":"2019-10-09T07:18:21.000Z","updated":"2019-10-09T08:30:26.008Z","comments":true,"path":"2019/10/09/daily-algorithm09/","link":"","permalink":"http://yoursite.com/2019/10/09/daily-algorithm09/","excerpt":"","text":"문제 출저 : 프로그래머스 K번째 수문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 123456789101112131415function solution(array, commands) &#123; var answer = []; let tempArray = []; for (let i = 0; i &lt; commands.length; i++) &#123; tempArray = array.slice((commands[i][0]) - 1, commands[i][1]); console.log(tempArray); tempArray.sort((a, b) =&gt; a - b); // ES5에서 사용될 코드 // tempArray.sort(function(a, b) &#123; return a - b; &#125;); answer.push(tempArray[commands[i][2] - 1]); &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm08","slug":"daily-algorithm08","date":"2019-10-08T07:47:14.000Z","updated":"2019-10-09T07:18:55.068Z","comments":true,"path":"2019/10/08/daily-algorithm08/","link":"","permalink":"http://yoursite.com/2019/10/08/daily-algorithm08/","excerpt":"","text":"문제 출저 : Poiema 1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라123456789101112function problem01() &#123; console.log('1번 문제입니다.'); const i = 15; if (i &gt; 10 &amp;&amp; i &lt; 20) &#123; console.log(i); &#125; console.log('-------------------'); return i;&#125;problem01(); 2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오. 1234567891011function problem02() &#123; console.log('2번 문제입니다.'); for (let i = 0; i &lt; 10; i++) &#123; if (i % 2 === 0) &#123; console.log(i); &#125; &#125; console.log('-------------------');&#125;problem02(); 3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오. 12345678910111213function problem03() &#123; console.log('3번 문제입니다.'); let strNum = []; for (let i = 0; i &lt; 10; i++) &#123; if (i % 2 === 0) &#123; strNum += i; &#125; &#125; console.log(strNum); console.log('-------------------');&#125;problem03(); 4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오. 1234567891011function problem04() &#123; console.log('4번 문제입니다.'); for (let i = 10; i &gt; 0; i--) &#123; if (i % 2 !== 0) &#123; console.log(i); &#125; &#125; console.log('-------------------');&#125;problem04(); 5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오. 1234567891011121314function problem05() &#123; console.log('5번 문제입니다.'); let i = 0; while (i &lt; 10) &#123; if (i % 2 === 0) &#123; console.log(i); &#125; i++; &#125; console.log('-------------------');&#125;problem05(); 6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오. 1234567891011121314function problem06() &#123; console.log('6번 문제입니다.'); let i = 10; while (i &lt;= 10 &amp;&amp; i &gt; 0) &#123; if (i % 2 !== 0) &#123; console.log(i); &#125; i--; &#125; console.log('-------------------');&#125;problem06(); 7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오. (결과 : 45)12345678910111213function problem07() &#123; console.log('7번 문제입니다.'); let sum = 0; for (let i = 0; i &lt; 10; i++) &#123; sum += i; &#125; console.log(sum); console.log('-------------------');&#125;problem07(); 8. 1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오. (결과 : 73)123456789101112131415function problem08() &#123; console.log('8번 문제입니다.'); let sum = 0; for (let i = 1; i &lt; 20; i++) &#123; if (i % 2 !== 0 &amp;&amp; i % 3 !== 0) &#123; sum += i; &#125; &#125; console.log(sum); console.log('-------------------');&#125;problem08(); 9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오. (결과 : 117)123456789101112131415function problem09() &#123; console.log('9번 문제입니다.'); let sum = 0; for (let i = 1; i &lt; 20; i++) &#123; if (i % 2 === 0 || i % 3 === 0) &#123; sum += i; &#125; &#125; console.log(sum); console.log('-------------------');&#125;problem09(); 10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오. 123456789101112131415function problem10() &#123; console.log('10번 문제입니다.'); for (let i = 1; i &lt; 6; i++) &#123; for (let j = 0; j &lt; 6; j++) &#123; if ((i + j) === 6) &#123; console.log(`[ $&#123;i&#125;, $&#123;j&#125; ]`); &#125; &#125; &#125; console.log('-------------------');&#125;problem10(); 11. 삼각형 출력하기 - pattern 1다음을 참고하여 *(별)로 높이가 5인(var line = 5) 삼각형을 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 12345678910111213141516171819202122232425function problem11() &#123; console.log('11번 문제입니다.'); const line = 5; let star = ''; for (let i = 0; i &lt; line; i++) &#123; for (let j = 0; j &lt;= i; j++) &#123; star += '*'; &#125; // 다른 방법 // for (let j = 0; j &lt;= line; j++) &#123; // if (j &lt;= i) &#123; // star += '*'; // &#125; // &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem11(); 12. 삼각형 출력하기 - pattern 2다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 123456789101112131415161718192021222324252627282930313233function problem12() &#123; console.log('12번 문제입니다.'); const line = 5; let star = ''; for (let i = 0; i &lt; line; i++) &#123; // for (let x = 0; x &lt;= i; x++) &#123; // star += ' '; // &#125; // for (let j = i; j &lt; line; j++) &#123; // star += '*'; // &#125; // star += '\\n'; // 다른방법 for (let x = 0; x &lt; line; x++) &#123; if (x &lt; i) &#123; star += ' '; &#125; &#125; for (let j = 0; j &lt; line; j++) &#123; if (j &gt;= i) &#123; star += '*'; &#125; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem12(); 13. 삼각형 출력하기 - pattern 3다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 123456789101112131415161718function problem13() &#123; console.log('13번 문제입니다.'); const line = 5; let star = ''; for (let i = line; i &gt; 0; i--) &#123; for (let j = 1; j &lt;= i; j++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem13(); 14. 삼각형 출력하기 - pattern 4다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 12345678910111213141516171819function problem14() &#123; console.log('14번 문제입니다.'); const line = 5; let star = ''; for (let i = line; i &gt; 0; i--) &#123; for (let j = i - 1; j &gt; 0; j--) &#123; star += ' '; &#125; for (let k = i - 1; k &lt; line; k++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem14(); 15. 정삼각형 출력하기 12345678910111213141516171819function problem15() &#123; console.log('15번 문제입니다.'); const line = 5; let star = ''; for (let i = 0; i &lt; line; i++) &#123; for (let j = 4; j &gt; i; j--) &#123; star += ' '; &#125; for (let k = 0; k &lt; (i * 2) + 1; k++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem15(); 16. 역정삼각형 출력하기 123456789101112131415161718function problem16() &#123; console.log('16번 문제입니다.'); const line = 5; let star = ''; for (let i = line; i &gt; 0; i--) &#123; for (let j = line; j &gt; i; j--) &#123; star += ' '; &#125; for (let k = 0; k &lt; (i * 2) - 1; k++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem16();","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-05","slug":"javascript-study-05","date":"2019-10-08T04:21:55.000Z","updated":"2019-10-09T08:41:29.710Z","comments":true,"path":"2019/10/08/javascript-study-05/","link":"","permalink":"http://yoursite.com/2019/10/08/javascript-study-05/","excerpt":"","text":"JavaScript Study 05 용어 제어문 블록문 조건문 if ~ else , else if switch( ) 반복문 for 문 while 문 do~while 문 break 문 레이블문 continue 문 타입변환 (암묵적) 문자열 타입 변환 (암묵적) 숫자 타입 변환 (암묵적) 불리언 타입 변환 (명시적) 문자열 타입 변환 용어 - ( 러버덕 ) 제어문 예제 ( 16가지 ) 제어문 블록문 0개 이상의 { } 로 묶은 것으로 코드 블록 또는 블록이라고 부른다. ( 하나의 실행단위 ) 조건문 주어진 조건식의 평가 결과에 따라 코드 블럭의 실행을 결정한다. if ... else 문 swith 문 1. if ~ else , else if12345if (조건식) &#123; // 조건식이 참이면 이 코드 블록이 실행된다.&#125; else &#123; // 조건식이 거짓이면 이 코드 블록이 실행된다.&#125; *else if 문과 else 문은 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. * if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다. 2. switch( )12345678910switch (표현식) &#123; case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;&#125; *switch문은 반드시 break; 동반 해야만 한다. * break;가 없다면 맞는 조건이어도 다음 case 표현식으로 넘어가게 된다. default에는 break; 생략이 가능하다. 반복문 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. for ( for-in, for-of ) , while , do~while 1. for문123for (변수 선언문 또는 할당문; 조건식; 증감식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 만약 , 모두 비워있다면 무한 루프가 된다. 123for(;;)&#123; 내용;&#125; 예제, 중첩 for문을 이용한 주사위 눈 합 12345for (var i = 1; i &lt;= 6; i++) &#123; for (var j = 1; j &lt;= 6; j++) &#123; if (i + j === 6) console.log(`[$&#123;i&#125;, $&#123;j&#125;]`); &#125;&#125; 자바스크립트에서 for문 대체 함수들 ​ 실무에서는 반복문 대신 아래 함수들을 더 많이 사용한다. 왠만해서는 가독성이 안좋다는 이유로 인해 반복을 안쓰려한다. 다만, 기본적인 for문을 다룰줄 알아야 아래 기능들에 대해 더 쉽게 이해가 가능하다. forEach map filter find reduce 2. while 문123while (조건식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; while문은 조건식이 true라면 무한루프가 된다. 12// 무한루프while (true) &#123; ... &#125; 무한 루프를 탈출 하기 위해서는 특정조건으로 인한 break; 를 추가하여야 한다. 3. do…while 문123do&#123; 최소 1번은 실행되고 그 후부터는 조건에 맞을 경우 반복 실행된다.&#125; while (조건식); do...while문은 최소 1번은 실행된 뒤 조건을 판별하여 게속해서 반복할지 안할지 유무를 결정한다. break 문 가장 가까운 레이블 문, 반복문( for, for-in, for-of, while, do…while ) 또는 switch문의 코드 블록을 탈출한다. 이외에 문에서 사용시 SyntaxError를 유발한다. 레이블 문이란? 식별자가 붙은 문을 의미한다. 12// foo라는 레이블 식별자가 붙은 레이블 문foo: console.log('foo'); 레이블문은 중첩for문에서 외부for문까지 한번에 빠져나가고자 할 때 이용한다. 12345678910// outer라는 식별자가 붙은 레이블 for 문outer: for (var i = 0; i &lt; 3; i++) &#123; for (var j = 0; j &lt; 3; j++) &#123; // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다. if (i + j === 3) break outer; console.log('inner ' + j); &#125;&#125;console.log('Done!'); continue 문 continue 문은 현재 진행되고 있는 반복문의 증감식을 중단하고 다음 증감식으로 이동한다. break문과 다르게 반복문을 탈출하지 않는다. 문자열자바스크립트의 문자열은 유사 배열이다.객체를 배열처럼 사용하는 것은 유사 배열 이다.배열은 원시값 + 객체이다.문자열(배열)을 만들고서 .을 찍어보면 프로퍼티가 나온다.즉, 문자열은 유사배열이다.따라서 문자열을 for문으로 접근하여 1문자씩 읽어들일 수 있다. 타입 변환 명시적 타입 변환 ( 타입 캐스팅 ) : 개발자에 의도하에 값의 타입을 변환하는 것. 암묵적 타입 변환 ( 강제 타입 변환 ) : 개발자에 의도하는 관계 없이 JS엔진에 의해 타입이 자동으로 변환되는 것. 1234567// 명시적 타입 변환var x = 10;var str = x.toString(); // '10';// 암묵적 타입 변환var x = 10;var str = x + ''; // '10'; 연산자의 부수효과​ 연산자 중 유일하게 피연산자의 값을 변경하는 연산자는 증가 ++ 와 감소 --밖에 없다. 암묵적 타입변환을 예상하는 방법. 어떻게해야 자바스크립트 엔진이 해당 구문을 보고 에러를 내지않을까? 라는 취지로 접근한다. 예 ) 123456789// 피연산자가 모두 문자열 타입이여야 하는 문맥'10' + 2 // '102'// 피연산자가 모두 숫자 타입이여야 하는 문맥5 * '10' // 50// 피연산자 또는 표현식이 불리언 타입이여야 하는 문맥!0 // trueif (1) &#123; &#125; (암묵적) 문자열 타입으로 변환121 + '2' // '12'console.log(`1 + 1 = $&#123;1 + 1&#125;`); // \"1 + 1 = 2\" 문자열 인터폴레이션 $&#123; 표현식 &#125; (암묵적) 숫자 타입으로 변환- * 는 대부분의 문자열을 숫자 타입으로 암묵적 타입변환시킨다. 1231 - '1' // 01 * '10' // 101 / 'one' // NaN + 추가&gt; &lt; = 등의 비교 연산자 또한 숫자타입으로 변환시킬 때도 있다. (다만, 이러한 경우가 최대한 안나오게 해야한다. 안좋은 코드) 1'1' &gt; 0 // true ++추가 단항 연산자를 이용하여 문자열 변환123456789101112131415161718192021222324// 문자열 타입+'' // 0+'0' // 0+'1' // 1+'string' // NaN// 불리언 타입+true // 1+false // 0// null 타입+null // 0// undefined 타입+undefined // NaN// 심볼 타입+Symbol() // TypeError: Cannot convert a Symbol value to a number// 객체 타입+&#123;&#125; // NaN+[] // 0+[10, 20] // NaN+(function()&#123;&#125;) // NaN (암묵적) 불리언 타입으로 변환불리언 값으로 평가되어야 할 문맥에서 false로 평가되는 Falsy 값이다. false undefined null 0, -0 NaN ’’ (빈문자열) (명시적) 문자열 타입으로 변환문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 아래와 같다. String 생성자 함수를 new 연산자 없이 호출하는 방법 ( 실무에서 잘 사용 안함 ) Object.prototype.toString 메소드를 사용하는 방법 ( 실무에서 잘 사용 안함 ) 문자열 연결 연산자를 이용하는 방법 = (암묵적) 경험자 입장에서 제일 가독성이 뛰어남. 1234567891011121314151617181920212223242526// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(Infinity)); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(String(true)); // \"true\"console.log(String(false)); // \"false\"// 2. Object.prototype.toString 메소드를 사용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log((1).toString()); // \"1\"console.log((NaN).toString()); // \"NaN\"console.log((Infinity).toString()); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log((true).toString()); // \"true\"console.log((false).toString()); // \"false\"// 3. 문자열 연결 연산자를 이용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(Infinity + ''); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(true + ''); // \"true\"console.log(false + ''); // \"false\"","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-070809","slug":"javascript-preview-070809","date":"2019-10-07T15:33:18.000Z","updated":"2019-10-07T15:34:13.488Z","comments":true,"path":"2019/10/08/javascript-preview-070809/","link":"","permalink":"http://yoursite.com/2019/10/08/javascript-preview-070809/","excerpt":"","text":"JacaScript 7강~9강 예습 7강 : 제어문 블록문 이란? 조건문 if문 switch문 반복문 for문 while문 do~while문 break문 label 문 continue문 8강 : 타입 변환과 단축 평가 타입변환이란? 명시적 타입 변환 암묵적 타입 변환 문자열 타입으로 변환 숫자 타입으로 변환 불리언 타입으로 변환 단축 평가 9강 : 객체 리터럴 객체란? 객체 타입 객체 리터럴에 의한 객체 생성 객체 리터럴 프로퍼티 프로퍼티 키, 메소드 프로퍼티 접근 프로퍼티 키 동적생성 프로퍼티 삭제 ES6에서 추가된 기능 객체 리터럴의 확장 기능 프로퍼티 키 동적 생성 메소드 축약표현 7강제어문 블록문 이란? 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 한다. 블록문은 JS에서 하나의 실행단위. 블록문의 끝에는 세미콜론( ; )을 붙이지 않는다. 제어문 혹은 함수선언문에 이용한다. 123456789101112131415161718// 블록문&#123; var foo = 10; console.log(foo);&#125;// 제어문var x = 0;while (x &lt; 10) &#123; x++;&#125;console.log(x); // 10// 함수 선언문function sum(a, b) &#123; return a + b;&#125;console.log(sum(1, 2)); // 3 조건문 주어진 조건식의 평가 결과에 따라 코드 블럭의 실행을 결정한다. if ... else 문 swith 문 1. if ~ else , else if12345if (조건식) &#123; // 조건식이 참이면 이 코드 블록이 실행된다.&#125; else &#123; // 조건식이 거짓이면 이 코드 블록이 실행된다.&#125; *else if 문과 else 문은 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. * if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다. 2. switch( )12345678910switch (표현식) &#123; case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;&#125; *switch문은 반드시 break; 동반 해야만 한다. * break;가 없다면 맞는 조건이어도 다음 case 표현식으로 넘어가게 된다. default에는 break; 생략이 가능하다. 반복문 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. for ( for-in, for-of ) , while , do~while 1. for문123for (변수 선언문 또는 할당문; 조건식; 증감식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 만약 , 모두 비워있다면 무한 루프가 된다. 123for(;;)&#123; 내용;&#125; 예제, 중첩 for문을 이용한 주사위 눈 합 12345for (var i = 1; i &lt;= 6; i++) &#123; for (var j = 1; j &lt;= 6; j++) &#123; if (i + j === 6) console.log(`[$&#123;i&#125;, $&#123;j&#125;]`); &#125;&#125; 2. while 문123while (조건식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; while문은 조건식이 true라면 무한루프가 된다. 12// 무한루프while (true) &#123; ... &#125; 무한 루프를 탈출 하기 위해서는 특정조건으로 인한 break; 를 추가하여야 한다. 예제, count가 3이면 코드 탈출 123456789var count = 0;// 무한루프while (true) &#123; console.log(count); count++; // count가 3이면 코드 블록을 탈출한다. if (count === 3) break;&#125; // 0 1 2 3. do…while 문123do&#123; 최소 1번은 실행되고 그 후부터는 조건에 맞을 경우 반복 실행된다.&#125; while (조건식); do...while문은 최소 1번은 실행된 뒤 조건을 판별하여 게속해서 반복할지 안할지 유무를 결정한다. break 문 가장 가까운 레이블 문, 반복문( for, for-in, for-of, while, do…while ) 또는 switch문의 코드 블록을 탈출한다. 이외에 문에서 사용시 SyntaxError를 유발한다. 레이블 문이란? 식별자가 붙은 문을 의미한다. 12// foo라는 레이블 식별자가 붙은 레이블 문foo: console.log('foo'); 레이블문은 중첩for문에서 외부for문까지 한번에 빠져나가고자 할 때 이용한다. 12345678910// outer라는 식별자가 붙은 레이블 for 문outer: for (var i = 0; i &lt; 3; i++) &#123; for (var j = 0; j &lt; 3; j++) &#123; // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다. if (i + j === 3) break outer; console.log('inner ' + j); &#125;&#125;console.log('Done!'); 예제 : 특정 문자열 찾기 123456789101112var string = 'Hello World';var search = 'l';var index;for(var i = 0; i &lt; String.length; i++) &#123; if(string[i] === search)&#123; index = i; break; &#125;&#125;console.log(index); 위와 똑같이 동작하는 메소드 12345var string = 'Hello World';var search = 'l';var index;console.log(string.indexOf(search)); // 2 continue 문 continue 문은 현재 진행되고 있는 반복문의 증감식을 중단하고 다음 증감식으로 이동한다. break문과 다르게 반복문을 탈출하지 않는다. 1234567891011121314151617181920var string = 'Hello World.';var search = 'l';var count = 0;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) &#123; // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다. if (string[i] !== search) &#123; continue; &#125; count++; // continue 문이 실행되면 이 문은 실행되지 않는다.&#125;console.log(count); // 3// 위 예제의 for 문은 아래와 동일하게 동작한다.for (var i = 0; i &lt; string.length; i++) &#123; // 'l'이면 카운트를 증가시킨다. if (string[i] === search) count++;&#125; 위와 똑같이 동작하는 메소드 123456var string = 'Hello World.';var search = 'l';var count = 0;const regexp = new RegExp(search, 'g');console.log(string.match(regexp).length); // 3 8강타입 변환과 단축 평가 타입 변환이란? 자바스크립트는 값에 타입이 있다. 값의 타입을 개발자의 의도에 의하여 다른 타입으로 변환이 가능하다. 이를 명시적 타입 변환 또는 타입캐스팅 이라 칭한다. 명시적 타입 변환12345var x = 10;// 명시적 타입 변환// 숫자를 문자열로 타입 캐스팅한다.var str = x.toString(); // str은 문자열 '10'을 지니고 있다. 또 반대로 JS엔진을 통하여 개발자의 의도와는 별개로 암묵적으로 타입이 자동 변환 될 수도 있다. 이를 암묵적 타입 변환 또는 타입 강제 변환 이라고 한다. 12345var x = 10;// 암묵적 타입 변환// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.var str = x + ''; 암묵적 타입 변환 과 명시적 타입 변환 둘다 원시값 자체를 변경할 수 없다, 원시값을 바꿀 수 있는 방법은 재할당 뿐이다. 암묵적 타입 변환 자바스크립트 엔진은 표현식을 평가할 때 코드의 문맥을 고려하여 암묵적 타입 변환을 실행한다. 문자열 타입으로 변환 피연산자 중 + 연산자 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 1234567891011121314151617181920212223242526272829// 숫자 타입0 + '' // \"0\"-0 + '' // \"0\"1 + '' // \"1\"-1 + '' // \"-1\"NaN + '' // \"NaN\"Infinity + '' // \"Infinity\"-Infinity + '' // \"-Infinity\"// 불리언 타입true + '' // \"true\"false + '' // \"false\"// null 타입null + '' // \"null\"// undefined 타입undefined + '' // \"undefined\"// 심볼 타입(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string// 객체 타입(&#123;&#125;) + '' // \"[object Object]\"Math + '' // \"[object Math]\"[] + '' // \"\"[10, 20] + '' // \"10,20\"(function()&#123;&#125;) + '' // \"function()&#123;&#125;\"Array + '' // \"function Array() &#123; [native code] &#125;\" 숫자 타입으로 변환 산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 피연산자 와 - * / 의 연산자 경우 하나 이상이 숫자 이므로 숫자 연사자로 동작한다. 1231 - '1' // 01 * '10' // 101 / 'one' // NaN 피연산자를 숫자 타입으로 변환할 수 없는 경우. 산술이 불가능하다. 단항 연산자의 +의 경우까지 숫자 타입으로 변환한다. 123456789101112131415161718192021222324// 문자열 타입+'' // 0+'0' // 0+'1' // 1+'string' // NaN// 불리언 타입+true // 1+false // 0// null 타입+null // 0// undefined 타입+undefined // NaN// 심볼 타입+Symbol() // TypeError: Cannot convert a Symbol value to a number// 객체 타입+&#123;&#125; // NaN+[] // 0+[10, 20] // NaN+(function()&#123;&#125;) // NaN 불리언 타입으로 변환 1234567if ('') console.log('1'); //falseif (true) console.log('2'); //trueif (0) console.log('3'); //falseif ('str') console.log('4'); //trueif (null) console.log('5'); //false// 2 4 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 인식할 값) 또는 Falsy 값(거짓으로 인식할 값)으로 구분한다. Truthy 값은 true로, Falsy 값은 false로 변환. false undefined null 0, -0 NaN ’ ’ (빈문자열) 위 예 들은 모두 false 로 평가되는 Falsy 값이다. 이외의 값들은 모두 Truthy, true로 평가된다. 아래 예제는 Truthy/Falsy 값을 판별하는 함수다. 함수 함수란 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. 123456789101112131415161718192021222324// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.function isFalsy(v) &#123; return !v;&#125;// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.function isTruthy(v) &#123; return !!v;&#125;// 모두 true를 반환한다.console.log(isFalsy(false));console.log(isFalsy(undefined));console.log(isFalsy(null));console.log(isFalsy(0));console.log(isFalsy(NaN));console.log(isFalsy(''));// 모두 true를 반환한다.console.log(isTruthy(true));// 빈 문자열이 아닌 문자열은 Truthy 값이다.console.log(isTruthy('0'));console.log(isTruthy(&#123;&#125;));console.log(isTruthy([])); 단축 평가 단축 평가 표현식 평가 결과 true || anything true false || anything anything true &amp;&amp; anything anything false &amp;&amp; anything false 즉, 결과를 되는 연산을 하였을 값을 출력한다 . 예를들어보자, 123456789// 논리합(||) 연산자'Cat' || 'Dog' // 'Cat' - 캣이 이미 true이므로 연산의 결과는 캣이다.false || 'Dog' // 'Dog' - 도그가 true라면 참이므로 연산의 결과 도그이다.'Cat' || false // 'Cat' - 캣이 이미 true이므로 연산의 결과는 캣이다.// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog' // Dog - 도그가 false라면 틀린값인데 결국 도그가 true이기 때문에 결과는 도그다.false &amp;&amp; 'Dog' // false - 도그가 true여도 이미 false가 존재하기 때문에 false'Cat' &amp;&amp; false // false - 캣이 ture여도 이미 false가 존재하기 때문에 false 단축 평가는 아래와 같은 경우 유용하게 사용된다. 1234var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null 함수를 호출할 때 인수를 전달하지 않을 경우 매개변수는 undefined를 갖게 된다. 12345function test(str)&#123; console.log(`현재 타입은 %&#123;typeof(str)&#125;`);&#125;test(); // 현재 타입은 undefined 입니다. 매개 변수를 전달하지 않았다. 함수 매개변수에 기본값을 설정할 때, 12345678910111213141516// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) &#123; str = str || ''; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') &#123; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2 9강객체 리터럴 객체란? 자바스크립트 객체 기반의 프로그래밍 언어이며 JS를 이루고 있는 거의 모든것이 객체다. 원시 타입을 제외한 나머지 값들(함수, 배열 , 정규표현식 등등)은 모두 객체이다. 객체 타입은 원시타입과 다르게 변경가능한 값이다. 객체타입​ 객체 타입은 다양한 타입의 값(원시 타입의 값 또는 다른 객체)들을 하나의 단위로 구성한 복잡한 자료 구조이다. 자바스크립트에서 사용할 수 있는 모드 값은 프로퍼티 값이 될 수 있다. 자바스크립트에서 함수는 값으로 취급이 가능하다. 프로퍼티 값으로 함수를 사용할 수 있다. (이를, 일반 함수랑 구분하기 위해서 메소드라 한다) 정리하면, 객체는 프로퍼티( 키 , 값 ) 와 메소드로 구성된 집합체. 프로퍼티: 객체의 상태를 나타내는 값(data) 메소드 : 프로퍼티를 참조하고 조작할 수 있는 동작(behavior) 객체와 함수 : 자바스크립트에서 함수로 객체를 생성하기 하며 함수 자체는 곧 객체이다. 객체 리터럴에 의한 객체 생성자바스크립트에 객체 생성 방법. 객체 리터럴 Object 생성자 함수 생성자 함수 (new 연산자) Object.create 메소드 클래스( ES6 ) 객체리터럴​ 객체를 선언하기 위한 가장 일반적인 방법이다.​ 객체 리터럴의 중괄호는 코드 블록을 의미하지 않음에 주의 12345678910111213var empty = &#123;&#125;; // 빈 객체console.log(typeof empty); // object// 할당이 이루어지는 시점에 객체 리터럴이 해석되고 그 결과 객체가 생성된다.var person = &#123; name: 'Lee', sayHello: function () &#123; console.log(`Hello! My name is $&#123;this.name&#125;.`); &#125;&#125;;console.log(typeof person); // objectconsole.log(person); // &#123;name: \"Lee\", sayHello: ƒ&#125; 프로퍼티 객체는 프로퍼티(Property)들 와 메소드의 집합이며 프로퍼티는 키(key)과 값(value)으로 구성된다. 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 프로퍼티 키 프로퍼티의 키는 식별자 네이밍 규칙을 준수할 경우와 준수하지 않을 경우로 나뉜다. 123456var person = &#123; first_name: 'Kim', // 유효한 이름 'last-name': 'Lee' // 유효하지 않은 이름&#125;;console.log(person); // &#123;first_name: \"Kim\", last-name: \"Lee\"&#125; 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표( ‘ )를 사용하여야 한다. 만약, 따옴표를 사용하지 않을 경우 SyntaxError를 일으킨다. 값을 반환하는 표현식을 이용해 프로퍼티 키를 동적으로 생성도 가능하다. 이 경우 사용할 표현식은 [ ]로 묶는다. 123456789var obj = &#123;&#125;;var key = 'hello';// ES5: 프로퍼티 키 동적 생성obj[key] = 'world';// ES6: 프로퍼티 키 동적 생성// var obj = &#123; [key]: 'world' &#125;;console.log(obj); // &#123;hello: \"world\"&#125; ++추가로 빈 문자열 이나 var, function와 같은 예약어를 프로퍼티 키를 사용해도 에러는 발생하지 않지만, 권장하지 않는다. 이미 존재하는 프로퍼티 키를 중복 선언시 나중 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 프로퍼티 키에 문자열이나 symbol값 이외의 값을 쓰면 암묵적으로 문자열이된다. 메소드​ 프로퍼티의 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드( Method )라 부른다. 즉, 메소드는 객체에 제한되어 있는 함수를 의미한다. 12345678910var circle = &#123; radius: 5, // ← 프로퍼티 // 원의 지름 getDiameter: function () &#123; // ← 메소드 return 2 * this.radius; // this는 circle를 가리킨다. &#125;&#125;;console.log(circle.getDiameter()); // 10 프로퍼티 접근 마침표 표기법 대괄호 표기법 프로퍼티 키가 식별자 네이밍 규칙을 따르고 있다면 마침표 표기법과 대괄호 표기법을 모두 사용이 가능하다. 123456789var person = &#123; name: 'Lee'&#125;;// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Lee// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Lee 주의 : 대괄호 표기법을 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 12345var person = &#123; name: 'Lee'&#125;;console.log(person[name]); // ReferenceError: name is not defined 존재 하지 않는 프로퍼티에 접근할 경우, undefined를 반환한다. 12345var person = &#123; name: 'Lee'&#125;;console.log(person.age); // undefined ,ReferenceError가 발생하지 않는다. 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름. 즉 유효하지 않음 이름이라면 반드시 대괄호 표기법을 이용한다. 이는 숫자로만 이루언 프로퍼티 키도 포함이다. 단, 숫자로 이루어진 프로퍼티키는 따옴표를 생략할 수 있다. 123456789101112131415var person = &#123; 'last-name': 'Lee', 1: 10&#125;;console.log(person.'last-name'); // SyntaxError: Unexpected stringconsole.log(person.last-name); // ReferenceError: name is not definedconsole.log(person[last-name]); // ReferenceError: last is not definedconsole.log(person['last-name']); // Lee// 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 따옴표를 생략 가능하다.console.log(person.1); // SyntaxError: missing ) after argument listconsole.log(person.'1'); // SyntaxError: Unexpected stringconsole.log(person[1]); // 10 : person[1] -&gt; person['1']console.log(person['1']); // 10 프로퍼티 키 동적생성123456789var person = &#123; name: 'Lee'&#125;;// person객체에 address 프로퍼티가 존재하지 않는다.// 따라서 person객체에 address 프로퍼티가 동적으로 생성되고 값이 할당된다.person.address = 'Seoul';console.log(person); // &#123;name: \"Lee\", address: \"Seoul\"&#125; 프로퍼티 삭제 delete 연산자 는 객체의 프로퍼티를 삭제한다. 존재하지 앟는 프로퍼티를 삭제하면 아무런 에러없이 무시된다. 12345678910111213141516var person = &#123; name: 'Lee'&#125;;// 프로퍼티 동적 추가person.address = 'Seoul';// person 객체에 address 프로퍼티가 존재한다.// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 있다.delete person.address;// person 객체에 age 프로퍼티가 존재하지 않는다.// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.delete person.age;console.log(person); // &#123;name: \"Lee\"&#125; ES6에서 추가된 기능객체 리터럴의 확장 기능 (ES5 VS ES6)ES5에서는 변수에 선언된 값을 프로퍼티 키의 값에 재할당 해주는 방면으로 이용하였다. 123456789// ES5var x = 1, y = 2;var obj = &#123; x: x, y: y&#125;;console.log(obj); // &#123;x: 1, y: 2&#125; ES6에서는 프로퍼티의 키 명과 변수의 명이 같을 경우 키를 생략하고 대입이 가능하다. 이때, 프로퍼티 키는 변수이름으로도 자동 생성된다. 1234567// ES6let x = 1, y = 2;// 프로퍼티 축약 표현const obj = &#123; x, y &#125;;console.log(obj); // &#123;x: 1, y: 2&#125; 프로퍼티 키 동적 생성 (ES5 VS ES6)​ 문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 단, 이때 표현식은 대괄호를 이용해야하며, 이를 계산된 프로퍼티 이름이라 칭한다. 12345678910// ES5var prefix = 'prop';var i = 0;var obj = &#123;&#125;; obj[prefix + '-' + ++i] = i; obj[prefix + '-' + ++i] = i; obj[prefix + '-' + ++i] = i;console.log(obj) // &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125; 1234567891011// ES6var prefix = 'prop';var i = 0;var obj = &#123; [`$&#123;prefix&#125;-$&#123;++i&#125;`] : i, [`$&#123;prefix&#125;-$&#123;++i&#125;`] : i, [`$&#123;prefix&#125;-$&#123;++i&#125;`] : i&#125;;console.log(obj) // &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125; 메소드 축약 표현 (ES5 VS ES6)123456789// ES5var obj = &#123; name: 'Lee', sayHo: function()&#123; console.log('My Name is ' + this.name); &#125;&#125;obj.sayHo(); //My Name is Lee 12345678910// ES6var obj = &#123; name: 'Lee', // ES6의 메소드 축약표현 sayHo()&#123; console.log('My Name is ' + this.name); &#125;&#125;obj.sayHo(); //My Name is Lee","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-04","slug":"javascript-study-04","date":"2019-10-07T09:05:57.000Z","updated":"2019-10-07T09:06:52.472Z","comments":true,"path":"2019/10/07/javascript-study-04/","link":"","permalink":"http://yoursite.com/2019/10/07/javascript-study-04/","excerpt":"","text":"JavaScript Study 04 용어 변수 명명 데이터 타입의 정의 데이터 타입의 종류 숫자 타입 문자열 타입 불리언 타입 undefined 타입 null 타입 동적 타이밍 연산자 이항 산술 연산자 단항 산술 연산자 문자열 연결 연산자 할당 연산자 비교 연산자 삼항 조건 연산자 논리 조건 연산자 그룹 연산자 typeof 연산자 지수 연산자 용어 - ( 러버덕 ) 네이밍 케이스 데이터 타입 동적 타이핑 변수명명 변수의 이름을 지정할 때에는 항상 고민하고 신중해야만한다. *식별자 이름 : 숫자 , 문자 , 특수기호(_ , $) * 규칙1 : 맨 앞자리 숫자 불가능 규칙2 : 예약어는 쓸 수 없다.(var , let, const , function …) 규칙3 : 대소문자를 구별한다. 규칙4 : 단어와 단어의 사이는 특정기법을 이용한다.(카멜케이스같은) 규칙5 : 변수 이름이 전체다 대문자라면 상수다. 주석은 최대한 적게 쓰도록, 변수명을 제대로 적어야만 한다. 특정기법 카멜케이스 : 변수 / 함수 1var firstName; 스네이크케이스 : javascript 에서 잘 사용하지 않는다. 1var first_name; 파스칼 케이스 : 생성자 함수, 클래스 이름 1var FirstName; 헝가리언 케이스 12var strFirstName; // type + identifiervar $elem = $('.myClass') // jQuery 데이터 타입의 정의 값의 종류 데이터 타입을 알아야 메모리 공간을 확보가 가능하다. (타입마다 확보할 메모리공간이 다르다.) 데이터를 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기 를 알 수 있다. 값을 어떻게 해석하는지 알 수 있다. 값을 만들어내는 방법 값 : 리터럴 표기법은 값을 만들어내는 가장 기본적인 방법이다. 표현식 : 평가되어 하나의 값을 만들어낸다. 값 더 이상 평가할 수 없는 최소 표현식(토큰) 자신을 평가시 자신이 나온다면 그것은 값 이다. ( ex : 30을 평가하면 30이다. ) 리터럴 표기법에 의하여 만들어진다. 표현식에 의하여 만들어진다. 평가 표현식 등의 결과를 새로운 값으로 반환한다. 표현식 하나의 값으로 평가될 수 있는 문. 평가되어 하나의 값을 표현하는 방법. (리터럴, 식별자(변수,함수), 연산자, 함수 호출등의 조합) 하나 이상의 리터럴, 하나 이상의 표현식 , 연상자등으로 구성된 문. 식별자도 결국 표현식이다. 123var a = 10;var b = a; // a라는 식별자(표현식)가 평가되어 10이라는 값을 반환하였고 b는 10이라는 값을 가리킨다. 리터럴 변수나 상수를 나타내는 값 자체; 소스 코드 안에서 직접 만들어낸 고정된 값. 리터럴 자체는 표현식이지만, 연산이 들어간 표현식은 리터럴이 될 수 없다.( 10 + 20 ) Symbol 심볼은 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용한다. (추후 다시 공부) 데이터 타입의 종류원시 타입 ( primitive ) - 6가지의 데이터 타입 : 숫자 ,문자열 ,boolean , null, undefined, Symbol ​ boolean : 평가 결과가 true 또는 false를 반환하는 데이터타입 ​ null : 변수에 값이 없다는것을 의도적으로 나타냄. (의도적 부재) ​ undefined : 변수를 선언하고 할당하지 않을 경우. 암묵적으로 javascript엔진에 의하여 초기화되는 값. 객체 타입 : 객체, 함수, 배열 숫자타입 C나 Java의 경우, 정수와 실수를 구분하여 int, long, float, double 등과 같은 다양한 숫자 타입이 존재한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다. 숫자 타입은 추가적으로 3가지 특별한 값들도 표현할 수 있다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not-a-number) 1234// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN - NaN대소문자 주의 ( nan,NAN 등등 다 안됨. ) 문자열 타입 텍스트 데이터를 나타내는데 사용한다. 작은 따옴표(‘’), 큰 따옴표(“”) 또는 백틱(``) 안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다. ++ 추가 ​ : 자바스크립트에서는 개행, 백스페이스 등을 나타낼수있는 이스케이스프 시퀀스를 지원한다. 이스케이프 시퀀스 의미 \\0 Null \\b 백스페이스 \\f 새로운 페이지 \\n 개행(LF, Line Feed) \\r 캐리지 리턴(CR, Carriage Return) \\t 탭(수평) \\v 탭(수직) \\’ 작은 따옴표 \\” 큰 따옴표 \\ 백슬래시 예를 들어, 줄바꿈과 들여쓰기가 적용된 HTML 문자열은 아래와 같이 이스케이프 시퀀스를 사용하여 작성한다. 근데 개행등의 불편함을 막기 위해스 ES6부터는 백틱( ` ) 이 사용이 가능하다. 1234567891011// ES5var template = '&lt;ul class=\"nav-items\"&gt;\\n';template += '\\t&lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt;\\n';template += '\\t&lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;\\n';template += '&lt;/ul&gt;';// ES6 - 백틱const template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`; 문자열 인터폴레이션​ 리터럴 문자열 연산을 더 쉽게 하기 위한 ES6의 새로운 기능. ​ ${ } 는 백틱 안에서만 사용이 가능하다. 1234567var first = 'Ung-mo';var last = 'Lee';// ES5: 문자열 연결console.log('My name is ' + first + ' ' + last + '.');// ES6: String Interpolation 문자열 인터폴레이션console.log(`My name is $&#123;first&#125; $&#123;last&#125;.`); 불리언 타입 불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다. undefined 타입 선언 이후 명시적으로 값을 할당하지 않은 변수는 자바스크립트 엔진의 암묵적 초기화에 의해 undefined 값을 가진다. 선언은 되었지만 아직 값을 할당하지 않은 변수에 접근하면 undefined가 반환된다. 선언 과 정의 자바스크립트의 선언, 식별자가 생성되었지만 값이 아직 할당되지 않은 상태 자바스크립트의 정의, 식별자가 생성되었고 값까지 할당되어 있는 상태를 의미한다. 123456// 변수 선언. 내부적으로 undefined로 정의된다.var foo;// 변수 선언과 정의var bar = 1;// 함수 정의. 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.function baz &#123;&#125; null 타입 null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 Intentional absence)할 때 사용한다. ++추가 : 자바스크립트에서는 null값을 사용하는 것보다, 변수의 생명주기에 대해서 이해하고 사용하는 것이 더 바람직하고 유용하다. Symbol 타입 / 객체 타입 추후 다시 공부 동적 타이핑정적 타입 언어 : 변수 자체에 데이터 타입을 사전에 선언한다. (int num, float num, char c 등등) 동적 타입 언어 : 변수에 데이터 타입을 알리지않는다. 대신 var / let / const등과 같이 키워드로 변수를 선언함만을 알린다.대신, 동적타입 언어는 변수가 아닌 값에 의해 타입이 정해진다. 정적 타입 언어 동적 타입 언어 장점 엄격한 규칙으로 인해 버그 발생률을 줄인다. 유연하다. 사용하기 편리하다. 단점 규칙이 엄격하다. 다루기 불편하다. 코드가 길어질수록 점점 변수에 해당되는 값을 알기가 힘들어진다. 자바스크립트는 동적 타입 언어이다. 동적 타입 언어는 정적처럼 변수에 타입을 지정하지 않기 때문에 버그 발생률을 높이는 치명적인 단점을 가지고 있기에 이를 해결하기 위해 TypeScript가 나타났다. 문 ; 으로 끝나면 모두 문 이다. 하나 이상의 표현식과 키워드의 조합. 변수에 할당할 수 있는 문 : 표현식인 문 변수에 할달할 수 없는 문 : 표현식이 아닌 문 표현식의 역할은 값을 생성하는 것 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것 세미콜론 자동 삽입 기능 ( ASI : automati semicolon insertion ) 자바스크립트 엔진에는 소스 코드를 해석할 때, 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 있다. 하지만, 왠만해서는 세미콜론을 사용하도록 한다. 연산자이항 산술 연산자조건 : 2개의 피연산자 필요. 이항 산술 연산자 의미 부수 효과 + 덧셈 ✕ - 뺄셈 ✕ * 곱셈 ✕ / 나눗셈 ✕ % 나머지 ✕ 단항 산술 연산자조건 : 1개의 연산자 필요. 단항 산술 연산자 의미 부수 효과 ++ 증가 ○ – 감소 ○ + 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. ✕ - 양수를 음수로 음수를 양수로 반전한 값을 반환한다. ✕ 문자열 연결 연산자12345678910111213141516171819// 문자열 연결 연산자'1' + 2; // -&gt; '12'1 + '2'; // -&gt; '12'// 산술 연산자1 + 2; // -&gt; 3// true는 1로 타입 변환된다.1 + true; // -&gt; 2// false는 0으로 타입 변환된다.1 + false; // -&gt; 1// null는 0으로 타입 변환된다.1 + null; // -&gt; 1// undefined는 숫자로 타입 변환되지 않는다.+undefined; // -&gt; NaN1 + undefined; // -&gt; NaN 할당 연산자우항의 피연산자의 결과가 좌항에있는 변수에 할당된다. 할당 연산자 사례 동일 표현 부수 효과 = x = 5 x = 5 ○ += x += 5 x = x + 5 ○ -= x -= 5 x = x - 5 ○ *= x *= 5 x = x * 5 ○ /= x /= 5 x = x / 5 ○ %= x %= 5 x = x % 5 ○ 비교 연산자비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다. 조건 : 피연산자 2개 비교 연산자 의미 사례 설명 부수 효과 == 동등 비교 x == y x와 y의 값이 같음 ✕ === 일치 비교 x === y x와 y의 값과 타입이 같음 ✕ != 부동등 비교 x != y x와 y의 값이 다름 ✕ !== 불일치 비교 x !== y x와 y의 값과 타입이 다름 ✕ 왠만하면 === 을 사용할것. 1234567// 일치 비교5 === 5; // -&gt; true// 암묵적 타입 변환을 하지 않고 값을 비교한다.// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.5 === '5'; // -&gt; false5 == '5' // -&gt; true 예외) NaN은 자신과 비교하면 false가 나온다. 12// NaN은 자신과 일치하지 않는 유일한 값이다.NaN === NaN; // -&gt; false 삼항 조건 연산자 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값 if문을 한줄로 표현이 가능할 때 자주사용한다. 삼항 조건 연산자 if 문 var x = 2;var result = x % 2 ? ‘홀수’ : ‘짝수’;console.log(result); // 짝수 var x = 2;if(x % 2){ var result = “홀수”}else{ var result = “짝수”} x( 2 ) 를 나눈 값의 나머지가 0인데 어째서 결과가 짝수인가? x % 2 = 0이다. 조건에서 0은 false를 의미한다. 논리 연산자 논리 연산자 의미 부수 효과 || 논리합(OR) ✕ &amp;&amp; 논리곱(AND) ✕ ! 부정(NOT) ✕ 123// 암묵적 타입 변환!0; // -&gt; true!'Hello'; // -&gt; false 1'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' - 단축평가 단축평가란? ‘Cat’은 true이고 그 뒤에 나와 있는 결과 값을 통해서 다이렉트로 값을 반환한다. 그룹 연산자​ 우선 순위를 강제로 조절하고자 할 때 사용한다. 123410 * 2 + 3; // -&gt; 23// 그룹 연산자를 사용하여 우선 순위 조절10 * (2 + 3); // -&gt; 50 +보다 *가 높다. typeof 연산자123456789101112typeof '' // -&gt; \"string\"typeof 1 // -&gt; \"number\"typeof NaN // -&gt; \"number\"typeof true // -&gt; \"boolean\"typeof undefined // -&gt; \"undefined\"typeof Symbol() // -&gt; \"symbol\"typeof null // -&gt; \"object\"typeof [] // -&gt; \"object\"typeof &#123;&#125; // -&gt; \"object\"typeof new Date() // -&gt; \"object\"typeof /test/gi // -&gt; \"object\"typeof function () &#123;&#125; // -&gt; \"function\" null 버그 : null의 type을 확인하고 싶다면 ===을 사용할 것. undefined: 선언하지 변수에 대하여 typeof 를 찍어보면 undefined를 반환한다. 지수 연산자 지수연산자 ( ES7 ) Math.pow 함수( ES6 이하 ) 5 ** 2; // -&gt; 255 ** 2.5; // -&gt; 55.901699437494745 ** 0; // -&gt; 15 ** -2; // -&gt; 0.04 Math.pow(5, 2); // -&gt; 25Math.pow(5, 2.5); // -&gt; 55.90169943749474Math.pow(5, 0); // -&gt; 1Math.pow(5, -2); // -&gt; 0.04 음수를 지수화 할 때는 반드시 ( ) 를 쳐야만 한다. 123-5 ** 2;// -&gt; SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence(-5) ** 2; // -&gt; 25 123456// 지수 연산자는 할당 연산자와 같이 사용이 가능하다.var num = 5;num **= 2; // -&gt; 25// 지수 연산자는 이항 연산자보다 우선순위가 높다.2 * 5 ** 2; // -&gt; 50","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm07","slug":"daily-algorithm07","date":"2019-10-07T03:56:27.000Z","updated":"2019-10-07T15:32:00.062Z","comments":true,"path":"2019/10/07/daily-algorithm07/","link":"","permalink":"http://yoursite.com/2019/10/07/daily-algorithm07/","excerpt":"","text":"문제 출저 : 프로그래머스 모의고사문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명입출력 예 #1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041function solution(answers) &#123; let answer = []; let student = &#123; s1: [1, 2, 3, 4, 5], s2: [2, 1, 2, 3, 2, 4, 2, 5], s3: [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] &#125;; let answerNum = [0, 0, 0]; let maxNum = 0; let arrayNum = 0; let i = 0; let j = 0; let keysArr; for (arrayNum = 0; arrayNum &lt; 3; arrayNum++) &#123; keysArr = Object.keys(student)[arrayNum]; for (i = 0; i &lt; answers.length; i++) &#123; if (j === student[keysArr].length) &#123; j = 0; &#125; if (answers[i] === student[keysArr][j]) &#123; answerNum[arrayNum]++; &#125; j++; &#125; j = 0; &#125; maxNum = Math.max.apply(null, answerNum); for (i = 0; i &lt; 3; i++) &#123; if (answerNum[i] === maxNum) &#123; answer.push(i + 1); &#125; &#125; answer.sort(); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm06","slug":"daily-algorithm06","date":"2019-10-05T08:35:27.000Z","updated":"2019-10-05T08:42:40.779Z","comments":true,"path":"2019/10/05/daily-algorithm06/","link":"","permalink":"http://yoursite.com/2019/10/05/daily-algorithm06/","excerpt":"","text":"문제 출저 : 프로그래머스 해당 문제 효율성(시간)이 너무 떨어져 재도전하였음. 완주하지 못한 선수문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 입출력 예 설명예제 #1leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 12345678910111213141516171819202122function solution(participant, completion) &#123; var answer = ''; participant.sort(); completion.sort(); /* //for in 구문을 자주 사용하지 말라는 MDN 통계가 있었음. for(var i in participant)&#123; if(participant[i] != completion[i])&#123; return answer = participant[i]; &#125; &#125; */ for(var i=0;i&lt;participant.length;i++)&#123; if(participant[i] != completion[i])&#123; return answer = participant[i]; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"VSCode-Settings","slug":"VSCode-Settings","date":"2019-10-05T07:25:56.000Z","updated":"2019-10-05T07:26:32.275Z","comments":true,"path":"2019/10/05/VSCode-Settings/","link":"","permalink":"http://yoursite.com/2019/10/05/VSCode-Settings/","excerpt":"","text":"VS CODE에서 자바스크립트 즉석 실행하기 ( Extention 설치 ) Code.Runner : 브라우저 나 노드에서 굳이 사용하지 않고 js파일을 실행할수있다. ctrl + option + n (단, 코드러너는 노드환경에서 실행되기 때문에 DOMAPI등은 못읽는다.) Quokka.js 시작 : cmd + shift + p - quokka.js : start on current file Quokka.js 종료 : stop all (current) VS CODE , 전역 Setting 하기 ( settings.json 파일 수정 )123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"editor.tabSize\": 2, // Fira code \"editor.fontFamily\": \"'Fira Code'\", \"editor.fontLigatures\": true, // \"editor.fontWeight\": \"normal\", // \"editor.fontWeight\": \"bold\", // \"editor.formatOnPaste\": true, \"editor.scrollBeyondLastLine\": false, // Theme \"workbench.colorTheme\": \"Atom One Light\", \"workbench.iconTheme\": \"material-icon-theme\", // LiveServer \"liveServer.settings.port\": 0, \"liveServer.settings.donotShowInfoMsg\": true, \"liveServer.settings.donotVerifyTags\": true, \"emmet.variables\": &#123; \"lang\": \"ko\" &#125;, \"files.exclude\": &#123; \"**/.git\": false &#125;, \"files.trimTrailingWhitespace\": true, \"window.zoomLevel\": 1, \"material-icon-theme.showUpdateMessage\": false, // ESLINT \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\" ], \"breadcrumbs.enabled\": true, // DOM 기반 terminal \"terminal.integrated.rendererType\": \"dom\", \"workbench.fontAliasing\": \"antialiased\", \"editor.multiCursorModifier\": \"alt\", // Type Safe JavaScript with JSDoc // \"javascript.implicitProjectConfig.checkJs\": true, \"editor.minimap.enabled\": false, \"editor.suggestSelection\": \"first\", \"vsintellicode.modify.editor.suggestSelection\": \"automaticallyOverrodeDefaultValue\", \"C_Cpp.updateChannel\": \"Insiders\", \"vsicons.projectDetection.disableDetect\": true, \"vsicons.dontShowNewVersionMessage\": true&#125; Fira Code 추가하기 구글 폰트 접속 Fira Code 검색 다운로드 압축해제 Fira Code 폴더 -&gt; static -&gt; 모든 .ttf 서체 더블클릭해서 추가(Mac 기준)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"http://yoursite.com/categories/Develop/Tips/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm05","slug":"daily-algorithm05","date":"2019-10-05T07:03:00.000Z","updated":"2019-10-05T07:04:05.833Z","comments":true,"path":"2019/10/05/daily-algorithm05/","link":"","permalink":"http://yoursite.com/2019/10/05/daily-algorithm05/","excerpt":"","text":"문제 출저 : 프로그래머스 *Dayil 01에서 풀었으나, 테스트 케이스 대부분 실패해서 다시 풀음 * 체육복문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function solution(n, lost, reserve) &#123; var answer = 0; var array = []; for(var i=0;i&lt;n;i++)&#123; array[i] = 1; &#125; for(var i=0;i&lt;reserve.length;i++)&#123; array[reserve[i]-1]++; &#125; for(var i=0;i&lt;lost.length;i++)&#123; array[lost[i]-1]--; &#125; for(var i=0;i&lt;n;i++)&#123; if(array[i] == 0)&#123; if(array[i-1] == 2)&#123; array[i-1] = 1; array[i] = 1; continue; &#125; if(array[i+1] == 2)&#123; array[i+1] = 1; array[i] = 1; continue; &#125; &#125; &#125; for(var i=0;i&lt;array.length;i++)&#123; if(array[i] == 2)&#123; array[i] = 1; &#125; answer = answer + array[i]; &#125; return answer; // test 12 Error!// var answer = n - lost.length; // for(var i=0; i&lt;lost.length; i++)&#123;// if(reserve.includes(lost[i]))&#123;// reserve.splice(reserve.indexOf(lost[i]),1)// answer++;// continue;// &#125; // else if(reserve.includes(lost[i]-1))&#123;// reserve.splice(reserve.indexOf(lost[i]-1),1);// answer++;// continue;// &#125; // else if(reserve.includes(lost[i]+1))&#123;// reserve.splice(reserve.indexOf(lost[i]+1),1)// answer++;// continue;// &#125;// &#125;// return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-03","slug":"javascript-study-03","date":"2019-10-04T13:49:35.000Z","updated":"2019-10-04T13:50:30.257Z","comments":true,"path":"2019/10/04/javascript-study-03/","link":"","permalink":"http://yoursite.com/2019/10/04/javascript-study-03/","excerpt":"","text":"JavaScript Study 03 용어 변수 식별자란? 평가란? 할당 참조 변수 선언 호이스팅 변수와 메모리의 관계 용어 - ( 러버덕 ) 키워드 식별자 변수 메모리와 메모리 주소 할당 호이스팅 변수 값을 저장하는 메커니즘. 메모리에 접근하기 위해 메모리의 주소에 이름을 부여하는 것. 메모리 공간 그 자체. 메모리 공간에 부여한 이름. 메모리 : 기억하는 영역메모리 셀 : 메모리를 이루는 공간. 1byte (8bit) 크기로 이루어져있음. 각 셀마다 주소를 가지고 있다.자바스크립트는 메모리의 주소를 알려주지않는다. 이유 : 각 메모리의 주소가 어디서 쓰고있는지 모르기에 변경을 했다거나 지웠다거나 하는 일이 생길 경우 큰 에러를 발생시킬수 있기 떄문이다. 따라서 각 메모리의 주소를 기억하게 하는 매커니즘(변수)을 사용한다. 변수의 이름 : 메모리 공간의 주소 위치를 별칭으로 참조한 것. 변수는 하나의 값만을 저장할 수 있다. (예외, 배열 / 객체) 변수의 명명은 1번 명명하면 해당 주소의 이름은 바꿀 수 없기 때문에, 변수의 이름을 지을때는 항상 고민하고 고민해야한다. 값이란? : 컴퓨터가 인식할 수 있는 데이터의 종류. 메모리에 들어가는 대상. 자바스크립트 엔진은 변수를 찾아갈 수 있다. 변수를 이용할 수 있다. 변수가 여러 값을 저장하기 위한 방법 자료구조 이용 객체 배열 식별자란? 메모리 주소를 가리키는 고유한 변수 이름. 메모리에 들어간 값을 구별해낼수 있는 고유한 이름을 식별자라 칭한다. ( 변수한정이 아니다. 함수도, 클래스도 식별자가 될 수 있다. ) 평가란? 값을 연산하는 과정 var는 자바스크립트엔진에게 내리는 키워드이며,var 뒤에 변수이름을 적어야한다. CPU : 계산(연산)하는 영역. 메모리는 한정된 영역이기 떄문에 자바스크린트 엔진에 내장된 Garbage Collector가 해당 메모리 주소가 사용이 되는지 안되는지를 게속 감시한다. 만약 해당 메모리 주소가 사용되지 않고 있다면 주소를 비워준다. 할당 변수에 값을 저장하는 행위 (=대입 , =저장) 참조 변수에 저장된 값을 읽어드리는 행위 변수선언 값을 할당하기 위한 메모리 공간을 확보하여 값을 저장하기 위한 준비를 하는 것. 변수를 선언하기 위해서는 var / let / const 키워드를 이용한다. 선언문 : 식별자를 만드는 것. 변수를 사용할 때는 반드시 선언을 하고 할당을 해야만 한다. 변수 이름의 등록처 : 실행컨텍스트 var키워드 변수선언시 최초로 undefined가 할당된다. 자바스크립트 엔진은 변수 선언을 아래의 2단계를 거쳐 수행한다. 선언 단계(Declaration phase) : 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. undefined는 원시타입이며, 원시타입은 메모리에 등록된 순간 변경이 불가능하다. ​ 만약, 변수에 재할당을 해서 변경했다면 그것은 걸려있던 메모리 주소를 옮긴 것이지 undefined를 지운것이 아니다. 호이스팅 자바스크립트 코드는 인터프리터가 한줄한줄 실행하기 앞서, 먼저 선언문들만 골라내서 먼저 실행한다. 123console.log(score); // undefinedvar score; // 변수 선언(문) 123456789console.log(score); // undefinedscore = 80; // 값의 할당var score; // 변수 선언console.log(score); // 80// var score은 호이스팅 되어 처음에 undefined가 할당이 되었고// score는 다시 80값으로 재할당되었다. 그 뒤에 나오는 var score; 구문은 이미 호이스팅하여 읽었으므로 다시 읽지 않고 넘어간다. 값의 교환 12345678var x = 1;var y = 2;var temp = x;x = y;y = temp;console.log(x, y); // 2 1 변수와 메모리의 관계 var result 로 특정 메모리 공간에 변수 선언 및 초기화를 한다. ( 메모리에는 undefined가 생성됨. ) result 변수에 100이라는 숫자 타입의 값을 재할당한다. ( 따라서 undefined라고 적힌 메모리에 걸려있는 링크를 끊고 새 메모리에 100값과 함께 링크를 건다.) ( undefined는 안쓰기때문에 가비지컬렉터에 의해 관리된다. ) result 변수에 200이라는 숫자 타입의 값을 재할당한다 ( 따라서 100 이라고 적힌 메모리에 걸려있는 링크를 끊고 새 메모리에 200값과 함께 링크를 건다. ) ( 100이 적힌 메모리 공간은 안쓰기때문에 가비지컬렉터에 의해 관리된다. ) VS CODE에서 자바스크립트 즉석 실행하기 Code.Runner : 브라우저 나 노드에서 굳이 사용하지 않고 js파일을 실행할수있다. ctrl + option + n (단, 코드러너는 노드환경에서 실행되기 때문에 DOMAPI등은 못읽는다.) quokka.js 시작 : cmd + shift + p - quokka.js : start on current file quokka.js 종료 : stop all (current)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"browser_operation","slug":"browser-operation","date":"2019-10-04T04:31:53.000Z","updated":"2019-10-04T04:34:03.235Z","comments":true,"path":"2019/10/04/browser-operation/","link":"","permalink":"http://yoursite.com/2019/10/04/browser-operation/","excerpt":"","text":"웹 브라우저의 동작 원리 클라이언트는 네이버에 접속을 시도한다. 네이버에 접속하기 위해서 인터넷 브라우저 주소창에 www.naver.com 을 입력한다. www.naver.com에 대한 IP 주소를 알기 위해서 DNS서버에 먼저 접속한 후DNS서버에게 www.naver.com에 해당되는 IP주소를 요청한다. DNS서버는 www.naver.com에 해당되는 IP주소를 응답한다. IP주소를 알게 된 브라우저는 다시 해당 IP주소를 통해서 네이버 서버에 접근하게 된다. 클라이언트는 서버에게 해당 페이지에 대한 접속과 .html 파일을 요청한다. 서버는 네이버 메인 페이지에 대한 화면 요소 정보가 담긴 index.html파일을 응답한다. 브라우저의 렌더링 엔진의 html파서는 index.html파일을 로드하고 파싱을 시작한다. 파싱중 &lt;link&gt; 를 만나게 된다. &lt;link&gt;에는 .css파일이 적혀있었다. html파서는 파싱을 중지한후 클라이언트는 다시 서버에게 .css파일을 요청한다. 서버는 .css파일을 응답한다. 클라이언트의 렌더링 엔진의 html파서는 제어권을 css파서에게 넘겨준다. css파서는 .css파일을 로드하고 파싱을 시작한다. 파싱이 완료되고 CSSOM트리가 완성된다. css파서는 제어권을 다시 html파서에게 넘겨준다. 중지되었던 html 파싱을 재 시작한다. 파싱하던중 &lt;script&gt; 를 만나게 된다. &lt;script&gt;에는 .js파일이 적혀있었다. html파서는 파싱을 중지한 후 클라이언트는 다시 서버에게 .js 파일을 요청한다. 서버는 .js파일을 응답한다. html파서는 .js파일을 읽을 수 없기 때문에 제어권을 브라우저에 탑재된 자바스크립트 엔진에게 넘겨준다. 제어권을 넘겨받은 자바스크립트 엔진은 DOM api를 이용하여 .js파일을 로드한다. 로드된 .js파일을 토크나이즈 하여 소스코드를 어휘분석하여 의미를 갖는 최소단위인 토큰으로 분리한다. 분리된 토큰을 구문분석하여 문법의 의미와 구조를 반영한 트리인 AST를 생성한다. AST는 자바스크립트 엔진의 인터프리터가 읽을 수 없기 때문에 인터프리터가 실행할 수 있는 중간코드인 바이트코드로 변환되고 실행된다. 실행된 후 제어권을 다시 렌더링엔진의 html파서에게 전달한다. 제어권을 돌려받은 html파서는 중지되었던 파싱을 재 실행한다. 파싱이 완료되어 DOM트리가 형성된다. 전에 만들어진 CSSOM트리와 DOM트리를 합쳐 RENDER트리로 만든다. RENDER트리를 기반으로 클라이언트의 화면에 표출한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"http://yoursite.com/categories/Develop/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm04","slug":"daily-algorithm04","date":"2019-10-03T13:38:45.000Z","updated":"2019-10-03T13:39:12.429Z","comments":true,"path":"2019/10/03/daily-algorithm04/","link":"","permalink":"http://yoursite.com/2019/10/03/daily-algorithm04/","excerpt":"","text":"문제 출저 : 프로그래머스 완주하지 못한 선수문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 입출력 예 설명예제 #1leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 1234567891011121314151617181920212223function solution(participant, completion) &#123; var answer = ''; var completion_array = []; completion_array = completion; var num = 0; for(var i=0;i&lt;participant.length;i++)&#123; for(var j=0;j&lt;completion_array.length;j++)&#123; if(participant[i] == completion_array[j])&#123; completion_array[j] = null; num = 0; break; &#125; num = 1; &#125; if(num == 1)&#123; answer = participant[i]; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-0506","slug":"javascript-preview-0506","date":"2019-10-03T06:46:38.000Z","updated":"2019-10-03T12:32:27.954Z","comments":true,"path":"2019/10/03/javascript-preview-0506/","link":"","permalink":"http://yoursite.com/2019/10/03/javascript-preview-0506/","excerpt":"","text":"JacaScript 5강~6강 예습 5강 : 데이터 타입 데이터 타입이란? 메모리 공간 확보 데이터 타입이 필요한 이유 값 값의 생성 데이터 타입의 분류(종류) 동적 타이밍 6강 : 연산자 표현식 과 연산자 문 문 vs 표현식 표현식인 문 vs 표현식이 아닌 문 완료값 연산자 산술연산자 문자열 연결 연산자 할당연산자 비교연산자 대소 관계 연산자 삼항 조건 연산자 논리 연산자 쉼표 연산자 typeof 연산자 지수 연산자 5강데이터타입 데이터타입 이란? 값의 종류를 의미하며, 자바스크립트의 모든 값은 데이터 타입을 지닌다. 메모리 공간 확보​ 자바스크립트 엔진은 데이터타입, 즉 값의 종류에 따라 적절한 크기의 메모리 공간을 지닌다. 예를들면 다음과 같다. ( 데이터타입에 따라 확보되는 메모리공간의 크기는 브라우저 제조사마다 다를 수 있다. ) 12var score = 100;// 위와 같이 숫자를 입력할 경우 자바스크립트 엔진은 데이터타입을 숫자로 인식하고 메모리 공간을 8byte 내주게된다. 데이터 타입이 필요한 이유 값을 저장할 떄 필요한 메모리 공간의 크기를 결정하기 위함 값을 참조할 떄 한번에 읽어들일 메모리 공간의 크기를 결정하기 위함 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위함 값 더 이상 평가할 수 없는 하나의 표현식 실제 메모리 공간에 저장되는 최소 단위 1210 + 20 // 10 + 20은 표현식이고 이로 인해 나온 결과 30은 더이상 평가할 수 없는 값이다. 값의 생성 리터럴 표기법 표현식으로 생성. 리터럴 소스 코드 내에서 직접 만들어 낸 고정된 값 자체. 사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령 리터럴 - 정수 리터럴 / 부동 소숫점 리터럴 100 / 10.5 2진수(0b) / 8진수 리터럴(ES 6도입, 0o) / 16진수 리터럴(ES 6도입, 0x) 0b01000001 / 0o101 / 0x41 문자열 리터럴 ‘Hello’ , “World” 불리언 리터럴 true , false null 리터럴 / undefined 리터럴 null / undefined 정규표현식 리터럴 ab+c 객체 리터럴 { name: ‘Lee’, age : 20 } 배열 리터럴 [ 1, 2, 3 ] 함수 리털럴 function( ){ } 표현식 값을 생성하는 다양한 방법 리터럴, 식별자(변수 혹은 함수 등), 연산자, 함수 호출등의 조합 하나의 값으로 평가될 수 있는 문(식) 1234567891011121314151617// 리터럴 표현식10'Hello'// 식별자 표현식(선언이 이미 존재한다고 가정)sumperson.namearr[1]// 연산자 표현식10 + 20sum = 10sum !== 10// 함수/메소드 호출 표현식(선언이 이미 존재한다고 가정)square()person.getName() 데이터 타입의 분류(종류) 원시타입 숫자(number) 타입: 숫자 (정수, 실수) 문자열(string) 타입: 문자열 불리언(boolean) 타입: 논리적 참(true)과 거짓(false) undefined 타입: 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입: ES6에서 새롭게 추가된 7번째 타입 객체 타입 / 참조 타입(object/reference type): 객체, 함수, 배열 등 숫자(number) 타입 자바스크립트는 Java , C처럼 정밀하게 숫자들을 나눠 놓은 형식은 없다. 모든 숫자들은 실수로 처리를 하여 표현한다. ( 정수만을 위한 특별한 타입은 존재하지 않는다. ) 모든 숫자(정수, 실수, 음의정수, 2진수, 8진, 16진수)는 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 2진수, 8진수, 16진수를 별도로 제공을 안하기 때문에 이 값들을 참조하면 모두 10진수로 해석한다. 1234// 숫자 타입은 모두 실수로 처리된다.console.log(1 === 1.0); // trueconsole.log(4 / 2); // 2console.log(3 / 2); // 1.5 + 추가로숫자 타입은 3가지 특별한 값들도 표현이 가능하다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not a number) 1234567// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN//+ 자바스크립트는 대소문자 구별을 하기에 NaN을 NAN, nan, Nan등으로 적으면 에러가 발생한다.var x = nan; // ReferenceError: nan is not defined 문자열 타입 텍스트 데이터를 나타내는데 사용한다. 16bit 유니코드 문자들의 집합으로 전세계 대부분의 문자가 표현이 가능하다. 작은 따옴표(‘’), 큰따옴표(“”), 백틱(`) 안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 이용한다. 문자열은 원시타입이며 변경 불가능한 값이다. 문자열은 한번 생성되면, 그 문자열은 변경할 수 없다는 것을 의미한다. 템플릿 리터럴 ES6 생긴 새로운 무자열 표기법. 백틱 문자 ` 를 사용한다. 특징1 : 일반적인 문자열에서는 줄바꿈이 허용되 않는다. 공백을 표현하기 위해서는 \\로 시작하는 이스케이프 시퀀스를 이용해야만하는데 템플릿 리터럴은 여러줄에 걸쳐 문자열을 작성시 공백을 있는 그대로 출력해준다. 12345678onst template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;console.log(template); 특징2 : 문자열은 문자열 연산자를 사용해 연결한다. 하지만 템플릿 리터럴은 연산자 없이도 문자열 삽입기능을 제공 하며 이를 문자열 인터폴레이션 이라 한다. $ { 표현식 } : 이에 대한 평가 결과는 강제로 문자열이 된다 12345678910// 기본적인 문자열 연산자를 이용한 문자열 연결console.log('나이는 : ' + 25 + '살 입니다.' );//문자열 인터폴레이션var age = \"나이는\";var num = 25;console.log('$&#123;age&#125; $&#123;num&#125; 살 입니다.');console.log(`1 + 1 = $&#123;1 + 1&#125;`); // 1 + 1 = 2 강제 문자열 불리언 타입 불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다. undefined 타입 선언은 되어있지만 아직 값을 할당하지 않는 변수에 접근할 경우 undefined가 반환된다. 이는 자바스크립트 엔진의 암묵적 초기화에 의한 것이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 ‘할당된 적인 없는 변수라는 것’ 을 개발자는 간파가 가능하다. 개발자가 의도적으로 변수에 undefined를 할당한다면 혼란을 줄 수 있으므로 권장하지 않는다. 자바스크립트의 정의와 선언의 차이 자바스크립트에서 선언은 식별자가 생성되었지만 값이 아직 할당되지 않은 상태를 말한다. 자바스크립트에서 정의는 식별자가 생성되었고 값까지 할당되어 있는 상태를 의미한다. 123456// 변수 선언. 내부적으로 undefined로 정의된다.var foo;// 변수 선언과 정의var bar = 1;// 함수 정의. 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.function baz &#123; &#125; null 타입 변수에 값이 없다는 것을 의도적으로 명시 할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미. 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 Null, NULL등과 다르다. (반드시 null로 써야한다.) 123456&lt;script&gt; var element = document.querySelector('.myElem'); // HTML 문서에 myElem 클래스를 갖는 요소가 없다면 null을 반환한다. console.log(element); // null &lt;/script&gt; document.querySelector 메소드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우, 에러 대신 null을 반환. 변수에 null을 할당하게 되면, 이는 더 이상 해당 변수의 값을 참조하지 않겠다는 것을 의미. 따라서 자바스크립트 엔진은 누구도 참조하지 않는 해당 변수의 메모리공간에 대해서 가비지 콜렉션을 수행할 것이다. symbol 타입 ES6에서 새롭게 추가된 7번째 타입. 변경 불가능한 원시 타입의 값. 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위함 사용방법 : Symbol 함수를 호출해 사용한다. 12345678910111213/// 심볼 값 생성var key = Symbol('key');console.log(typeof key); // symbol// 객체 생성var obj = &#123;&#125;;// 심볼 key를 이름의 충돌 위험이 없는 유일한 프로퍼티 키로 사용한다.obj[key] = 'value';console.log(obj[key]); // valueobj[\"key\"] = \"value\";console.log(obj); 똑같은 key : value라는 이름의 키와 값을 객체에 넣었는데 전혀 충돌이 나지 않고있다. 또한 Object.keys(obj) 를 찍어보면 Symbol은 나타나지 않고 일반적인 키와 값만 출력한다. 객체 타입 자바스크립트의 6가지 데이터 타입 이외에 모든 것은 전부 객체 타입이다. 객체타입은 추후에 마져 공부한다. 동적 타이밍 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 12345678// JAVA , C의 경우. int라는 키워드를 통해 이미 정수라는 타입이 결정되었음.int a;// javascript , var때문이 아닌 값이 5 라는것을 통해 숫자 타입이라는 것을 알게됨. var a = 5;// + 추가로 javascript는 언제든지 동적으로 값에 의해 변수의 타입이 변할수있다.var a = \"hello world\"; // a는 숫자 타입에서 \"hello world\" 라는 문자열 타입으로 변경되었다. 이러한 편리한 구조속에 동적 타이밍은 다음과 같은 단점을 지니고있다. 동적으로 변화하는 데이터 타입을 추척하기 어려울 수 있다. (즉, 확인하기 전까지는 데이터 타입의 값을 확신하기 힘들다.) 동적 타입 언어는 유연성(flexibility)은 높지만, 신뢰성(reliability)이 떨어진다. 따라 안정적인 프로그램 개발을 위해서는 데이터 타입을 체크해야하는 경우가 있는데 이러한 방식은 코드량의 증가를 야기한다. 코드량의 증가는 결국 버그발생률을 높이게 되며, 테스트 분량 또한 증가시킨다. 따라서 다음과 같은 변수 사용 주의사항이 있다. 변수 사용 주의사항 변수의 사용을 적극적으로 줄인다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 전역 변수는 사용하지 않는다. 변수의 생명주기를 최대한 짧게 만든다. 변수보다는 상수를 사용해 값의 변경을 억제한다. 변수 이름은 변수의 존재 이유를 파악할 수 있도록 명명한다. 6강표현식과 연산자 표현식이란? 리터럴 , 식별자(변수 혹은 함수의 이름) , 연산자, 함수호출등의 조합 표현식은 평가되어 하나의 값을 만든다. 12var x = 10;x + 30; // 40 위 예제에서 x+30이 표현식이다. + 연사자는 좌항과 우항의 값을 연산하는 연산자이고 좌항과 우항에는 숫자값이 위치해야한다. 우항은 30이라는 리터럴 표현식 이 좌항에는 x라는 식별자 표현식이 와있고 이 두개의 조합으로이해 40이라는 값을 낼수있다. 문(statement) 문이란? 하나 이상의 표현식과 키워드 조합으로 구서된 자바스크립트 엔진에게 내리는 명령 문의 집합으로 이루어진 것이 프로그램이며 문을 작성하고 나열하는 것이 프로그래밍이다. 문은 코드블록( {내용} )을 제외하고는 ; 으로 끝나야만 한다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식은 그 자체로 문이 될수도 있지만, 반대로 문은 표현식이 될수는 없다. 문 vs 표현식표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. 문은 선언문과 같이 var, let, const, function, class와 같은 선언 키워드를 사용하여 변수나 함수, 클래스를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다. 결론적으로, 표현식의 역할은 값을 생성하는 것. 문의 역할은 표현식으로 생성한 값을 사용해 JS엔진에게 명령을 내리는 것. 표현식인 문 / 표현식이 아닌 문 표현식인 문은 값으로 평가가 가능하다. 표현식이 아닌 문은 값으로 평가가 불가능하다. 12var x; // 변수 선언문. -&gt; 값으로 평가가 불가능하다.x = 300; // 할당문. x는 300이라는 값으로 평가가 가능하다. 완료값 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라 한다. 완료 값은 다른 값과 같이 변수에 할당할 수 없다. 연산자 연산자란? 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입연산등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자라 칭한다. 산술 연산자 피연산자를 대상으로 수학적 계산을 하여 새로운 숫자 값을 만든다. 연산이 불가능할 경우에는 NaN을 출력한다. 부수효과 : 피연산자의 값은 변경하는 것. 이항 산술 연산자 ( ex - var a = 1+2; ) : 피연산자끼리 계산을 하여 새로운 값을 만든다. 이항 산술 연산자 의미 부수 효과 + 덧셈 X - 뺄셈 X * 곱셈 X / 나눗셈 X % 나머지 X 단항 산술 연산자 ( ex - var a = 0; a++; ) 단항 산술 연산자 의미 부수 효과 ++ 증가 O – 감소 O + 숫자 타입이 아닌 피연산자를 숫자타입으로 변환. X - 양수를 음수로 음수를 양수로 반전화 시킨다. X 단항 산술 연산자의 ++ , –는 어느 위치냐에 따라 피연산자에 대한 값의 증가 및 감소처리의 로직이 달라질수 있다. 1234567891011121314151617var x = 5, result;// 선할당 후증가 (Postfix increment operator)result = x++;console.log(result, x); // 5 6// 선증가 후할당 (Prefix increment operator)result = ++x;console.log(result, x); // 7 7// 선할당 후감소 (Postfix decrement operator)result = x--;console.log(result, x); // 7 6// 선감소 후할당 (Prefix decrement operator)result = --x;console.log(result, x); // 5 5 + 단항 연산자는 숫자 타입의 피연산자에게 어떠한 영향도 주지 않는다. 숫자타입이 아닌 피연산자에게 적용시 강제로 숫자타입으로 반환 해준다. 1234567891011// 문자열을 숫자로 타입 변환한다.+'10'; // -&gt; 10// 불리언 값을 숫자로 타입 변환한다.+true; // -&gt; 1// 불리언 값을 숫자로 타입 변환한다.+false; // -&gt; 0// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.+'Hello'; // -&gt; NaN - 단항 연산자는 양수의 숫자타입을 음수로 바꾸거나, + 단항 연사자처럼 숫자타입이 아닌 피연사자를 강제로 음수 숫자타입으로 바꾸어 반환해준다. 1234567891011// 부호를 반전한다.-(-10); // -&gt; 10// 문자열을 숫자로 타입 변환한다.-'10'; // -&gt; -10// 불리언 값을 숫자로 타입 변환한다.-true; // -&gt; -1// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.-'Hello'; // -&gt; NaN 문자열 연결 연산자 + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 1234561 + 2 // 3'1' + 2 // '12'1 + true // 2 true : 11 + false // 1 false : 01 + null // 1 null : 01 + undefined // NaN : undefined 는 숫자로 타입 변환되지 않는다. true / false / null 등은 강제로 숫자타입으로 변환 후 연산을 실행한 것을 알 수 있다. 이를 암묵적 타입 변환 혹은 타입 강제 변환이라고 한다. 할당 연산자 할당 연산자 예 동일 표현 부수 효과 = x = 5 x = 5 O += x += 5 x = x + 5 O -= x -= 5 x = x - 5 O *= x *= 5 x = x * 5 O /= x /= 5 x = x / 5 O %= x %= 5 x = x % 5 O 물론 문자열도 할당 연산자를 적용시킬 수 있다. 123456var str = 'My name is ';// 문자열 연결 연산자str += 'Lee'; // str = str + 'Lee';console.log(str); // 'My name is Lee' 비교 연산자비교연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 boolean 값으로 반환한다. 비교연산자 의미 사례 설명 부수효과 == 동등 비교 x == y x와 y의 값이 같다. X === 일치 비교 x === y x와 y의 값과 타입이 같다. X != 부동등 비교 x != y x와 y의 값이 다르다. X !== 불일치 비교 x !== y x와 y의 값과 타입이 다르다. X 동등 비교와 부동등 비교의 경우 피연산자끼리 비교할 떄, 타입이 다른 경우 암묵적인 타입 변환을 통해 타입을 일치 시킨 후에 값이 같은지 비교를 한다. 따라서 타입이 다른 경우에도 true를 반환 할 수 도 있다. 반면에 일치비교와 불일치비교는 타입 과 값이 모두 비교를 하기에 좀 더 예측하기가 쉽다. 일치비교의 주의점 : NaN === NaN // false : NaN은 자신과 일치하지 않은 유일한 값 NaN을 조사할 때에는 빌트인 함수 inNaN을 사용해야한다. 123isNaN(NaN); // trueisNaN(10); // falseisNaN(10 + undefined); // true 대소 관계 비교 연산자조건문 이나 반복문에서 자주 사용되는 연산자로 boolean 값을 반환한다. 12345// 대소 관계 비교5 &gt; 0; // -&gt; true5 &gt; 5; // -&gt; false5 &gt;= 5; // -&gt; true5 &lt;= 5; // -&gt; true 삼항 조건 연산자삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 자바스크립트의 유일한 삼항 연산자이며 부수효과는 없다. 마치 조건문을 짧게 줄여놓은 형식이다. 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일 때 반환할 값 ? 앞에 나오는 조건식은 불리언 타입의 값으로 평가가 된다. (즉 (ture)1인지 (false)0인지 본다는 뜻 ) 만약 조건식 평가 결과가 불리언 값이 아니라면 불리언 값으로 암묵적 타입 변환을 실행한다. 123456var x = 2;// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 논리 연산자 논리 연산자는 항상 불리언 값을 반환한다. 피연산자는 불리언 타입으로 암묵적 타입 변환을 한다. 논리 연산자 의미 부수효과 || 논리합( OR ) X &amp;&amp; 논리곱( AND ) X ! 부정( NOT ) X &lt;주의&gt; 논리합 연산자( || ) 와 논리곱 연산자( &amp;&amp; ) 의 결과가 항상 불리언 값이 아닐수도 있다. 12// 단축 평가'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' 쉼표 연산자 쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. 12var x, y, z;x = 1, y = 2, z = 3; // 3 typeof 연산자 typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. 종류는 총 7개다 string number boolean undefined symbol object function 123456789101112typeof '' // -&gt; \"string\"typeof 1 // -&gt; \"number\"typeof NaN // -&gt; \"number\"typeof true // -&gt; \"boolean\"typeof undefined // -&gt; \"undefined\"typeof Symbol() // -&gt; \"symbol\"typeof null // -&gt; \"object\"typeof [] // -&gt; \"object\"typeof &#123;&#125; // -&gt; \"object\"typeof new Date() // -&gt; \"object\"typeof /test/gi // -&gt; \"object\"typeof function () &#123;&#125; // -&gt; \"function\" 주의점 NaN은 number로 반환한다. null값을 object로 반환한다. ( JavaScript의 첫 버그 ) 2번째 주의점인 null 타입 확인은 typeof 대신에 일치연산자 ( === ) 을 사용한다. 1234var foo = null;typeof foo === null; // -&gt; falsefoo === null; // -&gt; true 지수연산자 ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 지수 연산자가 도입 전에는 Math.pow 함수를 이용하였다. 지수연산자 Math.pow(a,b) 5 ** 2 ; //25 Math.pow(5, 2); //25 5 ** 2.5; // 55.901699~ Math.pow(5, 2.5); // 55.901699~ 5 ** 0 // 1 Math.pow(5, 0); // 1 5 ** -2 // 0.04 Math.pow(5, -2); // 0.04 음수를 거듭제곱의 밑으로 계산하려면 괄호로 묶어야 한다. 123-5 ** 2;// -&gt; SyntaxError(-5) ** 2; // -&gt; 25 지수 연산자는 할당 연산자와 함께 이용이 가능하며, 모든 이항 연산자보다 우선순위가 높다. 123456// 할당 연산자와 함께 사용이 가능하다.var num = 5;num **= 2; // -&gt; 25// num ** 2를 행한 값과 * 4를 한다.4 * num ** 2; // -&gt; 100","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-0304","slug":"javascript-preview-0304","date":"2019-10-02T19:23:49.000Z","updated":"2019-10-03T06:45:54.257Z","comments":true,"path":"2019/10/03/javascript-preview-0304/","link":"","permalink":"http://yoursite.com/2019/10/03/javascript-preview-0304/","excerpt":"","text":"JacaScript 3강~4강 예습 3강 : 자바스크립트 개발 환경과 실행 방법 자바스크립트 실행 환경 웹브라우저의 동작 방식 script 코드를 하단에 두어야 하는 이유 DOM이란? 4강 : 변수 변수란? 식별자 변수선언 변수 선언의 실행 시점과 변수 호스팅 값의 할당 값의 재할당 값의 교환 식별자 네이밍 규칙 자바스크립트 실행 환경 모든 브라우저는 자바스크립트을 실행하고 해석하기 위해서 자바스크립트 엔진을 내장하고 있다. 브라우저뿐만 아니라 Node.js도 자바스크립트 엔진을 내장하고 있다. 따라서 브라우저와 Node.js 둘다 자바스크립트의 코어인 ECMAScript를 실행할수는 있지만, ECMAScript 이외에 추가적인 기능은 호환되지 않는다. 브라우저에서의 자바스크립트 실행 환경 Node.js DOM API를 지원. File 시스템 (create / delete / read / update)를 지원. 클라이언트 사이드 Web API + ECMAScript Node.js 고유 API + ECMAScript 웹 어플리케이션의 자바스크립트는 사용자 컴퓨터의 브라우저에서 동작한다.(보안상 이유: Web API에서는 File 시스템을 미제공) 웹 어플리케이션의 자바스크립트는 브라우저에서 HTML,CSS와 함꼐 실행된다. 웹 브라우저의 동작 방식브라우저의 핵심 기능 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리하며, HTML파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해서 DOM 생성 프로세서를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 컴파일러 인터프리터 컴파일 타임에 소스 코드 전체를 한번에 CPU가 바로 실행할 수 기계어)로 변환한 후 실행한다. 런타임에 문 단위로 한 줄씩 중간 코드인 바이트 코드 특정한 하드웨어가 아니라 가상 머신에서 실행하도록 만든 바이너리 코드)로 변환한 후 실행한다. 실행 파일을 생성한다. 실행 파일을 생성하지 않는다. 컴파일 단계와 실행 단계가 분리되어 있다. 명시적인 컴파일 단계를 거쳐서 명시적으로 실행 파일을 실행한다. 인터프리트 단계와 실행 단계가 분리되어 있지 않다. 인터프리터는 한 줄씩 바이트 코드로 변환하고 즉시 실행한다. 실행에 앞서 컴파일은 단 한번 수행된다. 코드가 실행될 때마다 인터프리트 과정이 반복 수행된다. 컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠르다. 인터프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다. 토크나이징(Tokenizing) 단순한 문자열인 소스 코드를 어휘 분석(Lexical analysis)하여 의미를 갖는 코드의 최소 단위인 토큰(Token)들로 분리. 파싱(Parsing) 토큰들의 집합을 구문 분석(Syntactic analysis)하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성 AST는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료 구조 코드 실행 생성된 AST는 인터프리터가 실행할 수 있는 바이트 코드(bytecode)로 변환되고 인터프리터에 의해 실행. 결론 JS 소스 코드 + 어휘 분석 + 최소단위로 나누어 토큰으로 만듬 : 토크나이즈 토큰 + 구문분석 = 토큰에 문법적 의미 및 구조 반역 = AST 생성 : 파싱 AST를 인터프리터가 실행하도록 바이트코드로 변환하여 실행. script 코드를 하단에 두어야 하는 이유 HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다. DOM이란? Document Object Model (문서 객체 모델)- HTML, XML 문서의 프로그래밍 interface 로컬에서 작성된 코드가 브라우저에 의해 파싱되면 DOM으로 변환. JavaScript는 브라우저가 읽고 어떤 작업을 할 수 있는 언어이고 DOM은 이 작업이 이루어지는 장소이다. 어떠한 요소에 click이벤트가 일어나는지 감시하도록 JavaScript을 사용한 기능이 구현됬다. 하지만 이 요소는 DOM 노드이다. 여기서 DOM에 있는 property를 통해서 listener를 붙여 놓은 것 뿐임. DOM은 HTML요소이고, DOM API는 JavaScript에서 HTML에 DOM요소를 다루기 위한 JavaScript의 기본 함수. Node.js 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경. NPM node package manager의 약자. 자바스크립트 패키지 매니저이다. Node.js에서 사용할 수 있는 모듈들을 패키지화 하여 모아둔 장소 역할 과 패키지 설치 및 관리를 위한 CLI를 제공. 변수란? 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 / 또는 메모리 공간 자체. 데이터를 관리하기 위한 핵심 개념. 배열 혹은 객체와 같은 자료구조를 이용하면 하나의 변수에 여러개의 값을 그룹화하여 사용이 가능하다. 12345678910111213var userName = 'Lee';var userRole = 'Admin';// 객체나 배열과 같은 자료 구조를 사용하면 여러 개의 값을 하나로 그룹화하여 하나의 값처럼 사용할 수 있다.var user = &#123; name: 'Lee', role: 'Admin'&#125;;var users = [ &#123; name: 'Lee', role: 'Admin' &#125;, &#123; name: 'Kim', role: 'Developer' &#125;]; 변수에 값을 저장하는 행동 : 할당 변수에 저장된 값을 읽는 행동 : 참조 식별자 어떤 값을 구별하여 식별해낼 수 있는 이름 메모리 상에 존재하는 어떤 값을 구별하여 식별해낼 수 있어야 한다. 변수 , 함수 , 클래스등의 이름과 같은 식별자는 네이밍 규칙을 준수 해야만 한다. 선언에 의하여 자바스크립트 엔진에 식별자의 존재를 알린다. 변수 선언 변수 이름을 자바스크립트 엔진에 알려 등록하고 변수 값을 저장하기 위한 메모리 영역의 확보를 명령하는것. ( - 즉, 변수를 생성하는 것) 변수는 선언과 동시에 특정 값으로 초기화를 안하면 undefined라는 값이 암묵적으로 할당되어 초기화가 된다. 변수를 사용하려면 반드시 선언이 필요하다. 만약 선언 없이 변수(식별자)에 접근하면 ReferenceError가 발생한다. (이는 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 참조 에러다.) ES5 VS ES6 의 변수 선언 차이점 ES5의 변수 선언 키워드 ES6의 변수 선언 키워드 var let , const 123456// var 키워드의 최대 단점 : 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다.var a; //undefineda = 10;for(var a=0;a&lt;5;a++)&#123;&#125;console.log(a); 위는 var 키워드의 단점을 설명해주는 가장 큰 예이다. a의 결과값은 10이 아닌 5이다. 이유는 for는 { } 밖에 존재하기 때문이다. 실행 컨텍스트 자바스크립트 엔진이 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. 모든 식별자는 실행 컨텍스트에 등록된다. 자바스크립트는 실행 컨텏스트를 통해 식별자와 스코프를 관리한다. 실행 컨텍스트 내에 KEY / VALUE 형씩인 객체로 등록되어 관리된다. 변수 선언의 실행 시점과 변수 호이스팅 변수 선언은 소스 코드가 순차적으로 실해되는 시점에서 실해되 않는다. 구문 분석 단계에서 먼저 실행된다. 따라서 아래와 같은 코드가 참조 에러가 안나는것이다. 12console.log(score); // undefinedvar score; // 변수 선언(변수 선언문) 변수호이스팅 자바스크립트는 변수 선언문을 코드의 선두로 끌어 올려진 것처럼 동작하게 보인다. 이와 같은 고유의 특징을 변수 호이스팅이라고 한다. 추가로 사실 호이스팅은 변수 선언 뿐만이 아니라 var, let, const, function, function*, class 키워드를 사용하여 선언된 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. 모든 선언문은 런타임 이전인 구문 분석 단계에 먼저 실행되기 때문이다. 값의 할당 변수에 값을 할당할 때는 할당 연산자(=) 을 사용한다. ( 우변의 값을 좌변에 ) 변수 선언과 동시에 값을 할당하는 따로 선언후 구문을 나눠서 할당을 하든, 자바스크립트는 런타임 이전에 변수선언을 실행하고, 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다. 변수에 값을 할당 할 때 undefined가 적혀진 메모리 공간을 지우고 그곳에 값을 다시 저장하는게 아니라 새로운 메모리 공간을 확보하고 확보된 공간에 값을 할당한다. 123456console.log(score); // undefinedscore = 80; // 값의 할당var score; // 변수 선언console.log(score); // ?? 결과는 undefined / 80 이 출력된다. 이유 : var score는 구문 분석때 실행되어 undefined로 메모리 공간에 저장이 되어서 첫 score 값에 undefined 값이 저장이 되고 그 후 score는 80이라는 값이 할당이 되어 새로운 메모리 영역에 공간이 할당되고 80이라는 값이 저장된다. 따라서 2번째 값은 80이다. 값의 재할당 var 키워드로 선언한 변수는 값을 재할당이 가능하다. 재할당이 불가능한 식별자를 만들고 싶다면 const키워드를 이용한다. (즉 상수) 재할당이 끝나면 그 전에 할당되었던 값들은 필요가 없어진다. 이러한 쓰레기값들은 Garbage Collector에 의하여 메모리에서 자동 해제된다. 값의 교환123456789var x = 1;var y = 2;// do somethigvar temp = x;x = y;y = temp;console.log(x, y); // 2 1 식별자 네이밍 규칙 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러기호( $ ) 를 포함할 수 있다. 식별자는 문자 , underscore( _ ) , 달러기호( $ ) 로 시작해야 한다. 숫자 및 특수문자로 시작할 수 없다. 예약어는 식별자의 네이밍으로 사용이 불가능하다. 대소문자를 구별한다. (var firstName , Fristname, FIRSTNAME; // 모두 각각 다른 변수 ) 예약어 await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* Switch this throw true try typeof var void while with yield* 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다. 좋은 변수 이름은 코드의 가독성이 높인다. 하나 이상의 영어 단어로 구성된 식별자를 네이밍할때는 아래와 같은 네이밍 컨벤션을 이용한다. 123456789101112// 카멜 케이스 (camelCase)var firstName;// 스네이크 케이스 (snake_case)var first_name;// 파스칼 케이스 (PascalCase)var FirstName;// 헝가리언 케이스 (typeHungarianCase)var strFirstName; // type + identifiervar $elem = $('.myClass'); // jQuery 가장 일반적인 것 : 코드 전체의 가독성을 높이기 위해서 2가지 네이밍 컨벤션이 많이 쓰이고 있다. 변수명 / 함수명 -&gt; 카멜케이스 생성자 함수명 / 클래스명 -&gt; 파스칼케이스 ECMAScript 사양에 정의된 표준 객체(String, Number 등등)와 전역 함수들도 카멜케이스와 파스칼 케이스 네이밍 컨벤션이 사용되고 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-02","slug":"javascript-study-02","date":"2019-10-02T19:19:54.000Z","updated":"2019-10-02T19:20:49.334Z","comments":true,"path":"2019/10/03/javascript-study-02/","link":"","permalink":"http://yoursite.com/2019/10/03/javascript-study-02/","excerpt":"","text":"JavaScript Study 02 자바스크립트 특징 자바스크립트 엔진 자바스크립트 실행환경 웹 브라우저는 어떻게 동작하는가? 브라우저의 핵심 역할 서버의 핵심 역할 ESLint 자바스크립트 특징 웹 브라우저에서 동작하는 유일한 프로그래밍 언어 프로토타입 기반의 객체 지향 언어 ( 다른 언어에서 함수는 구문이지만 JS는 값) 값은 주고 받을 수가 있다. (함수형 프로그래밍) JS 는 절차지향(명령형), 객체지향, 함수형이 모두 가능한 멀티 패러다임 프로그래밍 언어 자바스크립트 엔진자바스크립트를 실행할 수 있는 환경으로 브라우저에 내장되어있다. 내부적으로 사용율이 높은 것은 컴파일을 하는 특징을 지니고 있으며 인터프리터와 컴파일러를 결합해서 작동한다. 현재 IE를 제외한 대부분의 브라우저는 ES6 까지 지원이 되고있다. (자바스크립트는 인터프리터언어라고는 하지만 그 기준이 위와 같은 잣대로 인해 모호해지고 있다.) 자바스크립트 실행환경&lt;head&gt; 안에는 기본적으로 &lt;meta ~ &gt;가 들어간다 시멘틱 문법상 &lt;head&gt;는 눈에 보이지 않는 데이터들을 모아놓은 집합이다. 따라서 script파일은 &lt;haed&gt;안에 들어가야 맞다. 하지만 인터프리터는 위에서 한줄 할줄 읽는다. 만약 script 가 head에 들어갈 경우 script에 정의된 변수나 객체들이 html에 랜더링 되어야 값들을 참조 못할 수 있다. 따라서 body 태그 최하단에 넣어주는 것이 바람직하며 시맨틱적인 표준을 지키고 싶다면 async defer 와 같은 옵션을 이용한다. 웹 브라우저는 어떻게 동작하는가? 클라이언트 : 서비스를 받는 입장 ( 요청하는 입장 ) 서버 : 서비스를 하는 입장 ( 응답하는 입장) 도메인 : ip를 식별하는 이름. 암묵적인 룰 : 웹서버는 root로 요청이 오면 index.html를 주도록 되어있다. ex) www.naver.com 브라우저의 핵심적인 역할 : 서버에 HTML, CSS , Javascript를 요청 (request) 서버로부터 받아온 HTML , CSS , Javascript를 파싱하는 역할. 서버의 역할 무한 대기 ( 리퀘스트를 받기 위해서 ) 요청에 대한 응답 (response) 응답받은 파일(html, css)은 메모리상에 올린다. 이를 Read 라 한다. 그 후 Rendering Engine이 실행할 수 있는 형식으로 만들어 준다. 이를 Parsing 이라 한다. Parsing이 완료되면 Tree가 만들어지는데 이를 DOM tree ( CSS라면 CSSOM tree)가 만들어진다. tree : 자료구조의 하나로 거슬로 올라가고 / 따라서 내려가기 편한 형태의 자료구조. Dom이 완성되기 전에 자바스크립트가 실행이 된다. 자바스크립트 엔진은 AST라는 트리를 만든다. 실행이 종료되면 돔을 만드는 작업을 마저한다. 중요단어 파싱, 돔트리, 렌더트리, CSSOM트리 검사창을 통해 테스트 하는 방법 console.log 디버깅이란? 논리적인 오류를 검출하여 제거하는 과정. 디버깅하는법 : 검사창을 통해 에러 확인 . Sources 탭에서 에러부분에 밑줄이 쳐있다. break 거는법은 의심가는 줄을 선택한다. 선탹된 소스부분은 디버깅시 넘어가지 않고 멈춘다. ESLint 코드 Linting 이란? 특정 스타일 규칙을 준수하지 않는 문제가 있는 소스코드를 찾는데 사용되는 방식 Linter는 이러한 Linting을 수행하는 도구를 의미. ESLint는 특정 스타일 규칙을 제한하거나 새롭게 개정까지 가능하다. 대부분의 프로그래밍 언어에는 컴파일하는 과정이 있어서 컴파일시 수행되는 Linter가 내장되어있다. 하지만, Javascript는 컴파일하는 언어가 아니기 때문에 이러한 오류를 잡기 위해 ESLint 와 같은 프로그램을 적극적으로 이용하여 실행하지 않고 기본적인 코드 오류, 구문 오류, 잘못된 규칙등을 발견할 수 있다. ESLint 사용 2가지 방식 JavaScript 개발시 사용되는 에디터에 플러그인을 추가하는 방식 Webpack에 번들링 하여 사용하는 방식. ESLint 설치 및 설정 폴더 생성 후 npm 초기화 및 npm으로 eslint 관련파일 설치 eslint eslint-config-airbnb-base : arirbnb 에서 제정된 코드 스타일 규칙은 좋기로 유명하다. eslint-plugin-import eslint-plugin-html 아래 명령 실행 $ cd &lt;project-folder&gt;$ npm init -y $ npm install eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-html --save-dev - 주의 : ESLint는 가급적이면 해당 폴더에서만 사용할 수 있도록 설치 하는것이 좋다. 전역설치는 매번 추가 설정이 필요로 한다. node_modules 폴더 package-lock.json (없을 수도 있다.) package.json VSCode에 extention 설치 사용중인 폴더에 .eslintrc.js 파일 생성 후 아래 코드 넣기 1234567891011121314151617181920212223module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) \"no-console\": \"warn\", \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"] &#125;&#125;; ESLint 사용처 명시하기 (맥OS 기준) - 설정 탭 접근 - 오른쪽 상단 아이콘 클릭 - 아래 코드 추가 12345\"eslint.validate\" : [ \"javascript\", \"javascriptreact\", \"html\"] ESLint 사용하기 ESLint 가 정상적으로 적용이 완료되었다면 위와 같이 전혀 문제 없어보이는 코드에도 에러, 경고등을 표시한다. 마우스를 살포시 올려보면 무엇이 에러인지 적혀있다. 위 예제에서는 “ var를 쓰지말고 let 이나 const를 써라 “라고 경고하고 있다. ESLint 규칙 설정하기 (.eslintrc.js) 위와 같이 마우스를 올릴 경우 나오는 에러 혹은 경고등을 .eslintrc.js 파일에서 설정이 가능하다. off : 0 warn : 1 error : 2","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"eslint-description","slug":"eslint-description","date":"2019-10-02T11:32:57.000Z","updated":"2019-10-02T11:36:44.604Z","comments":true,"path":"2019/10/02/eslint-description/","link":"","permalink":"http://yoursite.com/2019/10/02/eslint-description/","excerpt":"","text":"ESLint 코드 Linting 이란? 특정 스타일 규칙을 준수하지 않는 문제가 있는 소스코드를 찾는데 사용되는 방식 Linter는 이러한 Linting을 수행하는 도구를 의미. ESLint는 특정 스타일 규칙을 제한하거나 새롭게 개정까지 가능하다. 대부분의 프로그래밍 언어에는 컴파일하는 과정이 있어서 컴파일시 수행되는 Linter가 내장되어있다. 하지만, Javascript는 컴파일하는 언어가 아니기 때문에 이러한 오류를 잡기 위해 ESLint 와 같은 프로그램을 적극적으로 이용하여 실행하지 않고 기본적인 코드 오류, 구문 오류, 잘못된 규칙등을 발견할 수 있다. ESLint 사용 2가지 방식 JavaScript 개발시 사용되는 에디터에 플러그인을 추가하는 방식 Webpack에 번들링 하여 사용하는 방식. ESLint 설치 및 설정 폴더 생성 후 npm 초기화 및 npm으로 eslint 관련파일 설치 eslint eslint-config-airbnb-base : arirbnb 에서 제정된 코드 스타일 규칙은 좋기로 유명하다. eslint-plugin-import eslint-plugin-html 아래 명령 실행 $ cd &lt;project-folder&gt;$ npm init -y $ npm install eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-html --save-dev - 주의 : ESLint는 가급적이면 해당 폴더에서만 사용할 수 있도록 설치 하는것이 좋다. 전역설치는 매번 추가 설정이 필요로 한다. node_modules 폴더 package-lock.json (없을 수도 있다.) package.json VSCode에 extention 설치 사용중인 폴더에 .eslintrc.js 파일 생성 후 아래 코드 넣기 1234567891011121314151617181920212223module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) \"no-console\": \"warn\", \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"] &#125;&#125;; ESLint 사용처 명시하기 (맥OS 기준) - 설정 탭 접근 - 오른쪽 상단 아이콘 클릭 - 아래 코드 추가 12345\"eslint.validate\" : [ \"javascript\", \"javascriptreact\", \"html\"] ESLint 사용하기 ESLint 가 정상적으로 적용이 완료되었다면 위와 같이 전혀 문제 없어보이는 코드에도 에러, 경고등을 표시한다. 마우스를 살포시 올려보면 무엇이 에러인지 적혀있다. 위 예제에서는 “ var를 쓰지말고 let 이나 const를 써라 “라고 경고하고 있다. ESLint 규칙 설정하기 (.eslintrc.js) 위와 같이 마우스를 올릴 경우 나오는 에러 혹은 경고등을 .eslintrc.js 파일에서 설정이 가능하다. off : 0 warn : 1 error : 2","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"http://yoursite.com/categories/Develop/Tips/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"ESLint","slug":"ESLint","permalink":"http://yoursite.com/tags/ESLint/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"daily_algorithm03","slug":"daily-algorithm03","date":"2019-10-02T00:39:36.000Z","updated":"2019-10-02T00:42:35.353Z","comments":true,"path":"2019/10/02/daily-algorithm03/","link":"","permalink":"http://yoursite.com/2019/10/02/daily-algorithm03/","excerpt":"","text":"문제 출저 : 프로그래머스 수박수박수박수박수박수?문제 설명길이가 n이고, 수박수박수박수….와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 수박수박을 리턴하고 3이라면 수박수를 리턴하면 됩니다. 제한 조건 n은 길이 10,000이하인 자연수입니다. 입출력 예 n return 3 수박수 4 수박수박 1234567891011121314151617function solution(n) &#123; var answer = ''; var su = \"수\"; var bak = \"박\"; var i = 0; for(i=1;i&lt;=n;i++)&#123; if(i%2==0)&#123; answer = answer + bak; &#125; else if(i%2!=0)&#123; answer = answer + su; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-01","slug":"javascript-study-01","date":"2019-10-01T05:56:40.000Z","updated":"2019-10-01T09:51:57.861Z","comments":true,"path":"2019/10/01/javascript-study-01/","link":"","permalink":"http://yoursite.com/2019/10/01/javascript-study-01/","excerpt":"","text":"JavaScript Study 01 용어 OT 프론트 엔드 개발자가 하는 일 웹페이지 vs 웹어플리케이션 프론트엔드 개발에 필요한 기술 초심자가 경험하는 3가지 개발의 어려움 프로그래밍이란 아스키코드 , 유니코드 컴파일러 interpreter Syntax , Semantics 자바스크립트 용어 - ( 러버덕 ) 플랫폼 : 어플리케이션이 동작하는 환경. 아스키 코드 유니 코드 컴파일러 인터프리터 JavaScript VS ECMAScript OT 프론트 엔드 개발자가 하는 일 애플리케이션을 사용하는 사람( 유저 )이 애플리케이션과 소통하기 위한 창구( User-Interface )를 사용하기 좋게 구현한다. UI는 상태는 정보를 서버로 전송하기도 하고 서버의 데이터를 가져와서 UI에 표시한다. 웹 어플리케이션은 웹 브라우저에서 작동됨. 브라우저가 직접 실행하는 언어는 JavaScript가 유일하다. 디자이너, 백엔드 개발자와의 협업. ( Tool의 학습이 중요하다. ) 웹페이지 vs 웹어플리케이션 웹페이지 : 정적 , 단순 정보제공. 웹어플리케이션 : 동적 , 정보제공 과 더불어 데이터흐름이 이루어진다. 프론트엔드 개발에 필요한 기술 HTML : tags &amp; attributes, Sementic web CSS : Layout(float , flex , grid), transition/animation, 반응형 웹 , Preprocessor(Sass, Less, Stylus, PostCSS), CSS방법론, CSS 프레임워크 크로스브라우징 JavaScript : ES5 , ES6 , ES Next , 클라이언트 사이드 웹 API( DOM/Event , Ajax ), 동작원리(브라우저, 자바스크립트 엔진), node.js HTTP Tools : Git / Webpack / Babel / ESLint / npm … Library / Framework : SPA(Angular, React, Vue.js), TypeScript, jQuery, Lodash, Axios… TDD(Test Driven Development) : karma / jasmins, mocha, chai 알고리즘 / 자료구조 초심자가 경험하는 3가지 개발의 어려움. 개발자가 하는 말을 이해하기가 힘들다. -&gt; 배경지식 : 기본적인 Computer Sience 지식 / 용어에 대한 이해 / 기본상식 어떻게 만들어야 할 지 감조차 오지 않는다. -&gt; 문제해결 능력 : 문제가 무엇인지 알아채야함. 알고리즘 자료경험. 어떻게 만들어야 할 지는 알겠는데 막상 코딩이 안된다. -&gt; 공부부족. 프로그래밍이란? 프로그래머가 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션 아스키 코드 , 유니코드 아스키코드 : 0과 1의 조합으로 사람이 이해할 수 있는 문자와 숫자의 조합. 1Byte / 경우의수 256개 유니코드 : 2Byte / 국제표준 컴파일러 사람의 언어를 컴퓨터가 이해할 수 있도록 변형 시켜주는 일종의 번역기. 전체적인 코드를 한번에 번역해준다. 컴파일이라는 과정을 필요로 한다. interpreter 사람의 언어를 컴퓨터가 이해할 수 있도록 변형 시켜주는 일종의 번역기. 사람이 적어놓은 코드 내용을 한줄, 한줄씩 컴퓨터가 이해하도록 동시 통역한다. 자바스크립트는 interpreter이다. 즉, 우리가 짠 코드를 브라우저한테 주면 브라우저가 한줄 한줄씩 통역해줄 것이다. 컴파일러보다는 느리다. 단 컴파일 과정이 별도로 필요하지 않다. Syntax &amp; Semantics Syntax : 프로그래밍 문법. Semantics : 말 그대로 문장의 의미. 프로그래밍 문법을 잘 안다고하여 코딩을 잘 하는 것이 아니다. 반드시 문법(Syntax) 와 의미(Semantics) 을 맞게 구성하여야 한다. 예를 들어보자. 123const number = 'string';console.log(number * number); // NaN 위는 문법(Syntax)에는 전혀 문제가 없다. 하지만 의미상으로는 매우 이상하다. number라는 의미의 변수에는 누가보아도 숫자가 들어갈 것이라고 예상했지만, 이상하게 문자열이 들어가있으며 심지어 그 문자열을 서로 곱하는 연산을 취하고 있다. 정말로 이상한 의미를 지니고 있다. 위와 같은 예제로 보아 문법과 더불어 의미를 지켜가며 코딩을 해야만 한다. 자바스크립트 브랜던 아이크가 개발한 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량의 프로그래밍 언어. 컴파일이 실행되는 언어가 아닌 브라우저에서 즉시 통역하는 인터프리터 언어이다. 브라우저들만의 특징을 이용하여 인터프리터의 단점인 느린속도를 조금이나마 보안하였고, 명령형, 함수형, 프로토기반 객체지향 프로그램을 내포하는 멀티 패러다임 프로그래밍 언어(프로토타입 기반의 객체 지향 언어) 자바스크립트 와 ECMAScript자바스크립트는 ECMAScript보다 더 큰 개념이다. ECMAScript에서 설계되어있는 모든 문법 규정들을 포함한 언어를 JavaScript 라고 한다. ECMAScript는 스크립트 언어가 준수해야 하는 규칙, 세부 사항 및 지침을 제공한다. 자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대(core)를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, Ajax 자바스크립트를 이용해서 서버와 브라우저가 비동기적으로 데이터를 교환할 수 있는 통신기능. 이전의 웹 페이지는 서버로부터 HTML을 전달받아서 웹페이지를 전체적으로 렌더링 하는 방식이었다. 따라서 화면 내부에 있는 사소한 움직임까지도 전부 서버로부터 HTML에게 전달받아서 웹페이지를 다시 렌더링해야되는 정말로 불편한 구조였다. Ajax의 등장은 이러한 부분을 크게 해소하였다. 페이지 전체를 렌더링하지 않고 필요한 부분만 다시 그리는 방식이 가능해진것이다. 또한 데스크탑 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환까지 가능하게되면서 기존의 패러다임을 크게 부셔주는 역할을 하였고 이는 자바스크립트에 대한 인식을 바꿔주는 큰 계기가 되었다. jQuery DOM 을 보다 쉽게 제어가 가능하고 , 크로스 브라우징을 해결해주는 라이브러리. 등장 당시에는 크로스브라우징 이슈 , 자바스크립트의 러닝 난이도 해소등의 이유로 인해 정말로 많이 사용되었던 기술이지만, 현재는 점점 사용률이 줄어들고 있는 추세이다. 이유는 예전에는 HTML이 바뀌게 되면 javascript가 영향을 받게되었는데 현재에는 HTML이 바뀌게 되면 javascript가 영향을 받지 않게되었다. ( Component Based Development 방법론 ) 하지만, CBD방법론은 보통 대규모 프로젝트나 큰 프레임워크( React.js , Vue.js , Angular.js )를 이용할때 사용하게된다. 따라서 소규모 프로젝트나 경험으로 해보기에는 매우 좋은 라이브러리. V8 자바스크립트 엔진 자바스크립트로 웹 애플리케이션을 구축하려는 시도가 늘어가면서 보다 빠르게 동작하는 자바스크립트 엔진이 요구됨. 따라서 구축된 것이 구글에서 개발한 V8 자바스크립트 엔진. Node.js 자바스크립트는 원래 웹 브라우저에서 작동을 한다. Node.js는 자바스크립트가 웹브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되게 하는 범용 프로그래밍 언어. SPA 프레임워크 Single Page Application 의 줄임말, 진짜 말그대로 .html 페이지가 단 1개만 존재하며 필요한 구성부분을 모두 Component로 제작하여 사용한다. 이는 재사용성에 큰 기여를 한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm02","slug":"daily-algorithm02","date":"2019-10-01T05:56:06.000Z","updated":"2019-10-01T05:59:17.765Z","comments":true,"path":"2019/10/01/daily-algorithm02/","link":"","permalink":"http://yoursite.com/2019/10/01/daily-algorithm02/","excerpt":"","text":"문제 출저 : 프로그래머스 서울에서 김서방 찾기문제 설명String형 배열 seoul의 element중 Kim의 위치 x를 찾아, 김서방은 x에 있다는 String을 반환하는 함수, solution을 완성하세요. seoul에 Kim은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다. 제한 사항 seoul은 길이 1 이상, 1000 이하인 배열입니다. seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다. Kim은 반드시 seoul 안에 포함되어 있습니다. 입출력 예 seoul return [Jane, Kim] 1234567891011121314function solution(seoul) &#123; var answer = ''; var seoul_array_num = 0; for(var i=0;i&lt;seoul.length;i++)&#123; if(seoul[i] == \"Kim\")&#123; seoul_array_num = i; break; &#125; &#125; answer = \"김서방은 \" + seoul_array_num + \"에 있다\" return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm01","slug":"daily-algorithm01","date":"2019-09-30T10:38:58.000Z","updated":"2019-09-30T10:40:43.593Z","comments":true,"path":"2019/09/30/daily-algorithm01/","link":"","permalink":"http://yoursite.com/2019/09/30/daily-algorithm01/","excerpt":"","text":"문제 출저 : 프로그래머스 체육복문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 123456789101112131415161718192021222324252627function solution(n, lost, reserve) &#123; var answer = n-lost.length; var temp_value = 0; var lost_value = 0; for(var i=0;i&lt;reserve.length;i++)&#123; for(var j=0;j&lt;lost.length;j++)&#123; if(reserve[j]-1 == lost[i])&#123; lost_value++; temp_value++; break; &#125; if(reserve[j]+1 == lost[i])&#123; lost_value++; temp_value++; break; &#125; &#125; if(temp_value==lost.length)&#123; break; &#125; &#125; answer = answer + lost_value; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"linux-study-03","slug":"linux-study-03","date":"2019-09-30T10:26:04.000Z","updated":"2019-10-02T09:04:55.015Z","comments":true,"path":"2019/09/30/linux-study-03/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-03/","excerpt":"","text":"프로세스 cpu - processor (process X) ram - memory hdd, sdd - storage *각 특징 : * Storage : 가격이 싸고, 용량이 크다. 속도가 느리다 Memory : 가격이 비싸고 , 용량이 작다. 속도가 빠르다 processor : 기격이 매우비싸고, 용량이 매우작고, 속도가 매우빠르다 프로세스 관련 명령어 프로세스 리스트를 확인하는 명령어 : ps 백그라운드에서도 돌아가는 ps까지 확인하는 방법 : ps aux 이 중 특정 이름의 프로그램을 찾고싶다 -&gt; : ps aux | grep apache 프로세스를 끄는 방법 sudo kill [process-ID] 프로세스 리스트를 확인하는 명령어1 : top 프로세스 리스트를 확인하는 명령어2 : htop (별도 설치해야됨) 그 외 명령어 및 개념멀티 태스킹 : 여러개의 일을 하나의 화면에서 할 수 있다. 백그라운드로 멈추어서 보내는법 : ctrl + z 백그라운드에 실행되는 상태로 보내는법 : 명령어 맨뒤에 &amp;를 넣어준다. ex) ls -la &amp; 포그라운드로 가져오는법 : fg jobs : 백그라운드에서 실행 중인 프로그램 확인. +표시 : 백그라운드로 물러나있다가 포그라운드로 들어오는 프로그램 -표시 : +로 된 백그라운드가 끝나고나서 실행될 프로그램 백그라운드 종료 : kill %[번호] 백그라운드 강제 종료 : kill -9 %[번호] 항상 실행 - DemonWeb server = Demon 데몬은 /etc/init.d에 위치해 있다. 데몬을 키는방법은 sudo service [파일명] start ex) sudo service apache2 start 데몬을 끄는방법은 sudo service [파일명] stop ex) sudo service apache2 stop 데몬이 자동으로 실행되는 경우를 확인하는방법 아래 위치의 폴더에서 확인 가능하다. /etc/rc3.d -&gt; CLI방식 /etc/rc5.d -&gt; GUI방식 rc3.d로 cd S02apache2 S는 리눅스가 실행되면 실행된다. 는 것을 의미. 02는 우선순위 자동 데몬을 만들려면 실행시키고 싶은 프로그램을 rc3.d 혹은 rc5.d 폴더에 규칙대로 파일명을 생성하고 링크를 걸어준다. CRONCRON : 정기적으로 실행시키는 도구 crontab -e: 하고자 하는 일을 정의. [실행되는 분의주기 */1 = 1분에 한번 ] [실행되는 시간 *=상관없음] [실행되는 일] [실행되는 월] [실행되는 요일] [실행될 명령어] date &gt;&gt; date.log = 현재시각을 게속 저장함 crontab -e */1 * * * * date &gt;&gt; date.log 2&gt;&amp; 의미 : 1분마다 date라는 명령어의 결과를 date.log에 저장하는데 만약 에러가 나면 표준출력으로 redirection나게한다. 쉘이 실행될때 /bin/bash/.bashrc라는 파일을 실행되도록 설정되어있음. 따라서 쉘이 시작할때 무언가를 하고싶다면 .bashrc 안에서 설정해주면됨. 다중사용자명령어 id -&gt; 나는 누구인가? 명령어 who -&gt; 현재 시스템에 누가 접속해있는가? 유닉스의 계열의 2가지형태의 사용자 super(root) user 일반 user super(root) user sudo는 슈퍼유저의 권한을 빌려오는것 $표시 현재 사용자가 일반유저라는것을 의미, 슈퍼유저는 # *명령어 su * su - root : 슈퍼 유저로 사용자 변경 슈퍼유저에서 빠져나가는법 exit. sudo passwd -u root : root에 대해 lock을 풀어버림. sudo passwd -l root : root에 대해 lock을 걸어버림. cd : 최상위 디렉토리 cd /root : 최상위 디렉토리 안에 있는 root디렉토리 사용자 추가useradd -m 사용자명 : 처음, 사용자를 추가하면 passwd를 설정해야함. sudo passwd 사용자명 sudo usermod -a -G sudo 사용자명 권한 변경하는법chmod o-r 파일명 : other에 대한 파일권한중 읽기를 뼴 chmod o+r 파일명 : other에 대한 파일권한중 읽기를 추가해줌. chmod o+w 파일명 : other에 대한 파일권한 쓰기를 추가해줌. chmod u-r 파일명 : 소유자에 대한 읽기권한을 뺴버림. directory 권한r = 해당 폴더의 내용을 확인 w = 해당 폴더의 내용물에 파일생성등등 x = 해당 폴더의 접근.(cd) chmod -R o+w [폴더명] : 해당 폴더와 폴더내에잇는 모든 파일들 권한을 변경함. 숫자 변경법chmod 444 perm.txt : perm.txt에 대한 권한을 모두 read로 변경 사칙연산법chmod a=rwx perm.txt : perm.txt에 대한 모든 사용권한을 오픈함.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux-study-02","slug":"linux-study-02","date":"2019-09-30T08:23:37.000Z","updated":"2019-10-02T09:04:50.136Z","comments":true,"path":"2019/09/30/linux-study-02/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-02/","excerpt":"","text":"[Input/Output] IO Redirection Output : 출력 redirection -&gt; 출력위치를 변경할 수 있다. (보통은 모니터)​ 예) ls -l &gt; result.txt = ls -l의 결과(Standard Output)를 result.txt에 저장한다. ​ 총 2가지의 Output 이 존재한다. Success : 성공했을 경우의 Output Error : 실패했을 경우의 Output Standard Output으로 redirection 하는 방법 : 1&gt; Error Output으로 redirection 하는 방법 : 2&gt; ex) rm rename2.tex 1&gt;result.txt 2&gt;result.txt Input : 입력 redirectionStandard Input : keyboard 예) hello.txt 안에는 hello 라는 텍스트가 저장되어있다. 만약에 hello.txt파일 안의 내용을 cat으로 출력하고 싶다면 다음과 같이 작성한다. cat &lt; hello.txt cat hello.txt IO Redirection Ouput Appendls -al &gt; result.txt 할 경우 result.txt로 결과가 저장된다. 그 후 ls -a &gt; result.txt할 경우 result.txt로 결과가 덮어씌우게 된다 만약 추가를 하고 싶다면 다음과 같이 사용해야만 한다. ls -al &gt;&gt; result.txt","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux-study-01","slug":"linux-study-01","date":"2019-09-30T06:44:47.000Z","updated":"2019-10-02T09:04:40.396Z","comments":true,"path":"2019/09/30/linux-study-01/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-01/","excerpt":"","text":"리눅스 명령어 리눅스의 특징 : command line interface ls : 파일보기 ​ 옵션 -l : 파일권한, 소유자,생성시간등의 자세한 정보를 추가로 나열해준다. pwd : 현재 놓여있는 디렉토리를 파악한다. mkdir : 폴더생성 touch [파일명] : 파일생성 cd [디렉토리명] : 현재 디렉토리 위치 변경 ​ 디렉토리 변경시 2가지 방법이 있다. 절대경로 예) cd /home/ubuntu. =&gt; / : root를 의미한다. 상대경로 예) cd .. =&gt; 상대경로는 내 위치에 따라서 위치를 조정하는것. rm [파일 명] : 파일 삭제 명령어 rm -r [파일명] : 폴더 삭제 명령어 모든 명령어 뒤 –version : 해당 명령어의 버전을 알려준다. 모든 명령어 뒤 –help : 명령에 무슨 옵션이 있는지, 어떠한 기능을 하는지 설명 도움말을 보여준다. man [명령어명] : 예) man ls man 내부 상세 단어 검색 : 예) /sort : sort라는 단어 검색 -&gt; 넘기는 방법은 n키 누르면 됨. 돌아가는 방법은 b키 누르면 됨. man과 –help의 차이 : help는 간결하게 명령어의 기능및 옵션 / man은 상세하게 보여준다. mkdir -p [파일명] : 예) mkdir -p dir1/dir2/dir3/dir4 -&gt; 부모 디렉토리를 만들수 있다. 옵션 -는 축약형 –는 기본형 ex) mkdir -p / mkdir –parent 숨긴파일은 파일명 앞에 . 이 붙는다. 숨긴파일을 보는 방법은 ls -a / ls –all 옵션으로 보면 된다. mv [원본파일] [이동위치 또는 변경할 파일명] cp [원본파일] [대상위치] 명령어 검색방법구글에서 검색한다. 예) 구글에서 create a directory in linux sudo : 임시로 권리자 권한을 빌려온다. sudo는 super user do 의 약자로 권리자 권한을 의미함. 제일 심각한 명령어 : sudo rm -rf / =&gt; 묻지도 따지지않고 루트디렉토리 전부 삭제 sudo [command] 권한만 빌림. su - : root계정으로 전환함. Package manager ( 리눅스 apt / yum)​ 보통 권한이 필요하기 때문에 sudo를 사용해야만 한다. sudo apt-get update : 현재 사용할 수 있는 패키지들의 목록을 최신상태로 업데이트한다. sudo apt-get install [패키지명] : 패키지를 다운로드 받는다. sudo apt-get upgrade [패키지명] : 패키지를 최신상태로 업데이트 한다. 패키지명 생략시 모든 패키지를 업데이트 한다. sudo apt-get remove [패키지명]: 패키지를 삭제한다. sudo apt-cache search [패키지명]: [패키지명]와 관련된 패키지 목록을 보여준다. homebrew ( 맥용 )​ 맥에서 주로 사용하는 패키지 매니저 brew search [패키지명] : [패키지명]과 관련된 패키지 목록을 보여준다. brew install [패키지명] : [패키지명]과 관련된 패키지를 다운받는다. brew list : 로컬에서 homebrew를 통해 설치한 패키지목록을 표시해준다. brew uninstall [패키지명] : [패키지명]을 삭제한다. brew upgrade [패키지명] : [패키지명]을 업데이트한다. brew update : homebrew로 사용가능한 패키지들의 목록을 업데이트한다. 리눅스 명령어 기반에서 다운로드 받는 방법 : wget​ 다운로드 받을 프로그램이 필요하다. ( wget 이용 ) wget url주소 : 파일명 그대로 받게됨. wget -O [파일명] url주소 오픈소스 다운로드 방법 : git​ 맘에 드는 git 주소 들어가서 git clone~","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"VSCode-hotkey","slug":"VSCode-hotkey","date":"2019-09-30T06:44:10.000Z","updated":"2019-10-02T09:55:13.826Z","comments":true,"path":"2019/09/30/VSCode-hotkey/","link":"","permalink":"http://yoursite.com/2019/09/30/VSCode-hotkey/","excerpt":"","text":"VS 단축키(MAC은 command = ctrl / option = alt) shift + option + f : 전체 줄 정리 option + command + 화살표 : 다중 커서 라인 생성 option + command + g : 개별 약어 랩핑 ctrl + n : 파일 생성 ctrl + s : 저장 ctrl + b : 사이드 바 열기 ctrl + p : 시작 팔레트 ctrl + shift + P : 명령 팔레트 ctrl + shift + k : 그 줄 삭제 ctrl + F : 찾기(검색) ctrl + H : 찾기(검색)/바꾸기(대체) ctrl + / : 주석 Alt + Up : 해당 코드 줄 위로 이동 Alt + Down : 해당 코드 줄 아래로 이동 shift + alt + DownArrow : 아래 줄 복사 tab : 들여쓰기 shift + tab : 내어쓰기 ctrl + PageUp : 이전 편집기 열기(좌측 창으로 전환) ctrl + PageDown : 다음 편집기 열기 (우측 창으로 전환) ctrl + \\ : 편집기 분할(백슬래쉬) ctrl + 숫자 : 숫자 번째 분할된 편집기 그룹에 포커스 ctrl + W : 편집기 닫기 ! + enter : 기본적인 HTML","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"http://yoursite.com/categories/Develop/Tips/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"CSS-inline-block","slug":"CSS-inline-block","date":"2019-09-30T06:43:15.000Z","updated":"2019-10-02T09:57:13.981Z","comments":true,"path":"2019/09/30/CSS-inline-block/","link":"","permalink":"http://yoursite.com/2019/09/30/CSS-inline-block/","excerpt":"","text":"inline-block 특징 inline-block 끼리 나열할 경우 문제가 없다. 또한 inline-block은 서로간에 약간의 틈이 존재한다. 1234567891011121314151617&lt;style&gt; .test1&#123; display: inline-block; background: gold; width: 300px; height: 300px; &#125; .test2&#123; display: inline-block; background: silver; width: 300px; height: 300px; &#125;&lt;/style&gt;&lt;div class=\"test1\"&gt;&lt;/div&gt;&lt;div class=\"test2\"&gt;&lt;/div&gt; inline-block 끼리 나열 중 한 요소안에 또 다른 inline-block 요소가 나오면 레이아웃이 깨져버린다. 1234567891011121314151617181920212223242526272829&lt;/style&gt; .test1&#123; display: inline-block; background: gold; width: 300px; height: 300px; &#125; .test2&#123; display: inline-block; background: silver; width: 300px; height: 300px; &#125; .test2-test&#123; display: inline-block; background:lime; width: 20px; height: 100px; &#125;&lt;/style&gt; &lt;div class=\"test1\"&gt;&lt;/div&gt; &lt;div class=\"test2\"&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;/div&gt; 이럴 경우 각 부모 div에게 vertical-align 속성을 주어야 해결이 가능하다. 123.test1, .test2 &#123; vertical-align: top; &#125;","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"CSS","slug":"Develop/CSS","permalink":"http://yoursite.com/categories/Develop/CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"inline-block","slug":"inline-block","permalink":"http://yoursite.com/tags/inline-block/"}]},{"title":"html-css-study-13","slug":"html-css-study-13","date":"2019-09-28T08:01:51.000Z","updated":"2019-10-02T09:03:40.724Z","comments":true,"path":"2019/09/28/html-css-study-13/","link":"","permalink":"http://yoursite.com/2019/09/28/html-css-study-13/","excerpt":"","text":"HTML Study 13 css : filter ( 흑백처리 , blur 효과 등등 ) tab-index margin 겹침 현상 background size 중앙 정렬 처리하는 방법 (수직 정렬등) aria-label , aria-labelby ( vs title ) aria-expended , aria-haspopup iframe 사용시 주의점 fr 단위 반응형 디자인을 할때는 px보다는 em, rem같은 단위를 써야 유연해지기에 좋다. grid에서는 fr단위로 쉽게 조절이 가능하다. 수직중앙정렬시 translateY : -50%를 이용한다. iframe은 퍼올때부터 대부분 사이즈가 지정이 되어있으므로 유동적인 사이즈를 맞추려면 div로 한번더 감싼다. css : filter ( 흑백처리 , blur 효과 등등 ) filter 기능은 이미지를 흑백처리하거나 blur, 반전, 밝기 조절등의 효과를 넣는 것을 말한다. 포토샵만큼 디테일하게 효과를 줄 수는 없으나, CSS로 간단한 효과정도는 줄 수 있다. 12345678910/* 사용 방법 : 선택자 &#123;filter:효과이름(값)&#125; */ .blur &#123;filter:blur(20px);-webkit-filter:blur(20px);&#125; .grayscale &#123;filter:grayscale(100%);-webkit-filter:grayscale(100%);&#125; .sepia &#123;filter:sepia(100%);-webkit-filter:sepia(100%);&#125; .saturate &#123;filter:saturate(10);-webkit-filter:saturate(10);&#125; .hue-rotate &#123;filter:hue-rotate(100deg);-webkit-filter:hue-rotate(100deg);&#125; .invert &#123;filter:invert(10);-webkit-filter:invert(10);&#125; .opacity &#123;filter:opacity(0.5);-webkit-filter:opacity(0.5);&#125; .brightness &#123;filter:brightness(5);-webkit-filter:brightness(5);&#125; tab-index 처리 div, span 와 같은 focus 초점을 받지 못하는 요소나 혹은 foucs를 받는 요소에게 fouc를 빼앗는 역할을 부여 할 수 있다. tabindex=”1” : 문서 안에서 가장 먼저 초점을 받게 할 수 있다. (주의점 : 마크업 순서를 거스르기 때문에, autofocusr가 더 적합) tabindex=”0” : 키보드 초점을 받지 못하는 요소들( div, span 등등) 도 초점을 받도록 해준다. tabindex=”-1” : 키보드 초점을 받는 요소에게서 초점을 받지 못하도록 만든다. 123&lt;div class=\"test\" tabindex=\"0\"&gt; 초점을 받을 수 있게 된다.&lt;/div margin 겹침 현상 기본적으로 형제 사이에서 일어난다. (이 현상은 오직 세로 margin값에서 일어난다.) 부모 ~ 자식 간에서도 겹침 현상이 발생한다. (둘 중 하나 이상 inline block일때는 겹치지 않는다.) 이를 가장 쉽게 해결하는 방법은 부모에게 글자추가, border 혹은 padding,와 같은 시각적효과를 적용하면 해결된다. position:absolute / float / grid 와 같은 레이아웃 작업은 margin이 발생하지 않는다. background-size​ background에 url 형태로 이미지를 불러들였을 경우, 만약 이미지 크기가 맞지 않다면 background-size를 상자 크기에 맞게 조절하면 된다. ( 보통 100% 로 조절. ) 중앙 정렬 처리하는 방법가로 정렬은 보통 text-align , vertical-align 등을 통해 쉽게 배치가 가능하다. 하지만 가운데 정렬은 배치를 하기 위해서는 padding 값이나 margin값을 정적으로 계산해야만 한다. 하지만 위와 같은 방법을 이용한다면 쉽게 배치가 가능하다. 보통 absolute를 이용하여 많이 배치한다. 12345.header&#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; aria-label / aria-labelledbyaria-label 속성은 값에 ‘간결한’ 설명(string)을 직접 제공한다. 마치 해당 태그가 무슨 역할을 하는지 설명하듯 설명문을 적어주는것과 같다. 예를들면 다음과 같다. 12345&lt;!-- O: 참조할 설명이 없는 경우 --&gt;&lt;form&gt; &lt;input type=\"search\" aria-label=\"웹툰 검색\"&gt; &lt;button&gt;검색&lt;/button&gt;&lt;/form&gt; aria-labelledby 속성은 ID(s) 값을 이용하여 ‘간결한’ 내용을 참조(연결)하는 방식으로 설명한다. 보통 h1, h2, h3, h4, h5, h6, a, button 요소를 참조하면 적절하다. aria-label 속성과 함께 선언하는 경우 aria-labelledby 속성이 우선순위가 높기 때문에 보조기기는 aria-labelledby 속성을 설명한다. 예를들면 다음과 같다. 123456789101112&lt;!-- O: 설명 참조 --&gt;&lt;section aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;h2 id=\"LZ-PATH\"&gt;레진패스란?&lt;/h2&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/section&gt;&lt;!-- O: 잘못된 참조 --&gt;&lt;a id=\"LZ-PATH\" href=\"#LZ-PATH-TEXT\"&gt;레진패스란?&lt;/a&gt;&lt;!-- 숨긴처리된 설명은 참조해서는 안된다. --&gt;&lt;div id=\"LZ-PATH-TEXT\" aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/div&gt; aria-labelledby 속성으로 숨김 처리한 설명을 참조하면 안 됩니다. 참조가 불가능한 설명은 aria-label 속성을 사용한다. 자세한 설명을 참조하면 안 된다다. 자세한 설명은 aria-descibedby 속성을 사용. aria-expanded 애플리케이션에서 제공되는 메뉴가 하위 메뉴를 포함하고 있 을 경우 현재 하위 메뉴가 접힌 상태인지 펼쳐진 상태인지 스크린리더 사용자에게 정보를 제공 해야 할 경우가 있다. 이때 aria-expanded 속성을 사용하여 접힌 상태라면 false 값을 펼쳐진 상태라면 true 값을 지정할 수 있다. aria-haspopup레진 블로그 설명 aria-haspopup 속성은 요소에 연결되어 있는 팝업(메뉴, 대화상자 등) 정보를 제공한다. 팝업은 다른 내용 위에 표시하는 블럭을 의미한다. iframe 사용시 주의점 iframe 태그는 하나의 html 로 생각해야만 한다. 따라서 iframe 태그 자체를 width, height등을 이용해 유연한 배치를 할 수 없다. 만약에 iframe 의 크기를 조절하고 싶다면 div태그로 1번더 감싸야만 한다. 그리고서 해당 div에 absolute를 거는 방식을 이용한다. 12345678910111213141516171819202122232425&lt;style&gt; .responsive-container&#123; position: relative; width: 100%; height: 0 !important; &#125; .responsive-iframe&#123; position: absolute; top:0; left:0; width: 100%; height: 100%; border: 0 none; &#125; .responsive-iframe-43&#123; padding-top: 75%; &#125; .responsive-iframe-169&#123; padding-top: 56.25%; &#125;&lt;/style&gt;&lt;div class=\"responsive-container responsive-iframe-169\"&gt; &lt;iframe aria-labelledby=\"video-subject\" class=\"responsive-iframe\" src=\"https://www.youtube.com/embed/umfaXctbqOs\"allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt; fr 단위fr이란 유연한 크기를 갖는 단위이다.grid 컨테이너 내의 공간 비율을 분수(fraction)로 나타낸다. 다만, 지원 브라우저가 낮다. 사용자가 계산해야 할 부분을 fr을 통해서 쉽고 유연하게 사용할 수 있다. 1234.grid &#123; display: grid; grid-template-columns: auto 100px 1fr 2fr;&#125; 1번 열은 auto를 사용한다. 해당 Element 내부 콘텐츠에 맞게 사이즈가 조정된다. 2번 열은 100px을 할당한다. 100픽셀 크기만큼의 폭을 차지한다. 3번 열은 1fr 크기를 할당한다. 1fr이란 남은 자유 공간의 1/3(총fr)만큼의 크기를 할당한다. 4번 열은 2fr 크기를 할당한다. 2fr이란 남은 자유 공간의 2/3(총fr)만큼의 크기를 할당한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-12","slug":"html-css-study-12","date":"2019-09-24T16:56:09.000Z","updated":"2019-10-02T09:03:46.859Z","comments":true,"path":"2019/09/25/html-css-study-12/","link":"","permalink":"http://yoursite.com/2019/09/25/html-css-study-12/","excerpt":"","text":"HTML Study 12 webfont 정리 flex 재정리 white-space 속성 - pre , pre-wrap, pre-line 프로젝트 하면서 느낀점 9월 24일 webfont 정리 웹폰트를 사용하기 위해서는 다음과 같은 코드들이 일부 필요하다. 123456789101112131415@font-face &#123; font-family: NanumSquareWeb; src: local(NanumSquareR), local(NanumSquare), url(NanumSquareR.eot?#iefix) format('embedded-opentype'), url(NanumSquareR.woff) format('woff'), url(NanumSquareR.ttf) format('truetype'); font-style: normal; font-weight: normal; unicode-range: U+0-10FFFF;&#125; h1 &#123; font-family: NanumSquareWeb, sans-serif;&#125; 내가 사용할 웹폰트 패밀리명을 NanumSquareWeb으로 하겠다. 라고 선언한 예이다. 반드시는 아니지만, font-family 명과 사용할 폰트명을 동일시하게 하는 것 이 좋다. 로컬에 이미 설치 된 폰트의 경로를 적는 local() 속성과 다운로드 할 웹폰트의 주소를 적는 url() 속성이다. 위 코드는 local(NanumSquareR) → local(NanumSquare) → url(NanumSquareR.eot) → url(NanumSquareR.woff) → url(NanumSquareR.ttf) 순으로 폰트를 찾는다. format 속성을 사용하면 브라우저에서 지원 가능한 파일만 다운로드 받을 수 있습니다. 사용할 유니코드의 범위를 정한다. flex 재정리 (TCP 스쿨 내용 재정리)flex-direction 속성flex-direction 속성은 플렉스 컨테이너 안에서 플렉스 요소가 배치될 방향을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. row : 기본 설정으로, 플렉스 요소는 왼쪽에서 오른쪽으로, 그리고 위쪽에서 아래쪽으로 배치됩니다. row-reverse : 만약에 direction 속성값이 ltr(left-to-right)이면, 플렉스 요소는 반대로 오른쪽에서 왼쪽으로 배치됩니다. column : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 위쪽에서 아래쪽으로 배치됩니다. column-reverse : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 아래쪽에서 위쪽으로 배치됩니다. justify-content 속성justify-content 속성은 플렉스 요소의 수평 방향 정렬 방식을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. flex-start : 기본 설정으로, 플렉스 요소는 플렉스 컨테이너의 앞쪽에서부터 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 뒤쪽에서부터 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에서부터 배치됩니다. space-between : 플렉스 요소는 요소들 사이에만 여유 공간을 두고 배치됩니다. space-around : 플렉스 요소는 앞, 뒤, 그리고 요소들 사이에도 모두 여유 공간을 두고 배치됩니다. align-items 속성align-items 속성은 플렉스 요소의 수직 방향 정렬 방식을 설정합니다. 이 속성은 한 줄만을 가지는 플렉스 박스에서는 효과가 없으며, 두 줄 이상을 가지는 플렉스 박스에서만 효과가 있습니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 요소의 높이가 플렉스 컨테이너의 높이와 같게 변경된 뒤 연이어 배치됩니다. flex-start : 플렉스 요소는 플렉스 컨테이너의 위쪽에 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 아래쪽에 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에 배치됩니다. baseline : 플렉스 요소는 플렉스 컨테이너의 기준선(baseline)에 배치됩니다. flex-wrap 속성flex-wrap 속성은 플렉스 라인에 더 이상의 여유 공간이 없을 때, 플렉스 요소의 위치를 다음 줄로 넘길지를 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. nowrap : 기본 설정으로, 플렉스 요소가 다음 줄로 넘어가지 않습니다. 대신에 플렉스 요소의 너비를 줄여서 한 줄에 모두 배치시킵니다. wrap : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. wrap-reverse : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. 단, 아래쪽이 아닌 위쪽으로 넘어갑니다. align-content 속성align-content 속성은 flex-wrap 속성의 동작을 변경할 수 있습니다. 이 속성은 align-items 속성과 비슷한 동작을 하지만, 플렉스 요소를 정렬하는 대신에 플렉스 라인을 정렬합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 라인의 높이가 남는 공간을 전부 차지하게 됩니다. flex-start : 플렉스 라인은 플렉스 컨테이너의 앞쪽에 뭉치게 됩니다. flex-end : 플렉스 라인은 플렉스 컨테이너의 뒤쪽에 뭉치게 됩니다. center : 플렉스 라인은 플렉스 컨테이너의 가운데에 뭉치게 됩니다. space-between : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. space-around : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. 단, 양쪽 끝에 약간의 공간을 남겨둡니다. 플렉스 요소(flex item)의 flex 속성flex 속성을 이용하면 같은 플렉스 컨테이너 안에 있는 플렉스 요소의 너비를 상대적으로 설정할 수 있습니다. 다음 예제에서 첫 번째 플렉스 요소는 전체 너비의 3/5을 차지하며, 나머지 두 요소는 각각 전체 너비의 1/5씩을 차지하게 됩니다. 123.item:nth-child(1) &#123; -webkit-flex: 3; flex: 3; &#125;.item:nth-child(2) &#123; -webkit-flex: 1; flex: 1; &#125;.item:nth-child(3) &#123; -webkit-flex: 1; flex: 1; &#125; white-space 속성 - pre , pre-wrap, pre-line normal : 기본값. 공백을 여러개 넣어도 공백 1개만 인정. 자동줄바꿈. nowrap : 공백 1개만 인정. 텍스트가 길어도 줄바꿈이 안됨. pre : 공백을 마크업 그대로 표시. 코드에 줄바꿈이 없다면 줄바꿈이 안됨. pre-wrap : 공백을 마크업 그대로 표시함. 코드에 줄바꿈이 없어서 코드따라 줄바꿈됨. pre-line : 공백을 여러개 넣어도 1개만 표시. 코드에 불바꿈이 없어도 자동 줄바꿈이 됨. 프로젝트 하면서 느낀점 9월 24일 내가 모르는 태그들이 정말로 많다. layout 작업시 큰 틀에 대한 width를 전부 지정해주어야한다. 작은 틀을 맞추고 싶다면 width값을 100%로 큰틀에 대해 맞춘다. 최대한 그려가면서 레이아웃 작업을 진행해야 될 것 같음. 조언을 아끼지 말아라. (구하는 조언도, 모르는 조언도) 남들보다 1개더 안다면 1개더 배풀고 더 모른다면 알 떄까지 노력할 것. 암기보다 이해가 먼저고 이해가 정 안될 경우 암기한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-11","slug":"html-css-study-11","date":"2019-09-23T17:25:10.000Z","updated":"2019-10-02T09:03:30.957Z","comments":true,"path":"2019/09/24/html-css-study-11/","link":"","permalink":"http://yoursite.com/2019/09/24/html-css-study-11/","excerpt":"","text":"HTML Study 11 fontello 사용법 letter, word spacing transition 사용 주의점 프로젝트 하면서 느낀점 9월 23일 fontello 사용법 fontello 사용법 fontello 접속 마음에 드는 fontello 아이콘들 선택(라이센스 주의) 다운로드 다운로드 된 압출파일을 해제 해제된 폴더를 프로젝트에 붙여넣는다.(가급적이면 폴더 네임수정 - 지저분함) CSS파일에 다음과 같이 넣어준다. 12345678@import url('./fontello/css/fontello.css'); /*import*//*사용 방법*/.header::after&#123; content: '\\e805'; font-family: \"fontello\";&#125; letter , word spacing 글자 사이의 간격은 letter-spacing으로, 단어 사이의 간격은 word-spacing으로 정한다. 값이 커지면 간격이 커진다. 값에는 음수를 넣을 수 있다. ( 마이크로소프트 엣지나 인터넷 익스플로러에서는 단어 사이의 간격을 음수로 정해도 글자가 겹치지 않을 정도로만 간격이 줄어든다.) 음수를 값으로 하는 경우 글자가 겹칠 수 있다. 글자 사이의 간격을 변화시키면 단어 사이의 간격도 변한다. 단어 사이의 간격을 변화시켜도 글자 사이의 간격은 변하지 않는다. transition 사용 주의점​ transition 사용시 초(s) 단위를 붙일 경우, 0일떄 s를 생략하면 작동을 안한다. ​ 꼭 유의 하고 사용할 것. 프로젝트 하면서 느낀점 막히면 차분히 무엇이 문제인지 돌아보고 꼭 구조적으로 해결하기 보다는 작은부분부터 수정해 나가기. 개발 도중 정적이니 동적이니 반응형이니 고정형이니 생각하지 말고 현재 주어진 디자인만 생각하기. 레이아웃 설계는 가능한 그리면서 진행하기. (나중에 레이아웃을 뒤엎는 경우가 생긴다.) flex , float , absolute , grid 특성에 대해서 다시 한번 공부하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"CSS-Selector-Organize","slug":"CSS-Selector-Organize","date":"2019-09-22T16:12:32.000Z","updated":"2019-10-02T09:57:06.531Z","comments":true,"path":"2019/09/23/CSS-Selector-Organize/","link":"","permalink":"http://yoursite.com/2019/09/23/CSS-Selector-Organize/","excerpt":"","text":"CSS 선택자 정리 Etc 참고 : CSS 선택자 총 정리 사이트","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"CSS","slug":"Develop/CSS","permalink":"http://yoursite.com/categories/Develop/CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://yoursite.com/tags/Selector/"}]},{"title":"html-css-study-10","slug":"html-css-study-10","date":"2019-09-21T10:58:02.000Z","updated":"2019-10-02T09:03:21.734Z","comments":true,"path":"2019/09/21/html-css-study-10/","link":"","permalink":"http://yoursite.com/2019/09/21/html-css-study-10/","excerpt":"","text":"HTML Study 10 viewport VS % calc flex-basis 반응형 웹페이지 flex 이용 반응형 콘텐츠 -&gt; 이미지&amp;비디오 , iframe grid 이용 오늘의 학습 깨달음 레이아웃 구성 시 여라가지 flex 나 grid시스템을 사용할 수 있지만, 브라우저의 지원 유형을 잘 생각해보아야 한다. padding의 %는 width 기준이다. 즉, 가로의 %기준 만큼 패딩이 늘어난다. iframe은 이미지처럼 max-width 옵션이 작동안한다. 최대 넓이가 1600px 이상 넘어갔을 경우 화면 중앙으로 오게하는 방법 12max-width: 1600px;margin: 0 auto; viewport VS % viewport 는 화면대비 %비율이라 생각하면 편하고, %는 부모영역대비의 %비율이라 생각하면 편하다. 한, 예로 %는 부모영역보다 크게 %를 주어도 부모영역을 벗어날수는 없지만 viewport는 자식요소에 더 큰 viewport값을 줄 경우 부모요소를 넘어갈 수 있다. 초록색 영역이 %비율이고, 보라색 영역이 viewport 이다. calc 단순하게 생각하여, 사칙연산을 실행하고 계산값을 돌려주는 함수이다. calc(100vh - 100px); 와 같이 사용한다. flex-basis flex item이 된 컨텐츠들에게 적용할 수 있는 flex속성이다. flex-basis각 적용될 경우 기본 width값은 무의미하다. flex item이 적용된 width , height를 사용하고 싶다면 flex:auto 를 지정해주어야한다. flex-basis를 생략해면 flex-basis:auto 가 된다. flex-basis:0 과 flex-basis:auto의 차이는 auto는 width 만큼 item을 관리하며, flex-basis는 진짜 item 사이즈를 0으로 만든다. 단, 텍스트같은 콘텐츠가 있을 경우 콘텐츠 크기 만큼 줄게된다. flex-grow는 기본값이 0 / flex-shrink는 기본값이 1이다. 반응형 웹페이지 반응형 웹페이지는 말 그대로 유동적으로 변화가 가능한 웹페이지를 의미한다. 현재 시대는 모바일 , 테블릿 , 데스크탑 과 같은 여러가지 화면을 다루고 있기 때문에 유동적으로 각 기기에 맞는 화면을 송출할 줄 알아야만 한다. 반응형 웹페이지 제작시 주로 다음과 같이 이용한다. @media screen and (길이){ ​ 변할값 } 123456@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; width : 850px; &#125;&#125; 위 웹페이지의 fontsize가 16px이라 가정을 지었을 경우. 799px에서 800px로 넘어가는 순간 header 부분의 width가 850px로 넘어간다. 보통의 웹페이지는 flex,grid같은 시스템을 이용하여 min-width:800px (50em) / min-width:1024px (64em) / min-width:1600px (100em) [font-size : 16px기준] 로 설정해서 반응형을 많이 구축한다. flex 이용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* 모바일 스타일 */ /* 모바일 헤더 */ .header&#123; /* grow shrink basis */ flex-basis: 100%; height: 50px; &#125; /* 모바일 네비게이션 */ .navigation&#123; height: 50px; flex-basis: 100%; &#125; /* 모바일 메인 콘텐츠 */ .main-content&#123; height: calc(100vh - 200px); flex-basis: 100%; &#125; /* 모바일 광고 */ .ad&#123; flex-basis: 100%; height: 50px; &#125; /* 모바일 푸터 */ .footer&#123; flex-basis:100%; height: 50px; &#125;/* 테블릿 스타일 *//* 50em -&gt; 50글자까지 , 폰트사이즈 16px일경우 800px까지 */@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; flex-basis: 70%; &#125; /* 800 네비게이션 */ .navigation&#123; flex-basis:30%; &#125; /* 800 메인 콘텐츠 */ .main-content&#123; flex-basis:100%; height: calc(100vh - 150px); &#125; /* Tablet 레이아웃 순서 */ .header, .navigation, .ad&#123; order: -1; &#125;&#125;/* 랩탑 스타일 */@media screen and (min-width:64em)&#123; /* 랩탑 순서 */ .navigation&#123; order: -2; &#125; /* 랩탑 헤더 */ .header&#123; flex-basis: 100%; &#125; /* Laptop 내비게이션 */ .navigation&#123; flex-basis: 100%; &#125; /* 랩탑 메인 콘텐츠 */ .main-content&#123; flex-basis: 70%; &#125; /* 랩탑 광고 */ .ad&#123; flex-basis: 30%; height: calc(100vh - 150px); &#125;&#125;/* 와이드 랩탑 스타일 */@media screen and (min-width:100em)&#123; /* 와이드 랩탑 헤더 */ .navigation, .ad&#123; order: 0; &#125; .navigation, .main-content, .ad&#123; height: calc(100vh - 100px); &#125; /* 와이드 네비게이션 */ .navigation&#123; flex-basis: 30%; &#125; /* wide 메인 콘텐츠 */ .main-content&#123; flex-basis: 50%; &#125; /* wide 광고 */ .ad&#123; flex-basis: 20%; &#125;&#125; 반응형 콘텐츠 : 이미지&amp;비디오이미지 소스(비디오도 동작방식은 같다.) 1234567891011121314151617181920@charset \"utf-8\";/* 반응형 이미지 */.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; flex-basis: 50%; border: 10px solid #aaa; box-sizing: border-box; margin: 0; padding: 0;&#125;.rwd-img&#123; max-width: 100%; height: auto;&#125; 반응형 콘텐츠 : iframeiframe은 비디오와는 다르게 화면 비율에 대해 신경을 써주어야만 한다. 1234567891011121314151617181920212223242526 &lt;div class=\"container\"&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rNDmpbs4JTc\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\"width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nSHs3241p7E\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Vtj-T2c6jf0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/G-12mgNUwh0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233@charset \"utf-8\";.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; border: 10px solid teal; box-sizing: border-box; margin: 0; padding : 0; flex-basis: 30%; flex-grow : 1;&#125;.rwd-iframe-container&#123; width: 100%; padding-top: 56.25%; height: 0 !important; background: yellow; position: relative;&#125;.rwd-iframe&#123; /* iframe은 이미지처럼 max-width 옵션이 작동안한다. */ max-width: 100%; height: auto; position: absolute; top : 0; left : 0; width: 100%; height: 100%;&#125; grid 이용grid시스템 이용시 Chrome 보다는 firefox에서 확인한는게 더 편한다. 부모요소에서 display: grid; 를 쓰면서 시작할 수 있다. repeat함수 -&gt; repaet(반복할횟수, 크기[1 2) 크기 1개만 적을시 1개만 횟수만큼, 크기 1 2 다적을 시 배열식으로 적용한다.fr = fraction 분수단위 grid에서 순서를 지정해주고 싶다면 order를 쓰면 된다. 모든 기본 order값은 0이다. grid-auto-rows : 크기 / 콘텐츠 갯수만큼 자동적으로 적은 크기의 행을 만들어준다. grid-template-columns : 크기 / 크기 갯수만큼 적어 열을 생성한다. grid-template-rows : 크기 / 크기 갯수만큼 적어 행을 생성한다. grid-column-gap: 크기 / 각 콘텐츠 사이에 적은 크기의 마진을 발생시킨다. 라인 넘버 지정방법. 123456789101112131415.container&#123; display: grid grid-template-columns: 1fr 3fr 1fr; /* 3개의 열을 각각 5분의 1,3,1크기로 선언한다. */ grid-template-rows: repeat(3, 50px); /* 3개의 행을 50px크기로 선언한다.*/ &#125; .header&#123; /* grid-row : 1/2; grid-column : 1/4; */ /* row시작점 column시작점 row끝나는점 column끝나는점*/ grid-area: 1/1/2/4; &#125; /* 위에 구문은 병합 span으로도 아래처럼 사용이 가능하다. */.header&#123; grid-ared : 1/1/span 1/span 3; &#125; area 지정방법. 123456789101112131415161718192021222324252627282930313233343536@media screen and (min-width:50em)&#123; .container&#123; margin : 0 auto; max-width: 1600px; grid-template-columns: 1fr 3fr 1fr; grid-auto-rows: minmax(50px,auto); /* 최소 높이 50px이고 글자(텍스트 -콘텐츠)가 늘어남에 따라 auto로 상자가 늘어남. */ /* 아래에서 grid-area: 이름 ; 으로 지정한 것을 grid-template-areas에 각각 넣어준다. */ grid-template-areas: \"header header header\" \"navigation content ad\" \"footer footer footer\"; &#125;&#125; .container&#123; display: grid;&#125;.header&#123; grid-area: header;&#125;.navigation&#123; grid-area: navigation;&#125;.content&#123; grid-area: content;&#125;.ad&#123; grid-area: ad;&#125;.footer&#123; grid-area: footer;&#125; gird 시스템 이용시 짧게 사용할 경우 area:이름 기법이 훨씬 간편하지만, 열과 행이 많을 경우에는 line기법이 수월하다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-09","slug":"html-css-study-09","date":"2019-09-19T17:38:10.000Z","updated":"2019-10-02T09:03:14.524Z","comments":true,"path":"2019/09/20/html-css-study-09/","link":"","permalink":"http://yoursite.com/2019/09/20/html-css-study-09/","excerpt":"","text":"HTML Study 09 q , blockqueto 태그 + cite 속성 small 태그 address 태그 flex 속기법 + order, grow , shrink flex-basis aside 태그 CSS animation : transition background 속기법 태그들이 공통으로 사용가능한 속성 오늘의 학습 깨달음 의미없는 구분자들은 마크업 하지 않는다. 만약 의미없는 img 태그들을 사용해야할 경우 alt값은 비워둔다 ( alt = “” ) img 태그를 사용할 것인지, 일반적인 태그를 이용하고 SEO적인 내용을 붙인 후 CSS 배경처리를 할 지 고민이 필요함. 사이트를 마무리하는 영역인 footer에서는 heading 태그를 사용하지 않는다. header 태그의 대신 역할 role=”banner” 와 footer 태그의 대신 역할 role=”content-info”등은 article 태그나 section태그 내에서 사용하면 안된다!!!! 반드시, body 태그의 직계 자식 요소로 사용되는 태그들의 역할 모델이 되어야만 한다. button 태그 사이의 띄어쓰기는 요소검사로 잡기 힘드니 button 태그가 나란히 사용되었을 때, 간격이 있다면 확인할 것. 레이아웃 작업 시, 가능한 노말플로우를 유지하라. 레이아웃 작업 시, 더 간단하고 쉽게 적용가능한 방법들을 모색하라. q , blockqueto 태그 인용임을 나타내는 태그에는 q와 blockquote가 있다. q는 문단 안에서 인용할 때 사용하는 인라인 요소이고, blockquote는 새로운 문단에서 인용하는 블록 요소 이다. 12345678q&#123; quotes: \"[[\" \"]]\"; &#125; /* 사용한 태그의 앞과 뒤에 [[ 과 ]] 이 생긴다.*//*혹은 한쪽만 선택하고 싶을경우 다음처럼도 이용함.*/q::after&#123; content: \"\";&#125; 인용문 출처는 cite 속성 을 이용한다. 1&lt;q cite=\"https://www.codingfactory.net/\"&gt;consectetur adipiscing&lt;/q&gt; small 태그 small 태그는 저작권, 면책조항, 주의사항, 법적 제한 사항, 주석표시에 사용한다. small 태그는 부가 정보를 나타내는 주석표시이므로, 여러 단락이나 광범위한 텍스트가 포함된 섹션에서는 사용하지 않는다. 1&lt;small class=\"copyright\"&gt; Copyright since &amp;copy; 2010 by Web Cafe &lt;/small&gt; address 태그 address는 소유자 또는 작성자의 연락처를 나타내는 태그. body 태그 안에 있으면 문서의 소유자 또는 작성자의 연락처를 나타냄. article 태그 안에 있으면 기사의 소유자 또는 작성자의 연락처를 나타냄. 기본 모양은 기울임꼴. 12345&lt;address class=\"address\"&gt; &lt;span&gt;서울시 강남구 성수동 &lt;/span&gt; &lt;span&gt;전화 : 02-1234-5678 &lt;/span&gt; &lt;span&gt;email : iasg2004@gmail.com&lt;/span&gt;&lt;/address&gt; &lt;!-- span을 준 이유 : 간격을 관리가 편해서 --&gt; flex 속기법 + order, grow , shrink flex : flex-grow flex-shrink flex-basis Flex 한국어 정리 사이트 order Item의 순서를 설정.Item에 숫자를 지정하고 숫자가 클수록 순서가 밀린다.음수가 허용. flex-grow Item의 증가 너비 비율을 설정.숫자가 크면 더 많은 너비를 가짐.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-shrink Item이 감소하는 너비의 비율을 설정.숫자가 크면 더 많은 너비가 감소.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-basisItem의 (공간 배분 전) 기본 너비를 설정.값이 auto일 경우 width, height 등의 속성으로 Item의 너비를 설정할 수 있다.하지만 단위 값이 주어질 경우 설정할 수 없다. 값 의미 기본값 auto 가변 Item과 같은 너비 auto 단위 px, em, cm 등 단위로 지정 flex 속성에서 설명한 것 같이 단축 속성 내에서 flex-basis를 생략하면 값이 0이 되는 것을 주의합시다. aside 태그&lt;aside&gt; 컨텐츠는 추가되어야 할 요소이지만, 메인 컨텐츠를 이해하기 위해 필수적인 것은 아니다. 예를 들어, 각주는 추가적인 정보를 제공하지만 필수적이지 않다. 그리고 발췌문은 필수적인 컨텐츠인 반면, 메인 컨텐츠에서 인용된 카피 문구이다. 하지만, &lt;aside&gt;는 관련성이 있어야 한다는 사실을 명심해야 한다. 사이트의 사이드바를 &lt;body&gt;의 자식요소로&lt;aside&gt;에 넣는 것은 좋다. 하지만 사이트 전반에 걸친 정보를 &lt;article&gt;의 자식요소로서 &lt;aside&gt; 안에 보여져서는 안되는 것. 그리고 &lt;aside&gt; 요소가 그 부모 섹셔닝 요소에 관련만 있으면, 광고에도 적합하다. 123456789&lt;aside&gt; &lt;p&gt; &lt;em&gt;섹셔닝 루트&lt;/em&gt; 요소에는 &lt;blockquote&gt;, &lt;body&gt;, &lt;details&gt;, &lt;fieldset&gt;, &lt;figure&gt;,&lt;td&gt;가 있다. &lt;/p&gt; &lt;/aside&gt; &lt;p&gt; &lt;header&gt;와 &lt;footer&gt;는 현재 속해 있는 섹셔닝 요소 또는 '섹셔닝 루트' 요소에만 적용된다.&lt;/p&gt; CSS animation : transition​ CSS transition은 :hover , :focus 와 같은 이벤트에 CSS 장면전환을 주기 위한 옵션이다. 12345678910.list&#123; transition : height 3s 0s, padding 3s 0s, background 2s 3s; /* 속성 지속시간 딜레이 */&#125;.list:hover, .list:focus&#123; padding : 10px; background: yellow; height : 100px;&#125; 위 구문은 list 클래스에 마우스가 올라가거나 , 키보드로 선택이 되었을 경우 3초에 동안 높이가 100픽셀 , 패딩이 10픽셀 늘어난다. 3초 기다린 후 2초동안 점점 노란색으로 배경색이 변경된다. background 속기법123456789101112/* background-image background-position [/background-size] repeat-style attachement box background-color */ h1 &#123; background: url('img.jpg') 0 50% /8em no-repeat fixed border-box blue; &#125;/* background-image repeat-style background-position attachement */ h2&#123; background: url(./images/bg_flower.png) no-repeat 50% 0 fixed, #eee linear-gradient(#ccc,#eee,#fff) repeat 0 0 fixed;&#125; /* 배경 이중 중첩, 먼저 나온 배경이 위로.*/ 태그들이 공통으로 사용이 가능한 속성 title id style class lang data-*","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-08","slug":"html-css-study-08","date":"2019-09-18T17:58:58.000Z","updated":"2019-10-02T09:03:05.164Z","comments":true,"path":"2019/09/19/html-css-study-08/","link":"","permalink":"http://yoursite.com/2019/09/19/html-css-study-08/","excerpt":"","text":"HTML Study 08 position : sticky / fixed counter cursor : pointer calc( ) 함수 tabindex 일자로 요소를 나열하는 4가지 방법( 크게 ) position : sticky / fixed레진 fixed/sticky 참고 sticky sticky는 평소에는 기본 상태였다가 스크롤을 내리면서 임계점에 다했을 시 fixed처럼 요소가 게속 남아있는 형태를 말한다. 필수로 top, right, bottom, left 속성이 필수이다. fixed fixed는 스크롤 유무에 관계의 상관없이 뷰포트에 고정을 하는 것이다. 다만, sticky는 브라우저의 제한이 걸려있다.(아래참조) sticky와 fixed의 차이점은 fixed는 스크롤의 상관없이 뷰포트 자리 고정!, sticky는 스크롤이 다야 적용이된다는 것이다. counter​ css로 요소에 일일이 접근하지 않고 연속적인 리스트등에게 일렬번호등을 붙일 수 있다. 예를들어보자, 1234567891011ol&#123; counter-reset: chapter 0; /* counter-reset으로 초가화 : 카운터명 증가값(생략시 1씩 증가,0도 1씩증가)*/&#125;ol li&#123; counter-increment : chapter;&#125;ol li::before&#123; content : counter(chapter);&#125; cursor여러가지 커서 모양들 cursor : pointer는 마우스가 올라갈시 a링크를 hover한것처럼 마우스 커서가 손가락 표시 모양으로 바뀌게 된다. 그외 추가적인 커서 모양들은 위 링크를 참조하라. calc( ) 함수calc( ) 관련 블로그 CSS3에 새롭게 추가된 기능 중 calc()라는 것이 있다. 계산을 해주는 속성인데 기존에 자바스크립트로 하던 계산을 상당 부분 덜어준다. 예를 들어, 모든 문단을 “100% 너비에서 20픽셀(px)만큼 뺀 너비”로 설정하고 싶다면 다음과 같이 작성한다. 123456p &#123; width : 95%; /* 구식 브라우저를 위한 대비책(fallback) */ width : -webkit-calc(100% - 20px); /* for Chrome, Safari */ width : -moz-calc(100% - 20px); /* for Firefox */ width : calc(100% - 20px); /* for IE */&#125; calc() 내부에 입력할 수 있는 표현식은 +, -, *, / 등의 사칙 연산이 가능하다. 주의할 부분은 사칙 연산시 + 또는 - 는 반드시 기호 양쪽으로 공백을 삽입해야 한다는 것. 속성에 따라 값이 - 로 내려갈 수도 없는 경우가 있다.( width : calc(5px - 10px); = width: 0px; ) tabindex어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법이다. 어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법으로 사용된다. 크게 3가지 속성값을 이용할 수 있다. 0 값 - tabindex=”0” 양수 - tabindex=”1~32768” 음수 - tabindex=”-1” 속성 값이 0인 경우는 탭을 눌렀을 때 포커스가 가지 않는 엘리먼트에게 포커스를 줄 수 있다. 예를 들어, div영역에도 포커스를 줄 수 있다는 의미이다. 속성 값이 -1인 경우는 반대로 탭을 눌렀을 때 포커스가 가는 엘리먼트에게 포커스를 잃게 할 수 있다. 예를 들어, 링크 엘리먼트에 포커스를 잃게 한다는 의미다. 속성 값이 양수인 경우에는 우선순위를 지정해주는 것이다. 예를들어 , h3 tabindex=”6” 이라는 태그가 h3 tabindex=”3” 보다 먼저 나왔어도 키보드 탭 포커스는 3을 먼저 보여주고, 6을 보여줄 것이다. 일자로 요소를 나열하는 4가지 방법( 크게 )123456&lt;ol class=\"favorite-list\"&gt; &lt;li class=\"no1\"&gt; &lt;a href=\"#\"&gt;W3C&lt;/a&gt; &lt;em class=\"up\"&gt;상승&lt;/em&gt; &lt;/li&gt; &lt;/ol&gt; 위 그림과 같이 일자로 구성된 요소가 있다고 가정했을 떄. 만드는 방법은 크게 4가지가 존재한다. 1. flex flex는 가장 쉬운 방법이다. 다만, 브라우저 지원을 잘 확인해야만 한다. 12345678910.favorite-list li&#123; display : flex; align-items: center; /*y축 중간 매치*/ &#125; .favorite-list em &#123; margin-left: auto; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/&#125; 2. float float의 단점은 일자로 나열하고 하는 요소들의 높이가 모두 같다면 크게 문제가 없지만 높이의 차이가 존재한다면 억지로 높이를 맞춰주어야만 한다. 12345678910.favorite-list li::before&#123; float : left; &#125;.favorite-list a&#123; float : left;&#125;.favorite-list em &#123; float : right;&#125; /* 높이의 차이 때문에 억지로 크게를 맞춰주어야한다.*/ 3. position 부모요소에 relative를 주고 왼쪽부터 작성되는 html 특성을 고려하여 가장 오른쪽 상승,하락 그림만 absolute를 이용하여 오른쪽에 배치하는 기법이다. 12345678910111213141516171819.favorite-list li&#123; position: relative;&#125; .favorite-list li::before&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list a&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list em &#123; position : absolute; margin-top : -5px; /*absolute를 이용함으로서 상승,수직 이미지를 오른쪽으로 붙어버린다.*/ top : 50%; /* top과 margin은 글씨가 많아서 칸이 넘어가도 상승 좌표도 덩달아 움직이게 하기 위함이다.*/ right : 0;&#125; 4. inline-block inline-block에서 margin-left를 이용하여 em요소를 오른쪽으로 보내버리는 방법이다. inline-block에서의 특징은 반드시 정렬하고자는 요소들은 모두 width값들이 명시가 되어야만 한다. 그래야 컴퓨터가 maring-left : auto 값을 계산하여 em요소를 오른쪽에 배치시킬수 있다. 1234567891011121314151617.favorite-list li::before&#123; display: inline-block; vertical-align: middle; width: 20px;&#125;.favorite-list a&#123; display: inline-block; width: 120px; vertical-align: middle;&#125;.favorite-list em &#123; display: inline-block; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/ margin-left: auto; vertical-align: middle;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-07","slug":"html-css-study-07","date":"2019-09-16T18:12:39.000Z","updated":"2019-10-02T09:02:57.136Z","comments":true,"path":"2019/09/17/html-css-study-07/","link":"","permalink":"http://yoursite.com/2019/09/17/html-css-study-07/","excerpt":"","text":"HTML Study 07 article태그 강조 태그 ( em , strong ) font weight 가중치 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 agent-style 시 확인해야할 점들. float 대신에 inline-block 사용시 주의점. 밑줄 gradient 만드는 방법들. 애니메이션 방법들 article 태그 article 요소는 독립적이고 재배포하며 재사용 가능한 , 홀로 설 수 있는 내용들을 위주로 담는다. article 내부에는 header태그,footer등을 삽입할 수 있다. 주로 블로그 글, 포럼 글, 뉴스 기사, RSS피드 등이 article에 해당된다. 강조 태그 강조하는 태그 em em보다 더 큰 강조를 하는 strong 의미없이 글자크기만 굵게 하는 b태그 의미없이 기울이는 i태그 주로, 작품명(그림명, 책명, 영화명 등)을 표시하거나 인용할 때 사용 시멘틱점 관점으로 strong이 em보다 강조도가 높다. 디자인적 요소로는 em은 기울임, b와 strong은 굵게 표시한다. cite태그는 작품명 ,인용시 사용한다. b태그는 단순히 의미는없고 굵게만 표시한다. i태그는 단순히 의미없고 기울이게만 표시한다. font-weight 가중치웹 폰트 파헤치기 웹 폰트는 그룹화가 가능하다. 예를 들어보면, 다음과 같다. 12345678910111213141516171819@font-face &#123; font-family: Ngothic-Regular; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Bold; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-ExtraBold; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 나눔고딕 보통, 굵게 , 아주굵게, 이탤릭 을 사용한다고 가정시 보통 웹폰트의 이름을 모두 다르게 붙이고 필요에 따라 각 스타일을 호출한다. 이와 같이 같은 나눔고딕들을 묶어서 사용하는 방법이 바로 font-weight 다. 다음 코드를 보자. 123456789101112131415161718192021222324@font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 700; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 800; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; font-style: italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 위와 같이 font-family는 나눔고딕이라는 그룹으로 맺고 각 weight와 style을 통해 각 글꼴을 선택할 수 있게된다. 123456body &#123; font-family: \"Nanum Gothic\" &#125; h1 &#123; font-weight: 400 &#125; /* NanumGothic-Regular.woff */h2 &#123; font-weight: 700 &#125; /* NanumGothic-Bold.woff */h3 &#123; font-weight: 800 &#125; /* NanumGothic-ExtraBold.woff */h4 &#123; font-weight: 400; font-style: italic &#125; /* NanumGothic-Italic.woff */ 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 글자 위에 이미지로 해당 글자를 가려야 할 경우. 사용하는 기법들. 글자를 안사용하고 바로 이미지만 넣을 수는 있으나 SEO관점에서 불리하다. 따라서 글자는 적되 이미지를 특정기법을 이용하여 덮음으로써 SEO관점과 시각적 요소 모두 챙긴다. padding을 활용한 IR 기법 기본적인 방법. 높이를 0으로 줘서 그림 아래로 텍스트를 내려버린다. 그 후 overflow:hidden 속성을 이용하여 텍스트를 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 12345678910111213@charset \"utf-8\";/* padding을 활용한 IR 기법 */.brand1&#123; background:yellow url(../images/title.png) no-repeat; height: 0; width: 290px; padding-top: 195px; overflow: hidden;&#125;/* 위 2가지 트릭의 단점 -&gt; 네트워크의 오류로 인해 이미지가 안날라올경우 문제가 있다. */ text-indent를 이용한 IR 기법 넓이를 지정해놓고 , 들여쓰기를 넓이만큼 준다. 개행 금지 속성을 이용하여 텍스트가 다음 줄로 못내려가게 막고 화면을 넘어가버린 텍스트는 overflow:hidden 속성을 통해 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 123456789/* text-indent 트릭을 이용한 IR 기법 */.brand2&#123; background:pink url(../images/title.png) no-repeat; height: 195px; width: 290px; text-indent: 290px; white-space: nowrap; overflow: hidden;&#125; position 트릭 가상요소를 이용하여 텍스트는 자리 그대로 유지하고 absolute한 가상요소 이미지로 덮어씌운다. 네트워크 에러시 이미지가 안날라와도 가려져있던 텍스트가 보이게 됨으로써 무슨 텍스트인지 유추가 가능하다. 123456789101112131415161718192021222324/* 한줄일때만 이용 가능한 트릭. position트릭. 네트워크 오류로 이미지가 안날라올경우 가상요소는 안보이고 덮어쓰기 전의 내용이 보인다. */.brand3&#123; background: lime; height: 195px; line-height: 195px; width: 290px; text-align: center; font-size : 16px; font-weight: 400; position : relative;&#125;.brand3::after&#123; content: \"\"; position: absolute; background: orange url(../images/title.png); width: 100%; height : 100%; top: 0; left : 0;&#125; agent-style 시 확인해야할 점들. box 모델 겹침 문제 오타 상속 이슈 레이아웃 (margin, padding, position , display , float …) inline-block 으로 레이아웃 작업시 문제점들 inline-block으로 레이아웃시 다음과 같은 문제가 발생한다. 주의 깊게 봐야되는 점은 묻고답하기 오른쪽에 존재하는 Border 선과의 사아아알짝 떨어진 여백이다. 보통 li태그를 일자로 나열하는 방법으로 inline-block으로 지정하고서 구분선을 주기 위해 border를 주게되면 위와 같은 여백이 생기게 된다. 이 부분을 아래와 같이 margin값을 -로 주면서 해결을 할 수 있다. 1margin-left: -6px; /*극단적이게 큰 값을 줌.*/ 웬만해서는 float형태나 다른 레이아웃을 권장한다. 밑줄 gradient 만드는 방법들. 가상 요소 absolute 를 이용한 방법. 밑줄을 그리고 싶은 곳에 가상요소를 하나 띄우고 absolute화 한후 높이와 넓이를 맞춰서 대치하는 방법. 123456789.news::before&#123; content: \"\"; background: red linear-gradient(to right,#aaa,#fff); position : absolute; top : 30px; left : 0; width: 80%; height: 1px;&#125; border 선 자체에 gradient를 설정 하는 방법 123456789101112.news-heading&#123; margin : 20px 0; padding : 0 0 15px 0; width : 80%; font-size : 1.5rem; color: #bb7b13; border-style: solid; border-image: linear-gradient(to right, rgb(168, 167, 167), rgb(228, 228, 228)); border-image-slice: 0 0 1 0; border-image-width: 0 0 1px 0; border-left: none;&#125; 애니메이션 방법들 CSS 애니메이션 사용하기 참고 123456789101112131415161718192021/* 1번 Fade Slide In From Top */ @keyframes fade-slide-in-from-top &#123; 0% &#123; transform: translateY(-4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.app-header &#123; opacity: 0; animation: fade-slide-in-from-top 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 2번 Fade Slide In From Left */@keyframes fade-slide-in-from-left &#123; 0% &#123; transform: translateX(-4rem); /*right는 transform: translatxX(4rem);*/ opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.brand &#123; opacity: 0; animation: fade-slide-in-from-left 0.35s 0.4s ease-out forwards; &#125; 12345678910111213141516171819202122232425262728293031323334353637/* 3번 Fade In &amp; out */@keyframes fade-in &#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;button[title=\"메뉴 열기\"] &#123; opacity: 0; animation: fade-in /* name */ 0.35s /* duration */ 0.4s /* delay */ ease-out /* timing function */ forwards; /* fill mode */&#125;@keyframes fade-out &#123; 0% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125;.button[title=\"메뉴 열기\"] &#123; animation: fade-out 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 4번 Fade Slide In From Bottom */@keyframes fade-slide-in-from-bottom &#123; 0% &#123; transform: translateY(4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.ediya-menu__item &#123; opacity: 0; animation: fade-slide-in-from-bottom 0.35s 0.4s ease-out forwards; &#125; 1234567891011121314/* 5번 Motion Sequnce Animation */.ediya-menu__item &#123; /* 0% */ opacity: 0; transform: translateY(4rem); /* 100% */ animation: transform-none 0.3s 0.85s cubic-bezier(0.6, 0.01, 0.16, 1) forwards;&#125; /* 시간 차 애니메이션 */.ediya-menu__item:nth-child(1) &#123; animation-duration: 0.8s &#125;.ediya-menu__item:nth-child(2) &#123; animation-duration: 1.2s &#125;.ediya-menu__item:nth-child(3) &#123; animation-duration: 1.6s &#125;.ediya-menu__item:nth-child(4) &#123; animation-duration: 2.0s &#125; 그외 사이트 참조 Effective Management 애니메이션 코드 수 줄이고 관리하기. Text Sequencing Motion Stop &amp; Play Animation for Everyone (애니메이션 껏다 켜기 버튼기능)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"java-tips02","slug":"java-tips02","date":"2019-09-13T16:12:50.000Z","updated":"2019-10-02T09:59:33.239Z","comments":true,"path":"2019/09/14/java-tips02/","link":"","permalink":"http://yoursite.com/2019/09/14/java-tips02/","excerpt":"","text":"####1. String == 와 equals의 차이점 String으로 = =을 비교시 주소를 비교하는것이다. 따라서 내부 값을 비교하기 위해서는 equals를 쓰도록한다. 참고로 문자열말고 문자는 그냥 ==으로 하여도 무방함. ex) char A == ‘6’; 123456789101112131415// 둘다 똑같은 값을 가지고 있으니까 참 new String(\"test\").equals(\"test\") // --&gt; true // new String으로 새로운 객체를 생성하고 \"test\"는 다른 객체여서 falsenew String(\"test\") == \"test\" // --&gt; false // \"test\"라는 값을 가진 객체를 둘다 각자 생성해서 falsenew String(\"test\") == new String(\"test\") // --&gt; false // \"test\" \"test\"를 컴파일러는 같은 객체로 봐서 참 \"test\" == \"test\" // --&gt; true // checks for nulls and calls .equals()Objects.equals(\"test\", new String(\"test\")) // --&gt; trueObjects.equals(null, \"test\") // --&gt; false 02. charAt() , toCharArray() charAt() : 문자열타입에 저장된 값들을 배열형태로 인식하여 반환하는 함수. to.CharArray() : 문자열에 있는 모든 내용을 문자배열로 반환하는 함수. 12345678910111213141516 String a=\"001100111\";char[] x = a.toCharArray();for(int i=0;i&lt;a.length();i++)&#123;if(a.charAt(i)=='0')&#123; System.out.print(\"영\");&#125;else&#123; System.out.print(\"일\");&#125;&#125;System.out.println();for(int i=0;i&lt;a.length();i++)&#123;System.out.print(x[i]);&#125; System.out.println(); 03_1. 형변환 (요약) Integer.parseInt( ) -&gt; 문자열 -&gt; 정수 String.valueOf( ) -&gt; 정수 -&gt; 문자열 12345int a = 0;String s = \"55\";int a = Integer.parseInt(s); //a=55String s = String.valueOf(a+10); //s=\"65\" 03_2. 형변환 (목록) ①. 문자열에서 정수형으로 변환 (String to int) - int i = Integer.parseInt(String str); ②. 정수형을 문자열로 변환 (int to String) - String str = Integer.toString(int i); - String str = String.valueOf(int i); ③. 형식에 맞춰서 변수들을 문자열로 변환 (c언어의 printf 동일) - int i; float f; String str = String.format(“%d %f”,i,f); ④. 문자열에서 다른 숫자형태로 변환 - float f = Float.parseFloat(String str); // String to float - double d = Double.parseDouble(String str); // String to double - byte b = Byte.parseByte(String str); // String to byte - long l = Long.parseLong(String str); // String to long - short s = Short.parseShort(String str); // String to short ⑤. 다른 숫자형태에서 문자열로 변환 - String str = String.valueOf(boolean b); // true 또는 false가 str에 저장됨. - String str = String.valueOf(char c); // char to String - String str = String.valueOf(char[] data); // char array to String - String str = String.valueOf(double d); // double to String - String str = String.valueOf(float f); // float to String - String str = String.valueOf(long l); // long to String - String str = String.valueOf(Object o); // Object to String , o == null이면 “null” 이 되고 o!= null이면 o.toString()함수의 반환값은 str - String str = String.valueOf(char[] data, int offset, int count); // offset 의 index부터 count 개의 문자로 부분문자열 생성","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"http://yoursite.com/categories/Develop/Java/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"java-tips01","slug":"java-tips01","date":"2019-09-13T16:06:51.000Z","updated":"2019-10-02T09:59:24.672Z","comments":true,"path":"2019/09/14/java-tips01/","link":"","permalink":"http://yoursite.com/2019/09/14/java-tips01/","excerpt":"","text":"####1. charAt(i) charAt(i)는 문자열(String)을 대상으로 한다. 문자열의 i-1번째에 위치한 문자열을 char형으로 반환한다 12String n = \"abcda\";n.charAt(0) // char형으로 a를 의미. 즉, 'a'을 반환. 2. indexOf(문자열) indexOf(“문자열” || ‘문자’)은 문자열(String)을 대상으로 한다. (“문자열” || ‘문자’)가 해당 문자열(String)내에 존재할 경우 존재하는 위치를 값으로 반환한다. 만약 존재하지 않을 경우 -1을 반환한다. *주의점 1 : 첫 위치만 반환한다. *주의점 2 : 문자열을 대상으로한다. char형은 대상이 아니다. *주의점 3 : 매개변수는 문자(char형)도 가능하다. 12String n = \"abcda\";n.indexOf(\"a\") // 0을 반환한다. 4번째에도 a가 있지만 처음에 있는 위치만 반환한다. 3. replace(),replaceAll(), replaceFirst() replace 관련 함수를 이용하여 치환 혹은 제거가 가능하다. replace(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거 replaceAll(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거. replace와 다른 점은 정규식도 사용 가능. repaceFirst(“찾는 문자열”,”바꿀 문자열”) -&gt; 조건에 있는 첫 문자열을 치환 혹은 제거. * 주의점 1 : 바꿀 문자열을 “”으로 줄 경우 제거가 됨. * 주의점 2 : 반드시 반환 대상이 있어야 됨. 자기 자신으로라도 반환을 해주어야함.(당연한 것) 12345678910111213141516171819202122String s = \"봉숭아 학당! 봉숭아 학당!\"; // 원본 문자열String s2; // (1) s2 = s.replace(\"숭아\", \"맹구\"); System.out.println(\"치환(1): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (2) s2 = s.replaceFirst(\"숭아\", \"맹구\"); System.out.println(\"치환(2): \" + s2); // 출력 결과: 봉맹구 학당! 봉숭아 학당! // (3) s2 = s.replaceAll(\"숭아\", \"맹구\"); System.out.println(\"치환(3): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (4) s2 = s.replace(\"숭아\", \"\"); System.out.println(\"치환(4): \" + s2);// 출력 결과: 봉 학당! 봉 학당! 04. char형 아스키코드를 이용한 알파벳배열 초기화. 아스키 코드를 이용하여 알파벳 배열을 만들 수 있다. 이런식으로 아스키코드를 이용한 조건을 만들 수도 있다. 123456char[] alphabet = new char[25];for(int i=0;i&lt;25;i++)&#123; alphabet[i] = (char) (i+65);&#125; // A - 65System.out.println(alphabet[0]); //'A' 출력됨.","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"http://yoursite.com/categories/Develop/Java/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"html-markup","slug":"html-markup01","date":"2019-09-12T16:01:04.000Z","updated":"2019-10-02T09:04:05.708Z","comments":true,"path":"2019/09/13/html-markup01/","link":"","permalink":"http://yoursite.com/2019/09/13/html-markup01/","excerpt":"","text":"123456789101112131415161718192021&lt;section class=\"news\"&gt; &lt;h2 class=\"news-heading\"&gt; 새소식 &lt;/h2&gt; &lt;a href=\"#\" class=\"news-link\"&gt; &lt;dl class=\"news-list\"&gt; &lt;dt class=\"news-title\"&gt; &lt;span&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/span&gt; &lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; &lt;/dt&gt; &lt;dd class=\"news-description\"&gt; 디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다. &lt;/dd&gt; &lt;/dl&gt; &lt;figure class=\"news-thumbnail\"&gt; &lt;img class=\"news-thumbnail-image\" src=\"./images/news.gif\" alt=\"W3C 리뉴얼\"&gt; &lt;figcation class=\"news-thumbnail-title\"&gt;W3C 리뉴얼&lt;/figcation&gt; &lt;/figure&gt; &lt;/a&gt; &lt;a href=\"#\" class=\"icon-plus news-more\" title=\"새소식 더보기\" aria-labelledby=\"news-link\"&gt;더보기&lt;/a&gt;&lt;/section&gt; webcafe.html 부분 새소식 영역 마크업 및 html 구성","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"MarkUP","slug":"MarkUP","permalink":"http://yoursite.com/tags/MarkUP/"}]},{"title":"html-css-study-06","slug":"html-css-study-06","date":"2019-09-12T13:15:38.000Z","updated":"2019-10-02T09:01:57.604Z","comments":true,"path":"2019/09/12/html-css-study-06/","link":"","permalink":"http://yoursite.com/2019/09/12/html-css-study-06/","excerpt":"","text":"HTML Study 06 MarkUp 짤 때 고민해야하는 점. fieldset 태그의 버그 button태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?) vertical-align / text-align time 태그 block 태그 안에서 여백을 주는 여러가지 방법들. 글자 수 숨기기 (… 처리하기) fontello aria-labelledby MarkUp 짤 때 고민해야하는 점.​ MarkUp시 너무 많은 버튼에 대한 고민을 해야만 한다. 예를들어보자, 위와 같은 공지사항과 자료실에 대한 게시물 리스트를 모아놓은 영역을 마크업 해야할 때, 보통의 경우라면, 다음과 같이 생각할것 같다. 공지사항 , 자료실은 서로 다른 영역이다. 게시물 목록을 나열한다. 더보기 버튼을 나눈다. 결론적으로, 공지사항 - 목록 - 더보기 | 자료실 - 목록 - 더보기 구성이 되겠다. 문제는 이와같은 구성시 너무 많은 탭을 요구하게 된다. 비장애의 영역에서는 시각을 통해 여러가지 정보를 한번에 확인을 할 수 있지만, 장애 또는 봇의 영역에서는 눈대신 청각에 의존해야한다. 스크린 리더기가 모든 게시물 제목을 하나하나 전부 읽는다는 것은 너무 힘들고 듣는다는것도 힘들것이다. ! 해결법은 무엇인가?​ 해결법이야 여러가지 방법이 존재하겠지만, 그 중 대표적인 예를 들어보면 - 공지사항,자료실 같은 수많은 포커스가 되는 영역에서는 방향키 화살표를 통해 읽고 싶은 요소만 선택하게 하는것이다. 공지사항 자료실 세션 1 목록 더보기 세션2 목록 더보기 [이를 적용한 대한항공 사이트] https://www.koreanair.com/content/koreanair/global/en.html/ fieldset 태그의 버그​ fieldset 태그는 보통 form 태그 내부에서 쓰인다. form - fieldset + legend + label + input 형식으로 많이 사용하는데, 여기서 fieldset 태그에 flex를 주게 될 경우, 크롬에서는 버그를 일으키게된다. ( 보통, form태그에 display:flex를 주면 크롬은 flex가 적용이 안되는 버그를 일으킨다. ) 해결법으로는 form - fieldset + legend + label + input 과 같은 형식에서 form - fieldset - div + legend + label + input 과 같이 태그로 1번더 그룹핑한다. 그리고 div에 flex관련 css 스타일을 주면 해결할 수 있다. [flex 관련 이슈] https://naradesign.github.io/article/flex-browser-compatibility.html button 태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?)​ button 태그는 브라우저마다 padding , margin 영역이 다른 특성을 가지고 있다. 따라서 a 태그와 WAI-ARIA를 이용하고 role=”button” 을 주어 이 부분을 해결할 수 있다. vertical-align / text-align vertical-align 은 inline 요소를 수직으로 정렬해주는 기능을 담고 있다. text-align 은 block 요소를 정렬해주는 기능으로 block 요소 안에있는 inline 요소들(텍스트나 이미지)등도 같이 정렬해준다. inline 관련 태그에 직접 text-align 속성을 지정해줘도 작동하지 않는다. time 태그​ 이 태그의 용도는 문서 내용 안에 어떤 날짜나 시간을 나타내는 표현이 있을 때 그 부분에 사용하여 알맞은 날짜나 시간을 컴퓨터가 인식할 수 있게 의미적으로 나타내는 데 사용한다. 1&lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; block 태그 안에서 여백을 주는 여러가지 방법들.​ 여백을 주는 각 방법들마다 차이가 있으니 확인하고 써야 할 것. 특히 %, auto , 정적px에 대한 차이를 이해하는것이 중요하다. padding ?%; ?px; margin ?%; ?px; width : ?px; width : ?%; margin : auto; calc -&gt; 반응형 글자 수 숨기기 (… 처리하기)​ block 박스에서 글자수가 일정 이상 넘어가서 …을 처리하고 싶다먼 아래 style을 모두 구성해주어야한다. 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; fontello​ 이전에 설명한 fontello를 html문서에서 class 형태로 주어 icon이미지를 생성하면 그 태그 앞에 가상클래스를 자동으로 만들어주고 이미지를 넣게된다. 12&lt;li class=\"icon-dot-circled\"&gt; &lt;!-- li클래스 앞에 가상클래스를 만들고 이미지를 넣는것을 자동으로 해줌. --&gt; ​ fontello.css 에 있는 내용 중… 1.icon-dot-circled:before &#123; content: '\\f192'; &#125; aria-labelledby1 &lt;a href=\"#\" class=\"icon-plus notice-more more\" title=\"공지사항\" aria-labelledby=\"notice\"&gt;더보기&lt;/a&gt; 위 a링크는 aria-labelledby=”notice” 로 인해 id가 “notice”인것을 연결해준다. 1&lt;a href=\"#\" class=\"tab\" role=\"button\" id=\"notice\"&gt;공지사항&lt;/a&gt; JavaScript 맛보기[defer 및 async] https://blog.asamaru.net/2017/05/04/script-async-defer/ 12&lt;script src=\"./js/jquery.min.js\" defer&gt;&lt;/script&gt;&lt;script src=\"./js/webcafe.js\" defer&gt;&lt;/script&gt; 1234567891011var section = $('.board section'); //jqeury lib에서 지원하는 선택 객체var tab = $('.tab');// .on('이벤트명')// tab.on('click keyup',function(e)&#123;tab.on('click', function(e)&#123; e.preventDefault();// 기본 이벤트를 취소함. 예를들면 a의 속성 href의 이벤트를 취소함. // if((e.type === 'keyup' &amp;&amp; e.keyCode === 13) || e.type === 'click')&#123; section.removeClass('tab-act'); $(this).parent().parent().addClass('tab-act');&#125;)//멀티 이벤트 바인딩 예-&gt; 클릭, 마우스온 등 다양한 환경 대응 board라는 이름을 가진 클래스의 section태그의 내용을 section이라는 이름의 변수로 선언. tab이라는 이름을 가진 클래스의 정보를 tab이라는 이름의 변수로 선언. tab이 클릭 되었을 때, 다음과 같은 기능을 수행한다. tab이라는 이름을 가진 클래스의 태그가 가진 기본적인 이벤트 기능을 모두 취소(제거) 한다. board라는 이름을 가진 클래스의 section태그 내부에서 tab-act라고 불리는 클래스를 제거한다. tab이라는 이름을 가진 클래스의 태그의 부모의 부모에게 tab-act라는 클래스네임을 붙여준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-05","slug":"html-css-study-05","date":"2019-09-10T16:48:58.000Z","updated":"2019-10-02T09:01:51.405Z","comments":true,"path":"2019/09/11/html-css-study-05/","link":"","permalink":"http://yoursite.com/2019/09/11/html-css-study-05/","excerpt":"","text":"HTML Study 05 MarkUp 짜기 로그인창 HTML ~CSS 구성해보기 form 태그 dt dl dd 태그 a태그의 속성 들여쓰기 방법들 line-height 마크업시 생각나는 고민들!div -&gt; 의미없는 정보 section -&gt; 1장 1절 같은 정보 , header 태그가 없으면 경고를 띄운다. article -&gt; 독립된 완결된 정보, RSS , header 태그가 없으면 경고를 띄운다. margin은 겹침현상이 발생한다. box-shadow 도 인접 태그의 margin에 영향을 주지 않는다.(즉, 겹친다.) title은 id, class, style같은 대표속성이며 태그에 사용시 마우스를 올렸을 경우 글박스를 띄운다. text-indent 는 첫줄 들여쓰기를 넣어주는 속성이며, 박스에 영향을 주지않는다. 단, 개행시 유효하지 않은 속성이 된다. 반응형 이미지들은 반드시 등으로 랩핑하는것이 좋다. 이유 : 이미지가 유동적으로 커짐과 줄어듬 MarkUp 짜기​ 간단해보이지만 HTML중 가장 어려운 구간이다. 어떠한 태그를 좋게 사용하느냐, 논리적인 순서를 지켰느냐의 위주로 짜야하며 반드시 디자인적 관점으로 구성하면 안된다! 논리적 순서를 가려낸다. 시멘틱하게 이름 정하기 코드 짜기 대표적인 네이버의 로그인창 예제. 보통 마크업 순서라면 아이디 -&gt; 비밀번호 -&gt; 로그인 -&gt; 로그인 상태 유지 일것이다. 하지만! 논리적으로 계산해보면 로그인 하기전에 로그인상태유지 버튼을 체크하거나 해제하는것이 맞지 않을까? 로그인창 HTML ~CSS 구성해보기 form 태그form 관련 요소 -&gt; 정보를 보내고 받는 값들의 입력 서식을 모아놓은 모음들. https://formspree.io/ : form 정보를 내 이메일로 보내게끔 서비스하는 사이트 . 무료,유료 나뉜다. form , fieldset, legend ==&gt; XHTML 관점에서 다 있어야만 한다. HTML4에서는 form만 있어도 되고 HTML5에서는 둘다 허용이된다. 따라서 form, fieldset , legend, label, input 모두 사용하는 것이 좋다. fieldset은 폼서식을 그룹화하는 것. legend는 그룹화한 폼서식에 대한 제목이다. 하나의 form안에 fieldset은 여러개 들어가도 상관없다. required -&gt; 논리적 검사 예 ) input 태그 안에 required를 적게 되면 이메일 값을 안적을 경우 경고창을 띄운다. form 안 에서 값을 그냥 입력하면 안되고 반드시 1:1로 값을 대입해줘여한다. 아이디 은 입력서식에 대한 이름 이고 는 정보를 입력받는 창이다. placeholder 속성은 입력서식에 대한 예시다. dl dt dd 태그용어를 설명하는 정의형 목록을 만든다. dt -&gt; 용어의 제목을 의미하며 dd는 용어를 설명하는 내용이다. dl dt dd는 정의형 목록을 의미하며 각 태그당 한개씩만 사용하는것이 좋다. dl 안에 태그를 삽입해도 되지만, 아래와 같은 유형만 추천한다. 1234567&lt;dl&gt; &lt;div&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/div&gt;&lt;/dl&gt; &lt;!--가능한 구문. 단, div가 dt나 dd쪽에 들어가서는 안된다.--&gt; a태그하이퍼링크를 걸어주는 태그. 1&lt;a href=\"#\" target=\"_self | _blank | _parent | _top | 프레임명\" &gt;&lt;/a&gt; self -&gt; 기본값 생략가능. target=”_blank”. -&gt; 새창을 열음 parent -&gt; 부모페이지로, iframe에서 사용. top -&gt; 최상위페이지로, iframe에서 사용. 프레임명 : 직접 명시 들여쓰기 방법들 padding margin text-indent line-height1line-height: normal | length | number | percentage | initial | inherit | 숫자값 normal : 웹브라우저에서 정한 기본값. 보통 1.2 length : 길이로 줄 높이를 정한다. number : 글자 크기의 몇 배인지로 줄 높이를 정한다. percentage : 글자 크기의 몇 %로 줄 높이로 정한다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 예) 글자크기가 40px일 때 line-height의 값을 1.5로 하면, 줄 높이는 40의 1.5배인 60px가 된다. 줄 높이는 60px인데 글자 크기는 40px이므로, 글자 위와 아래에 각각 10px의 여백이 생긴다. 줄 높이가 글자 크기보다 작으면 세로 방향으로 글자가 겹치게 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-04","slug":"html-css-study-04","date":"2019-09-09T11:33:31.000Z","updated":"2019-10-02T09:01:40.084Z","comments":true,"path":"2019/09/09/html-css-study-04/","link":"","permalink":"http://yoursite.com/2019/09/09/html-css-study-04/","excerpt":"","text":"HTML Study 04 HTML5 콘텐츠 모델 CSS 셀렉터 html5 표준확인 CSS 구체성점수 Shadow Entity list opcacity 시나리오 작성 z-index background 애니메이션( @keyframes, + 곡선도 ) position, float 다시 정리 float 객체에 강제로 높이 를 알려주는법(overflow, 가상요소 clear:both) float, position:absolute -&gt; display를 block화 시킨다. 오늘의 팁 position : absolute , float는 강제로 display:block 화시킨다. 1에서 한 absolute의 경우 display는 block이 맞지만 마치 inline 형태의 display를 띄고 있으며, absolute 선언 시, block 레벨 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정해야만 하며, 부조 또는 조상요소가 static일 경우, 최종으로는 document의 body태그를 기준으로 위치하게된다. 태그의 링크 클릭 반경을 넓히고 싶다면 padding 을 늘려야 한다. 간단하게 여백을 주는 방법으로는 대표적으로 margin, padding 등이 있다. float화 된 상태에서 부모의 자식들 요소가 모두 float화 되었다면 그 부모요소는 높이를 잃어버리게 된다. 이에 잃어버린 높이를 찾는 3가지 방법이 있다. height = 45px : 높이를 직접 입력 [비추천] &lt;부모&gt; overflow:hidden/auto : overflow 자체는 흘러넘치는 콘텐츠를 다루는 태그지만 overflow태그는 잠재적으로 잃어버린 높이를 일깨워주는 역할을 하기 때문에 사용할 수 있다. clear:both : 가장 좋은 방법. float화된 요소 마지막에 가상자식요소를 생성하여 clear:both를 선언. clear:both는 float요소 중에 높이가 제일 긴 것을 찾아서 강제로 margin을 추가하여 높이가 늘어나 잃어버린 높이를 찾아낸다. 123456.menu::after&#123; content:\"\"; clear: both; /* clear는 display:block 에서만 사용 가능. right, left 등도 있다. */ display: block; &#125; display 숨김처리 12345678910.a11y-hidden &#123; background-color: red; position: absolute; width: 1px; height: 1px; overflow: hidden; margin: -1px; clip: rect(0,0,0,0); white-space: nowrap;&#125; HTML5 콘텐츠 모델 CSS 셀렉터​ 대표적으로 id 셀렉터인 # , 클래스 셀렉터인 점(.) , 전체 선택자인 * 외에도 수많음 셀렉터가 있다. 자세한 내용은 아래 블로그가 정리를 정말 잘 해놓았기에 링크로 남겨둔다. https://code.tutsplus.com/ko/tutorials/the-30-css-selectors-you-must-memorize--net-16048 html 5 표준확인 google에 html w3c 검색 [html5 mulder21c : 블로그] https://mulder21c.github.io/html/ [html5 한글명세서] https://mulder21c.github.io/html/ CSS 구체성 점수​ css 셀렉터에 id, class, tag 이름이 갖는 점수를 계산하여 점수가 높은 selector가 우선순위를 갖는 가상 개념. 대표적으로 id &gt; class &gt; tag 순이며, 제일 높은 html 태그 내부에 적용하는 css가 제일 높은 우선순위를 지닌다. 착각하면 안되는 것!! -&gt; class가 10개 쓰인다고 해서 id보다 높을 수 없다. 체급차이가 다르다고 생각하면됨. 123&lt;div style=\"padding : 20px\"&gt; 이것은 div 태그에 style이 적용된 예입니다.&lt;/div&gt; 추가 important 1234&gt; .menu-act .btn-menu&#123;&gt; color:yellow important;&gt; &#125;&gt; important는 우선순위를 무력화시킬 수 있다. 즉, important 는 지정한 스타일이 안먹는다고 생각햇을떄. 추적할때. 파악용도 클래스가 동적으로 추가될 가능성이 있을떄; 다른 사람이 수정해서 내 소스의 상속이 깨질 우려가 있을 경우. Shadow 그림자를 나타내는 태그는 크게 박스와 텍스트가 있다. 1box-shadow: none | x-position y-position blur spread color | inset | initial | inherit; none : 그림자 효과를 없앤다.. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어진다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어진다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려짐. spread : 양수면 그림자를 확장하고, 음수면 축소. color : 그림자 색을 정한다, inset : 그림자를 요소의 안쪽에 만든다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 1text-shadow: offset-x offset-y blur-radius color | none | initial | inherit offset-x : 그림자의 수평 거리를 정한다. (필수) offset-y : 그림자의 수직 거리를 정한다. (필수) blur-radius : 흐림 정도를 정한다. (선택 : 값을 정하지 않으면 0) color : 색을 정한다. (선택 : 값을 정하지 않으면 브라우저 기본값) none : 글림자 효과를 없앤다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. Entity list​ CSS에서 사용할 수 있는 특수문자 리스트. html에서 &amp;&amp;를 그냥 입력하면 안되기 때문에 아래의 리스트를 이용한다. [사용가능한 특수문자 코드 리스트] https://www.w3schools.com/cssref/css_entities.asp Opacity1opacity: number | initial | inherit number : 0.0부터 1.0까지의 수를 넣는다. (투명도 0 -&gt; 불투명 / 1-&gt; 투명) initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 시나리오 작성 CSS의 style을 작성할 때, 시나리오를 작성하며 차근차근 하는것을 익숙해지도록 한다. 예) 글씨가 왼쪽 -&gt; 오른쪽으로 날라옴. : 이동효과 [padding, margin, position-relative, position-absolute] 글자의 투명도를 추가 해야함 . [color: rgba 또는 opacity] 글자 크기의 번화 [font-size] z-index요소들의 배치가 자유로워지면서, 때떄로 서로의 위치를 겹치게 하는 경우가 생긴다. 그 때 사용하는것이 z-index. z-index 값을 지정하기 위해서는 해당 요소의 position 속성이 relative, absolute, fixed 중 하나여야만 한다. [z-index 를 잘 설명한 블로그] http://dev.epiloum.net/904 backgroundbackground-color : yellow 같은 기본 코드 외에도, background는 말 그대로 배경에 대한 색 , 이미지등의 콘텐츠를 다루는 요소 css이다. 123456789/*background-image : url로 2개의 이미지를 불러낸다. */background-image: url('./images/ani_flower_01.png'),url('./images/ani_flower_02.png');/*해당 이미지들은 처음에는 일정 간격마다 반복 되어있기에 반복을 제거한다.*/background-repeat : no-repeat;/*해당 이미지들에 대한 위치값을 지정해준다.*/background-position: 0 -10px, 670px 0; /*x축 y축을 의미*//*위 내용 한꺼번에 입력하기. */background : url('./images//ani_flower_01.png') no-repeat 0 -10px, url('./images/ani_flower_02.png') no-repeat 670px 0; 애니메이션[애니메이션 정리 잘된 블로그] https://brunch.co.kr/@99-life/3 애니 메이션을 사용하기 위해서는 먼저 2가지 조건을 충족시켜야 한다. animation-name : 키프레임 이름 *필수 animation-duration : 시간(s,ms 등등) *필수 animation-fill-mode : forwards; 먼저 keyframes를 선언한다12345678910111213141516171819@keyframes text-ani&#123; 0%&#123; font-size: 12px; color : rgba(0,0,0,0); transform: translate(0,0); /* top: 0; left: 0; *//* margin : 0; *//* padddig : 75px 0 0 400px */ &#125; /* from */ 100%&#123; font-size : 24px; color : rgba(0,0,0,1); transform: translate(400px,75px) /* top : 75px; left:400px; *//*padding:75px 0 0 400px*//*margin:75px 0 0 400px; */ &#125; /* to */&#125;@keyframes bg-ani&#123; 0%&#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125; transform 은 좌표공간을 변형함으로써 일반적인 문서 흐름을 방해하지 않고 콘텐츠의 형태와 위치를 바꾼다. 그 중, transform : translate는 요소의 위치를 이동 시키는 함수이다. 구버전의 browser는 사용이 안된다. animation-duration지속성을 의미한다. 필수조건. 기본적으로 s , ms단위의 시간을 입력한다. 1animation-duration: 5s; animation-fill-mode 속성 및 내용1animation-fill-mode: none | forwards | backwards | both | inherit; none 애니메이션이 끝난 후 상태를 설정하지 않습니다. forwards 애니메이션이 끝난 후 그 지점에 그대로 있습니다. backwards 애니메이션이 끝난 후 시작점으로 돌아옵니다. both 애니메이션이의 앞 뒤 결과를 조합하여 설정합니다. inherit 애니메이션의 상태를 상위 요소한테 상속받습니다. 추가내용 123456789101112/*animation-name: bg-ani;animation-duration: 2000ms;animation-iteration-count: infinite;animation-direction: alternate;animation-timing-function: paused; *//* 위 내용을 짧게 줄인 short 표기법 *//* short표기법 : 이름 듀레이션 딜레이 반복 방향 반복곡선도 */animation: bg-ani 2000ms 1000ms infinite alternate ease-in-out; animation-timing-function에 관한 내용 중 cubic-bezier 에 관한 내용 https://kutar37.tistory.com/entry/CSS-cubic-bezier%EB%9E%80 cubic-bezier 설정하는 곳 https://cubic-bezier.com/#.17,.67,.83,.67","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-03","slug":"html-css-study-03","date":"2019-09-07T12:52:07.000Z","updated":"2019-10-02T09:01:29.872Z","comments":true,"path":"2019/09/07/html-css-study-03/","link":"","permalink":"http://yoursite.com/2019/09/07/html-css-study-03/","excerpt":"","text":"HTML Study 03 가상 요소 nth:child WAI-ARIA a11y-hidden / aria-hidden : 태그 숨김처리 role Web Font - 이미지 아이콘 CSS 단위 float 그림자 gradiunt CSS 색상값 단위 {참고} 가상 요소[가상요소] https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements 가상 요소는 존재하지 않는 요소를 존재하는 것처럼 부여하여 문서의 특정부분을 선택하게 할 수 있다. 대표적인 가상 요소 ::before -&gt; 해당 css의 요소박스 전에 같은 형식의 태그요소를 가상으로 만든다. ::after -&gt; 해당 css의 요소박스 후에 같은 형식의 태그요소를 가상으로 만든다. nth:child[nth:child] http://nthmaster.com/ nth-child는 형제 요소 중에서 특정 순서 요소를 선택하고 싶을 때 사용한다. 1234567.member li:nth-child(n+2)::before&#123;content: '\\f142'; /*가상요소 before 와 after에게 필수*/font-family:'fontello';width: 1em;&#125;/* nth-child를 이용하여 member 하위의 &lt;li&gt;중 2번째 요소부터 끝까지 각 요소 앞에 가상 요소를 생성하고 내용은 '\\f142'를 입력하고 font 와 width를 적용한다.*/ WAI-ARIA [설명] https://www.biew.co.kr/36 WAI-ARIA는 ‘Web-Accessibility Initiative’의 약자로 W3C에서 웹 접근성을 담당하는 조직. ARIA는 리치 인터넷을 위한 W3C의 접근 명세. [W3C에서 제공하는 명세서를 보기 좋게 기술로 변화시킨 레진의 ARIA] https://tech.lezhin.com/2018/04/20/wai-aria a11y-hidden / aria-hidden : 태그 숨김처리a11y-hidden 화면상에서는 안보이나 스크린 리더기 혹은 보조기등에서 보이게 끔 하기 위하여 개안된 CSS스타일. 헷갈리면 안되는것이 WAI-ARIA 에서 재정된 aria-hidden은 클래스명이 아니라 하나의 속성이다! 결국 다른거임. 추가로 off-screen / readable-hidden 등도 있다. aria-hidden 시각장애인, 검색봇, 스크린리더 사용자가 홈페이지에 더 쉽게 접근하기 위해서 읽을 필요없는 요소나 내용을 감춰준다. 외에도 여러가지 태그 숨긴 방법이 있지만, 대표적으로 위와 같은 형태를 권장한다. display:none , visibilitty , hidden 은 비권장. 1234567891011121314/* a11y-hidden */.a11y-hidden&#123; position: absolute; width: 1px; height: 1px; margin: -1px; overflow: hidden; /* 넘치는 부분을 감쳐준다 */ clip: rect(0,0,0,0); /* 선행조건 : position:absolute 해당 화면을 잘라내서 보여줌 */ white-space: nowrap; /* 줄바꿈을 하지않음. */ opacity: 0; /* 투명도 */&#125;/* aria-hidden */&lt;span class=\"line\" aria-hidden=\"true\"&gt;내용&lt;/span&gt; role​ 다른태그에 role로 규정한 태그의 역할? 혹은 기능을 넣을 수 있다. 역시 WAI-ARIA에저 정의한 기술로 https://webdir.tistory.com/89 에 정리가 되어있다. 대표적인 예로는 button이 있으며 , 시멘틱 관점에서도 중요한 역할을 지닌다. role = header,main,contentinfo 는 각각 를 의미한다. 1&lt;a href=\"#\" class=\"btn-menu\" role=\"button\"&gt;CSS에 대해&lt;/a&gt; Web Font - 이미지 아이콘 로컬에 있는 폰트를 쓰는게 아닌 웹에서 폰트를 받았다가 사용함. 저작권에 주의 대표적 : [Font Awesome] https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use [Fontello] http://fontello.com/ Fontello 적용 방법. 다운받은 압축파일을 해제하고 들어가보면 font폴더와 css폴더가 존재한다. 다운받은 font폴더에서 모두 복사하여 하고있는 프로젝트 font폴더에 붙여넣기를 한다.(단, css내부의 font폴더가 아니다.) 다운받은 css폴더에서 fontello.css를 복사하여 하고있는 프로젝트 css폴더에 붙여넣기를 한다. import 시키기 12/* css 파일 */@import url('./fontello.css'); 사용방법은 html 내부 , css 내부 가 있다. 123456789101112&lt;!-- html 내부 --&gt;&lt;!-- class 명으로 선언하여 사용하는 방법. class 명은 다운받은 css폴더에서 확인이 가능하다. --&gt;&lt;a href=\"#\"&gt;&lt;span class=\"icon-ellipsis-vert\"&gt;로그인&lt;/span&gt; &lt;style&gt;/* 사용하고자 하는곳에서 숫자값과 font-family를 선언. 숫자값은 css폴더에서 확인이 가능하다. */ .member li:nth-child(n+2)::before&#123; content: '\\f142'; font-family:'fontello'; width: 1em; &#125;&lt;/style&gt; CSS 단위https://github.com/HYEOK999/TIL/blob/master/HTML-CSS/study01/CSS-7%EA%B0%80%EC%A7%80-%EB%8B%A8%EC%9C%84.md float float는 css에서 정렬하기 위해 사용되는 속성이다. 떠잇다는 의미로 float태그 걸려있는 요소를 띄워서 표시한다. float는 display:block 형태의 태그에만 적요이 가능하다. … float는 글씨가 겹칠수 없는 속성을 가지고 있는 float가 정의된 요소가 공중에 뜬다면 그 다음 글씨는 옆으로 밀어낸다. 만약 float가 정의된 모든 요소가 공중에 떳을 경우, 해당 요소는 크기를 잃기때문에 그 다음 태그 이어지게 보일 수 있다. 따라서 강제적으로 크기를 주거나 overflow:hidden 같은 기능을 이용하여 height 값을 간접적으로 알려줘야만한다. 1234567891011121314151617.box&#123; background-color: lime; /* height: 50px; --- 강제로 높이를 주어 float로 잃어버린 높이를 깨워넴(안쓰는게 좋음) overflow:hidden 은 원래 넘치는 content를 감추는 역할인데 이 속성은 잊혀진 높이등을 일깨워 준다.따라서 float로 잃어버린 높이를 일깨워서 heading3를 밑으로 내린다. */ overflow: hidden; /*넘치는 값을 지워주세요.*/ &#125; .box2&#123; position: relative; top:10px; &#125; .box [class^=\"box\"]&#123; /* border: 1px solid red; */ float: left; &#125; float 는 position: relative와는 겹칠수 있으나 absolute선언시 float는 자동으로 none 값이 된다. clear : both , left , right 각각 float가 걸려있는 요소의 양쪽, 왼쪽, 오른쪽에 있는 요소들에게 clear값을 취소하는것. 이는 반드시 display : block이여만 한다. 그림자 box-shadow: none | x-position y-position blur spread color | inset | initial | inherit none : 그림자 효과를 없앱니다. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어집니다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어집니다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려집니다. spread : 양수면 그림자를 확장하고, 음수면 축소합니다. color : 그림자 색을 정합니다. inset : 그림자를 요소의 안쪽에 만듭니다. initial : 기본값으로 설정합니다. inherit : 부모 요소의 속성값을 상속받습니다. 12 text-shadow: 1px 0 0 black, -1px 0 0 black, 0 1px 0 black, 0px -1px 0 black;/* 그림자를 각각 위 아래 오른쪽 왼쪽 을 줌으로서 글씨 주변으로 박스 쳐진것처럼 보이게 할수 있다. */ gradient[gradient 가공 사이트] “https://www.colorzilla.com/gradient-editor/&quot; 123456789/* gradient 적용하기- 위 사이트에서 그라디언트 만든 후 복사 후 적용. 단, background를 background-image로 수정.*/.menu&#123;background-image: linear-gradient(to bottom, #f4c730 0%,#f7aa2e 35%,#f7aa2e 70%,#f4c730 100%);/* background-image: linear-gradient(to bottom, red, green,red); 시작 빨간색,끝 - 녹색 */&#125; [++ 추가 사이트] “https://codepen.io/FelixRilling/pen/qzfoc&quot; CSS 색상값 단위 (참고)[CSS 색상 값단위] https://aboooks.tistory.com/279","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"git-gui-study02","slug":"git-gui-study02","date":"2019-09-06T14:38:43.000Z","updated":"2019-10-02T09:56:51.688Z","comments":true,"path":"2019/09/06/git-gui-study02/","link":"","permalink":"http://yoursite.com/2019/09/06/git-gui-study02/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 -\\1. GIT Hubhttp://github.com Build software better, togetherGitHub is where people build software. More than 28 million people use GitHub to discover, fork, and contribute to over 85 million projects.github.com ▷ 버전관리 시스템인 Git을 이용하는 프로젝트들을 위한 원격저장소를 제공하는 서비스▷ 오픈소스는 무료, 비공개 프로젝트는 유료 정책▷ 저장소 크기의 제한이 없다.▷ 로컬 버전관리 시스템이 없이도 많은 작업을 웹상에서 할 수 있으며 따로 설치가 필요없다.▷ 사람 중심의 서비스 구성이기 때문에 특정 저장소에 접근하려면 ‘아이디/저장소명’으로 해야 한다.EX) HYEOK999/TEST01 \\2. Git 사용하기1 ( 저장소 생성 , 첫 버전파일 생성 ) ▷ Source Tree를 처음 실행하여 계정 등록의 절차를 걸치고 난 후에 뜨는 화면입니다.▷ 1번 Local 현재 자신의 pc 저장소를 의미합니다.▷ 2번 Remote는 원격저장소를 의미합니다.SourceTree에 타 원격저장소 Git HUB , Git lab등과 같은 저장소를 이용할때 사용되는 탭입니다.▷ 3번은 클론저장소 입니다.협업 프로젝트 진행 할 때 개발되어진 소스를 처음에 전부 가지고와야될 경우 사용합니다.▷ 4번은 자신의 PC에 이미 생성된 저장소를 불러올경우 사용되는 탭입니다.Git으로 인해 버전관리가 되어진 폴더의 경우에만 사용이 가능합니다.▷ 5번은 버전관리에 사용될 저장소를 생성합니다. ▷ 5번 탭에서 새로운 버전관리 저장소를 만듭니다.test_git 이라는 새로운 폴더를 만들어주고 해당 폴더에 간단한 html문서를 하나 생성하고test01.html 이라고 저장을 하도록 하겠습니다. 그럴경우 소스트리에서 변화가 생겼습니다.우선 왼쪽 상단의 파일 상태 탭을 보면 2가지 창으로 분류 되어있는 것을 볼수 있습니다.아래쪽의 창을 Working Copy 라고 부르고위쪽의 창을 Staging Area 혹은 Index라고 부릅니다. 그리고 Working Copy를 자세히 볼 경우? 라고 되어 있는 곳에 아까 생성한 html 파일명이 있는 것을 확인할 수 있습니다.우선 ? 라는 표시의 의미는 git이 모르는 파일 .즉, 관리가 안되고 있는 파일 혹은 관리를 처음으로 시작해야하는 파일을 의미합니다.해당 파일을 Stage selected 나 all을 누를경우 스테이징 에어리어에 test01.html 파일이 올라갑니다.그리고나면 왼쪽의 아이콘은 +로 바뀌는데 이것은 해당 파일을 버전관리에 추가함을 의미합니다. 그 후 코멘트를 작성 한 후 Commit을 누를경우 처음으로 버전관리가 되어집니다.여기서 코멘트는 무조건 작성해야 합니다. 만약 작성을 안할경우 Commit이 불가능합니다.왜냐하면 버전관리의 의도는 해당 버전이 무엇인 변경되었는지 어떠한 코드가 추가되었는지알 수 있도록 해야하기 위함이기 때문입니다. Commit을 누를 경우 왼쪽에서 Branches 라는 탭을 보면 master라고 뜨면서 오른쪽 창에는제가 적은 코멘트와 함께 버전이 올아와있습니다.여기서 master는 저 자신 즉, 본인을 의미하고 왼쪽하단에는 코멘트와 날짜와 같은 정보,오른쪽 하단에는 추가된 내용이 있습니다. \\2. Git 사용하기2 ( 추가 버전 생성 ) 이제 다시 HTML 로 돌아와서 간단하게 내용을 추가하도록 하겠습니다. 태그 안에 ‘Git 테스트 공부!’ 라는 내용을 추가하고 저장을 하겠습니다. 그럴경우 master BRANCHES에서 변화가 생깁니다.Uncommitted changes라는 문구와 함께 새로운 버전이 올라와 있습니다.왼쪽에 나타난 쿠키모양의 아이콘은 버전관리중인 파일을 의미합니다. 그리고 하단을 보면 Working copy와 Staging Area 창이 보입니다.Working copy에 있는 파일을 눌러보면 오른쪽창에 무엇이 변경되었는지 확인할 수 있습니다.해당 파일을 Staging Area에 올려놓도록 하겠습니다. 해당 파일을 Staging Area에 올려놓고 오른쪽 클릭을 하면 Commit이 있습니다.해당 버튼을 클릭하면 오른쪽 그림처럼 코멘트를 입력할 수 있는 창이 뜨게 됩니다.해당 창에 ‘ 태그 내용 추가’라고 입력하고 Commit하도록 하겠습니다. 그러면 최종적으로 이제 새로운 버전이 추가된 것을 알 수 있습니다.","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"http://yoursite.com/categories/Develop/GIT/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"git-gui-study01","slug":"git-gui-study01","date":"2019-09-06T14:36:10.000Z","updated":"2019-10-02T09:56:44.023Z","comments":true,"path":"2019/09/06/git-gui-study01/","link":"","permalink":"http://yoursite.com/2019/09/06/git-gui-study01/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 - 1. Git의 개요 GIT이란? 프로젝트를 실행하면서 문제가 생길경우 문제를 찾기 위해 해매거나 수시로 과거의 파일을 뒤지면서 결국 예전 상태로 돌아가려는 행위를 한적이 있을 것이다. Git은 문제가 발생하여 프로젝트에 이상이 생길 경우 과거의 상태로 쉽게 돌아가게 해준다. 결과적으로서 실패에 대한 부담감이 확연히 줄어들고(그냥 과거로 백하면 되기떄문) 이것저것 시도를 할 수 있게 해주는 효과를 제공한다. 현재 Git은 버전관리, 백업, 협업과 같은 중대한 장점을 제공한다. 2. Git 설치 www.git-scm.com여기서 git을 받을 수 있다. GitAbout The advantages of Git compared to other source control systems. Documentation Command reference pages, Pro Git book content, videos and other material. Downloads GUI clients and binary releases for all major platforms. Community Get involved! Bug reporting, mailing list, chat, development andwww.git-scm.com △Git 다운로드 완료시 시작버튼에 Git에 관련된 아이콘들이 추가되어 있는 것을 확인 할 수 있다.▽Git Bash를 실행시키고 “git” 이라고 입력시 제대로 설치되었는지 확인할 수 있다. 이 Bash 창을 통해 Git을 유닉스 나 리눅스의 환경처럼 다룰수도 있고 명령어를 이용한 관리가 가능하다. 3. Git을 GUI 형태로 이용할 Source Tree( 소스트리 )설치 Git은 원래 명령어를 가지고 이용을 하는 버전관리 프로그램이다.하지만 이 기능이 너무 어렵고 GUI에 익숙해진 우리들로서는 너무너무 불편하다!따라서 GUI 기능을 가진 SW인 소스트리를 추가적으로 설치하자. 설치는 이곳에서 가능하다.https://www.sourcetreeapp.com/그 외 설치방법은 이 블로그의 포스트를 참조하자.http://codedragon.tistory.com/4907 Sourcetree | Free Git GUI for Mac and WindowsA Git GUI that offers a visual representation of your repositories. Sourcetree is a free Git client for Windows and Mac.www.sourcetreeapp.com SourceTree(소스트리) 설치하기SourceTree(소스트리) 설치파일 다운받기 http://codedragon.tistory.com/4906 SourceTree(소스트리) 설치하기 다운받은 설치파일을 실행합니다. [계속] 계정이 이미 있다면 [Use an existing account] 클릭 o..codedragon.tistory.com 다운로드 완료시 SourceTree 실행화면","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"http://yoursite.com/categories/Develop/GIT/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"html-css-study-02","slug":"html-css-study-02","date":"2019-09-05T16:15:15.000Z","updated":"2019-10-02T08:56:43.140Z","comments":true,"path":"2019/09/06/html-css-study-02/","link":"","permalink":"http://yoursite.com/2019/09/06/html-css-study-02/","excerpt":"","text":"HTML Study 02 display flex layout a 태그 position font css 개발 방법론 외부 css 적용 방법 ( reset CSS 와 normalize CSS ) 오늘의 중요점!css 문제가 생길시 홈페이지를 열어서 검사를 하고 항상 작은 단위부터 큰단위로 확인하다.( 특히 상속,겹침,우선순위 ) box-sizing 방식은 통일하는게 나중의 유지보수에 좋다. 123456&gt; *, *::before, *::after&#123;&gt; &gt; box-sizing: border-box;&gt; &gt; &#125; /*import 바로 아래*/&gt; 부모가 css box 레이아웃을 결정하면 자식도 그것을 따라감.(상속 - 무조건은 아니다. margin , padding 등등) display 요소(즉 태그)는 inline과 block 요소로 나뉜다. inline : 줄 속에 넣는 요소. 줄바꿈이 되지 않고 글자수에 따라 크기 자체가 줄고 늘어난다. block : 좀 더 넓은 범위를 지정할 때 사용하는 요소. 가로화면을 100% 다차지. 줄바꿈이 됨. display : inline - block과 다르게 줄바꿈이 안되고, width와 height가 적용되지 않는다. 오로지 적용된 글자 수에 따라서 크기가 결정된다. display : block - 가로 화면을 다 차지함. 줄바꿈 O display : none - 박스 생성x, 공간 차지x display : flex - 새로 생긴 display. 따라서 특정 버전이 낮은 브라우저에서는 실행X Flex layout flex 모델은 크기 수치를 잘못입력하여도 레이아웃이 크게 깨지지 않는다. 이유는 전체길이에 대해서 비율로 따져서 스스로 값을 정해주기 떄문. display: flexIE 10 or 그 이상 버전에서 사용 가능. flex 설정된 노드의 자식도 flex item을 가지고 모두 flex display가 된다. flex-direction (부모노드)flex-direction은 flex설정시 어떤 방향으로 제기 될것인가를 나열한다. 기본 flex-direction=row 이다. x축 , y축 으로 기준을 나눈다. row = x축 column = y축 flex-basis (자식 노드)flex-item의 크기를 결정합니다. 각 축에 해당하는 (width / height) 의 값을 설정. JUSTIFY-CONTENT: 메인 축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 space-between , flex-item들의 사이를 동일하게 비워줌. space-around, flex-item들의 사이를 비워줌. space-evenly : 익스플로러 지원x ALIGN-ITEMS: 교차축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 order : item 간에 순서를 지정합니다. flex-grow : item들 끼리 크기에 대한 비율을 결정합니다. ex) a-1 b-2 c-1 flex-shrink : flex-item의 크기가 flex-container보다 클때 다른 items의 크기들을 축소시키고 그만큼 해당 item크기를 확대 시킨다. a 태그1&gt; 하이퍼링크 태그인 &lt;a&gt; 는 상황에 따른 css 스타일을 지정할 수 있다. 1234a:link&#123; &#125; /* 선택 안했을 때의 css */a:visited&#123; &#125; /* 선택해서 들어갔을때 */a:hover&#123; &#125; /* 마우스 올라갔을때 글자색 변경 */a:active&#123; &#125; /* 마우스로 클릭한 순간의 상태 */ position static : MarkUp 순서대로 배치, top-bottom-left-right 의 속성값이 적용되지 않는다. absolute : 상위 요소(상위는 반드시 static이 아닌 다른 값)를 기준으로 위치를 설정. relative : 상위 요소(상위는 반드시 static)를 기준으로 위치를 설정. fixed : 요소의 위치를 사용자의 브라우저 기준으로 설정. ( 광고, 상단바, 하단바 등등) font em : 상위요소의 크기에 대해서 비율로 계산한다. rem : 최상위 요소(root)의 크기에 대해서 비율로 계산한다. line-height : 1.15 추천 SpoqaHanSans-kr 본고딕 ( 어도비 배포 ) 1@import url('https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css'); Noto Sans KR 본고딕( 구글 배포 ) 12345&lt;link href=\"https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap\" rel=\"stylesheet\"&gt;&lt;style&gt;@import url('https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap');&lt;/style&gt; CSS 개발 방법론 쉬운 유지보수 코드의 재사용 확장 가능 직관적인 네이밍 BEM OOCSS SMACSS [ CSS 개발 방법론 ] https://gomdoreepooh.github.io/notes/smacss-bem-oocss 외부 CSS 적용 방법 대표적 외부 CSS normalize CSS : 개발 초기 필요한 정도만 초기화 후 사용. Reset CSS : 개발 초기 불필요한 margin, padding 같은 크기들을 모두 초기화. ​ [nomalize css] https://github.com/necolas/normalize.css/ ​ [Reset css] https://meyerweb.com/eric/tools/css/reset/ 적용방법 ( 예 - nomalize ) 123456&lt;link rel=\"stylesheet\"href=\"https://necolas.github.io/normalize.css/latest/normalize.css\"&gt; &lt;style&gt;@import url('https://necolas.github.io/normalize.css/latest/normalize.css');&lt;/style&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-01","slug":"html-css-study-01","date":"2019-09-04T12:47:07.000Z","updated":"2019-10-02T08:56:52.240Z","comments":true,"path":"2019/09/04/html-css-study-01/","link":"","permalink":"http://yoursite.com/2019/09/04/html-css-study-01/","excerpt":"","text":"HTML Study 01 DTD 소개 및 사용 방법 html 영역의 언어 선택 head 영역 안 인코딩 선언 타이틀 요소를 이용한 좋은 제목을 만드는 방법 HTML의 구조 설계 CSS 레이아웃 박스 모델 WEB은 디자인관점이 아닌 콘텐츠 관점으로 보아야 한다.SEO 관점으로 페이지를 작성해야만 한다.문서와 구조와 표현을 분리 해놓는 것이 중요하다.DTD 소개 및 사용 방법 문서타입을 정의 한다. 브라우져에게 해당 HTML이 어떤 표준에 따른 것인지를 알려주는 것을 DTD(Document Type Definition)이라고 한다.DTD는 문서의 제일 위에 위치한다. &lt;! DOCTYPE html&gt; html 영역의 언어 선택 속성 lang=”언어” 식으로 한다. (영어 en, 한국 ko-KR) 언어를 지정해주는 이유는 SEO관점으로서 브라우저에서 검색엔진에 따른 효율성을 높이기 위함이다. head 영역 안 인코딩 선언 meta 태그는 빈요소이다. meta의 속성 charset은 인코딩 형식을 지원한다. 반드시 타이틀보다 먼저 등장해야만 한다. 1&lt;meta charset=\"UTF-8\"&gt; meta의 속성 http-equiv=”X-UA-Compatible” content=”ie=edge” 는 브라우저 사용자 호환성 모드를 의미한다. ( 예, 지원하는 렌더링 모드가 11인데 깔려있는 브라우저 렌더링 버전이 8일경우 11의 렌더링을 8로 호환하여 열어준다.) content는 기본 호환성 브라우저 렌더링 모드를 지정할수있다. 사용자의 브라우저가 edge브라우저를 지원한다면 해당 모드로 연다. 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; 타이틀 요소를 이용한 좋은 제목을 만드는 방법​ SEO 관점에 따라 타이틀 요소를 제대로 적는 것이 중요하다.​​ &gt; 검색 엔진 최적화 (영어: search engine optimization, SEO)는 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다.​​ 12​ &lt;title&gt;웹카페-HTML5,CSS3,웹표준,웹접근성&lt;/title&gt;​ ​​ ###​​​​ ### HTML의 구조 설계​​​​ ## 웹페이지 분석 -&gt; Mark Up -&gt; Naming​​ #### 분석 : 웹페이지는 주로 삼단 구조를 가진다.​​ &gt; 머리말(헤더)​ &gt;​ &gt; 본문(콘텐츠)​ &gt;​ &gt; 꼬리말(푸터)​​​​ #### Web. Cafe. 페이지 분석(삼단 ++)​​ &gt;머리말(헤더)​ &gt;​ &gt;+비주얼(광고등으로 활용가능성)​ &gt;​ &gt;본문(콘텐츠)​ &gt;​ &gt;+슬로건 (커피잔 , 명언)​ &gt;​ &gt;꼬리말(푸터)​​​​ #### Mark Up 단계​​ &gt; body 태그 안​ &gt;​ &gt; ​ header - 머리말​ &gt;​ &gt; ​ div - 비주얼​ &gt;​ &gt; ​ main - 본문​ &gt;​ &gt; ​ article - RSS, 슬로건​ &gt;​ &gt; ​ footer - 꼬리말​​​​ #### Naming 단계 ( Naming : 컴퓨터가 이해할 수 있도록 이름을 지어준다. )​​ &gt; ### { top , bottom 같은 위치 기반 이름은 정말로 안좋음!!! }​ &gt;​ &gt; 이름 주는 방법​ &gt;​ &gt; class : 여러번 사용가능.​ &gt;​ &gt; id : 고유하게 정할 때 사용.​​​​ ### CSS 레이아웃​​ &gt; 정통방식 : float , position, display:inline, display:inline-block​ &gt;​ &gt; 모던방식 : display:inline, display:inline-block, flex, glid​​ ### 박스 모델​​ 12​ box-sizing: content-box | border-box | initial | inherit​ ​​ - content-box : 콘텐트 영역을 기준으로 크기를 정합니다.​ - border-box : 테두리를 기준으로 크기를 정합니다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/tags/TIL/"}]},{"title":"백준 TEST07_문자열 사용하기","slug":"Algorism-for-java07","date":"2019-09-04T10:26:52.000Z","updated":"2019-10-02T09:11:12.245Z","comments":true,"path":"2019/09/04/Algorism-for-java07/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java07/","excerpt":"","text":"백준 TEST07_문자열 사용하기필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 아스키코드1234567891011121314class TEST07_01&#123; public TEST07_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int a = n.charAt(0); // n에 담겨진 첫번째 문자(0번쨰)를 캐릭터형으로 변환후 다시 정수형으로 변환. bw.write(a +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (이클립스 상 답이 맞지만 어째서인지 오답처리됨.)123456789101112131415161718192021222324252627282930313233343536373839404142434445class TEST07_02_t&#123; public TEST07_02_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; int null_num = -1; String S = null; String str = \"abcdefghijklmnopqrstuvwxyz\"; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(int i=0;i&lt;str.length();i++)&#123; int a = 0; for(int j=0;j&lt;S.length();j++)&#123; if(j &gt;= 1 &amp;&amp; S.charAt(j-1) == S.charAt(j))&#123; continue; &#125; if(str.charAt(i) == S.charAt(j))&#123; bw.write(j + \" \"); a++; &#125; &#125; if(a==0)&#123; bw.write(null_num + \" \"); &#125; &#125; bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (정답)123456789101112131415161718192021222324252627282930class TEST07_02_A&#123; public TEST07_02_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; String S = null; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(char alphabet = 'a'; alphabet &lt;= 'z'; alphabet++) &#123; bw.write(S.indexOf(alphabet) + \" \"); &#125; //String.indexOf() 메소드는 원하는 값을 문자열 내에서 원하는 값을 찾아 인덱스 값을 반환한다. 단, 원하는 값이 없으면 -1 을 반환한다. bw.flush(); bw.close(); &#125;&#125; 문자열 반복123456789101112131415161718192021222324class TEST07_03&#123; public TEST07_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = Integer.parseInt(br.readLine()); String a = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\$%*+-./:\"; int b = 0; for(int i=0;i&lt;n;i++)&#123; String xx = br.readLine(); for(int z=2;z&lt;xx.length();z++)&#123; for(int j=0;j&lt;Integer.parseInt(xx.substring(0, 1));j++)&#123; bw.write(xx.charAt(z)); &#125; &#125; bw.write(\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (시간초과 ㅜㅜㅜㅜㅜㅜㅜㅜ)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class TEST07_04_t&#123; public TEST07_04_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String a = null; String A = null; ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); int[] num; while(true)&#123; int count = 0; a = br.readLine(); A = a.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 num = new int[A.length()]; //입력받은 문자의 갯수만큼 정수형 배열을 생성. if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! array.add(String.valueOf(chrInput)); &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end //각각 자신의 개수를 비교하기 시작. for (int i = 0; i &lt; A.length()-1; i++) &#123; for(int j=i+1;j&lt;A.length();j++)&#123; if(array.get(i).equals(array.get(j)))&#123; num[i]++; &#125;//if end &#125;//for-2 end &#125;//for-1 end int temp = 0; String chr_tmp = \"\"; for(int i=0;i&lt;A.length()-1;i++)&#123; for(int j=i+1;j&lt;A.length();j++) if(num[i]&gt;num[j])&#123; temp = num[i]; chr_tmp = array.get(i); num[i] = num[j]; array.set(i,array.get(j)); num[j] = temp; array.set(j,chr_tmp); &#125; &#125; /* for(int i=0;i&lt;A.length();i++)&#123; bw.write(array.get(i)+\" \"); &#125; bw.write(\"\\n\\n\"); for(int i=0;i&lt;A.length();i++)&#123; bw.write(num[i]+\" \"); &#125; bw.write(\"\\n\\n\"); */ if(num.length == 1)&#123; bw.write(array.get(0)); &#125; else if(num[A.length()-1] == num[A.length()-2])&#123; bw.write(\"?\\n\"); &#125; else&#123; bw.write(array.get(A.length()-1)); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (정답)123456789101112131415161718192021222324252627282930313233343536373839404142class TEST07_04_A&#123; public TEST07_04_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String A = null; int[] num = new int[26]; int max = 0; char answer = 0; while(true)&#123; int count = 0; A = br.readLine(); A = A.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end for(int i=0;i&lt;A.length();i++)&#123; num[A.charAt(i)-65]++; if(num[A.charAt(i)-65]&gt;max)&#123; //최초 max는 0 answer = A.charAt(i); max = num[A.charAt(i)-65]; //max값이 증가한다. &#125; else if((num[A.charAt(i)-65]==max))&#123; answer = '?'; &#125; &#125; bw.write(answer); bw.flush(); bw.close(); &#125;&#125; 그룹 단어 체커1234567891011121314151617181920212223242526272829303132333435363738394041class TEST07_05&#123; public TEST07_05()throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String str = null; int count = 0; // a-97 z-122 while(true)&#123; int n = Integer.parseInt(br.readLine()); count = n; int i=0; if(n&lt;=100)&#123; for(i=0;i&lt;n;i++)&#123; int[] num = new int[26]; str = br.readLine(); num[str.charAt(0)-97] = -1; //맨 처음 문자 값은 -1 if(str.length()&gt;1) &#123; for(int j=1;j&lt;str.length();j++)&#123; if(num[str.charAt(j)-97] == -1 &amp;&amp; str.charAt(j) != str.charAt(j-1))&#123; count--; //초기값으로 -1을 지정하였고 그 다음에는 서로 붙어있는지 비교함. 만약 안 붙어있다면 카운트-- break; &#125;//if end num[str.charAt(j) - 97] = -1; // 초기값을 -1로 초기화 시켜나감. &#125;//for-j end &#125;//if end &#125;//for-i end bw.write(count+\"\"); &#125;//if end if(i == n) &#123; break; &#125; &#125;//while end bw.flush(); bw.close(); &#125; &#125; 6단계 - 1차원배열 사용하기 1번문제 임. (전 포스팅 참조)상수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class TEST07_07&#123; public TEST07_07() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] num; while(true)&#123; num = br.readLine().split(\" \"); int w_count = 0; if(num[0].length() &gt; 3 &amp;&amp; num[0].length() &lt; 0)&#123; continue; &#125; if(num[1].length() &gt; 3 &amp;&amp; num[1].length() &lt; 0)&#123; continue; &#125; for(int i=0;i&lt;2;i++)&#123; w_count = 0; for(int j=0;j&lt;num[i].length();j++) if(num[i].charAt(j) == '0')&#123; w_count++; break; &#125; &#125; if(w_count &gt;= 1 )&#123; continue; &#125; int A = Integer.parseInt(num[0]); int B = Integer.parseInt(num[1]); if(A != B)&#123; break; &#125; &#125; int a = 0; int[] sum = new int[2]; for(int i=0;i&lt;2;i++)&#123; for(int j=2;j&gt;=0;j--)&#123; switch(j)&#123; case 2 : a = num[i].charAt(j) - '0'; a = a*100; break; case 1 : a = num[i].charAt(j) - '0'; a = a*10; break; case 0 : a = num[i].charAt(j) - '0'; break; &#125;// charAt(i) - '0' -&gt; char형을 int형으로 변환 sum[i] = sum[i] + a; &#125; &#125; if(sum[0] &gt; sum[1])&#123; bw.write(sum[0] + \"\"); &#125; else&#123; bw.write(sum[1] + \"\"); &#125; bw.flush(); bw.close(); &#125;&#125; 다이얼1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST07_08&#123; public TEST07_08() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String num; int count = 0; while(true)&#123; num = br.readLine(); int w_count = 0; if(num.length()&lt;2 &amp;&amp; num.length()&gt;15)&#123; continue; &#125; for(int i=0;i&lt;num.length();i++)&#123; if(num.charAt(i) &lt; 64 &amp;&amp; num.charAt(i) &gt; 91)&#123; w_count++; break; &#125; &#125;//대문자로만 입력 if(w_count == 0)&#123; break; &#125; &#125; for(int i=0;i&lt;num.length();i++)&#123; switch(num.charAt(i))&#123; case 'A': case 'B': case 'C' : count += 3; break; case 'D': case 'E': case 'F' : count += 4; break; case 'G': case 'H': case 'I' : count += 5; break; case 'J': case 'K': case 'L' : count += 6; break; case 'M': case 'N': case 'O' : count += 7; break; case 'P': case 'Q': case 'R' : case 'S' : count += 8; break; case 'T': case 'U': case 'V' : count += 9; break; case 'W': case 'X': case 'Y' : case 'Z' : count += 10; break; &#125; &#125; bw.write(count + \"\"); bw.flush(); bw.close(); &#125;&#125; 크로아티아 알파벳12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TEST07_09&#123; public TEST07_09() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String c_alpha2[] = &#123;\"c=\",\"c-\",\"d-\",\"lj\",\"nj\",\"s=\",\"z=\"&#125;; String c_alpha3 = \"dz=\"; String croa; while(true)&#123; croa = br.readLine(); int w_count = 0; if(croa.length()&lt;1 &amp;&amp; croa.length()&gt;100)&#123; continue; &#125; for(int i=0;i&lt;croa.length();i++)&#123; if(croa.charAt(i) &lt; 97 || croa.charAt(i) &gt; 122)&#123; if (croa.charAt(i) == '-'|| croa.charAt(i) == '=' )&#123; continue; &#125; w_count++; break; &#125; //소문자 혹은 '-' '=' 가 아닐경우 무한반복 &#125; if(w_count == 0)&#123; break; &#125; &#125; int count = croa.length(); while(true)&#123; if(croa.indexOf(c_alpha3) &gt; -1)&#123; count = count - 2; croa = croa.replaceFirst(c_alpha3,\" \"); &#125; else&#123; break; &#125; &#125;//\"dz=\" 이라는 문자가 존재시 해당 문자를 빼머리고 전체값에서 -2 후 공백으로 변환. for(int k=0;k&lt;7;k++)&#123; while(true)&#123; if(croa.indexOf(c_alpha2[k]) &gt; -1)&#123; count = count - 1; croa = croa.replaceFirst(c_alpha2[k],\" \"); &#125; else&#123; break; &#125; &#125; &#125;//for-k end bw.write(count + \" \"); bw.flush(); bw.close(); &#125;&#125; Main123456789101112131415public class TEST07 &#123; //Main&#123; public static void main(String[] args) throws IOException&#123; // TEST07_01 test07_01 = new TEST07_01(); // TEST07_02_t test07_02_t = new TEST07_02_t(); // TEST07_02_A test07_02_A = new TEST07_02_A(); // TEST07_03 test07_03 = new TEST07_03(); // TEST07_04_t test07_04_t = new TEST07_04_t(); //시간초과 // TEST07_04_A test07_04_A = new TEST07_04_A(); //정답 // TEST07_05 test07_05 = new TEST07_05(); //6번 문제는 1차원배열사용하기 - 1번문제 // TEST07_07 test07_07 = new TEST07_07(); // TEST07_08 test07_08 = new TEST07_08(); TEST07_09 test07_09 = new TEST07_09(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST06_1차원 배열 사용하기","slug":"Algorism-for-java06","date":"2019-09-04T10:26:50.000Z","updated":"2019-10-02T09:11:07.127Z","comments":true,"path":"2019/09/04/Algorism-for-java06/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java06/","excerpt":"","text":"백준 TEST06_1차원 배열 사용하기 필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 단어의개수123456789101112131415161718192021222324252627282930313233class TEST06_01 &#123; public TEST06_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int count=1; for(int i=0;i&lt;n.length();i++)&#123; char chrInput = n.charAt(i); if(n.charAt(i) ==' ')&#123; count++; &#125; if (chrInput &lt; 0x61 &amp;&amp; chrInput &gt; 0x7A) &#123; break; &#125; // 영문(소문자)가 아닐경우 무한 반복! else if (chrInput &lt; 0x41 &amp;&amp; chrInput &gt; 0x5A) &#123; break; &#125; // 영문(대문자)가 아닐 경우 무한 반복! &#125;// for end //count++; if(n.charAt(0)==' ' &amp;&amp; n.charAt(n.length()-1)==' ')&#123; count--; count--; &#125; else if(n.charAt(0)==' ' || n.charAt(n.length()-1)==' ')&#123; count--; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 숫자의 개수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TEST06_02&#123; public TEST06_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int[] num = new int[10]; int A = Integer.parseInt(br.readLine()); int B = Integer.parseInt(br.readLine()); int C = Integer.parseInt(br.readLine()); //bw.write( A * B * C +\"\\n\"); String sum = A * B * C +\"\"; //bw.write(sum); char[] a = sum.toCharArray(); for(int i=0;i&lt;a.length;i++)&#123; switch(a[i])&#123; case '0' : num[0]++; break; case '1' : num[1]++; break; case '2' : num[2]++; break; case '3' : num[3]++; break; case '4' : num[4]++; break; case '5' : num[5]++; break; case '6' : num[6]++; break; case '7' : num[7]++; break; case '8' : num[8]++; break; case '9' : num[9]++; break; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; bw.write(num[i]+\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; OX퀴즈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST06_03&#123; public TEST06_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int t_case = Integer.parseInt(br.readLine()); int[] num = new int[t_case]; String[] ox = new String[t_case]; // O- 0x4F X-0x58 while(true)&#123; int i = 0; for(i=0;i&lt;t_case;i++)&#123; int j = 0; ox[i] = br.readLine(); char[] chrInput= ox[i].toCharArray(); if(ox[i].length() &gt; 80 || ox[i].length() &lt; 0)&#123; break; //MAIN FOR BREAK &#125; for(j=0;j&lt;ox[i].length();j++)&#123; if(chrInput[j] == 'O' ||chrInput[j] == 'X') continue; else break; //SUB FOR BREAK &#125; if(j!=ox[i].length()) break; //MAIN FOR BREAK &#125; if(i==t_case) break; //O혹은 X가 아닐경우 처음 부터 다시 &#125;//while end for(int i=0;i&lt;t_case;i++)&#123; char[] sub = ox[i].toCharArray(); int score = 0; for(int j=0;j&lt;ox[i].length();j++)&#123; if(sub[j] == 'O')&#123; score++; num[i] += score; &#125; else score = 0; &#125;// for - j end bw.write(num[i] + \"\\n\"); &#125;//for - i end bw.flush(); bw.close(); &#125;&#125; 음계1234567891011121314151617181920212223242526272829303132333435363738class TEST06_04&#123; public TEST06_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] m = br.readLine().split(\" \"); String[] x = new String[8]; String[] y = new String[8]; int count = 0 ; for(int i=0;i&lt;m.length;i++)&#123; x[i] = String.valueOf(i+1); y[i] = String.valueOf(8-i); if(x[i].equals(m[i]))&#123; count++; &#125; if(y[i].equals(m[i]))&#123; count--; &#125; &#125; // bw.write(m.length+\"\\n\"); // bw.write(x[3]+\"\\n\"); if(m[0].equals(\"1\") &amp;&amp; count == 8)&#123; bw.write(\"ascending\"); &#125; else if(m[0].equals(\"8\") &amp;&amp; count == -8)&#123; bw.write(\"descending\"); &#125; else&#123; bw.write(\"mixed\"); &#125; bw.flush(); bw.close(); &#125;&#125; 평균 점수12345678910111213141516171819202122232425262728class TEST06_05&#123; public TEST06_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int sum = 0; while(true)&#123; int i=0; for(i=0;i&lt;5;i++)&#123; int n = Integer.parseInt(br.readLine()); if(n&lt;0 || n%5!=0)&#123; break; &#125; if(n&lt;40) n=40; sum += n; &#125;//main for end if(i==5)&#123; break; &#125; &#125;//while end bw.write(sum/5 +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; Main123456789public class TEST06 &#123; public static void main(String[] args) throws IOException&#123; // TEST06_01 test06_01 = new TEST06_01(); // TEST06_02 test06_02 = new TEST06_02(); // TEST06_03 test06_03 = new TEST06_03(); // TEST06_04 test06_04 = new TEST06_04(); TEST06_05 test06_05 = new TEST06_05(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST05_함수 사용하기","slug":"Algorism-for-java05","date":"2019-09-04T10:26:48.000Z","updated":"2019-10-02T09:10:58.677Z","comments":true,"path":"2019/09/04/Algorism-for-java05/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java05/","excerpt":"","text":"## 필요 패키지 및 외부 클래스 123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 셀프넘버12345678910111213141516171819202122232425262728293031323334class hamsu&#123; public int d(int num)&#123; int xxxx = num/1000; int xxx = (num/100)%10; int xx = (num/10)%10; int x = num%10; num = num + xxxx + xxx + xx + x; return num; &#125;&#125;class TEST05_01 extends hamsu&#123; public TEST05_01()&#123;// ArrayList array = new ArrayList(); int i = 0; int[] fin = new int[10000]; //배열 10000개 선언 알아서 0으로 초기화함. for(i=0;i&lt;10000;i++)&#123; if(d(i)&lt;10000)&#123; fin[d(i)] = 1; &#125; if(fin[i] == 0)&#123; System.out.println(i); &#125; &#125; &#125; &#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_01 test05_01 = new TEST05_01(); &#125;&#125; 한수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST05_02 &#123; public TEST05_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int count = 0; int xxxx,xxx,xx,x = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000)&#123; break; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i&lt;100)&#123; count++; &#125; if(i&gt;=100)&#123; xxx = i/100; xx = (i/10)%10; x = i%10; if(xx-x==xxx-xx)&#123; count++; &#125; &#125; if(i&gt;=1000)&#123; xxxx = i/1000; xxx = (i/100)%10; xx = (i/10)%10; x = i%10; if(xxxx-xxx == xxx-xx) if(xx-x == xxx-xx)&#123; count++; &#125; &#125; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_02 test05_02 = new TEST05_02(); &#125;&#125; 별찍기 - 11 별찍기에 대해서 초반에 어떻게 문제를 풀어야하는지 감이 너무 오질 않았다. 따라서 강의를 보면서 이해하는 형식으로 진행하였다. 해당 강의는 C를 기반으로 진행하였으므로 나는 자바의 형식에 맞게 수정을 해주었다. https://youtu.be/WjmEVp-Lgns 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class TEST05_03 &#123; static char[][] arr; public TEST05_03() throws IOException&#123; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = input_num(); arr = new char[n][2*n-1]; //예제 y축 24칸, x축 47칸임(맨 아래 밑변). //배열 선언은 while문 아래가 될 수 없다. for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;2*n-1; j++) &#123; arr[i][j] = ' '; &#125; &#125;//초기화 구문, 자바에서 미선언시 char은 널값으로 초기화됨. 따라서 모두 공백으로 미리 초기화. solution(n,n-1,0);// n은 몇층까지 를 의미, n-1은 첫 시작의 별 위치 -&gt; x축, 0은 첫줄을 의미한다. -&gt;y축 for(int i=0; i&lt;n; i++) &#123; bw.write(arr[i]); bw.write('\\n'); &#125; //이차원배열로 선언되었기 때문에 a[i]번째 줄에 저장된 모든 값을 출력. bw.flush(); bw.close(); &#125; public int input_num() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = 0; int count = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); for(int k=0;k&lt;=10;k++)&#123; if(n==3*(Math.pow(2, k)))&#123; count = 1; &#125; //제대로 된 수를 입력할 때 까지 무한반복 N은 3*2^k승. &#125; if(count == 1) break; &#125; return n; &#125; // 제대로된 n값을 입력하였느지 확인. 제대로된 값이 아니라면 무한반복. public void solution(int n,int x,int y)&#123; if (n == 3) &#123; arr[y][x] = '*'; //첫 별 * arr[y + 1][x - 1] = '*'; //두번 째 별 1 * * arr[y + 1][x + 1] = '*'; //두번째 별 2 arr[y + 2][x - 2] = '*'; //세번째 별 1 ***** arr[y + 2][x - 1] = '*'; //세번째 별 2 ***** arr[y + 2][x] = '*'; //세번째 별 3 ***** arr[y + 2][x + 1] = '*'; //세번째 별 4 ***** arr[y + 2][x + 2] = '*'; //세번째 별 5 ***** return; &#125; //n이 3일때 별을 그려주는 로직 시작. // n이 3이 최소임. solution(n/2, x, y); // 첫 큰 삼각형 solution(n/2, x-(n/2) , y+(n/2)); // 왼쪽 큰 삼각형 solution(n/2, x+(n/2) , y+(n/2)); // 오른쪽 큰 삼각형 &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_03 test05_03 = new TEST05_03(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST04_if문 사용해보기","slug":"Algorism-for-java04","date":"2019-09-04T10:26:47.000Z","updated":"2019-10-02T09:10:53.516Z","comments":true,"path":"2019/09/04/Algorism-for-java04/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java04/","excerpt":"","text":"백준 TEST04_if문 사용해보기 기본 필요 패키지 및 외부클래스123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 시험성적1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST04_01&#123; public TEST04_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&gt;= 0 &amp;&amp; n&lt;101)&#123; break; &#125; &#125; switch (n/10) &#123; case 10 : case 9 : bw.write(\"A\\n\"); bw.flush(); break; case 8 : bw.write(\"B\\n\"); bw.flush(); break; case 7 : bw.write(\"C\\n\"); bw.flush(); break; case 6 : bw.write(\"D\\n\"); bw.flush(); break; default : bw.write(\"F\\n\"); bw.flush(); break; &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_01 test04_01 = new TEST04_01(); &#125;&#125; 세 수 - 버전112345678910111213141516171819202122232425262728293031323334class TEST04_02_01&#123; public TEST04_02_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); if ((A&gt;=B)&amp;&amp;(A&lt;=C)||(A&gt;=C)&amp;&amp;(A&lt;=B))&#123; bw.write(A+\"\\n\"); bw.flush(); bw.close(); &#125; else if((B&gt;=C)&amp;&amp;(B&lt;=A)||(B&gt;=A)&amp;&amp;(B&lt;=C))&#123; bw.write(B+\"\\n\"); bw.flush(); bw.close(); &#125; else&#123; bw.write(C+\"\\n\"); bw.flush(); bw.close(); &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_01 test04_02_01 = new TEST04_02_01(); &#125;&#125; 세 수 - 버전2 (정렬이용)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TEST04_02_02&#123; public TEST04_02_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; int tmp; ArrayList&lt;Integer&gt; num = new ArrayList&lt;&gt;(); String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); num.add(A); num.add(B); num.add(C); //버블정렬 for(int i=1;i&lt;num.size();i++)&#123; for(int j=0;j&lt;num.size()-i;j++)&#123; if(num.get(j)&gt;=num.get(j+1))&#123; //num.get(1);//확인. num.set(1,temp);//수정. tmp = num.get(j); num.set(j, num.get(j+1)); num.set(j+1, tmp); &#125; &#125; &#125; /* //선택정렬 for(int i=0;i&lt;num.size()-1;i++)&#123; for(int j=i+1;j&lt;num.size();j++)&#123; if(num.get(i) &gt;= num.get(j)) &#123; tmp = num.get(j); num.set(j,num.get(i)); num.set(i,tmp); &#125; &#125; &#125; */ bw.write(num.get(1)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_02 test04_02_02 = new TEST04_02_02(); &#125;&#125; X보다 작은 수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST04_03&#123; public TEST04_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int i = 0; int x = 0; while(true)&#123; String[] a = br.readLine().split(\" \"); n = Integer.parseInt(a[0]); x = Integer.parseInt(a[1]); if(x&gt;=1 &amp;&amp; x&lt;=10000 &amp;&amp; n&gt;=1 &amp;&amp; n&lt;=10000)&#123; break; &#125; &#125; String[] A = br.readLine().split(\" \"); while(true)&#123; for(i=0;i&lt;n;i++)&#123; int y = Integer.parseInt(A[i]); if(y&lt;=0 &amp;&amp; y&gt;=10000)&#123; break; &#125; if(y&lt;x)&#123; bw.write(y+\" \"); &#125; &#125; if(i==n)&#123; break; &#125; &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_03 test04_03 = new TEST04_03(); &#125;&#125; 평균1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TEST04_04&#123; public TEST04_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); //정수형을 값을 저장할 리스트 공간 int n,i,tmp = 0; //n은 과목수 , i는 조건을 위한 수 , tmp는 임시저장소 , sum 최종합 double sum = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000) break; &#125; while(true)&#123; String[] a = br.readLine().split(\" \"); for(i=0;i&lt;n;i++)&#123; tmp = Integer.parseInt(a[i]); array.add(Integer.parseInt(a[i])); if(tmp&gt;100 &amp;&amp; tmp&lt;=0)&#123; break; &#125; &#125; if(i==n)&#123; break; &#125; &#125; for(i=0;i&lt;array.size()-1;i++)&#123; for(int j=i+1;j&lt;array.size();j++)&#123; if(array.get(i)&gt;array.get(j))&#123; tmp = array.get(i); array.set(i, array.get(j)); array.set(j,tmp); &#125; &#125; &#125;//선택정렬 이용 for(i = 0;i&lt;array.size();i++)&#123; sum += array.get(i); &#125; bw.write((double)(sum/array.size()/array.get(array.size()-1)*100.0)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_04 test04_04 = new TEST04_04(); &#125;&#125; 텍스트 추가 \\05. 평균은 넘겠지 텍스트 추가 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TEST04_05&#123; public TEST04_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Double&gt; number = new ArrayList&lt;&gt;(); int C = Integer.parseInt(br.readLine()); int j = 0; double hap = 0; while(true)&#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); double num = 0; int sum = 0; double avg = 0; String[] x = br.readLine().split(\" \"); if(Integer.parseInt(x[0])&lt;1 &amp;&amp; Integer.parseInt(x[0])&gt;1000)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); for(int i=0;i&lt;=Integer.parseInt(x[0]);i++)&#123; array.add(Integer.parseInt(x[i])); if(Integer.parseInt(x[i])&lt;0 &amp;&amp; Integer.parseInt(x[i])&gt;100)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); &#125; sum = 0; for(int i=1;i&lt;array.size();i++)&#123; sum = sum + array.get(i); &#125; avg = sum/array.get(0); for(int i=1;i&lt;array.size();i++)&#123; if(array.get(i)&gt;avg)&#123; num++; &#125; &#125; hap = num/array.get(0); number.add((num/array.get(0))*100); j++; if(j==C)&#123; break; &#125; &#125; for(int i=0;i&lt;C;i++)&#123; System.out.printf(\"%.3f\",number.get(i)); System.out.println(\"%\"); &#125; /* for(int i=0;i&lt;C;i++)&#123; bw.write(number.get(i)+\"%\"+\"\\n\"); &#125; bw.flush(); bw.close(); */ &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_05 test04_05 = new TEST04_05(); &#125;&#125; 더하기 사이클123456789101112131415161718192021222324252627282930313233343536373839404142class TEST04_06&#123; public TEST04_06() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int xx = 0; int x = 0; int fin = 0; int cycle_num = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); fin = n; if(n&gt;=0 &amp;&amp; n&lt;=99)&#123; break; &#125;// 아닐경우 무한반복 &#125; while(true)&#123; xx = n/10; x = n%10; n = (xx + x)%10; n = (x*10)+n; cycle_num++; if(fin == n)&#123; break; &#125; &#125; bw.write(cycle_num+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_06 test04_06 = new TEST04_06(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST03_for문 사용해보기","slug":"Algorism-for-java03","date":"2019-09-04T10:26:45.000Z","updated":"2019-10-02T09:10:38.033Z","comments":true,"path":"2019/09/04/Algorism-for-java03/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java03/","excerpt":"","text":"백준_TEST03_for문 사용해보기N찍기123456789101112131415161718192021import java.util.*;class TEST03_01&#123; public TEST03_01()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_01 test03_01 = new TEST03_01(); &#125;&#125; 기찍 N123456789101112131415161718192021import java.util.*;class TEST03_02&#123; public TEST03_02()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=N;i&gt;=1;i--)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_02 test03_02 = new TEST03_02(); &#125;&#125; 구구단12345678910111213141516171819202122import java.util.*;class TEST03_03&#123; public TEST03_03()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=9;i++)&#123; System.out.println(N+\" * \"+i+\" = \"+N*i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_03 test03_03 = new TEST03_03(); &#125;&#125; 별찍기-1123456789101112131415161718192021222324import java.util.*;class TEST03_04&#123; public TEST03_04()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_04 test03_04 = new TEST03_04(); &#125;&#125; 별찍기-21234567891011121314151617181920212223242526272829303132333435import java.util.*;class TEST03_05&#123; public TEST03_05()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); // int K = N-1; for(int i=1;i&lt;=N;i++)&#123; /* for(int x=K;x&gt;=1;x--)&#123; System.out.print(\" \"); &#125; */ for(int j=1;j&lt;=N-i;j++)&#123; System.out.print(\" \") ; &#125; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; //K--; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_05 test03_05 = new TEST03_05(); &#125;&#125; 별찍기-3123456789101112131415161718192021222324252627import java.util.*;class TEST03_06&#123; public TEST03_06()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=N-i+1;j&gt;=1;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_06 test03_06 = new TEST03_06(); &#125;&#125; 별찍기-4123456789101112131415161718192021222324252627import java.util.*;class TEST03_07&#123; public TEST03_07()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;i;j++)&#123; System.out.print(\" \"); &#125; for(int j=N-i;j&gt;0;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_07 test03_07 = new TEST03_07(); &#125;&#125; ###2007년 -&gt; 해결은 하였으나 더 간단하게 푸는 방법이 존재함. -&gt; 1번=직접 해결한 소스. 2번=해답 소스 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1번import java.util.*;class TEST03_08&#123; public TEST03_08()&#123; Scanner scan = new Scanner(System.in); int x,y,z = 0; //z는 일주일 7을 의미. while(true)&#123; x = scan.nextInt(); if(x&gt;=1 &amp;&amp; x&lt;=12)&#123; break; &#125; &#125; while(true)&#123; y = scan.nextInt(); if(y&gt;=1 &amp;&amp; y&lt;=31)&#123; break; &#125; &#125; // x = 월, y = 일을 입력받는다. //ArrayList&lt;String&gt; month = new ArrayList&lt;&gt;(); //month.add(\"SUN\");month.add(\"MON\"); //한개씩은 위처럼 한번에는 아래처럼 이용. Array.asList ArrayList&lt;String&gt; week = new ArrayList&lt;&gt;(Arrays.asList(\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\",\"SUN\")); for(int i=1;i&lt;=12;i++)&#123; if(i==1 || i==3 || i==5|| i==7 || i==8 || i==10 || i==12)&#123; for(int j=1;j&lt;=31;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 1,3,5,7,8,10,11,12 월 for문 end &#125; else if(i==2)&#123; for(int j=1;j&lt;=28;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 2월 for문 end &#125; else&#123; for(int j=1;j&lt;=30;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 4,6,9,11 월 for문 end &#125; // if end &#125;//for-i end &#125; &#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_08 test03_08 = new TEST03_08(); &#125;&#125; 12345678910111213141516171819202122//2번 - 해답import java.util.Scanner; public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int month = sc.nextInt(); int day = sc.nextInt(); sc.close(); int[] daysInMonth = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; String[] dayOfTheWeeks = &#123;\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"&#125;; int totalDays = day; for (int i = 0; i &lt; month - 1; ++i) &#123; totalDays += daysInMonth[i]; &#125; System.out.println(dayOfTheWeeks[totalDays % 7]); &#125;&#125; 합123456789101112131415161718192021import java.util.*;class TEST03_09&#123; public TEST03_09()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int sum = 0; for(int i=1;i&lt;=n;i++)&#123; sum += i; &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_09 test03_09 = new TEST03_09(); &#125;&#125; 숫자의 합 &lt;미해결&gt;-&gt; 미해결한 이유 : Scanner 메서드로는 숫자를 1개씩 입력 받는건 불가능하다. 123456789101112131415161718192021222324252627import java.util.*;class TEST03_10_1&#123; public TEST03_10_1()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int a = 0; int sum = 0; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=n;i++)&#123; a = scan.nextInt(); array.add(a); &#125; for(int i=1;i&lt;=n;i++)&#123; sum += array.get(i-1); &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_1 test03_10_1 = new TEST03_10_1(); &#125;&#125; 숫자의 합 &lt;해결&gt;-&gt; 해결법 : 문자열로 받아서 끊어서 하나하나 더하거나 아스키코드를 이용한다. -&gt; 여기서는 끊어서 사용하는 substring() 함수를 이용. 12345678910111213141516171819202122232425import java.util.*;class TEST03_10_2&#123; public TEST03_10_2()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); String a = scan.next(); scan.close(); int sum = 0; for(int i=0;i&lt;n;i++)&#123; sum += Integer.parseInt(a.substring(i, i + 1)); &#125; //Integer.parseInt() 인트형으로 형변환 메서드 //substring(a,b); a=현재위치 b=까지 System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_2 test03_10_2 = new TEST03_10_2(); &#125;&#125; 열 개씩 끊어 출력하기1234567891011121314151617181920212223import java.util.*;class TEST03_11&#123; public TEST03_11()&#123; Scanner scan = new Scanner(System.in); String n = scan.next(); scan.close(); for(int i=1;i&lt;=n.length();i++)&#123; System.out.print(n.charAt(i-1)); if(i%10==0)&#123; System.out.println(\"\"); &#125; &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_11 test03_11 = new TEST03_11(); &#125;&#125; 빠른 A+B (BufferedReader , BufferedWriter)1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;class TEST03_12&#123; public TEST03_12() throws IOException&#123; //버퍼드리더와 버퍼드라이터를 쓰기 위한 조건 : throws NumberFormatException, IOException BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));//선언 int test_case = Integer.parseInt(br.readLine()); // 몇개 입력? //readline은 버퍼에 입력하는것. for(int i=0; i&lt;test_case;i++) &#123; //ex) 5개라 입력했으면 총 5줄의 입력을 받음. String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. bw.write(\"현재 입려숫자는 각각\"+a[0]+\" \"+a[1]+\"\\n\"); int answer = Integer.parseInt(a[0]) + Integer.parseInt(a[1]); bw.write(answer+\"\\n\"); // write는 버퍼에 해당 값을 저장하는것. // flush는 버퍼에 있는 내용을 printf하는것이다. // 여기서 한번 flush를 해버리면 버퍼의 내용을 출력과 동시에 비운다. &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_12 test03_12 = new TEST03_12(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준_TEST02_사칙연산 도전하기","slug":"Algorism-for-java02","date":"2019-09-04T10:26:42.000Z","updated":"2019-10-02T09:10:45.829Z","comments":true,"path":"2019/09/04/Algorism-for-java02/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java02/","excerpt":"","text":"백준 TEST02_사칙연산 도전하기A*B123456789101112131415161718192021import java.util.*;//1번 2번은 TEST01단계에서 해결했음. A+B , A-Bclass TEST02_03&#123; public TEST02_03()&#123; // 생성자 Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.println(a*b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_03 test02_03 = new TEST02_03(); &#125;&#125; A / B (오차범위 10-9까지)1234567891011121314151617181920import java.util.*;class TEST02_04&#123; public TEST02_04()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.printf(\"%.9f\",a/b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자// TEST02_03 test02_03 = new TEST02_03(); TEST02_04 test02_04 = new TEST02_04(); &#125;&#125; 사칙연산1234567891011121314151617181920212223import java.util.*;class TEST02_05&#123; public TEST02_05()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;=1 &amp;&amp; b&lt;=10000)&#123; System.out.println((int)a+(int)b); System.out.println((int)a-(int)b); System.out.println((int)a*(int)b); System.out.println((int)a/(int)b); System.out.println((int)a%(int)b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_05 test02_05 = new TEST02_05(); &#125;&#125; 나머지1234567891011121314151617181920212223import java.util.*;class TEST02_06&#123; public TEST02_06()&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); int c = scan.nextInt(); if(a&gt;=2 &amp;&amp; a&lt;=10000 &amp;&amp; b&gt;=2 &amp;&amp; b&lt;=10000 &amp;&amp; c&gt;=2 &amp;&amp; c&lt;=10000)&#123; System.out.println((a+b)%c); System.out.println((a%c + b%c)%c); System.out.println((a*b)%c); System.out.println((a%c * b%c)%c); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_06 test02_06 = new TEST02_06(); &#125;&#125; A+B-2 백준 TEST01 단계의 A+B 동일 문제. 따라서 넘어감. 설탕 배달 알고리즘1234567891011121314151617181920212223242526272829303132import java.util.*;class TEST02_08&#123; public TEST02_08()&#123; Scanner scan = new Scanner(System.in); int box = 0 ; int sugar_kg = scan.nextInt(); if(sugar_kg &gt;=3 &amp;&amp; sugar_kg &lt;= 5000)&#123; if(sugar_kg/5 != 0)&#123; for(box = sugar_kg/5;box&gt;=0;box--)&#123; if((sugar_kg - box*5)%3==0)&#123; box += (sugar_kg - box*5)/3; break; &#125; &#125; &#125; else if(sugar_kg == 3)&#123; box = 1; &#125; else&#123; box = -1; &#125; &#125; System.out.println(box); &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_08 test02_08 = new TEST02_08(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST01_입/출력 받아보기","slug":"Algorism-for-java01","date":"2019-09-04T10:26:38.000Z","updated":"2019-10-02T09:10:32.255Z","comments":true,"path":"2019/09/04/Algorism-for-java01/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java01/","excerpt":"","text":"# # 백준 TEST01_입/출력 받아보기 Hello World12345public class TEST01_01 &#123; public static void main(String args[])&#123; System.out.println(\"Hellow World\"); &#125;&#125; A+B12345678910import java.util.*;public class TEST01_02&#123; public static void main(String args[])&#123; Scanner scan = new Scanner(System.in); int a, b; a = scan.nextInt(); b = scan.nextInt(); System.out.println(a + b); &#125;&#125; A-B1234567891011import java.util.*;public class TEST01_03 &#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); System.out.println(a-b); &#125;&#125; 등록텍스트 추가 123456public class TEST01_04 &#123; public static void main(String[] args)&#123; System.out.println(\"맞은갯수\"); System.out.println(\"아이디명\"); &#125;&#125; 개텍스트 추가 1234567891011public class TEST01_05 &#123; public static void main(String[] args)&#123; System.out.println(\"|\\\\_/|\"); //역슬래쉬를 print로 표시하고 싶으면 \\\\로 사용. System.out.println(\"|q p| /&#125;\"); System.out.println(\"( 0 )\\\"\\\"\\\"\\\\\"); //따옴표를 print로 표시하고 싶으면 \\\"로 사용. System.out.println(\"|\\\"^\\\"` |\"); System.out.println(\"||_/=\\\\\\\\__|\"); &#125;&#125; We love kriii12345public class TEST01_06 &#123; public static void main(String[] args)&#123; System.out.printf(\"강한친구 대한육군\\n강한친구 대한육군\\n\"); &#125;&#125; 그대로 출력하기 (연습)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. charAt(i) =&gt; str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. substring(i,j) =&gt; i부터 j-1까지. 문제점 -&gt; 0~100줄까지 전부 입력을 해야하는데 빈줄이 주어지지않는다. 라는 점에서 문제가 있다고 생각함. 만족 조건은 입력 최대 100줄과 각 줄이 100줄을 넘을 경우 잘라내는 기능 까지만 구현이 완료됬음. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;public class TEST01_07 &#123; public static boolean checkInputOnlyNumberAndAlphabet(String str) &#123; char chrInput = str.charAt(0); for (int i = 0; i &lt; str.length(); i++) &#123; chrInput = str.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 // charAt(i) = str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; // 영문(소문자) OK! &#125; else if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; // 영문(대문자) OK! &#125; else if (chrInput &gt;= 0x30 &amp;&amp; chrInput &lt;= 0x39) &#123; // 숫자 OK! &#125; else &#123; return false; // 영문자도 아니고 숫자도 아님! &#125; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); for (int n = 0; n &lt; 100; n++) &#123; String str = scan.nextLine(); if (str.length() &gt; 100) &#123; str = str.substring(0, 100); &#125; // substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. // substring(i,j) =&gt; i부터 j-1까지. if (checkInputOnlyNumberAndAlphabet(str)) &#123; System.out.println(str); &#125;//줄에 영문,숫자를 제외한 다른글자가 포함되어있을 경우 출력을 안함. &#125; // for문 끝 &#125; &#125; 그대로 출력하기 (답)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. 고친점 : 너무 어렵게 생각하고 있었음. 굳이 함수를 따로 생성하지 않고 hasNextLine()을 이용해 엔터를 치면서 게속해서 글을 작성하도록 변경 그 외 함수를 추가적으로 이용하였음. ArryList에 제네릭을 이용하여 String만 받기로 함. -함수-각 줄은 100글자를 넘지 않으며: word.length() &gt; 100 빈 줄은 주어지지 않는다: word.isEmpty() 각 줄은 공백으로 시작하지 않고: word.startsWith(“ “) 공백으로 끝나지 않는다: word.endsWith(“ “) 1234567891011121314151617181920212223242526272829303132333435import java.util.*; public class TEST01_07_ANS &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.startsWith(\" \") || word.endsWith(\" \") || word.length()&gt;100 || word.isEmpty()) &#123; break; &#125; array.add(word); &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); &#125; &#125; &#125; /*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break빈 줄은 주어지지 않는다: word.isEmpty()-&gt; 빈줄일경우 break각 줄은 공백으로 시작하지 않고: word.startsWith(\" \")-&gt; 첫글자가 공백 일경우 break공백으로 끝나지 않는다: word.endsWith(\" \")-&gt; 마지막 글자가 공백 일 경우 break */ 그대로 출력하기2* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄이 있을 수도 있다. * 각 줄은 공백으로 시작할수도 있고, 공백으로 끝날수도 있다. 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Scanner;public class TEST01_08 &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.length()&gt;100 ) &#123; break; &#125; if(word.equals(\"BYE\"))&#123; //BYE를 입력해서 WHILE 탈출 break; &#125; array.add(word); //현재 줄의 입력내용을 Array배열에 추가. &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); // 각 Array배열의 내용을 출력. &#125; &#125;&#125;/*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break*/","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"ETC-test","slug":"ETC-test","date":"2019-09-04T05:04:06.000Z","updated":"2019-10-02T10:16:38.424Z","comments":true,"path":"2019/09/04/ETC-test/","link":"","permalink":"http://yoursite.com/2019/09/04/ETC-test/","excerpt":"","text":"","categories":[{"name":"etc","slug":"etc","permalink":"http://yoursite.com/categories/etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-03T13:04:58.334Z","updated":"2019-09-03T13:08:10.424Z","comments":true,"path":"2019/09/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"20190903-personal-study-html","slug":"20190903-personal-study-html","date":"2019-09-03T12:54:57.000Z","updated":"2019-10-02T08:53:40.946Z","comments":true,"path":"2019/09/03/20190903-personal-study-html/","link":"","permalink":"http://yoursite.com/2019/09/03/20190903-personal-study-html/","excerpt":"","text":"20190903-Test-web-page Study파일 구조 style.css1234567891011121314151617181920212223242526272829303132body&#123;overflow: hidden;&#125;.image&#123;position:relative;float: left;height: 200px;width:300px;margin : 2px;border: 1px solid white;z-index:0;&#125;.image-selected&#123; border: 1px solid black;background-color:white;&#125;.image-selected &gt; img&#123;opacity: 0.5;&#125;.image &gt; img&#123;height:100%;&#125;.image-magnified&#123;z-index:1;&#125;.image-magnified &gt; img&#123;height:400px;width:600px;margin-left:-150px;margin-top:-100px;opacity:0.95;&#125; image_list.json1234567891011121314[\"./images/1.jpg\",\"./images/2.jpg\",\"./images/3.jpg\",\"./images/4.jpg\",\"./images/5.jpg\",\"./images/6.jpg\",\"./images/7.jpg\",\"./images/8.jpg\",\"./images/9.jpg\",\"./images/10.jpg\",\"./images/11.jpg\",\"./images/12.jpg\"] index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;title&gt;Select the Gallery&lt;/title&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Show\" onclick=\"slideShow(this)\"&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; script.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var req = new XMLHttpRequest();req.open(\"GET\", \"./json/image_list.json\");req.onreadystatechange = function()&#123;if(this.readyState == 4)&#123;var data = JSON.parse(this.response);for(var i= 0; i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125;div.onmouseover = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000);&#125;div.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125;var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);&#125;&#125;&#125;req.send();function selectAll(btn)&#123;var img = document.getElementsByClassName(\"image\");for(var i=0; i&lt;img.length; i++)&#123;if(btn.value == \"UnSelect All\")&#123;img[i].classList.remove(\"image-selected\");&#125;else&#123;img[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"UnSelect All\")&#123;btn.value = \"Select All\";&#125;else&#123;btn.value = \"UnSelect All\";&#125;&#125;function slideShow(btn)&#123;var img = document.getElementsByClassName(\"image\");var index = 0;img[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;img[index].classList.remove(\"image-magnified\");index ++;if(index &lt; img.length)&#123;img[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝낫습니다.\");&#125;&#125;,1000);&#125; 프로젝트에 images 폴더 추가 프로젝트에 json 폴더 추가 프로젝트에 css 파일 추가 script 파일 생성 html 태그 안에 script 파일 및 css 파일 연결 1234&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt; script 파일 작성 시작 1 Ajax 사용하여 비동기방식으로 json 데이터를 요청하고 응답한 값을 가지고 것 임. 123456789101112131415161718192021222324252627var req = new XMLHttpRequest(); // 1. Ajax를 이용하기 위한 객체를 생성req.open(\"GET\",\"./json/image_list.json\"); // 2. 요청방식과 URL 설정// 3. onreadystatechange : 서버로부터 응답시 할 행동을 작성req.onreadystatechange = function()&#123; // 4. 4번 -&gt; 모든 응답이 제대로 받았을 겅우를 의미if(this.readyState == 4)&#123; // 5. 응답데이터(문자열)를 javascript 객체로 변환하고 div태그를 생성하여 데이터를 대입해줍니다.// div 태그의 속성은 class = \"image\" 로 설정합니다.var data = JSON.parse(this.response); for(var i=0;i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");// 6. img 태그를 생성하고 각 데이터를 img태그에 넣습니다. // img 태그는 div태그의 자손으로, div태그는 dody태그의 자손으로 삽입합니다.var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);//밑에서 추가 진행함&#125; &#125; &#125;req.send(); // 요청합니다. script 파일 작성 시작 2 생성된 div 태그에 기능을 추가합니다. 기능은 총 3가지입니다. 클릭 (onclick) 1234567891011121314// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성// 1. 생성된 태그에 클릭 이벤트를 넣어줍니다. // 선택 및 취소 했을 경우 스타일 달리지도록 만듭니다.// 선택시 image-selected , 미선택시 imagediv.setAttribute(\"class\",\"image\");div.onclick = function()&#123;if(this.getAttribute(\"class\").indexOf(\"image-selected\") == -1)&#123;this.setAttribute(\"class\",\"image image-selected\");&#125;else&#123;this.setAttribute(\"class\",\"image\");&#125;&#125; 위 문의 if문과 else 문은 classList 함수를 이용하여 짧게 가능.1234// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125; 마우스 오버 (onmouseover) 123456789// 2. 생성된 태그에 마우스오버 이벤트를 넣어줍니다.// div 위에 마우스가 올라갈 경우 시간만큼 스타일이 달라지도록 만듭니다.// 사용할 css style : image-magnifieddiv.onmouseove = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000); //1초&#125; 마우스 아웃 (onmouseout) 12345678// 3. 생성된 태그에 마우스아웃 이벤트를 넣어줍니다.// div 위에 마우스가 빠져나갈 경우 적용된 스타일을 제거하고 시간을 초기화 하도록 만듭니다.// 제거할 css style : image-magnifieddiv.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125; html 파일 안 태그 안에 2개의 버튼을 생성하고 click 이벤트를 연결합니다. 모두 선택 및 해제 기능 각 이미지가 1번씩 크게 보여지는 슬라이드 쇼 기능 123456&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Slidshow\" onclick=\"slideShow(this)\"&gt; &lt;!-- 사용될 함수에서 해당 button 객체의 value값을 이용하기 위해 인자로 this를 넘겨줍니다. --&gt;&lt;hr&gt; &lt;!-- 한줄 띄어줍니다. --&gt;&lt;/body&gt; script 파일 작성 : 모두 선택 기능 추가. 1234567891011121314151617function selectAll(btn)&#123;var images = document.getElementsByClassName(\"image\"); //div class명이 image입니다.for(var i=0; i&lt;images.length ; i++)&#123;if(btn.value == \"Unselect All\")&#123;images[i].classList.remove(\"image-selected\");&#125;else&#123;images[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"Unselect All\")&#123;btn.value = \"Selcet All\";&#125;else&#123;btn.value = \"Unselect All\";&#125;&#125; script 파일 작성 : 슬라이드쇼 기능 추가. 12345678910111213141516function slideShow(btn)&#123;var images = document.getElementsByClassName(\"image\");var index = 0;images[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;images[index].classList.remove(\"image-magnified\");index++;if(index &lt; images.length)&#123;images[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝났습니다.\");&#125;&#125;,1000);","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"20190902-start-git","slug":"20190902-start-git","date":"2019-09-02T12:52:11.000Z","updated":"2019-10-02T08:53:05.685Z","comments":true,"path":"2019/09/02/20190902-start-git/","link":"","permalink":"http://yoursite.com/2019/09/02/20190902-start-git/","excerpt":"","text":"20190902-start-git* git 개발은 항상 끊어서 커밋 해야만 한다. 그리고 영어로 쓰는 것을 습관화들여라! *Git CLI 기본 설정. ( 설정이 완료되있다면 git 시작하기 1 or 2부터 시작 ) * git config –list ( git 설저한 내용 확인 ) git config –global user.name “HYEOK999”. git config –list (위에서 입력한 내용 확인). git config –global user.email “iasg2004@naver.com“. git config –global editor “vim”. git 시작하기1 ( local -&gt; remote ) 가장 중요한 명령어 : 현재 상태 확인 git status 폴더생성 및 폴더 진입 git init git diff git status(현재 상태) 파일 생성 및 내용 작성 git add 파일명.확장자 github 계정 페이지에 접속 후 레파지토리에서 new를 누르고 저장소를 만든다. 저장소 명은 폴더명과 같게끔 설정할것. 만든후 주소 복사. git remote add [origin] 주소복붙 등록 확인 -&gt; git remote git commit 편집모드( i ) 들어가서 첫줄이 제목 (엔터치기 전까지) 다음줄이 내용! commit 제목은 현재형 구나 절로 적는다! / 내용은 자세하게 적는다. feat : 협업 docs : 문서작업 bugfix : 버그를 수정했을 때 hotfix : 빠르게, 급하게 수정했을 때 release : 개발 git push -u [origin] master -u : 로컬 브랜치를 새로 만든 후 원격저장소에 해당 브랜치를 push하고자 할 때 처음 이후의 Git Commit 파일 및 폴더 내용 수정 및 추가 git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용 “ git push [origin] master git 시작하기2 ( remote -&gt; local ) 가장 중요한 명령어 : 현재 상태 확인 git status 저장소 생성 ( public , gitignore:Node , LICENSE:MIT ). 저장소 주소 복사 git clone 주소복붙. 파일 및 폴더 내용 수정 및 추가. git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용” git push [origin] master.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"GIT","slug":"TIL/GIT","permalink":"http://yoursite.com/categories/TIL/GIT/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"20190902-study-terminal","slug":"20190902-study-terminal","date":"2019-09-02T12:52:11.000Z","updated":"2019-10-02T08:53:27.970Z","comments":true,"path":"2019/09/02/20190902-study-terminal/","link":"","permalink":"http://yoursite.com/2019/09/02/20190902-study-terminal/","excerpt":"","text":"20190902-study-termianl 기본적인 리눅스 리눅스 : 커널 또는 GNU를 포함한 라오픈 라이브러리와 도구가 포함된 운영체제. 여러종류의 쉘을 제공함. Shell : 운영체제의 커널과 사용자를 이어주는 소프트웨어 CLI . ( Shell 사용할 경우 GUI보다 효율성이 높다. )Kenal : 컴퓨터와 소프트웨어를 이어 주는 시스템소프트웨어 터미널 리눅스(유닉스) 명령어 명령어 의미 예 ctr+c키 명령어 취소 ~ 접속시 나오는 폴더를 의미 ls 현재 폴더에서 접속가능한 폴더 리스트를 나열함. -a 숨긴파일도 표시 -l 파일의 추가정보를 나열하며 한줄씩 표시 cd Change Directory 의 약자. 폴더 이동 .. 상위 폴더를 의미 mkdir MaKe DIRectory 의 약자. 폴더 생성 mv {1} {2} MoVe의 약자.{1}을 {2}로 이동 mv {1} {2} (같은 위치에 있을경우) {1}을 {2}로 이름바꾸기 cp {1} {2} CoPy의 약자. {1}을 {2}로 이동 rm {1} ReMove의 약자. 파일을 삭제. rm -r {1} {1}이 폴더 일 경우. 폴더를 삭제. touch 파일 생성 ( 생성할떄 파일명 앞에 . 을 붙이면 히든파일생성) chmod {권한} {폴더 및 파일} {폴더 및 파일}을 {권한}으로 권한 레벨 변경. chmod 555 study.html Vim 명령어 vi {1} : {1}을 vim으로 열기. (vim은 에디트)ext : 어떠한 모드에서 기본모드로 돌아감. 모드 3가지 ( 기본, I , : )기본 명령어 의미 예 Y 커서가 놓인 줄 복사 P 커서가 놓인 줄 아래에 붙여넣기 dd 커서가 놓인 줄 잘라내기 x 커서놓인 곳 한글자 삭제. i 커서가 놓은 곳 앞에 i 모드 돌입. o 커서가 놓인 줄 아래에 i 모드 돌입. O 커서 놓은 줄 위에 i 모드 돌입. Insert 편집 모드 ( key - i ) 명령어 의미 예 exc키 노멀모드로 돌아감. 명령어 모드 ( key - : ) 명령어 의미 예 q quit의 약자. vim 편집기를 나감. !q 저정하지않고 나감. wq 저장하면서 나감. exc키 가본 모드로 돌아감.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"post-test","slug":"post-test","date":"2019-09-01T12:28:38.000Z","updated":"2019-10-02T10:16:20.346Z","comments":true,"path":"2019/09/01/post-test/","link":"","permalink":"http://yoursite.com/2019/09/01/post-test/","excerpt":"","text":"SSS","categories":[{"name":"etc","slug":"etc","permalink":"http://yoursite.com/categories/etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]}]}