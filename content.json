{"meta":{"title":"HYEOK999's Blog","subtitle":"HYEOK999's Daily Develop","description":"HYEOK999's IT Develop Blog","author":"Jun Hyeok Kim","url":"https://hyeok999.github.io","root":"/"},"pages":[],"posts":[{"title":"리액트 컴포넌트 타입스크립트로 작성하기","slug":"TypeScript-04","date":"2020-04-03T11:36:10.000Z","updated":"2020-04-03T11:39:49.760Z","comments":true,"path":"2020/04/03/TypeScript-04/","link":"","permalink":"https://hyeok999.github.io/2020/04/03/TypeScript-04/","excerpt":"","text":"리액트 컴포넌트 타입스크립트로 작성하기목차 프로젝트 생성 Arrow vs Function 새로운 컴포넌트 만들기 interface vs type React.FC 의 장단점 props에 기본적으로 children 이 있어 사용하기 편하다 컴포넌트의 defaultProps, propTypes, contextTypes 를 설정 할 때 자동완성이 될 수 있다는 것 React.FC를 생략할 경우 컴포넌트에 생략할 수 있는 props 설정하기 컴포넌트에서 함수 타입의 props 받아오기 정리 프로젝트 생성 1$ npx create-react-app ts-react-tutorial --typescript npx 제일 뒤에 --typescript 가 있으면 타입스크립트 설정이 적용된 프로젝트가 생성된다. 만약, 이미 진행 중인 프로젝트에 타입스크립트를 추가하려면 다음과 같은 명령어를 사용한다. 1$ npm install --save typescript @types/node @types/react @types/react-dom @types/jest 타입스크립트를 이용 시 특정 컴포넌트에 필요한 값이나 자동완성이 필요할 땐 Ctrl + Space 를 눌러보면 확인 할 수 있다. Arrow vs Function 프로젝트를 생성 후 App.tsx 를 확인해보면 다음과 같은 코드들을 확인할 수 있다. 1234567891011121314151617181920212223242526import React from &apos;react&apos;;import logo from &apos;./logo.svg&apos;;import &apos;./App.css&apos;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; 여기서 함수의 정의 형태가 일반함수로서 화살표 함수가 아니다. 예전엔 컴포넌트 생성 시, const App: React.FC = () =&gt; { ... } 와 같이 화살표함수를 사용하여 컴포넌트가 선언되었다. 그런데, 꼭 화살표 함수를 사용하여 선언 할 필요는 없다. 최근 해외의 유명 개발자들(링크1, 링크2)은 보통 function 키워드를 사용하여 함수형 컴포넌트를 선언하는 것으로 추세다. 리액트 공식 매뉴얼에서도 function 키워드를 사용하고 있기도 한다. 반면 예전 프로젝트를 만들 때 자동 생성 된 App.tsx 의 경우 React.FC 라는 타입을 사용하여 화살표 함수를 사용하면서 컴포넌트를 선언했는데, 이렇게 타입하는 것이 좋을 수 도 있고 나쁠 수도 있다. 결론적으로, 함수형 컴포넌트를 작성 할 때는 화살표 함수(=&gt;)로 작성해도 되고, function 키워드를 사용해도 된다. 요즘은 function 키워드가 통일시 되고 있다.단, React.FC 라는 타입은 사용을 자제하는 것이 좋다. 새로운 컴포넌트 만들기 파일 위치 : src/Greetings.tsx interface vs type 컴포넌트의 props에 대한 타입을 선언 할 때에는 type 을 써도 되고, interface 를 사용해도 상관없다. 단, 프로젝트에서 일관성만 유지하면 충분하다. (A에서는 interface 를 B에서는 type 쓰는 걸 자제) 123456789101112// typeimport React from &apos;react&apos;;type GreetingsProps = &#123; name: string;&#125;;const Greetings: React.FC&lt;GreetingsProps&gt; = (&#123; name &#125;) =&gt; ( &lt;div&gt;Hello, &#123;name&#125;&lt;/div&gt;);export default Greetings; 123456789101112// interfaceimport React from &apos;react&apos;;interface GreetingsProps &#123; name: string;&#125;;const Greetings: React.FC&lt;GreetingsProps&gt; = (&#123; name &#125;) =&gt; ( &lt;div&gt;Hello, &#123;name&#125;&lt;/div&gt;);export default Greetings; React.FC 의 장단점 React.FC 를 사용 할 때는 props 의 타입을 &lt;Generics&gt; 로 넣어서 사용한다. React.FC를 사용해서 얻을 수 있는 장단점은 두가지가 있다. 이 두가지는 장점이 될 수 도 단점이 될 수 도 있다. props에 기본적으로 children 이 있어 사용하기 편하다. 컴포넌트의 defaultProps, propTypes, contextTypes 를 설정 할 때 자동완성이 될 수 있다는 것. props에 기본적으로 children 이 있어 사용하기 편하다. 이 부분은 어찌보면 장점이 될 수도 있고, 단점이 될 수도 있다. 이유는 특정 컴포넌트에서는 children 필요할수도 하지 않을 수도 있는데, React.FC 는 children 을 옵셔널 타입으로 지정해놨기에 이는 타입스크립트의 철학과는 모호한 관계를 띄게 된다. 따라서 특정 컴포넌트에서 children 을 필요로 한다면 반드시 children 타입을 명시해야한다. 1234type GreetingsProps = &#123; name: string; children: React.ReactNode;&#125;; 결과 적으로 차라리, React.FC 를 사용하지 않고 GreetingsProps 타입을 통해 children이 있다 없다를 명백하게 명시하는게 덜 헷갈린다. 컴포넌트의 defaultProps, propTypes, contextTypes 를 설정 할 때 자동완성이 될 수 있다는 것. 추후 개선의 여지가 있지만, 아직까진 React.FC를 이용할 때 defaultProps가 제대로 동작이 되고 있지 않다. 12345678910111213141516171819// src/Greetings.tsximport React from &apos;react&apos;;type GreetingsProps = &#123; name: string; mark: string;&#125;;const Greetings: React.FC&lt;GreetingsProps&gt; = (&#123; name, mark &#125;) =&gt; ( &lt;div&gt; Hello, &#123;name&#125; &#123;mark&#125; &lt;/div&gt;);Greetings.defaultProps = &#123; mark: &apos;!&apos;&#125;;export default Greetings; 위와 같은 코드를 작성하고 App.tsx에서 해당 코드를 로드할 경우, 아래 부분에서 에러를 유발한다. 12345678910// src/App.tsximport React from &apos;react&apos;;import Greetings from &apos;./Greetings&apos;;const App: React.FC = () =&gt; &#123; return &lt;Greetings name=&quot;Hello&quot; /&gt;; // 이 부분에서 에러&#125;;export default App; 결국, mark 를 defaultProps 로 넣었음에도 불구하고 mark값이 없다면서 제대로 작동하지 않는다. React.FC를 쓰면서 defaultProps 를 사용하려면 결국 코드를 다음과 같이 작성하는 수 밖에 없다. 따라서, 아래처럼 비구조화 할당을 하는 과정에서 기본값을 설정해야만 한다. 123456789101112131415161718192021// src/Greetings.tsximport React from &apos;react&apos;;type GreetingsProps = &#123; name: string; mark: string;&#125;;const Greetings: React.FC&lt;GreetingsProps&gt; = (&#123; name, mark = &apos;!&apos; &#125;) =&gt; ( &lt;div&gt; Hello, &#123;name&#125; &#123;mark&#125; &lt;/div&gt;);// 결국 무의미해진 defaultProps?Greetings.defaultProps = &#123; mark: &apos;!&apos; &#125;;export default Greetings; React.FC를 생략할 경우 위와 같은 React.FC의 장점보다는 단점을 회피하고자 React.FC 를 생략할 경우, 다음과 같이 작성할 수 있다. 즉, React.FC 를 이용하지 않는 것이 좀 더 권장된다. 1234567891011121314151617181920212223// src/Greetings.tsximport React from &apos;react&apos;;type GreetingsProps = &#123; name: string; mark: string;&#125;;/*function Greetings(&#123; name, mark &#125;: GreetingsProps) &#123; return (*/const Greetings = (&#123; name, mark &#125;: GreetingsProps) =&gt; ( &lt;div&gt; Hello, &#123;name&#125; &#123;mark&#125; &lt;/div&gt;);Greetings.defaultProps = &#123; mark: &apos;!&apos;&#125;;export default Greetings; 컴포넌트에 생략할 수 있는 props 설정하기 컴포넌트의 props 중에서 생략해도 되는 값이 있다면 ? 문자를 사용하면 된다. 123456789101112131415161718192021222324// src/Greetings.tsximport React from 'react';type GreetingsProps = &#123; name: string; mark: string; optional?: string;&#125;;function Greetings(&#123; name, mark, optional &#125;: GreetingsProps) &#123; return ( &lt;div&gt; Hello, &#123;name&#125; &#123;mark&#125; &#123;optional &amp;&amp; &lt;p&gt;&#123;optional&#125;&lt;/p&gt;&#125; &lt;/div&gt; );&#125;Greetings.defaultProps = &#123; mark: '!'&#125;;export default Greetings; 컴포넌트에서 함수 타입의 props 받아오기 컴포넌트에서 특정 함수를 props 로 받아와야 한다면 다음과 같이 타입을 지정 할 수 있다. 1234567891011121314151617181920212223242526272829// src/Greetings.tsximport React from 'react';type GreetingsProps = &#123; name: string; mark: string; optional?: string; onClick: (name: string) =&gt; void; // 아무것도 리턴하지 않는다는 함수를 의미합니다.&#125;;function Greetings(&#123; name, mark, optional, onClick &#125;: GreetingsProps) &#123; const handleClick = () =&gt; onClick(name); return ( &lt;div&gt; Hello, &#123;name&#125; &#123;mark&#125; &#123;optional &amp;&amp; &lt;p&gt;&#123;optional&#125;&lt;/p&gt;&#125; &lt;div&gt; &lt;button onClick=&#123;handleClick&#125;&gt;Click Me&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;Greetings.defaultProps = &#123; mark: '!'&#125;;export default Greetings; 그리고, src/App.tsx 에서 해당 컴포넌트를 사용해야 할 때 다음과 같이 작성한다. 12345678910111213// src/App.jsimport React from &apos;react&apos;;import Greetings from &apos;./Greetings&apos;;const App: React.FC = () =&gt; &#123; const onClick = (name: string) =&gt; &#123; console.log(`$&#123;name&#125; says hello`); &#125;; return &lt;Greetings name=&quot;Hello&quot; onClick=&#123;onClick&#125; /&gt;;&#125;;export default App; 정리 이번 섹션에서 배웠던 것. React.FC 는 별로 좋지 않다. 함수형 컴포넌트를 작성 할 때는 화살표 함수로 작성해도 되고, function 키워드를 사용해도 된다. Props 에 대한 타입을 선언 할 땐 interface 또는 type 을 사용하면 되며, 프로젝트 내부에서 일관성만 지키면 된다. Reference velopert.log : 타입스크립트 기초 연습","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"TypeScript","slug":"TIL/TypeScript","permalink":"https://hyeok999.github.io/categories/TIL/TypeScript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://hyeok999.github.io/tags/자바스크립트/"},{"name":"typescript","slug":"typescript","permalink":"https://hyeok999.github.io/tags/typescript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"https://hyeok999.github.io/tags/타입스크립트/"}]},{"title":"타입스크립트 기초 연습하기 (타입 별명, 제네릭)","slug":"TypeScript-03","date":"2020-03-31T14:42:04.000Z","updated":"2020-03-31T14:45:45.296Z","comments":true,"path":"2020/03/31/TypeScript-03/","link":"","permalink":"https://hyeok999.github.io/2020/03/31/TypeScript-03/","excerpt":"","text":"타입스크립트 기초 연습하기 (타입 별명, 제네릭)목차 Type Alias 사용하기 Generics 함수에서 Generics 사용하기 interface 에서 Generics 사용하기 Type Alias 에서 Generics 사용하기 클래스에서 Generics 사용하기 Type Alias 사용하기 type은 특정 타입에 별칭을 붙이는 용도로 사용한다. 객체를, 배열, 또는 그 어떤 타입이던 별칭을 지어줄 수 있다. 1234567891011121314151617181920212223242526type Person = &#123; name: string; age?: number; // 물음표가 들어갔다는 것은, 설정을 해도 되고 안해도 되는 값이라는 것을 의미한다.&#125;;// &amp; 는 Intersection 으로서 두개 이상의 타입들을 합쳐준다.// 참고: https://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-typestype Developer = Person &amp; &#123; skills: string[];&#125;;const person: Person = &#123; name: '김사람'&#125;;const expert: Developer = &#123; name: '김개발', skills: ['javascript', 'react']&#125;;type People = Person[]; // Person[] 를 이제 앞으로 People 이라는 타입으로 사용 할 수 있습니다.const people: People = [person, expert];type Color = 'red' | 'orange' | 'yellow';const color: Color = 'red';const colors: Color[] = ['red', 'orange']; Q . 위 코드를 보았을 때 interface와 많이 유사하다. 그렇다면 어떤 무엇을 쓰는게 정답일까? A . 정답은 어떤 것을 이용하던 상관없다. 단, 일관성 있게 사용하는 것이 중요하다. 구버전의 타입스크립트에서는 type 과 interface 의 차이가 많이 존재했었는데 이제는 큰 차이는 없다. 다만 라이브러리를 작성하거나 다른 라이브러리를 위한 타입 지원 파일을 작성하게 될 때는 interface를 사용하는것이 권장 되고 있다. Generics 제네릭(Generics)은 타입스크립트에서 함수,클래스, interface, type을 사용하게 될 때 여러 종류의 타입에 대하여 호환을 맞춰야 하는 상황에서 사용하는 문법이다. 함수에서 Generics 사용하기 객체 A 와 객체 B를 합쳐주는 merge 라는 함수를 만든다고 가정하자. 이럴 경우, 객체 A와 객체 B가 어떤 타입이 올 지 알 수 없기 때문에 any 라는 타입을 사용한다. 12345678function merge(a: any, b: any): any &#123; return &#123; ...a, ...b &#125;;&#125;const merged = merge(&#123; foo: 1 &#125;, &#123; bar: 1 &#125;); 문제는 위와 같은 코드를 작성할 경우, 타입추론이 모두 깨진 것이나 다름 없다. 결과가 any 라는 것은 즉 merged 안에 무엇이 있는지 알 수 없다는 뜻이기 때문이다. 위와 같은 상황에서 제네릭을 사용한다. 제네릭을 사용 할 때는 이렇게 &lt;T&gt; 처럼 꺽쇠 안에 타입의 이름을 넣어서 사용하며, 이렇게 설정을 해주면 제네릭에 해당하는 타입에는 뭐든지 들어올 수 있게 되면서도, 사용 할 때 타입이 깨지지 않게 된다. 이런식으로 제네릭을 사용하게 된다면 함수의 파라미터로 넣은 실제 값의 타입을 활용하게 된다. 1234567891011121314151617function merge&lt;A, B&gt;(a: A, b: B): A &amp; B &#123; return &#123; ...a, ...b &#125;;&#125;const merged = merge(&#123; foo: 1 &#125;, &#123; bar: 1 &#125;);// 다른 예시function wrap&lt;T&gt;(param: T) &#123; return &#123; param // param: number; &#125;&#125;const wrapped = wrap(10); interface 에서 Generics 사용하기 만약 Items 라는 타입을 사용하게 된다면, Items 타입을 지니고 있는 객체의 list 배열은 string[] 타입을 지니고 있게 된다. 이렇게 함으로써, list가 숫자배열인 경우, 문자열배열인경우, 객체배열, 또는 그 어떤 배열인 경우에도 하나의 interface 만을 사용하여 타입을 설정 할 수 있다. 1234567interface Items&lt;T&gt; &#123; list: T[];&#125;const items: Items&lt;string&gt; = &#123; list: ['a', 'b', 'c']&#125;; Type Alias 에서 Generics 사용하기 1234567type Items&lt;T&gt; = &#123; list: T[];&#125;;const items: Items&lt;string&gt; = &#123; list: ['a', 'b', 'c']&#125;; 클래스에서 Generics 사용하기 제네릭을 이용하여 Queue 만들어보기. Queue는 선입선출(FIFO) 의 성질을 가지고 있는 자료구조이다. 등록(enqueue) 한 항목을 먼저 출력(dequeue) 할 수 있다. 제네릭을 이용한 Queue 에서는 다양한 원소 타입으로 이루어진 Queue의 타입을 설정할 수 있다. 예를 들어서 Queue 이라고 하면 문자열로 이루어진 Queue의 타입이 된다. 12345678910111213141516171819202122232425262728293031323334class Queue&lt;T&gt; &#123; list: T[] = []; get length() &#123; return this.list.length; &#125; enqueue(item: T) &#123; this.list.push(item); &#125; dequeue() &#123; return this.list.shift(); &#125;&#125;const queue = new Queue&lt;number&gt;();queue.enqueue(0);queue.enqueue(1);queue.enqueue(2);queue.enqueue(3);queue.enqueue(4);console.log('큐의 길이: ', queue.length);console.log(queue.dequeue());console.log(queue.dequeue());console.log(queue.dequeue());console.log(queue.dequeue());console.log(queue.dequeue());/*큐의 길이: 501234*/ Reference velopert.log : 타입스크립트 기초 연습","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"TypeScript","slug":"TIL/TypeScript","permalink":"https://hyeok999.github.io/categories/TIL/TypeScript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://hyeok999.github.io/tags/자바스크립트/"},{"name":"typescript","slug":"typescript","permalink":"https://hyeok999.github.io/tags/typescript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"https://hyeok999.github.io/tags/타입스크립트/"}]},{"title":"타입스크립트 기초 연습하기 (셋팅, 기본 타입, 함수타입, 인터페이스)","slug":"TypeScript-02","date":"2020-03-30T13:58:53.000Z","updated":"2020-03-31T14:42:44.778Z","comments":true,"path":"2020/03/30/TypeScript-02/","link":"","permalink":"https://hyeok999.github.io/2020/03/30/TypeScript-02/","excerpt":"","text":"타입스크립트 기초 연습하기 (셋팅, 기본 타입, 함수타입, 인터페이스)목차 셋팅 tsconfing.json 타입스크립트 파일 만들기 및 컴파일 src/practice.ts npx tsc 기본 타입 부울 (Boolean) 숫자형 (Number) 문자열 (String) 배열 (Array) 튜플 (Tuple) 열거 (Enum) Any Void Null 과 Undefined Never 타입 단언 함수에서 타입 정의하기 interface 사용해보기 클래스에서 interface 를 implements 하기 일반 객체를 interface 로 타입 설정하기 셋팅 npm install -g typescript : 전역에 설치 (이미 설치되어 있다면 건너띄기) tsc --init : tsconfig.json파일을 생성 tsconfing.json target: 컴파일된 코드가 어떤 환경에서 실행될 지 정의. 예를들어서 화살표 함수를 사용하고 target 을 es5 로 한다면 일반 function 키워드를 사용하는 함수로 변환을 해준다. 하지만 이를 es6 로 설정한다면 화살표 함수를 그대로 유지해준다. module: 컴파일된 코드가 어던 모듈 시스템을 사용할지 정의. 예를 들어서 이 값을 common 으로 하면 export default Sample 을 하게 됐을 때 컴파일 된 코드에서는 exports.default = helloWorld 로 변환해주지만 이 값을 es2015 로 하면 export default Sample 을 그대로 유지하게 된다. strict: 모든 타입 체킹 옵션을 활성화한다는 것을 의미. esModuleInterop: commonjs 모듈 형태로 이루어진 파일을 es2015 모듈 형태로 불러올 수 있게 해준다. outDir: 컴파일된 파일들이 저장되는 경로를 지정 할 수 있다. 예를 들어서 이 값을 &quot;./dist&quot;라고 을 경우, 컴파일된 파일들은 ./dist 폴더에 저장된다. 타입스크립트 파일 만들기 및 컴파일 프로젝트에 src 디렉터리를 만들고 그 안에 practice.ts 파일을 작성. src/practice.ts 12const message: string = 'hello world';console.log(message); 여기서 message 옆의 string이 타입을 의미. 저런식으로 string으로 지정하였는데 만약 문자열외의 값을 대입할 경우 에디터 상에서 오류를 나타나게 함. npx tsc 위와 같이 작성 후 npx tsc 를 터미널에 입력 시 컴파일 된다. 컴파일 후 dist/practice.js 라는 파일이 생성되고 내부에는 다음과 같은 코드가 작성되어 있다. 123\"use strict\";var message = 'hello world';console.log(message); 기본 타입 부울 (Boolean) 숫자형 (Number) 문자열 (String) 배열 (Array) 튜플 (Tuple) 열거 (Enum) Any Void Null 과 Undefined Never 타입 단언 부울 (Boolean) true / false 1let isDone: boolean = false; 숫자형 (Number) JavaScript와 마찬가지로 TypeScript의 모든 숫자는 부동 소수 점 값TypeScript는 10진수 및 16진수와 함께 ECMAScript2015에 도입된 2진수 및 8진수 문자를 지원 1234let decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744; 문자열 (String) JavaScript와 마찬가지로 TypeScript 또한 문자열 데이터를 감싸기 위해 큰 따옴표(&quot;) 또는 작은 따옴표(&#39;)를 사용 백틱 / 백 쿼트 (`` ) 문자로 감싸져 있고 표현식은${ 표현식 }` 형식인 템플릿 문자열 또한 사용 가능 12345let color: string = \"blue\";color = 'red';let fullName: string = `Bob Bobbington`;let sentence: string = `Hello, my name is $&#123; fullName &#125;.` 배열 (Array) 배열의 타입은 두 가지 방법 중 하나로 작성 가능 [] 을 이용한 배열 타입 제네릭 배열 타입 12let list: number[] = [1, 2, 3]; // []을 이용한 배열 타입let list: Array&lt;number&gt; = [1, 2, 3]; // 제네릭 배열 타입 튜플 (Tuple) 고정된 갯수의 배열을 사용할 때 이용.또한 배열 내부의 타입들이 서로 다를 경우 표현할 수 있다. 123456// 2개의 원소를 가지는 배열 - 튜플 타입 선언let x: [string, number];// 초기화x = [\"hello\", 10]; // 가능// 부정확한 초기화x = [10, \"hello\"]; // 오류 인덱스를 넘어서 추가로 설정할 수 있으나 앞서 설정한 타입을 제외하고 다른 타입은 전부 에러처리난다. 12345let x : [string, number];x[2] = 3 //OKx[2] = 'a' //OKx[2] = true //ERROR : 앞서 x는 string, number만 해놨기 때문 열거 (Enum) enum은 numeric 값 집합에 더 친숙한 이름을 부여하는 방법 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 기본적으로 enums는 0부터 시작하는 자신의 멤버 번호를 매기기를 시작멤버 중 하나의 값을 수동으로 설정하여 이를 변경할 수 있다.예를 들어 이전 예제를 0 대신 1로 시작할 수 있다. 1234567enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green;// 또는 열거 형의 모든 값을 수동으로 설정합니다:enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green; enum의 편리한 기능은 숫자 값에서 enum의 해당 값 이름으로 이동할 수 있다는 것. 1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];alert(colorName); // 위의 값이 2 이므로 'Green'을 표시. Any 변수의 타입을 지정할 때 알지 못할 타입을 지정할 경우 사용. 12345let notSure: any = 4;notSure = \"문자열일수도 있다\";notSure = false;let list: any[] = [1, true, \"free\"]; Void 일반적으로 반환 값을 반환하지 않는 함수의 반환 타입void타입의 변수는 undefined 또는 null 만 할당할 수 있다. 123function warnUser(): void &#123; alert(\"This is my warning message\");&#125; Null 과 Undefined TypeScript에서는 undefined와 null이라는 자체적인 타입을 가짐.기본적으로 null과 undefined는 다른 모든 타입의 서브 타입임. 123// 그 외에도 이러한 변수에 할당할 수 있다!let u: undefined = undefined;let n: null = null; Never never 타입은 절대로 발생하지 않는 값의 타입을 나타냄. 주로, exception과 같이 throw되는 함수에 주로 사용됨. never에는 undefined, null, any조차 할당이 불가능. 1234// 반환되는 함수에는 연결할 수 없는 end-point가 있어서는 안 된다.function error(message: string): never &#123; throw new Error(message);&#125; 타입 단언 (Type assertions) 컴파일러에게 개발자가 특정 변수의 타입이 무엇인지 알고 있다고 얘기하는 것. 이는, 컴파일러에서만 사용되며 런타임에는 영향을 주지 않는다. 123let someValue : any = \"this is a string\";let strLength : number = someValue.length; // compile error 가 뜬다. 어떤 타입인지 모르는데 length를 썼기 때문이다. 처음에 선언한 someValue는 any로 컴파일 되는데 밑에서 someValue는 length field를 사용하였다. 컴파일러는 someValue가 length field가 있는지 없는지 알 수 없기 때문에 컴파일 에러가 뜬다. 비록 any에 string 값이 들어갔더라도 말이다. 하지만 사용자가 타입을 직접 캐스팅 할경우 컴파일러는 해당 변수를 string으로 본다. 123456let someValue : any = 'This is a string'let strLength : number = (&lt;string&gt;someValue).length //error가 나지 않는다.//또는 (someValue as string).length로 사용도 가능하다.//as를 사용하기를 추천한다. jsx에서는 제네릭이 안된다고 한다. 컴파일러는 someValue를 string으로 보고 someValue가 실제 무엇이 있는지는 확인하지 않는다는 점에 주목해야 한다. 즉, 타입의 변경에 대한 책임은 오로지 사용자에게 있으며 컴파일러는 someValue의 값에 무엇이 들어있는지는 확인하지 않고 오로지 someValue 가 string이라 판단하고 length field가 있다고 판단한다. 해당 변수가 무엇인지 확신할 수 있을 때 타입을 캐스팅해야한다. 컴파일러는 알수 없을테니 말이다. 참고 : number를 string으로는 캐스팅 할 수 없다. 함수에서 타입 정의하기 함수에서는 총 2개의 타입을 지정해야 한다. 파라미터 타입 반환 타입 타입스크립트를 사용하면 다음과 같이 코드를 작성하는 과정에서 함수의 파라미터로 어떤 타입을 넣어야 하는지 바로 알 수 있다. 1234567891011121314// 일반 함수// let sum: (x: number, y: number) =&gt; number =function sum(x: number, y: number): number &#123; return x + y;&#125;let sum = (x : number, y:number) : number =&gt; &#123; return x + y;&#125;sum(1, 2);// 익명함수let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; 참고로 함수에서 만약 아무것도 반환하지 않아야 한다면 이를 반환 타입을 void 로 설정하면 된다. 123function returnNothing(): void &#123; console.log('I am just saying hello world');&#125; interface 사용해보기 interface는 클래스 또는 객체를 위한 타입을 지정 할 때 사용되는 문법 클래스에서 interface 를 implements 하기 클래스를 만들 때, 특정 조건을 준수해야 함을 명시하고 싶을 때 interface 를 사용하여 클래스가 가지고 있어야 할 요구사항을 설정. 클래스를 선언 할 때 implements 키워드를 사용하여 해당 클래스가 특정 interace의 요구사항을 구현한다는 것을 명시한다. src/practice.ts 1234567891011121314151617181920212223242526272829303132333435363738// Shape 라는 interface 를 선언interface Shape &#123; getArea(): number; // Shape interface 에는 getArea 라는 함수가 꼭 있어야 하며 해당 함수의 반환값은 숫자.&#125;class Circle implements Shape &#123; // `implements` 키워드를 사용하여 해당 클래스가 Shape interface 의 조건을 충족하겠다는 것을 명시. radius: number; // 멤버 변수 radius 값을 설정. // constructor(public radius: number) &#123; constructor(radius: number) &#123; this.radius = radius; &#125; // 너비를 가져오는 함수를 구현. getArea() &#123; return this.radius * this.radius * Math.PI; &#125;&#125;class Rectangle implements Shape &#123; width: number; height: number; // constructor(private width: number, private height: number) &#123; constructor(width: number, height: number) &#123; this.width = width; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;const shapes: Shape[] = [new Circle(5), new Rectangle(10, 5)];shapes.forEach(shape =&gt; &#123; console.log(shape.getArea());&#125;); 여기서 주의깊게 봐야할 것은 constructor 의 파라미터 쪽에 public 또는 private accessor 를 사용하면 직접 하나하나 설정해주는 작업을 생략할 수 있다. public accessor 는 특정 값이 클래스의 코드 밖에서도 조회 가능하다는 것을 의미한다. private accessor는 클래스의 코드 밖에서 해당 값을 조회할 수 없음을 의미한다. 일반 객체를 interface 로 타입 설정하기 일반 객체를 interface 를 사용하여 타입을 지정하는 방법. 12345678910111213141516171819interface Person &#123; name: string; age?: number; // 물음표가 들어갔다는 것은, 설정을 해도 되고 안해도 되는 값이라는 것을 의미.&#125;interface Developer &#123; name: string; age?: number; skills: string[];&#125;const person: Person = &#123; name: '김사람', age: 20&#125;;const expert: Developer = &#123; name: '김개발', skills: ['javascript', 'react']&#125;; 지금 보면 Person 과 Developer 가 형태가 유사하다. 이럴 땐 interface 를 선언 할 때 다른 interface 를 extends 해서 상속받을 수 있다. src/practice.ts 12345678910111213141516171819interface Person &#123; name: string; age?: number; // 물음표가 들어갔다는 것은, 설정을 해도 되고 안해도 되는 값이라는 것을 의미합니다.&#125;interface Developer extends Person &#123; skills: string[];&#125;const person: Person = &#123; name: '김사람', age: 20&#125;;const expert: Developer = &#123; name: '김개발', skills: ['javascript', 'react']&#125;;const people: Person[] = [person, expert]; Reference velopert.log : 타입스크립트 기초 연습 GitBook : 기본 타입","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"TypeScript","slug":"TIL/TypeScript","permalink":"https://hyeok999.github.io/categories/TIL/TypeScript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://hyeok999.github.io/tags/자바스크립트/"},{"name":"typescript","slug":"typescript","permalink":"https://hyeok999.github.io/tags/typescript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"https://hyeok999.github.io/tags/타입스크립트/"}]},{"title":"React에서 TypeScript 사용하기","slug":"TypeScript-01","date":"2020-03-28T14:16:19.000Z","updated":"2020-03-28T14:24:01.342Z","comments":true,"path":"2020/03/28/TypeScript-01/","link":"","permalink":"https://hyeok999.github.io/2020/03/28/TypeScript-01/","excerpt":"","text":"React에서 TypeScript 사용하기목차 JavaScript의 단점 JS 편집기의 자동완성의 불편함 함수 파라미터 타입 체킹을 안해줌 리덕스를 사용할 때 불편함 리액트 컴포넌트 쓸 떄 어떤 props를 넣어야하는지 에디터에서 알 방법이 없다. TypeScript를 써야 하는 이유 JavaScript의 단점 JS 편집기의 자동완성의 불편함 함수 파라미터 타입 체킹을 안해줌 리덕스를 사용할 때 불편함 리액트 컴포넌트 쓸 떄 어떤 props를 넣어야하는지 에디터에서 알 방법이 없다. JS 편집기의 자동완성의 불편함 VS Code를 사용할 경우 간단한 자동완성은 가능하다. 다만, 파라미터가 배열이고 그 배열에 대한 자동완성은 함수내부에서 안될 경우가 존재한다. 함수 파라미터 타입 체킹을 안해줌 가정을 해보자. 아래와 같이 문자열을 인자로 받고 문자열의 길이를 반환해주는 함수가 있다고 가정하자. 개발자라면 당연하게도 이 함수에 들어갈 변수의 타입은 문자열이라고 이해를 할 수 있다. 왜냐하면 변수명을 명백하게도 문자열(str)이라고 적어놨기 때문이다. 123function getLength(str) &#123; return str.length;&#125; 문제는 저 함수에 숫자를 넣든 배열을 넣는 문제가 안된다는 것이다. 12getLength(3); // undefinedgetLength([1,2,3,4,5]); // 5 이는 곧 큰 문제를 야기할 수 있다. 왜냐하면 getLength(str)를 만든 개발자의 의도는 문자열을 받는 함수였기 때문이다. 그런데 엉뚱한 숫자 혹은 배열이 해당 함수에 들어갈 경우 의도와는 다른 결과를 내면서 심지어 오류처리조차 해주지 않는다. 즉, 자바스크립트 환경에서는 실행해볼때까지 해당 코드에 오류가 있는지 없는지 알 방법이 없다. 리덕스를 사용할 때 불편함 종종 리덕스를 사용하다보면 특정 상태를 가지고는 왔는데 해당 상태 내부를 조회할 경우 불편함을 느낀적이 꽤 있다. 예를들면, 아래와 같은 경우이다. 1const feed = useSelector(state =&gt; state.feed.feeds) useSelector를 이용해 리덕스 스토어 안에 있는 상태를 조회하였다. JS만을 이용할 경우, 여기서 state.feed.feeds에 .을 붙인다고 안에 있는 상태가 나열되지 않는다. 즉, 상태안에 어떤값이 들어가 있는지 알아보려면 에디터 단에서는 알 수 가 없다. 따라서, Redux DevTools로 확인 하거나, 리듀서 관련 코드가 들어가 있는 파일을 열어서 확인해봐야 한다. 리액트 컴포넌트 쓸 떄 어떤 props를 넣어야하는지 에디터에서 알 방법이 없다. 리액트 컴포넌트에서는 propTypes 라는 것을 사용하면 특정 컴포넌트에서 필요한 props 를 지정해서 컴포넌트에서 필요한 props 가 없다면 콘솔에 경고를 출력하도록 할 수 있다. 문제는 propTypes 쓰는 과정이 너무나도 번거롭다. 특히 props 로 배열이나 객체 가져와야 하는경우엔 arrayOf, shape 같은 함수를 이용해야 할 때도 있고 여러 타입인 경우엔 oneOfType 란걸 써야 하기 때문에 불편하다. propTypes 를 설정해도 props 빠뜨리면 브라우저 단에서만 경고를 보여줄 뿐 에디터에서는 아무 경고도 보여주지 않기 때문에 실제로 코드를 실행해봐야만 실수를 했는지 안했는지 알 수가 있다. TypeScript를 써야 하는 이유 IDE 를 더욱 적극적으로 활용 할 수 있다. 자동완성 및 타입 체킹이 되기 떄문에 개발 생산성 상승. 어떤 컴포넌트를 사용하거나, 함수를 사용 할 때 해당 파일을 직접 얼여보지 않고도 어떤 props 또는 파라미터를 넣어줘야 하는지 알 수 있다. 리덕스를 사용하게 될 때에도, 리듀서 관련 코드를 열지 않고도 상태 객체가 어떤 구조로 이루어졌는지 확인 가능. 실수를 줄 일 수 있다. 대부분의 실수들은 타입 체킹(특히 null)에서 많이 나오게 되는데 TypeScript를 이용할 경우 에디터 단에서 타입 체킹이 바로바로 가능해져 이러한 실수를 많이 줄일 수 있다. 협업 시 유용 IDE에서 컴포넌트, 함수 등을 사용 할 때 어떤 값을 어떤 타입으로 넣어야 하는지 바로 IDE상에서 확인 할 수 있기 때문에 굳이 주석으로 작성하거나, 코드를 읽어보거나, 협업하는 사람에게 물어보지 않아도 쉽게 사용 할 수 있다. Reference velopert.log : 리액트 프로젝트에서 타입스크립트 사용하기","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"TypeScript","slug":"TIL/TypeScript","permalink":"https://hyeok999.github.io/categories/TIL/TypeScript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://hyeok999.github.io/tags/자바스크립트/"},{"name":"typescript","slug":"typescript","permalink":"https://hyeok999.github.io/tags/typescript/"},{"name":"타입스크립트","slug":"타입스크립트","permalink":"https://hyeok999.github.io/tags/타입스크립트/"}]},{"title":"FeedList 일부 수정 및 FeedDetail 구현","slug":"feed-04","date":"2020-03-21T13:44:30.000Z","updated":"2020-04-06T13:23:15.398Z","comments":true,"path":"2020/03/21/feed-04/","link":"","permalink":"https://hyeok999.github.io/2020/03/21/feed-04/","excerpt":"","text":"d.code 패션 피드 구현- FeedList 일부 수정 및 FeedDetail 구현1 -목차 FeedList useEffect 수정 FeedList Link 태그 수정 HOC 작성 Detail 관련 Redux 추가하기 FeedDetailContainer 만들기 + 좋아요 로직 구성 Detail에서 사용할 Icon 추가하기 Detail에서 사용할 logo Img 추가하기 FeedDetail 페이지 추가하기 FeedList useEffect 수정 사용자가 feed Detail의 url만 가지고서 Detail 페이지에 접근할 경우를 대비해 만약 store에 feed가 존재한다면 dispatch를 막아야 하는 코드를 작성합니다. 123456789101112131415161718192021222324252627282930313233// src/components/FeedList/index.jsximport React, &#123; useEffect &#125; from 'react';import &#123; StyledMain, StyledContent, StyledFeedArticle &#125; from './Styles';import &#123; v4 as uuidv4 &#125; from 'uuid';import MainTitle from './MainTitle';import FeedHeader from './FeedHeader';import FeedContent from './FeedContent';import FeedFooter from './FeedFooter';const FeedList = (&#123; feeds, loading, error, getFeed &#125;) =&gt; &#123; // 수정 부분 useEffect(() =&gt; &#123; if (!feeds) getFeed(); &#125;, [feeds, getFeed]); return ( &lt;StyledMain&gt; &lt;MainTitle /&gt; &lt;StyledContent&gt; &#123;feeds &amp;&amp; feeds.list.map(feed =&gt; ( &lt;StyledFeedArticle key=&#123;uuidv4()&#125;&gt; &lt;FeedHeader feed=&#123;feed&#125; /&gt; &lt;FeedContent feed=&#123;feed&#125; /&gt; &lt;FeedFooter feed=&#123;feed&#125; /&gt; &lt;/StyledFeedArticle&gt; ))&#125; &lt;/StyledContent&gt; &lt;/StyledMain&gt; );&#125;;export default FeedList; FeedList Link 태그 수정 기존에 &lt;Link&gt;태그로 작성되어있던 부분을 &lt;button role=&quot;link&quot;&gt; 로 변경합니다. useDispatch() 를 이용해 route 를 하기 위함입니다. 이제 store에 url path가 저장됩니다. 12345678910111213141516171819202122232425// src/components/FeedList/FeedContent.jsximport React from 'react';import &#123; push &#125; from 'connected-react-router';import &#123; useDispatch &#125; from 'react-redux';import &#123; StyledButton, StyledFeedImg, StyledFeedTagBox, StyledFeedContent &#125; from './Styles';import &#123; v4 as uuidv4 &#125; from 'uuid';const FeedContent = (&#123; feed &#125;) =&gt; &#123; const dispatch = useDispatch(); return ( &lt;StyledButton role=\"link\" onClick=&#123;() =&gt; dispatch(push(`/feed/$&#123;feed.id&#125;`))&#125;&gt; &lt;StyledFeedImg src=&#123;feed.mediaList[0].url&#125; alt=\"images\" /&gt; &lt;StyledFeedTagBox&gt; &#123;feed.tags.map(tag =&gt; ( &lt;span key=&#123;uuidv4()&#125;&gt;&#123;`#$&#123;tag&#125;`&#125;&lt;/span&gt; ))&#125; &lt;/StyledFeedTagBox&gt; &lt;StyledFeedContent&gt;&#123;feed.text&#125;&lt;/StyledFeedContent&gt; &lt;/StyledButton&gt; );&#125;;export default FeedContent; HOC 작성 Detail페이지를 구현하기 앞서 HOC를 작성합니다. 해당 HOC의 역할은 사용자가 /feed/:feedId와 같은 url로 접속을 하였을 경우 store에 feed데이터가 존재하지 않으므로 그 때 feed의 상태를 조건으로 하여 getFeeds를 dispath하여 추가합니다. 123456789101112131415161718192021222324// src/hocs/withFeed.jsximport React, &#123; useEffect &#125; from 'react';import &#123; useSelector, useDispatch &#125; from 'react-redux';import &#123; getFeeds &#125; from '../redux/modules/feed';function withFeed(Component) &#123; function WrappedComponent(props) &#123; const &#123; feeds &#125; = useSelector(state =&gt; state.feed); const dispatch = useDispatch(); const &#123; feedId &#125; = props.match.params; useEffect(() =&gt; &#123; if (feeds === null) &#123; dispatch(getFeeds()); &#125; &#125;, [dispatch, feeds]); return &lt;Component &#123;...props&#125; feedId=&#123;feedId&#125; /&gt;; &#125; WrappedComponent.displayName = `withAuth($&#123;Component.name&#125;)`; return WrappedComponent;&#125;export default withFeed; Detail 관련 Redux 추가하기 feed.js모듈을 수정합니다. COMMENTS(댓글)을 추가하는 액션을 만듭니다. 초기 state르 수정합니다. 초기 상태가 변경되었으니 handleAction 부분도 수정합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// src/redux/modules/feed.jsimport FeedService from '../../services/FeedService';import &#123; createAction, createActions, handleActions &#125; from 'redux-actions';import &#123; put, call, takeEvery &#125; from 'redux-saga/effects';const options = &#123; prefix: 'd-code/feed',&#125;;// 액션 타입 및 생성자를 한번에 모아서 사용한다. - redux-actions// const success = feeds =&gt; (&#123; type: SUCCESS, feeds &#125;);const &#123; successList, successComments, pending, fail &#125; = createActions( &#123; SUCCESS_LIST: feeds =&gt; (&#123; feeds &#125;), SUCCESS_COMMENTS: comments =&gt; (&#123; comments &#125;), &#125;, 'PENDING', 'FAIL', options);// ACTIONSexport const getFeeds = createAction('GET_FEEDS');export const getFeedComments = createAction('GET_FEED_COMMENTS');export const setFeedLike = successList;// 비동기 처리 redux-sagafunction* fetchFeedLists() &#123; try &#123; yield put(pending()); const &#123; data: feeds &#125; = yield call(FeedService.getList); yield put(successList(feeds.data)); &#125; catch (error) &#123; console.log('error : ', error); yield put(fail(error)); &#125;&#125;function* fetchFeedComments() &#123; try &#123; yield put(pending()); const &#123; data: feeds &#125; = yield call(FeedService.getComments); yield put(successComments(feeds.data)); &#125; catch (error) &#123; console.log('error : ', error); yield put(fail(error)); &#125;&#125;// FEED ROOT SAGAexport function* feedSaga() &#123; yield takeEvery(getFeeds, fetchFeedLists); yield takeEvery(getFeedComments, fetchFeedComments);&#125;// INIITIAL STATEconst initialState = &#123; feeds: null, comments: null, loading: false, error: null,&#125;;const feed = handleActions( &#123; PENDING: state =&gt; (&#123; ...state, loading: true, error: null, &#125;), SUCCESS_LIST: (state, action) =&gt; (&#123; ...state, feeds: action.payload.feeds, loading: false, error: null, &#125;), SUCCESS_COMMENTS: (state, action) =&gt; (&#123; ...state, comments: action.payload.comments, loading: false, error: null, &#125;), FAIL: (state, action) =&gt; (&#123; ...state, loading: false, error: action.payload, &#125;), &#125;, initialState, options);export default feed; FeedDetailContainer 만들기 + 좋아요 로직 구성 Detail 페이지에서 사용할 컨테이너를 만들도록 하겠습니다. 또한 좋아요 버튼을 누를 경우 현재 상태에 저장되어있는 좋아요 수도 올라가야 하기 때문에 해당 로직을 같이 작성합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041// src/containers/FeedDetailContainer.jsximport &#123; connect &#125; from 'react-redux';import &#123; getFeedComments, setFeedLike &#125; from '../redux/modules/feed';import FeedDetail from '../components/FeedDetail';const mapStateToProps = state =&gt; (&#123; feeds: state.feed.feeds, comments: state.feed.comments, loading: state.feed.loading, error: state.feed.error,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; getFeedComments: () =&gt; &#123; dispatch(getFeedComments()); &#125;, setFeedLike: (feed, feedId, likeCount) =&gt; &#123; dispatch( setFeedLike(&#123; ...feed, list: feed.list.map(item =&gt; item.id === feedId ? &#123; ...item, likedCount: likeCount === 1 ? item.likedCount ? item.likedCount + likeCount : 1 : item.likedCount ? item.likedCount + likeCount : -1, &#125; : item ), &#125;) ); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(FeedDetail); Detail에서 사용할 Icon 추가하기 위치 : src/components/Icons.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041import React from 'react';import &#123; faSearch, faShoppingCart, faAngleRight &#125; from '@fortawesome/free-solid-svg-icons';import &#123; faHeart, faCommentAlt, faShareSquare &#125; from '@fortawesome/free-regular-svg-icons';import &#123; faFacebook, faGooglePlay, faApple &#125; from '@fortawesome/free-brands-svg-icons';import &#123; FontAwesomeIcon &#125; from '@fortawesome/react-fontawesome';export function SearchIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faSearch&#125; size=\"lg\" /&gt;;&#125;export function ShoppingCartIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faShoppingCart&#125; size=\"lg\" /&gt;;&#125;export function HeartIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faHeart&#125; /&gt;;&#125;export function CommentAltIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faCommentAlt&#125; /&gt;;&#125;export function LinkIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faShareSquare&#125; /&gt;;&#125;export function FacebookIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faFacebook&#125; /&gt;;&#125;export function AppStoreIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faApple&#125; /&gt;;&#125;export function PlayStoreIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faGooglePlay&#125; /&gt;;&#125;export function ReplyCommentIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faAngleRight&#125; /&gt;;&#125; Detail에서 사용할 logo Img 추가하기 FeedDetail 페이지 추가하기 위치 : src/pages/FeedDetail.jsx 작성했던 HOC로 감싸줍니다. 1234567891011121314151617181920212223242526// src/pages/FeedDetail.jsximport React from 'react';import Head from '../components/Head';import Header from '../components/Header';import FeedDetailContainer from '../containers/FeedDetailContainer';import withFeed from '../hocs/withFeed';import Footer from '../components/Footer';const FeedDetail = (&#123; feedId &#125;) =&gt; &#123; return ( &lt;&gt; &lt;Head keywords=\"d.code, Feed\" description=\"최신 패션 뉴스를 전해드립니다.\" title=\"디코드(d.code) 패션 셀렉트샵\" favicon=\"/static/favicon.ico\" /&gt; &lt;Header /&gt; &lt;FeedDetailContainer feedId=&#123;feedId&#125; /&gt; &lt;Footer /&gt; &lt;/&gt; );&#125;;export default withFeed(FeedDetail);","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"패션사이트 피드 클론 -Head 작성 및 Feed List 목록 구현-","slug":"feed-03","date":"2020-03-20T13:44:30.000Z","updated":"2020-04-04T13:56:25.430Z","comments":true,"path":"2020/03/20/feed-03/","link":"","permalink":"https://hyeok999.github.io/2020/03/20/feed-03/","excerpt":"","text":"d.code 패션 피드 구현- Head 작성 및 Feed List 목록 구현 -목차 라이브러리 인스톨하기 Head 작성하기 Feed page에 Head 컴포넌트 삽입하기 파일 정리하기 FeedList 폴더 및 파일 스트럭쳐 구성하기 Styles.jsx index.jsx MainTitle.jsx FeedHeader.jsx FeedContent.jsx FeedFooter.jsx 라이브러리 인스톨하기 12cd d-code-feednpm i react-helemt Head 작성하기 위치 : src/components/Head.jsx 요구사항 : 피드를 페이스북에 공유하는 기능 추가하기 페이스북에 공유하기 기능을 추가합니다. 페이스북이 제공하는 open graph 공유 기능을 이용하기 위해서 &lt;head&gt;~&lt;/head&gt; 사이에 meta를 집어넣습니다. url의 위치에 따라서 meta가 변해야만 합니다. 따라서 react-helmet을 이용하여 동적으로 meta를 바꿔주도록 하겠습니다. 1234567891011121314151617import React from 'react';import &#123; Helmet &#125; from 'react-helmet';const Head = (&#123; keywords, description, title, favicon &#125;) =&gt; &#123; return ( &lt;Helmet&gt; &lt;meta name=\"description\" content=&#123;description&#125; /&gt; &lt;meta name=\"keywords\" content=&#123;keywords&#125; /&gt; &lt;title&gt;&#123;title&#125;&lt;/title&gt; &lt;meta property=\"og:title\" content=&#123;title&#125; /&gt; &lt;meta property=\"og:image\" content=&#123;favicon&#125; /&gt; &lt;meta property=\"og:site_name\" content=\"디코드(d.code) 패션 셀렉트샵\" /&gt; &lt;meta property=\"og:description\" content=&#123;description&#125; /&gt; &lt;/Helmet&gt; );&#125;;export default Head; Feed page에 Head 컴포넌트 삽입하기 위치 : src/components/Feed.jsx 123456789101112131415161718192021import React from 'react';import Head from '../components/Head';import Header from '../components/Header';import FeedListContainer from '../containers/FeedListContainer';import Footer from '../components/Footer';const Feed = () =&gt; &#123; return ( &lt;&gt; &lt;Head keywords=\"d.code, Feed\" description=\"최신 패션 뉴스를 전해드립니다.\" title=\"디코드(d.code) 패션 셀렉트샵\" favicon=\"/static/favicon.ico\" /&gt; &lt;Header /&gt; &lt;/&gt; );&#125;;export default Feed; 파일 정리하기 containers/FeedContainer.jsx -&gt; containers/FeedListContainer 로 변경 Test.jsx 삭제 containers/FeedListContainer에 props로 줄 컴포넌트 변경하기 1234567891011121314151617import &#123; connect &#125; from 'react-redux';import &#123; getFeeds &#125; from '../redux/modules/feed';import FeedList from '../components/FeedList';const mapStateToProps = state =&gt; (&#123; feeds: state.feed.feeds, loading: state.feed.loading, error: state.feed.error,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; getFeed: () =&gt; &#123; dispatch(getFeeds()); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(FeedList); pages/Feed.jsx 에서도 container 바꿔주기 12345678910111213141516171819202122import React from 'react';import Head from '../components/Head';import Header from '../components/Header';import FeedListContainer from '../containers/FeedListContainer';import Footer from '../components/Footer';const Feed = () =&gt; &#123; return ( &lt;&gt; &lt;Head keywords=\"d.code, Feed\" description=\"최신 패션 뉴스를 전해드립니다.\" title=\"디코드(d.code) 패션 셀렉트샵\" favicon=\"/static/favicon.ico\" /&gt; &lt;Header /&gt; &lt;FeedListContainer /&gt; &lt;/&gt; );&#125;;export default Feed; FeedList 폴더 및 파일 스트럭쳐 구성하기 위치 : src/components/FeedList/ Styles.jsx FeedList 영역에서 사용되는 모든 style을 Stytled Components 를 이용하여 관리하고 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import styled from 'styled-components';// FeedList/index.jsxexport const StyledMain = styled.main` padding-top: 7.2rem; width: 144rem; margin: 0 auto; margin-top: 10.7rem;`;// FeedList/MainTitle.jsxexport const StyledMainTitle = styled.div` h2 &#123; font-size: 3.2rem; line-height: 1.5; font-weight: 900; &#125; p &#123; line-height: 1.5; font-weight: 700; &#125;`;// FeedList/index.jsxexport const StyledFeedArticle = styled.article` display: inline-block; width: 32%; margin-top: 2.5rem;`;// FeedList/index.jsxexport const StyledContent = styled.div` width: 100%; display: flex; justify-content: space-between; flex-wrap: wrap;`;// FeedList/FeedContent.jsxexport const StyledFeedImg = styled.img` width: 100%;`;// FeedList/FeedContent.jsxexport const StyledFeedTagBox = styled.div` font-size: 2.4rem; line-height: 1.3; font-weight: 900; margin: 1rem 0; span &#123; margin-right: 1rem; &#125;`;// FeedList/FeedContent.jsxexport const StyledFeedContent = styled.p` white-space: pre-line; line-height: 1.5; word-break: keep-all; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 10; -webkit-box-orient: vertical;`;// FeedList/FeedFooter.jsxexport const StyledCountSpan = styled.span` margin-left: 1rem; margin-right: 1rem;`;// FeedList/FeedFooter.jsxexport const StyledFeedMdInfo = styled.figure` img &#123; width: 10rem; float: left; &#125; figcaption &#123; line-height: 1.5; font-style: italic; &#125;`;// FeedList/FeedFooter.jsxexport const StyledFeedFooter = styled.footer` color: #a6a7a9; margin-top: 1rem; padding-left: 25%; span &#123; font-style: italic; &#125; div &#123; margin-bottom: 0.3rem; &#125;`;// FeedList/FeedFooter.jsxexport const StyledShareButton = styled.a.attrs((&#123; id &#125;) =&gt; (&#123; role: 'button', target: '_blank', withoutrel: 'noopener noreferrer', href: `http://www.facebook.com/sharer/sharer.php?u=https://www.itsdcode.com/feed/$&#123;id&#125;`,&#125;))` background: #1877f2; border-radius: 0.3rem; border: none; font-size: 11px; height: 2rem; padding: 0.3rem 0.6rem; color: white; svg &#123; margin-bottom: 0.1rem; &#125; span &#123; font-style: normal; margin-left: 0.5rem; &#125;`; index.jsx 12345678910111213141516171819202122232425262728293031import React, &#123; useEffect &#125; from 'react';import &#123; StyledMain, StyledContent, StyledFeedArticle &#125; from './Styles';import &#123; v4 as uuidv4 &#125; from 'uuid';import MainTitle from './MainTitle';import FeedHeader from './FeedHeader';import FeedContent from './FeedContent';import FeedFooter from './FeedFooter';const FeedList = (&#123; feeds, loading, error, getFeed &#125;) =&gt; &#123; useEffect(() =&gt; &#123; getFeed(); &#125;, [getFeed]); return ( &lt;StyledMain&gt; &lt;MainTitle /&gt; &lt;StyledContent&gt; &#123;feeds &amp;&amp; feeds.list.map(feed =&gt; ( &lt;StyledFeedArticle key=&#123;uuidv4()&#125;&gt; &lt;FeedHeader feed=&#123;feed&#125; /&gt; &lt;FeedContent feed=&#123;feed&#125; /&gt; &lt;FeedFooter feed=&#123;feed&#125; /&gt; &lt;/StyledFeedArticle&gt; ))&#125; &lt;/StyledContent&gt; &lt;/StyledMain&gt; );&#125;;export default FeedList; MainTitle.jsx 12345678910111213import React from 'react';import &#123; StyledMainTitle &#125; from './Styles';const MainTitle = () =&gt; &#123; return ( &lt;StyledMainTitle&gt; &lt;h2&gt;Feed&lt;/h2&gt; &lt;p&gt;최신 패션 뉴스를 전해드립니다.&lt;/p&gt; &lt;/StyledMainTitle&gt; );&#125;;export default MainTitle; FeedHeader.jsx 1234567891011121314import React from 'react';import &#123; v4 as uuidv4 &#125; from 'uuid';const FeedHeader = (&#123; feed &#125;) =&gt; &#123; return ( &lt;header&gt; &lt;h3 key=&#123;uuidv4()&#125; className=\"a11y-hidden\"&gt; &#123;feed.tags.map(tag =&gt; `$&#123;tag&#125; `)&#125; &lt;/h3&gt; &lt;/header&gt; );&#125;;export default FeedHeader; FeedContent.jsx 1234567891011121314151617181920import React from 'react';import &#123; Link &#125; from 'react-router-dom';import &#123; StyledFeedImg, StyledFeedTagBox, StyledFeedContent &#125; from './Styles';import &#123; v4 as uuidv4 &#125; from 'uuid';const FeedContent = (&#123; feed &#125;) =&gt; &#123; return ( &lt;Link to=&#123;`/feed/$&#123;feed.id&#125;`&#125;&gt; &lt;StyledFeedImg src=&#123;feed.mediaList[0].url&#125; alt=\"images\" /&gt; &lt;StyledFeedTagBox&gt; &#123;feed.tags.map(tag =&gt; ( &lt;span key=&#123;uuidv4()&#125;&gt;&#123;`#$&#123;tag&#125;`&#125;&lt;/span&gt; ))&#125; &lt;/StyledFeedTagBox&gt; &lt;StyledFeedContent&gt;&#123;feed.text&#125;&lt;/StyledFeedContent&gt; &lt;/Link&gt; );&#125;;export default FeedContent; FeedFooter.jsx 페이스북의 공유기능에서 local로 설정시 공유가 안되는 문제를 발견했습니다. 따라서 일단은 실제 d.code와 연결해서 공유를 해놓았고 링크는 선택한 피드의 id값을 토대로 url에 집어넣어 공유되도록 설정하였습니다. 1234567891011121314151617181920212223242526272829import React from 'react';import &#123; HeartIcon, CommentAltIcon, LinkIcon, FacebookIcon &#125; from '../Icons';import &#123; StyledFeedFooter, StyledFeedMdInfo, StyledCountSpan, StyledShareButton &#125; from './Styles';const FeedFooter = (&#123; feed &#125;) =&gt; &#123; return ( &lt;StyledFeedFooter&gt; &lt;StyledFeedMdInfo&gt; &lt;img src=&#123;feed.mdInfo.mdThumb&#125; alt=\"MD 사진\" /&gt; &lt;figcaption&gt;MD : &#123;feed.mdInfo.mdName&#125;&lt;/figcaption&gt; &lt;/StyledFeedMdInfo&gt; &lt;span&gt;&#123;feed.createdAt.split(' ')[0]&#125;&lt;/span&gt; &lt;div&gt; &lt;HeartIcon /&gt; &lt;StyledCountSpan&gt;&#123;feed.likedCount ? feed.likedCount : '0'&#125;&lt;/StyledCountSpan&gt; &lt;CommentAltIcon /&gt; &lt;StyledCountSpan&gt;&#123;feed.replyCount ? feed.replyCount : '0'&#125;&lt;/StyledCountSpan&gt; &lt;LinkIcon /&gt; &lt;StyledCountSpan&gt;&#123;feed.sharedCount ? feed.sharedCount : '0'&#125;&lt;/StyledCountSpan&gt; &lt;/div&gt; &lt;StyledShareButton id=&#123;feed.id&#125;&gt; &lt;FacebookIcon /&gt; &lt;span&gt;공유하기&lt;/span&gt; &lt;/StyledShareButton&gt; &lt;/StyledFeedFooter&gt; );&#125;;export default FeedFooter;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"패션사이트 피드 클론 -Header, Store 저장 테스트-","slug":"feed-02","date":"2020-03-19T13:46:19.000Z","updated":"2020-04-02T14:18:51.062Z","comments":true,"path":"2020/03/19/feed-02/","link":"","permalink":"https://hyeok999.github.io/2020/03/19/feed-02/","excerpt":"","text":"d.code 패션 피드 구현- header 꾸미기, Store에 feed 저장 테스트 하기 -목차 라이브러리 인스톨하기 전역적으로 사용할 Icons 파일 작성하기 Feed.jsx 에 Header 컴포넌트 추가하기 Header 폴더 및 파일 스트럭쳐 구성하기 Styles.jsx HeaderLogo.jsx MainMenu.jsx Member.jsx index.jsx (Feed - Header 컴포넌트) Feed List 데이터를 받아서 Redux Store 저장 테스트 하기 modules/feed.js 작성하기 Combine Reducer에 리듀서 추가하기 Root Saga에 사가함수 추가하기 Container, Test Component 작성하기 라이브러리 인스톨하기 12345cd d-code-feednpm i @fortawesome/fontawesome-svg-corenpm i @fortawesome/free-brands-svg-icons @fortawesome/free-regular-svg-icons @fortawesome/free-solid-svg-iconsnpm i @fortawesome/react-fontawesomenpm i redux-actions 전역적으로 사용할 Icons 파일 작성하기 위치 : src/components/Icons.jsx 1234567891011import React from 'react';import &#123; faSearch, faShoppingCart &#125; from '@fortawesome/free-solid-svg-icons';import &#123; FontAwesomeIcon &#125; from '@fortawesome/react-fontawesome';export function SearchIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faSearch&#125; size=\"lg\" /&gt;;&#125;export function ShoppingCartIcon() &#123; return &lt;FontAwesomeIcon icon=&#123;faShoppingCart&#125; size=\"lg\" /&gt;;&#125; Feed.jsx 에 Header 컴포넌트 추가하기 위치 : src/pages/Feed.jsx 작성할 Header 컴포넌트를 미리 작성 해둡니다. 123456789101112import React from 'react';import Header from '../components/Header';const Feed = () =&gt; &#123; return ( &lt;&gt; &lt;Header /&gt; &lt;/&gt; );&#125;;export default Feed; Header 폴더 및 파일 스트럭쳐 구성하기 위치 : src/components/Header/ Styles.jsx Header 영역에서 사용되는 모든 style을 Stytled Components 를 이용하여 관리하고 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import styled from 'styled-components';// Header/index.jsxexport const StyledHeader = styled.header` position: fixed; width: 100vw; min-width: 114.8rem; top: 0;`;// Header/HeaderLogo.jsxexport const StyledHeaderLogo = styled.h1` position: absolute; width: 9rem; height: 3.7rem; top: 5.4rem; left: 5.4rem; a, img &#123; width: inherit; &#125;`;// Header/Member.jsxexport const StyledMember = styled.ul` text-align: right; position: relative; padding: 0.8rem 5.6rem; height: 3.5rem; border-bottom: 0.1rem solid #e3e3e2; color: #707070; background: #fff; li &#123; display: inline-block; font-size: 1.2rem; &#125; a &#123; display: inline-block; padding-right: 3.7rem; &#125;`;// Header/MainMenu.jsxexport const StyledMainMenu = styled.section` height: 7.1rem; display: flex; justify-content: space-between; border-bottom: 0.1rem solid #e3e3e2; padding: 1.6rem 5.4rem; padding-left: 15rem; background: #fff;`;// Header/MainMenu.jsxexport const StyledNav = styled.nav` font-size: 1.7rem; font-weight: 900; width: 68rem; display: flex; justify-content: space-between; align-items: center;`;// Header/MainMenu.jsxexport const StyledSearchBox = styled.div` width: 28rem; div &#123; display: inline-block; border-bottom: 0.1rem solid black; &#125; input &#123; font-size: 1.6rem; width: 17rem; height: 3.8rem; border: none; &#125; button &#123; border: none; background: transparent; &#125; .shoppin-cart &#123; padding-left: 4.4rem; &#125;`; HeaderLogo.jsx 123456789101112131415import React from 'react';import &#123; StyledHeaderLogo &#125; from './Styles';import &#123; Link &#125; from 'react-router-dom';const HeaderLogo = () =&gt; &#123; return ( &lt;StyledHeaderLogo&gt; &lt;Link to=\"/\"&gt; &lt;img src=\"/logo/d-code-logo.png\" alt=\"디코드\" /&gt; &lt;/Link&gt; &lt;/StyledHeaderLogo&gt; );&#125;;export default HeaderLogo; MainMenu.jsx 123456789101112131415161718192021222324252627282930313233import React from 'react';import &#123; StyledMainMenu, StyledNav, StyledSearchBox &#125; from './Styles';import &#123; Link &#125; from 'react-router-dom';import &#123; SearchIcon, ShoppingCartIcon &#125; from '../Icons';const MainMenu = () =&gt; &#123; return ( &lt;StyledMainMenu&gt; &lt;h2 className=\"a11y-hidden\"&gt;메인 메뉴&lt;/h2&gt; &lt;div className=\"logo-area\" /&gt; &lt;StyledNav&gt; &lt;Link to=\"/pre-order\"&gt;PRE-ORDER&lt;/Link&gt; &lt;Link to=\"/brand\"&gt;BRAND&lt;/Link&gt; &lt;Link to=\"/men\"&gt;MEN&lt;/Link&gt; &lt;Link to=\"/women\"&gt;WOMEN&lt;/Link&gt; &lt;Link to=\"/feed\"&gt;FEED&lt;/Link&gt; &lt;/StyledNav&gt; &lt;StyledSearchBox&gt; &lt;div&gt; &lt;input type=\"text\" placeholder=\"검색\" /&gt; &lt;button type=\"button\"&gt; &lt;SearchIcon /&gt; &lt;/button&gt; &lt;/div&gt; &lt;button className=\"shoppin-cart\" type=\"button\"&gt; &lt;ShoppingCartIcon /&gt; &lt;/button&gt; &lt;/StyledSearchBox&gt; &lt;/StyledMainMenu&gt; );&#125;;export default MainMenu; Member.jsx 123456789101112131415161718192021import React from 'react';import &#123; StyledMember &#125; from './Styles';import &#123; Link &#125; from 'react-router-dom';const Member = () =&gt; &#123; return ( &lt;StyledMember&gt; &lt;li&gt; &lt;Link to=\"/sign-in\"&gt;로그인&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/sign-up\"&gt;회원가입&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/service-center\"&gt;고객센터&lt;/Link&gt; &lt;/li&gt; &lt;/StyledMember&gt; );&#125;;export default Member; index.jsx (Feed - Header 컴포넌트) 1234567891011121314151617import React from 'react';import &#123; StyledHeader &#125; from './Styles';import HeaderLogo from './HeaderLogo';import Member from './Member';import MainMenu from './MainMenu';const Header = () =&gt; &#123; return ( &lt;StyledHeader&gt; &lt;HeaderLogo /&gt; &lt;Member /&gt; &lt;MainMenu /&gt; &lt;/StyledHeader&gt; );&#125;;export default Header; Feed List 데이터를 받아서 Redux Store 저장 테스트 하기 본격적으로 Feed List를 불러오고 Store에 저장하는 테스팅 코드를 작성하겠습니다.API는 기존에 작성해둔 services/FeedService.js에 모아두었습니다. modules/feed.js 작성하기 위치 : src/redux/modules/feed.js 모듈을 작성합니다. 액션, 액션생성자(크리에이터), 리듀서 등을 보다 관리하기 쉽고 가독성, 유지보수성을 위해 redux-actions 라이브러리를 사용합니다. 3개의 리듀서로 나눕니다. (PENDING, SUCCESS, FAIL) - switch문 대신 redux-actions의 handleActions를 시용 PENDING : 리덕스 사가가 비동기처리를 시작하면서 데이터 결과를 확인 전까지 Pending 상태로 둡니다. 기본적으로 추후에만들 Spinner 나 Gray-scale 등을 사용하기 위해 만들었습니다. SUCCESS: 리덕스 사가를 통해 데이터를 안전하게 반환받았다면 SUCCESS를 통해서 데이터를 store에 저장합니다. FAIL : 불특정의 이유로 인해 데이터를 받아오지 못했을 경우 해당 에러 메시지를 store에 저장합니다. 초기 상태를 생성합니다. 비동기 처리를 실행할 redux-saga 함수를 만듭니다. (우선 Feed List 부분만) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import FeedService from '../../services/FeedService';import &#123; createAction, createActions, handleActions &#125; from 'redux-actions';import &#123; put, call, takeEvery &#125; from 'redux-saga/effects';const options = &#123; prefix: 'd-code/feed',&#125;;// 액션 타입 및 생성자를 한번에 모아서 사용함. - redux-actions// const success = feeds =&gt; (&#123; type: SUCCESS, feeds &#125;);const &#123; success, pending, fail &#125; = createActions( &#123; SUCCESS: feeds =&gt; (&#123; feeds &#125;), &#125;, 'PENDING', 'FAIL', options);// ACTIONSexport const getFeeds = createAction('GET_FEEDS');// 비동기 처리 redux-sagafunction* fetchFeedLists() &#123; try &#123; yield put(pending()); const &#123; data: feeds &#125; = yield call(FeedService.getList); yield put(success(feeds.data)); &#125; catch (error) &#123; console.log('error : ', error); yield put(fail(error)); &#125;&#125;// FEED SAGAexport function* feedSaga() &#123; yield takeEvery(getFeeds, fetchFeedLists);&#125;// INIITIAL STATEconst initialState = &#123; feeds: null, loading: false, error: null,&#125;;const feed = handleActions( &#123; PENDING: state =&gt; (&#123; ...state, loading: true, error: null, &#125;), SUCCESS: (state, action) =&gt; (&#123; feeds: action.payload.feeds, loading: false, error: null, &#125;), FAIL: (state, action) =&gt; (&#123; ...state, loading: false, error: action.payload, &#125;), &#125;, initialState, options);export default feed; Combine Reducer에 리듀서 추가하기 위치 : src/redux/modules/reducer.js 위에서 작성한 feed 리듀서를 Combine Reducer에 추가합니다. 1234567891011import &#123; combineReducers &#125; from 'redux';import feed from './feed';import &#123; connectRouter &#125; from 'connected-react-router';const reducer = history =&gt; combineReducers(&#123; feed, router: connectRouter(history), &#125;);export default reducer; Root Saga에 사가함수 추가하기 위치 : src/redux/modules/saga.js 위에서 작성한 feedSaga 함수를 rootSaga에 추가합니다. 123456import &#123; all &#125; from 'redux-saga/effects';import &#123; feedSaga &#125; from './feed';export default function* rootSaga() &#123; yield all([feedSaga()]);&#125; Container, Test Component 작성하기 Container 위치 : src/containers/FeedContainer.jsx Test Component 위치 : src/components/Test.jsx Container 1234567891011121314151617import &#123; connect &#125; from 'react-redux';import &#123; getFeeds &#125; from '../redux/modules/feed';import Test from '../components/Test';const mapStateToProps = state =&gt; (&#123; feeds: state.feed.feeds, loading: state.feed.loading, error: state.feed.error,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; getFeed: () =&gt; &#123; dispatch(getFeeds()); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(Test); Test Component 1234567891011import React, &#123; useEffect &#125; from 'react';const Test = (&#123; feeds, loading, error, getFeed &#125;) =&gt; &#123; useEffect(() =&gt; &#123; getFeed(); &#125;, [getFeed]); return &lt;div&gt;&#123;feeds &amp;&amp; feeds.list[0].text&#125;&lt;/div&gt;;&#125;;export default Test;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"패션사이트 피드 클론 -셋팅-","slug":"feed-01","date":"2020-03-18T14:16:23.000Z","updated":"2020-04-01T14:28:30.833Z","comments":true,"path":"2020/03/18/feed-01/","link":"","permalink":"https://hyeok999.github.io/2020/03/18/feed-01/","excerpt":"","text":"d.code 패션 피드 구현- 초기 셋팅 하기 -목차 프로젝트 생성 라이브러리 인스톨하기 nvm 설정파일 생성하기 package.json 설정 추가하기 prettier 설정파일 생성하기 라우터 설정하기 pages 폴더 만들고 컴포넌트 설정하기 Redux 셋팅하기 상위 컴포넌트에 Provider 셋팅 하기 redux 모듈 작성하기 create 함수 작성하기 combineReducer 작성하기 rootSaga 작성하기 index.js Reset.css 적용하기 프로젝트 생성 1npx create-react-app d-code-feed 라이브러리 인스톨하기 123456cd d-code-feednpm i react-error-boundary react-helmetnpm i react-router-dom connected-react-routernpm i redux react-redux redux-saganpm i uuid axios styled-componentsnpm i prettier eslint-config-prettier husky lint-staged redux-devtools-extension -D nvm 설정파일 생성하기 .nvmrc 파일 생성 (위치 : .gitignore 랑 같은 위치) 112.11.1 package.json 설정 추가하기 &quot;scripts&quot;: {...} 아래에 삽입 123456789101112131415161718\"eslintConfig\": &#123; \"extends\": [ \"react-app\", \"prettier\" ]&#125;,\"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125;&#125;,\"lint-staged\": &#123; \"**/*.&#123;js,jsx&#125;\": [ \"eslint --fix\", \"prettier --write\", \"git add\" ]&#125;, prettier 설정파일 생성하기 .prettierrc 파일 생성 (위치 : .gitignore 랑 같은 위치) 12345&#123; \"printWidth\": 100, \"singleQuote\": true, \"trailingComma\": \"es5\"&#125; 라우터 설정하기 path 에러가 날 경우 특정 컴포넌트로 이동하도록 &lt;ErrorBoundary FallbackComponent={ErrorFallbackComponent}&gt;를 설정합니다. 추후 Redux를 사용할 것이고, error에 관한 state는 차후 반드시 필요하기에 미리 설정합니다. 지금은 상세보기(FeedDatail)에 관한 REST API가 주어져있기 때문에 상관없지만, 차후에는 선택된 Feed에 대하여 상세보기의 주소가 feed/:feedId형식으로 적용될 것으로 예상됩니다. 따라서 ConnectedRouter를 이용하여 현재 url의 history객체를 Redux store에 저장합니다. exact : 주어진 경로와 정확히 맞아 떨어져야만 설정한 컴포넌트를 보여줍니다. Switch 컴포넌트에 감싸면 매칭되는 첫번째 라우트만 보여주고 나머지는 보여주지 않습니다. 123456789101112131415161718192021222324// App.jsimport React from 'react';import &#123; Switch, Route &#125; from 'react-router-dom';import &#123; ConnectedRouter &#125; from 'connected-react-router';import Feed from './pages/Feed';import NotFound from './pages/NotFound';import ErrorBoundary from 'react-error-boundary';import &#123; history &#125; from './redux/create';const ErrorFallbackComponent = (&#123; error &#125;) =&gt; &lt;div&gt;&#123;error.message&#125;&lt;/div&gt;;const App = () =&gt; ( &lt;ErrorBoundary FallbackComponent=&#123;ErrorFallbackComponent&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route exact path=\"/feed\" component=&#123;Feed&#125; /&gt; &lt;Route exact path=\"/\" component=&#123;Feed&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/ConnectedRouter&gt; &lt;/ErrorBoundary&gt;);export default App; pages 폴더 만들고 컴포넌트 만들기 pages– Feed.jsx– NotFound.jsx 12345678// Feed.jsximport React from 'react';const Feed = () =&gt; &#123; return &lt;&gt;Feed 입니다.&lt;/&gt;;&#125;;export default Feed; 12345678// NotFound.jsximport React from 'react';const NotFound = props =&gt; &#123; return &lt;div&gt;NotFound&lt;/div&gt;;&#125;;export default NotFound; Redux 셋팅하기 상위 컴포넌트에 Provider 셋팅 하기 Provider 는 react-redux 라이브러리에 내장되어있는, 리액트 앱에 store 를 손쉽게 연동 할 수 있도록 도와주는 컴포넌트입니다. store 선언 및 create() 함수 호출 12345678910111213141516// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import create from './redux/create';import &#123; Provider &#125; from 'react-redux';const store = create();ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); redux 모듈 작성하기 create 함수 작성하기 현재 url에 관한 history 객체를 store에 저장합니다. 리덕스 개발자 도구를 사용하기 위한 코드를 추가합니다. 비동기 처리는 redux-saga를 이용할 것이기 때문에 createSagaMiddle를 이용하여 Redux Store에 연결합니다. 123456789101112131415161718192021222324// src/redux/create.jsimport &#123; composeWithDevTools &#125; from 'redux-devtools-extension';import &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './modules/reducer';import createSagaMiddleware from 'redux-saga';import &#123; createBrowserHistory &#125; from 'history';import &#123; routerMiddleware &#125; from 'connected-react-router';import rootSaga from './modules/rootSaga';export const history = createBrowserHistory();const sagaMiddleware = createSagaMiddleware();const create = () =&gt; &#123; const store = createStore( reducer(history), composeWithDevTools(applyMiddleware(routerMiddleware(history), sagaMiddleware)) ); sagaMiddleware.run(rootSaga); return store;&#125;;export default create; combineReducer 작성하기 흩어진 리듀서를 모아 하나의 리듀서로 통합시키는 combinerReducer를 작성합니다. 우선 틀만 작성해두었습니다. 12345678910// src/redux/modules/reducer.jsimport &#123; combineReducers &#125; from 'redux';import &#123; connectRouter &#125; from 'connected-react-router';const reducer = history =&gt; combineReducers(&#123; router: connectRouter(history), &#125;);export default reducer; rootSaga 작성하기 combineReducer 와 같이 모든 Saga를 통합관리하기 위한 rootSaga 를 작성합니다. 우선 틀만 작성해두었습니다. 12345import &#123; all &#125; from 'redux-saga/effects';export default function* rootSaga() &#123; yield all([]);&#125; index.js Reset.css 적용하기 개발하기 앞서 CSS를 초기화 하고 시작합니다. reset.css 를 참고 하였습니다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"SkyPrinter-CreateSession","slug":"CreateSession","date":"2020-03-13T08:20:27.000Z","updated":"2020-03-14T08:28:37.751Z","comments":true,"path":"2020/03/13/CreateSession/","link":"","permalink":"https://hyeok999.github.io/2020/03/13/CreateSession/","excerpt":"","text":"CreateSession 및 URL PATH 영역 유효성 검사를 통과시 티켓 데이터를 가져오기 위한 세션 생성 SkyPrinter 바로가기 목차 Session의 필요성 Session 생성 및 티켓 발급 로직 항공권 검색 버튼 클릭 URL 변경 -&gt; URL의 파라미터와 쿼리데이터를 이용해 Redux Store 초기화 -&gt; dispatch /src/pages/TicketResult.jsx withPath - HOC(High Order Component) Session 생성 -&gt; Poll -&gt; 티켓 발급 Session의 필요성 처음 skyscanner를 단순히 생각으로만 클론하려 했을 때는 버튼 클릭시 바로 티켓 페이지를 보여주는 것으로 생각했습니다. API 조사를 통해 이런식으로 바로 티켓을 보여주면 안되는 여러 이유를 알게되었습니다. 과도한 API요청을 막을 수 있습니다. 한번 생성된 세션은 10~15분정도 유지됩니다. 이는 재 검색할 때 세션을 또 만들 필요를 줄이고 Poll만 게속하면 되기 때문에 과도한 API요청을 막을 수 있습니다. 세션을 만드는 즉시 서버측에서는 해당 API를 지속적으로 업데이트 하면서 데이터를 로드해옵니다. 그 동안 만들어진 세션에 대해서 UpdatesComplete가 될 때 까지 게속 poll을 해주어야만 합니다. 여기서 UpdatesPending일 때 사용자가 미리 티켓이나 항공편등을 볼 수 있는 편의성을 제공해줍니다. Session 생성 및 티켓 발급 로직 항공권 검색 버튼 클릭 URL 변경 -&gt; URL의 파라미터와 쿼리데이터를 이용해 Redux Store 초기화 -&gt; dispatch Session 생성 -&gt; Poll -&gt; 티켓 발급 항공권 검색 버튼 클릭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function SearchButton(&#123; children, allInfo, createSession, setError &#125;) &#123; ... const create = () =&gt; &#123; ... // 유효성 검사 이후 에러가 존재하지 않는다면 URL 이동 if (errorLists.length &gt;= 1) &#123; setError(errorLists); &#125; else &#123; clearError(); createSession(allInfo); &#125; &#125;; return &lt;button onClick=&#123;create&#125;&gt;&#123;children&#125;&lt;/button&gt;;&#125;...const mapDispatchToProps = dispatch =&gt; (&#123; createSession: allInfo =&gt; &#123; // 모든 에러를 지움. dispatch(clearError()); // URL 생성하기 위한 변수들을 각각 정의 (값은 Redux Store를 통해 가져옴.) const originPlace = allInfo.places.inBoundId.toLowerCase(); const originPlaceName = allInfo.places.inBoundName; const destinationPlace = allInfo.places.outBoundId.toLowerCase(); const destinationPlaceName = allInfo.places.outBoundName; const tripType = allInfo.datepicker.tripType; const outboundDate = TicketService.convertDateToString( allInfo.datepicker.outboundDate ); const inboundDate = allInfo.datepicker.inboundDate &amp;&amp; TicketService.convertDateToString(allInfo.datepicker.inboundDate); const adults = allInfo.passenger.adults; const children = allInfo.passenger.children.length; const childrenAge = allInfo.passenger.children.map(c =&gt; c.age).join('|'); const infants = allInfo.passenger.children.filter(c =&gt; c.type === 'infant') .length; const cabinclass = allInfo.passenger.cabinClass; dispatch( push( `/transport/flights/$&#123;originPlace&#125;/$&#123;destinationPlace&#125;/$&#123;outboundDate&#125;?inboundDate=$&#123;inboundDate&#125;&amp;tripType=$&#123;tripType&#125;&amp;adults=$&#123;adults&#125;&amp;children=$&#123;children&#125;&amp;childrenAge=$&#123;childrenAge&#125;&amp;infants=$&#123;infants&#125;&amp;cabinclass=$&#123;cabinclass&#125;&amp;originPlaceName=$&#123;originPlaceName&#125;&amp;destinationPlaceName=$&#123;destinationPlaceName&#125;` ) );.... URL 변경 -&gt; URL의 파라미터와 쿼리데이터를 이용해 Redux Store 초기화 -&gt; dispatch URL이 변경되면 App.js를 통해 라우팅이 됩니다. (TicketResult.jsx) 123456789101112131415// App.js&lt;Provider store=&#123;store&#125;&gt; &lt;ErrorBoundary FallbackComponent=&#123;ErrorFallbackComponent&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route path=\"/transport/flights/:originId/:destinationId/:outboundDate\" component=&#123;TicketResult&#125; /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/ConnectedRouter&gt; &lt;/ErrorBoundary&gt;&lt;/Provider&gt; /src/pages/TicketResult.jsx TickrResult 페이지는 withPath(HOC)를 통해 관리되고 있습니다. 12345678910const TicketResult = () =&gt; ( &lt;&gt; &lt;HeaderContainer width=\"144rem\" /&gt; &lt;Main /&gt; &lt;Footer /&gt; &lt;Copyright /&gt; &lt;/&gt;);export default withPath(TicketResult); withPath - HOC(High Order Component) withPath에서는 URL을 통해 TicketResult 페이지에 접근시 ReduxStore가 비워져있다면 ReduxStore을 URL파라미터와 쿼리의 값을 이용하여 초기화하고 안비워져있다면 그대로 이용하기 위함으로 설계하였습니다. withPath에서 redux에게 dispatch를 여기서 하여 session을 만들어 줍니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function withPath(Component) &#123; function WrappedComponent(props) &#123; const storePlaces = useSelector(state =&gt; state.places); const culture = useSelector(state =&gt; state.culture); const dispatch = useDispatch(); useEffect(() =&gt; &#123; const urlQuery = qs.parse(props.location.search); const places = &#123; inBoundId: props.match.params.originId, inBoundName: urlQuery.originPlaceName, outBoundId: props.match.params.destinationId, outBoundName: urlQuery.destinationPlaceName &#125;; const datepicker = &#123; tripType: urlQuery.tripType, outboundDate: new Date(props.match.params.outboundDate), inboundDate: urlQuery.inboundDate ? new Date(urlQuery.inboundDate) : null, prevInboundDate: null &#125;; const children = +urlQuery.children ? urlQuery.childrenAge.split('|').map((c, i) =&gt; (&#123; id: i, age: c, type: c &gt;= 2 ? 'child' : 'infant' &#125;)) : []; const passenger = &#123; cabinClass: urlQuery.cabinclass, adults: +urlQuery.adults, children &#125;; // Query String const allInfo = &#123; culture: culture, places: places, passenger: passenger, datepicker: datepicker &#125;; // createSession dispatch(createSession(allInfo)); // reset ReduxStore if (storePlaces &amp;&amp; storePlaces.inBoundId.length === 0) &#123; dispatch( setPlace(&#123; PlaceId: places.inBoundId, PlaceName: places.inBoundName, type: 'inBound' &#125;) ); dispatch( setPlace(&#123; PlaceId: places.outBoundId, PlaceName: places.outBoundName, type: 'outBound' &#125;) ); dispatch(resetDate(&#123; ...datepicker &#125;)); dispatch(resetPassenger(&#123; ...passenger &#125;)); &#125; // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [props.match, props.location]); return &lt;Component &#123;...props&#125; /&gt;; &#125; WrappedComponent.displayName = `withPath($&#123;Component.name&#125;)`; return WrappedComponent;&#125;export default withPath; Session 생성 -&gt; Poll -&gt; 티켓 발급 session을 생성하자마자 UpdatesComplete가 날 때 까지 Poll을 해야만 합니다. while 반복문을 이용하여 UpdatesComplete가 날 때까지 만들어진 session의 key를 이용해 게속해서 요청을 합니다. 요청을 게속해서 해야하기 때문에 Redux Saga 미들웨어로 비동기 처리를 하였습니다. 업데이트가 꼬일 확률을 대비해 delay를 1500 설정하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// /src/redux/modules/session.jsexport function* postSession(&#123; allInfo &#125;) &#123; const &#123; culture, places, passenger, datepicker &#125; = allInfo; const &#123; country, currency, locale &#125; = culture; const &#123; inBoundId, outBoundId &#125; = places; // children, infants const &#123; adults &#125; = passenger; const &#123; outboundDate, inboundDate &#125; = datepicker; const params = &#123; locale, country, currency, originPlace: inBoundId + '-sky', destinationPlace: outBoundId + '-sky', outboundDate: TicketService.convertDateToString(outboundDate), adults &#125;; if (inboundDate) params.inboundDate = TicketService.convertDateToString(inboundDate); try &#123; // 1. 초기화 yield put(resetResult()); // 2. 세션 생성 const &#123; headers &#125; = yield call(SessionService.createSession, params); const locationToArr = headers.location.split('/'); const sessionKey = locationToArr[locationToArr.length - 1]; yield put(setSessionKey(sessionKey)); // 3. 2에서 생성한 Session의 상태가 complete될 때까지 poll const filterOption = yield select((&#123; session &#125;) =&gt; session.filterOption); while (true) &#123; const &#123; data &#125; = yield call( SessionService.pollSession, sessionKey, filterOption ); .... yield delay(1500); &#125; &#125; catch (error) &#123; console.dir(error); if (error.response.status === 400) &#123; yield put(push(`/error`)); &#125; console.log(error); &#125;&#125;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"SkyPrinter-FilterArea","slug":"FilterArea","date":"2020-03-13T04:16:06.000Z","updated":"2020-03-14T08:24:56.114Z","comments":true,"path":"2020/03/13/FilterArea/","link":"","permalink":"https://hyeok999.github.io/2020/03/13/FilterArea/","excerpt":"","text":"Filter 영역 SkyPrinter Ticket Result Filter Area SkyPrinter 바로가기 목차 Filter 폴더 구조 Filter API 알아보기 - Poll Session Result - Filter 방식 파악하기 Redux Module 파악하기 session module 오리지널 데이터 스토어 UI용 데이터 스토어 Fiter 옵션 데이터 스토어 Saga 함수 작성 postSession getSession filter 옵션 stop filter Time filter Carrier filter Filter 폴더 구조 /src/components/Main/TicketResult/filter 12345// /src/components/Main/TicketResult/TicketResultInfo.jsx&lt;StopFilter /&gt;&lt;TimeFilter /&gt;&lt;DurationFilter /&gt;&lt;CarrierFilter /&gt; /CarrierFilter.jsx /DurationFilter.jsx /TimeFilter.jsx /StopFilter.jsx Filter API 알아보기 - Poll Session Results -session을 만들고 얻은 session key를 이용하여 Poll을 할 때 파라미터를 통해 필터조건을 줄 수 있습니다. 예제 : 경유 - 직항 / 아시아나 항공 제외 123456789101112131415161718192021222324252627282930import axios from 'axios';import axios from 'axios';// 2. Poll Session(async () =&gt; &#123; try &#123; const SESSION_KEY = '6aa0be06-8526-4d52-a5d6-f70e5670046a'; const POLL_URL = `https://skyscanner-skyscanner-flight-search-v1.p.rapidapi.com/apiservices/pricing/uk2/v1.0/$&#123;SESSION_KEY&#125;`; const headers = &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'X-RapidAPI-Key': 'RAPID_API_KEY' &#125;; // 필터 예 , 경유 : 직항 , 항공기 : 아시아나 제외 const params = &#123; stops: '0', excludeCarriers: 'OZ;KE', &#125;; const &#123; data &#125; = await axios.get(POLL_URL, &#123; params, headers &#125;); console.dir(data); &#125; catch (e) &#123; console.error(e); &#125;&#125;)(); Filter 방식 파악하기 실제 스카이 스캐너에서는 Poll 데이터가 ‘UpdatesComplete’ 상태가 아닌 경우에도 필터링이 가능합니다. 즉, 프로그레스바가 진행 중일 때도 경유, 항공사, 출발지 - 도착지 시간대 설정이 모두 가능합니다. 따라서, session은 1개만 만들어지지만 실제로 poll은 2개로 나뉘어서 해야합니다. 그리고 Redux Store에 프로그레스바와 실제 데이터를 담아둘 오리지널 데이터용 Store를 하나 만들고, 나머지 하나는 실제로 보여질 UI 데이터용 Store 하나를 생성합니다. 추가로 각 필터옵션들은 한번 체크 해두면 해제하기 전까지 다른 필터조건과 같이 작용해야만 합니다. 그러므로 필터옵션들도 Redux Store로 관리를 하도록합니다. 즉, 정리하면 다음과 같이 3개의 스토어를 생성해야만 합니다. 프로그레스바, 실제 데이터를 담아둘 변하지 않은 오리지널 데이터 스토어 실제 필터를 적용해 화면에 보여질 UI 데이터 스토어 Filter 옵션들을 저장할 스토어 Redux Module 파악하기 위에서 필요한 스토어들을 정리해봅니다. 오리지널 데이터 스토어 UI용 데이터 스토어 Filter 옵션 데이터 스토어 session module 오리지널 데이터 스토어 1234567891011export const SET_ALL_RESULT = 'skyprinter/session/SET_ALL_RESULT';export const setAllResult = allResult =&gt; (&#123; type: SET_ALL_RESULT, allResult&#125;);export const setAllResult = allResult =&gt; (&#123; type: SET_ALL_RESULT, allResult&#125;); UI용 데이터 스토어 1234567891011121314151617181920export const SET_POLL_RESULT = 'skyprinter/session/SET_POLL_RESULT';export const setPollResult = data =&gt; (&#123; type: SET_POLL_RESULT, pollResult: data&#125;);case SET_POLL_RESULT:....return &#123; ...state, pollResult: &#123; ...action.pollResult, Itineraries: sortedItineraries &#125;, minDurationItinerary, earliestOutboundItinerary, cheapestItinerary&#125;; Fiter 옵션 데이터 스토어 12345678910111213export const SET_FILTER_OPTION = 'skyprinter/session/SET_FILTER_OPTION';export const setFilterOption = filterOption =&gt; (&#123; type: SET_FILTER_OPTION, filterOption&#125;);case SET_FILTER_OPTION: return &#123; ...state, isDirect: false, filterOption: action.filterOption&#125;; Saga 함수 작성 postSession 세션을 만들고 처음 poll을 보낼떄 사용되는 Saga함수입니다. 지속적으로 XHR(비동기) 요청을 해야하기 때문에 Saga함수를 이용하였습니다. 위에서 정의한 setAllResult 와 setPollResult를 사용합니다. 먼저 세션키를 만듦가 동시에 첫 poll을 할 때에는setAllResult 와 setPollResult 모두 스토어에 값을 담아줍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293export function* postSession(&#123; allInfo &#125;) &#123; const &#123; culture, places, passenger, datepicker &#125; = allInfo; const &#123; country, currency, locale &#125; = culture; const &#123; inBoundId, outBoundId &#125; = places; // children, infants const &#123; adults &#125; = passenger; const &#123; outboundDate, inboundDate &#125; = datepicker; const params = &#123; locale, country, currency, originPlace: inBoundId + '-sky', destinationPlace: outBoundId + '-sky', outboundDate: TicketService.convertDateToString(outboundDate), adults &#125;; if (inboundDate) params.inboundDate = TicketService.convertDateToString(inboundDate); try &#123; // 1. 초기화 yield put(resetResult()); // 2. 세션 생성 const &#123; headers &#125; = yield call(SessionService.createSession, params); const locationToArr = headers.location.split('/'); const sessionKey = locationToArr[locationToArr.length - 1]; yield put(setSessionKey(sessionKey)); // 3. 2에서 생성한 Session의 상태가 complete될 때까지 poll const filterOption = yield select((&#123; session &#125;) =&gt; session.filterOption); while (true) &#123; const &#123; data &#125; = yield call( SessionService.pollSession, sessionKey, filterOption ); // 프로그래스바 계산 const &#123; Agents &#125; = data; const AllAgents = Agents.length; const PendingAgents = Agents.filter( Agent =&gt; Agent.Status === 'UpdatesComplete' ).length; const progressNum = (PendingAgents / AllAgents) * 100; yield put(&#123; type: SET_PROGRESS_RESULT, progress: Math.floor(progressNum) &#125;); // 4. 세션 로딩시 표시할 티켓 생성 // all data는 계속 업데이트 해준다 yield put(setAllResult(data)); // 4. 세션 로딩이 complete되면 원본을 allResult에 저장한 뒤 // 5. UI에 표시할 티켓을 가장 최근 적용된 필터로 poll해온다. if (data.Status === 'UpdatesComplete') &#123; const pollResult = yield select((&#123; session &#125;) =&gt; session.pollResult); // status가 complete인데 pollResult의 결과가 없다면 if ( !pollResult || !pollResult.Itineraries || !pollResult.Itineraries.length ) &#123; const allResult = yield select((&#123; session &#125;) =&gt; session.allResult); // allResult는 있는 경우 if (allResult.Itineraries &amp;&amp; allResult.Itineraries.length) &#123; yield put(setPollResult(allResult)); yield put(&#123; type: SET_TICKETS &#125;); &#125; yield put(setFilterOption(&#123; sortType: 'price', sortOrder: 'asc' &#125;)); &#125; else &#123; yield put(&#123; type: POLL_SESSION &#125;); &#125; break; &#125; else &#123; const isPolling = yield select((&#123; session &#125;) =&gt; session.isPolling); if (!isPolling) yield put(&#123; type: POLL_SESSION &#125;); &#125; yield delay(1500); &#125; &#125; catch (error) &#123; console.dir(error); if (error.response.status === 400) &#123; yield put(push(`/error`)); &#125; console.log(error); &#125;&#125; getSession getSession은 특정 필터링, sorting때 poll데이터(UI용 데이터)를 변경하기 위한 Saga함수입니다. 역시 XHR(비동기) 요청을 해야하기 때문에 Saga함수를 이용하였습니다. 리덕스 스토어에 저장된 필터 조건을 이용하여 필터링된 새로운 response를 poll 스토어에 저장합니다. 1234567891011121314151617181920212223242526272829export function* getSession(action) &#123; yield put(&#123; type: TOGGLE_POLL_STATUS &#125;); if (action.loader) yield put(toggleFliterLoader()); const sessionKey = yield select((&#123; session &#125;) =&gt; session.sessionKey); const filterOption = yield select((&#123; session &#125;) =&gt; session.filterOption); const isDirect = yield select((&#123; session &#125;) =&gt; session.isDirect); let newFilter = &#123; ...filterOption &#125;; if (isDirect) &#123; newFilter.stops = 0; &#125; try &#123; const &#123; data &#125; = yield call( SessionService.pollSession, sessionKey, newFilter ); if (action.loader) yield put(toggleFliterLoader()); yield put(setPollResult(data)); yield put(&#123; type: SET_TICKETS &#125;); yield put(&#123; type: TOGGLE_POLL_STATUS &#125;); &#125; catch (error) &#123; console.error(error); &#125;&#125; filter 옵션 stop filter 지역 상태를 만들고 리덕스의 상태에 따라 업데이트 하도록 설계하였습니다. 기존의 스카이스캐너에서는 직항, 1회경유, 2회경유 이상을 제공했지만 Rapid Api에서는 조건을 다르게 제공해서 Radio버튼식으로 구현하였습니다. 편도일 경우, 티켓 한장의 경유에 대한 최저가를 표시하였습니다. 왕복일 경우, 티켓 한장 중 출국,귀국에 대해서 직항이면 출귀국 모두 직항인 최저가를, 1회경유라면 출귀국 모두 1회경유인 최저가를 표시하였습니다. 경유가 모두일 때에는 직항, 최대 1회경유중 가장 적은 금액을 표시하였습니다. 최저가의 값은 소수점은 버린 후 1000원단위로 콤마를 찍어서 표시하였습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204const StopFilter = React.memo((&#123; session, setFilter &#125;) =&gt; &#123; const [drop, setDrop] = useState(true); const [stopLists, setStopLists] = useState([]); const getStops = useCallback( (&#123; Itineraries, Legs, Segments &#125;) =&gt; &#123; const DirectStopList = []; const OneOverStopList = []; for (let i = 0; i &lt; Itineraries.length; i++) &#123; ticketLists(Itineraries[i]); if (DirectStopList.length &amp;&amp; OneOverStopList.length) break; &#125; function ticketLists(itinerary) &#123; const &#123; PricingOptions, OutboundLegId, InboundLegId &#125; = itinerary; // get Outbound Leg let OutboundLeg; Legs.forEach(leg =&gt; &#123; if (leg.Directionality === 'Outbound' &amp;&amp; leg.Id === OutboundLegId) &#123; OutboundLeg = &#123; ...leg &#125;; &#125; &#125;); // get Outbound segments const OutboundSegments = []; OutboundLeg.SegmentIds.forEach(id =&gt; &#123; OutboundSegments.push(&#123; ...Segments[id] &#125;); &#125;); OutboundLeg.Segments = OutboundSegments; const ticket = &#123; PricingOptions, OutboundLeg &#125;; // get Inbound Leg (왕복이라면) if (InboundLegId) &#123; let InboundLeg; Legs.forEach(leg =&gt; &#123; if (leg.Directionality === 'Inbound' &amp;&amp; leg.Id === InboundLegId) &#123; InboundLeg = &#123; ...leg &#125;; &#125; &#125;); const InboundSegments = []; InboundLeg.SegmentIds.forEach(id =&gt; &#123; InboundSegments.push(&#123; ...Segments[id] &#125;); &#125;); InboundLeg.Segments = InboundSegments; ticket.InboundLeg = InboundLeg; if ( ticket.OutboundLeg.Stops.length === ticket.InboundLeg.Stops.length ) &#123; if (ticket.OutboundLeg.Stops.length === 0) &#123; if (DirectStopList.length === 0) DirectStopList.push(ticket); &#125; if (ticket.OutboundLeg.Stops.length === 1) &#123; if (OneOverStopList.length === 0) OneOverStopList.push(ticket); &#125; &#125; &#125; else &#123; if (ticket.OutboundLeg.Stops.length === 0) &#123; if (DirectStopList.length === 0) DirectStopList.push(ticket); &#125; if (ticket.OutboundLeg.Stops.length === 1) &#123; if (OneOverStopList.length === 0) OneOverStopList.push(ticket); &#125; &#125; &#125; function numberWithCommas(x) &#123; return x.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, ','); &#125; function allStopPrice() &#123; if (DirectStopList.length &gt; 0 &amp;&amp; OneOverStopList.length &gt; 0) &#123; const OneOverPrice = OneOverStopList[0].PricingOptions[0].Price; const DirectPrice = DirectStopList[0].PricingOptions[0].Price; return OneOverPrice &lt; DirectPrice ? `₩ $&#123;numberWithCommas(Math.floor(OneOverPrice))&#125;` : `₩ $&#123;numberWithCommas(Math.floor(DirectPrice))&#125;`; &#125; if (DirectStopList.length &gt; 0 &amp;&amp; OneOverStopList.length === 0) &#123; const DirectPrice = DirectStopList[0].PricingOptions[0].Price; return `₩ $&#123;numberWithCommas(Math.floor(DirectPrice))&#125;`; &#125; if (DirectStopList.length === 0 &amp;&amp; OneOverStopList.length &gt; 0) &#123; const OneOverPrice = OneOverStopList[0].PricingOptions[0].Price; return `₩ $&#123;numberWithCommas(Math.floor(OneOverPrice))&#125;`; &#125; if (DirectStopList.length === 0 &amp;&amp; OneOverStopList.length === 0) &#123; if (Itineraries.length === 0) &#123; return '없음'; &#125; else &#123; return `₩ $&#123;numberWithCommas( Math.floor(Itineraries[0].PricingOptions[0].Price) )&#125;`; &#125; &#125; return '없음'; &#125; const stops = [ &#123; id: '직항', checked: session.filterOption.stops === 0 ? true : false, price: DirectStopList.length &gt;= 1 ? `₩ $&#123;numberWithCommas( Math.floor(DirectStopList[0].PricingOptions[0].Price) )&#125;` : '없음', disabled: DirectStopList.length === 0 ? true : false &#125;, &#123; id: '최대 1회 경유', checked: session.filterOption.stops === 1 ? true : false, price: OneOverStopList.length &gt;= 1 ? `₩ $&#123;numberWithCommas( Math.floor(OneOverStopList[0].PricingOptions[0].Price) )&#125;` : '없음', disabled: OneOverStopList.length === 0 ? true : false &#125;, &#123; id: '모두', checked: session.filterOption.stops === undefined ? true : false, price: allStopPrice(), disabled: false &#125; ]; return stops; &#125;, [session.filterOption.stops] ); useEffect(() =&gt; &#123; setStopLists(getStops(session.allResult)); &#125;, [getStops, session.allResult]); const onChange = stopList =&gt; &#123; if (stopList.id === '직항') &#123; setFilter(&#123; ...session.filterOption, stops: 0 &#125;); &#125; if (stopList.id === '최대 1회 경유') &#123; setFilter(&#123; ...session.filterOption, stops: 1 &#125;); &#125; if (stopList.id === '모두') &#123; const &#123; stops, ...filterOption &#125; = session.filterOption; setFilter(&#123; ...filterOption &#125;); &#125; &#125;; const switchDrop = () =&gt; &#123; setDrop(!drop); &#125;; return ( ... &lt;FilterWrapperDd&gt; &lt;FilterDropDiv drop=&#123;drop&#125;&gt; &#123;stopLists.map(stopList =&gt; ( &lt;OptionHeader key=&#123;uuid.v4()&#125; zero=&#123;stopList.disabled&#125;&gt; &lt;StyleCheckBox onChange=&#123;() =&gt; &#123; if (stopList.checked) return; onChange(stopList); &#125;&#125; checked=&#123;stopList.checked&#125; disabled=&#123;stopList.disabled ? true : false&#125; &gt; &#123;stopList.id&#125; &lt;/StyleCheckBox&gt; &lt;OptionContent zero=&#123;stopList.disabled&#125;&gt; &#123;stopList.price&#125; &lt;/OptionContent&gt; &lt;/OptionHeader&gt; ))&#125; &lt;/FilterDropDiv&gt; &lt;/FilterWrapperDd&gt; ... );&#125;);const mapStateToProps = state =&gt; (&#123; session: state.session&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; setFilter: filterOption =&gt; &#123; dispatch(setFilterOption(filterOption)); dispatch(pollSession(true)); &#125;&#125;);export default connect(mapStateToProps, mapDispatchToProps)(StopFilter); Time filter 가는날 오는날 전부 초기상태가 오전 12시 ~ 오후 11시 59분으로 맞춰져 있습니다. 슬라이더 status를 기준으로 2%당 시간 30분으로 잡았고 최대는 100%가 아닌 98%로 놓음으로서 총 24시간을 구현하였습니다. 절반 상태인 12시가 될 경우 오전 -&gt; 오후로 바뀌게끔 설정하였습니다. 그리고 제일 끝인 오후12시는 11시 59분으로 맨 앞은 오전 12시로 설정하였습니다. 한자리 숫자(0)으로 표기 되는 경유 강제로 ‘00’으로 붙게끔 조건을 두었습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186const TimeFilter = (&#123; session, setFilterOption &#125;) =&gt; &#123; const [drop, setDrop] = useState(true); const [outBoundMinTime, setOutBoundMinTime] = useState('오전 12:00'); const [outBoundMaxTime, setOutBoundMaxTime] = useState('오후 11:59'); const [inBoundMinTime, setInBoundMinTime] = useState('오전 12:00'); const [inBoundMaxTime, setInBoundMaxTime] = useState('오후 11:59'); const getTime = (persent, day) =&gt; &#123; if (day) &#123; const time = persent * 15; let date = ''; let hour = '0'; let minute = ''; if (time &gt;= 750) &#123; date = '오후'; &#125; else &#123; date = '오전'; &#125; if (time &gt;= 60) &#123; hour = Math.floor(time / 60); minute = time % 60; &#125; else &#123; minute = time; &#125; const answer = `$&#123;date&#125; $&#123;persent &gt; 48 ? (hour = hour - 12) : hour&#125;:$&#123; minute === 0 ? '00' : minute &#125;`; if (persent === 48) &#123; return '오후 12:00'; &#125; if (answer === '오전 0:00') &#123; return '오전 12:00'; &#125; else &#123; return answer; &#125; &#125; else &#123; const time = persent * 15; let date = ''; let hour = ''; let minute = ''; if (time &lt; 750) &#123; date = '오전'; &#125; else &#123; date = '오후'; &#125; if (time &gt;= 60) &#123; hour = Math.floor(time / 60); minute = time % 60; &#125; else &#123; minute = time; &#125; const answer = `$&#123;date&#125; $&#123;persent &lt; 48 ? hour : hour - 12&#125;:$&#123; minute === 0 ? '00' : minute &#125;`; if (persent === 48) &#123; return '오후 12:00'; &#125; if (answer === '오후 12:00') &#123; return '오후 11:59'; &#125; else &#123; return answer; &#125; &#125; &#125;; const parseString = data =&gt; &#123; if (`$&#123;data&#125;`.length === 1) &#123; return `0$&#123;data&#125;`; &#125; else &#123; return `$&#123;data&#125;`; &#125; &#125;; const slideAfterOutBoundChange = () =&gt; &#123; const minHour = +(outBoundMinTime.substring(3, 5)[1] === ':' ? outBoundMinTime.substring(3, 4) : outBoundMinTime.substring(3, 5)); const minMinute = outBoundMinTime.slice(-2); const maxHour = +(outBoundMaxTime.substring(3, 5)[1] === ':' ? outBoundMaxTime.substring(3, 4) : outBoundMaxTime.substring(3, 5)); const maxMinute = outBoundMaxTime.slice(-2); const newFilterOption = &#123; ...session.filterOption, outboundDepartStartTime: outBoundMinTime.substring(0, 2) === '오후' ? `$&#123;minHour + 12&#125;:$&#123;minMinute&#125;` : `$&#123;parseString(minHour)&#125;:$&#123;minMinute&#125;`, outboundDepartEndTime: outBoundMaxTime.substring(0, 2) === '오후' ? `$&#123;maxHour + 12&#125;:$&#123;maxMinute&#125;` : `$&#123;parseString(maxHour)&#125;:$&#123;maxMinute&#125;` &#125;; setFilterOption(newFilterOption); &#125;; const slideOutBoundChange = e =&gt; &#123; setOutBoundMinTime(getTime(e[0], true)); setOutBoundMaxTime(getTime(e[1], false)); &#125;; const slideAfterInBoundChange = () =&gt; &#123; const minHour = +(inBoundMinTime.substring(3, 5)[1] === ':' ? inBoundMinTime.substring(3, 4) : inBoundMinTime.substring(3, 5)); const minMinute = inBoundMinTime.slice(-2); const maxHour = +(inBoundMaxTime.substring(3, 5)[1] === ':' ? inBoundMaxTime.substring(3, 4) : inBoundMinTime.substring(3, 5)); const maxMinute = inBoundMaxTime.slice(-2); const newFilterOption = &#123; ...session.filterOption, inboundDepartStartTime: inBoundMinTime.substring(0, 2) === '오후' ? `$&#123;minHour + 12 === 24 ? 23 : minHour + 12&#125;:$&#123;minMinute&#125;` : `$&#123;parseString(minHour)&#125;:$&#123;minMinute&#125;`, inboundDepartEndTime: inBoundMaxTime.substring(0, 2) === '오후' ? `$&#123;maxHour + 12 === 24 ? 23 : maxHour + 12&#125;:$&#123;maxMinute&#125;` : `$&#123;parseString(maxHour)&#125;:$&#123;maxMinute&#125;` &#125;; setFilterOption(newFilterOption); &#125;; const slideInBoundChange = e =&gt; &#123; setInBoundMinTime(getTime(e[0], true)); setInBoundMaxTime(getTime(e[1], false)); &#125;; const switchDrop = () =&gt; &#123; setDrop(!drop); &#125;; return ( ... &lt;FilterDropDiv drop=&#123;drop&#125;&gt; &lt;OutBoundTimeDiv&gt; &lt;TimeHeader&gt;가는날 출발 시간&lt;/TimeHeader&gt; &lt;TimeContent&gt;&#123;`$&#123;outBoundMinTime&#125; - $&#123;outBoundMaxTime&#125;`&#125;&lt;/TimeContent&gt; &lt;StyleSliderWrapper&gt; &lt;StyleSlider onAfterChange=&#123;slideAfterOutBoundChange&#125; onChange=&#123;slideOutBoundChange&#125; range step=&#123;2&#125; min=&#123;0&#125; max=&#123;96&#125; tooltipVisible=&#123;false&#125; defaultValue=&#123;[0, 100]&#125; /&gt; &lt;/StyleSliderWrapper&gt; &lt;/OutBoundTimeDiv&gt; &lt;InBoundTimeDiv&gt; &lt;TimeHeader&gt;오는날 출발 시간&lt;/TimeHeader&gt; &lt;TimeContent&gt;&#123;`$&#123;inBoundMinTime&#125; - $&#123;inBoundMaxTime&#125;`&#125;&lt;/TimeContent&gt; &lt;StyleSliderWrapper&gt; &lt;StyleSlider onAfterChange=&#123;slideAfterInBoundChange&#125; onChange=&#123;slideInBoundChange&#125; range step=&#123;2&#125; min=&#123;0&#125; max=&#123;96&#125; tooltipVisible=&#123;false&#125; defaultValue=&#123;[0, 100]&#125; /&gt; &lt;/StyleSliderWrapper&gt; &lt;/InBoundTimeDiv&gt; &lt;/FilterDropDiv&gt; ... );&#125;;const maptStateToProps = state =&gt; (&#123; session: state.session&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; setFilterOption: filterOption =&gt; &#123; dispatch(setFilterOption(filterOption)); dispatch(pollSession(true)); &#125;&#125;);export default connect(maptStateToProps, mapDispatchToProps)(TimeFilter); Carrier filter Carrier 리스트와 해당 Carrier에 맞는 최저가 Price를 구하는 로직을 구현하였습니다. 지역 상태를 두어 Redux의 filter옵션에 따라 지역상태가 바뀌게끔 설계하였습니다. 항공사 조합을 따로 만들지 않고 그냥 모든 항공사를 보여주도록 표기하였고 코드는 달라도 중복된 이름의 항공사의 경우 최저가가 낮은 항공사의 코드만 표시하였습니다. exClude 옵션을 이용하여 사용자가 선택 해제한 항공사는 exClude 리스트에 추가됩니다. 만약 모두 지우기를 선택하면 모든 항공사가 exClude리스트에 추가되고, 모두 선택을 누르면 모든 exClude리스트가 완전히 삭제됩니다. exClude는 문자열 형태로 코드와 코드 사이에 ‘;’을 넣어 구분합니다. exClude 처리는 정규표현식을 이용하여 해결하였습니다. 항공기별 최저가는 티켓의 가장 최저가 첫번째에서 선별해왔고 소수점은 버린 후 1000원단위로 콤마를 찍어서 표시하였습니다. 모두 선택인 상태일 경우, 모두 선택을 비활성화 / 모두 해제인 상태일 경우, 모두 지우기 비활성화 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245const CarrierFilter = React.memo((&#123; session, setFilter &#125;) =&gt; &#123; const [drop, setDrop] = useState(true); const [carrierLists, setCarrierLists] = useState([]); const getCarriers = useCallback( (&#123; Carriers, Itineraries, Legs, Segments &#125;) =&gt; &#123; const CarrierList = []; for (let i = 0; i &lt; Itineraries.length; i++) &#123; CarrierList.push(ticketLists(Itineraries[i])); &#125; function getUniqueObjectArray(array) &#123; return array.filter((item, i) =&gt; &#123; return ( array.findIndex((item2, j) =&gt; &#123; return item.CarrierId === item2.CarrierId; &#125;) === i ); &#125;); &#125; function predicate(key, value) &#123; // key와 value를 기억하는 클로저를 반환 return item =&gt; item[key] === value; &#125; function ticketLists(itinerary) &#123; const carrierPriceList = []; const &#123; PricingOptions, OutboundLegId, InboundLegId &#125; = itinerary; // get Outbound Leg let OutboundLeg; Legs.forEach(leg =&gt; &#123; if (leg.Directionality === 'Outbound' &amp;&amp; leg.Id === OutboundLegId) &#123; OutboundLeg = &#123; ...leg &#125;; &#125; &#125;); // get Outbound segments const OutboundSegments = []; OutboundLeg.SegmentIds.forEach(id =&gt; &#123; OutboundSegments.push(&#123; ...Segments[id] &#125;); &#125;); OutboundLeg.Segments = OutboundSegments; const ticket = &#123; PricingOptions, OutboundLeg, &#125;; // get Inbound Leg (왕복이라면) if (InboundLegId) &#123; let InboundLeg; Legs.forEach(leg =&gt; &#123; if (leg.Directionality === 'Inbound' &amp;&amp; leg.Id === InboundLegId) &#123; InboundLeg = &#123; ...leg &#125;; &#125; &#125;); const InboundSegments = []; InboundLeg.SegmentIds.forEach(id =&gt; &#123; InboundSegments.push(&#123; ...Segments[id] &#125;); &#125;); InboundLeg.Segments = InboundSegments; ticket.InboundLeg = InboundLeg; if ( ticket.InboundLeg.Carriers[0] === ticket.OutboundLeg.Carriers[0] ) &#123; carrierPriceList.push(&#123; Price: ticket.PricingOptions[0].Price, CarrierId: ticket.OutboundLeg.Carriers[0], &#125;); return carrierPriceList[0]; &#125; &#125; carrierPriceList.push(&#123; Price: ticket.PricingOptions[0].Price, CarrierId: ticket.OutboundLeg.Carriers[0], &#125;); return carrierPriceList[0]; &#125; function numberWithCommas(x) &#123; return x.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, ','); &#125; const _carriers = getUniqueObjectArray(CarrierList); function inspectChecked(Carrier) &#123; if (session.filterOption.excludeCarriers) &#123; return session.filterOption.excludeCarriers.includes(Carrier.Code) ? false : true; &#125; else &#123; return true; &#125; &#125; const carriers = Carriers.map(Carrier =&gt; (&#123; id: Carrier.Id, code: Carrier.Code, name: Carrier.Name, price: _carriers.findIndex(predicate('CarrierId', Carrier.Id)) !== -1 &amp;&amp; numberWithCommas( Math.floor( _carriers[_carriers.findIndex(predicate('CarrierId', Carrier.Id))] .Price, ), ), checked: inspectChecked(Carrier), &#125;)) .sort((a, b) =&gt; &#123; return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0; &#125;) .filter(carrier =&gt; carrier.price !== false); return carriers; &#125;, [session.filterOption.excludeCarriers], ); useEffect(() =&gt; &#123; setCarrierLists(getCarriers(session.allResult)); &#125;, [getCarriers, session.allResult]); const onChange = carrierList =&gt; &#123; if (carrierList.checked) &#123; // true -&gt; false 상황, setFilter(&#123; ...session.filterOption, excludeCarriers: session.filterOption.excludeCarriers ? `$&#123;session.filterOption.excludeCarriers&#125;;$&#123;carrierList.code&#125;` : `$&#123;carrierList.code&#125;`, &#125;); &#125; else &#123; // false -&gt; true 상황, const reg = new RegExp(carrierList.code, 'g'); const excludeCarrierList = session.filterOption.excludeCarriers .replace(reg, '') // 1. 해당 캐리어 코드를 exclude에서 제거한다. .replace(/[;]/g, '') // 2. 모든 특수문자를 제거한다. .replace(/(.&#123;2&#125;)/g, '$1;');//3.2글자단위로 세미콜론을 찍어준다. 단, 마지막에도 ';'가 포함됨. if (excludeCarrierList.length &lt;= 2) &#123; const &#123; excludeCarriers, ...filterOption &#125; = session.filterOption; setFilter(&#123; ...filterOption, &#125;); &#125; else &#123; setFilter(&#123; ...session.filterOption, excludeCarriers: excludeCarrierList.substr( 0, excludeCarrierList.length - 1, ), // 4. 마지막의 ';'을 제거 &#125;); &#125; &#125; &#125;; const switchDrop = () =&gt; &#123; setDrop(!drop); &#125;; const allSelect = () =&gt; &#123; const &#123; excludeCarriers, ...filterOption &#125; = session.filterOption; setFilter(&#123; ...filterOption, &#125;); &#125;; const allRemove = () =&gt; &#123; let allExcludeCarrier = ''; carrierLists.forEach( carrierList =&gt; (allExcludeCarrier = allExcludeCarrier + carrierList.code + ';'), ); setFilter(&#123; ...session.filterOption, excludeCarriers: allExcludeCarrier.substr( 0, allExcludeCarrier.length - 1, ), &#125;); &#125;; return ( ... &lt;FilterDropDiv drop=&#123;drop&#125; allView=&#123;true&#125;&gt; &lt;AllSelectOrRemoveDiv&gt; &lt;AllSelectBtn onClick=&#123;allSelect&#125; disabled=&#123; !carrierLists.some( carrierList =&gt; carrierList.checked !== true, ) &#125; &gt; 모두 선택 &lt;/AllSelectBtn&gt; | &lt;AllRemoveBtn onClick=&#123;allRemove&#125; disabled=&#123; !carrierLists.some( carrierList =&gt; carrierList.checked !== false, ) &#125; &gt; 모두 지우기 &lt;/AllRemoveBtn&gt; &lt;/AllSelectOrRemoveDiv&gt; &#123;carrierLists.map(carrierList =&gt; ( &lt;OptionHeader key=&#123;uuid.v4()&#125;&gt; &lt;StyleCheckBox onChange=&#123;() =&gt; onChange(carrierList)&#125; checked=&#123;carrierList.checked&#125; &gt; &#123;carrierList.name&#125; &lt;/StyleCheckBox&gt; &#123;console.log('test', carrierList.price)&#125; &lt;OptionContent&gt; &#123;`₩ $&#123;carrierList.price&#125;`&#125; &lt;/OptionContent&gt; &lt;/OptionHeader&gt; ))&#125; &lt;/FilterDropDiv&gt; ... );&#125;);const mapStateToProps = state =&gt; (&#123; session: state.session,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; setFilter: filterOption =&gt; &#123; dispatch(setFilterOption(filterOption)); dispatch(pollSession(true)); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(CarrierFilter);","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"SkyPrinter-ProgressBar","slug":"ProgressBar","date":"2020-03-13T04:16:06.000Z","updated":"2020-03-14T08:22:29.128Z","comments":true,"path":"2020/03/13/ProgressBar/","link":"","permalink":"https://hyeok999.github.io/2020/03/13/ProgressBar/","excerpt":"","text":"프로그레스 바 - 검색 진행 상황 알림 session의 상태를 UI로 표시 SkyPrinter 바로가기 목차 ProgressBar 구현 로직 ProgressBar 퍼블리싱 ProgressBar 구현 로직프로그레스바는 poll한 데이터에 담겨져있는 Agent객체에 UpdatesComplete가 전부 됬는지를 판단합니다. (Poll 자체가 아닌 Agent 객체의 상태 입니다.) Agent가 모두 UpdatesComplete상태라면 progressBar는 화면에서 제거 될 것이고, 아니라면 백분율 퍼센트로 계산하여 화면에 렌더링합니다. 프로그레스 퍼센트 비율을 Redux Store에 저장하여 어디서든 참조 가능하도록 합니다. 123456789101112// /src/redux/modules/session.jsconst &#123; Agents &#125; = data;const AllAgents = Agents.length;const PendingAgents = Agents.filter( Agent =&gt; Agent.Status === 'UpdatesComplete').length;const progressNum = (PendingAgents / AllAgents) * 100;yield put(&#123; type: SET_PROGRESS_RESULT, progress: Math.floor(progressNum)&#125;); ProgressBar 퍼블리싱123&lt;ProgressDiv&gt; &lt;Progress percent=&#123;session.progress&#125; showInfo=&#123;false&#125; /&gt; &lt;/ProgressDiv&gt; percent속성에 위 로직에서 계산한 퍼센트를 대입합니다. Progress 자체는 antd의 progress를 사용했기 때문에 실제 skyscanner처럼 보여지기 위해 커스텀 합니다. 1234567891011121314export const ProgressDiv = styled.div.attrs(&#123;&#125;)` position: absolute; top: 3rem; width: 680px; .ant-progress-inner &#123; background-color: rgb(215, 215, 225); &#125; .ant-progress-bg &#123; background-color: rgb(1, 102, 218); height: 6px !important; &#125;`;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"SkyPrinter-Error","slug":"SkyPrinter-Error","date":"2020-03-12T06:30:25.000Z","updated":"2020-03-13T12:36:26.408Z","comments":true,"path":"2020/03/12/SkyPrinter-Error/","link":"","permalink":"https://hyeok999.github.io/2020/03/12/SkyPrinter-Error/","excerpt":"","text":"ErrorBox 영역 유효성 검사 기능 SkyPrinter 바로가기 목차 ErrorBox 가 열리는 조건 출발지와 도착지가 같을 경우 &amp; 출발지와 도착지가 비워있을 경우 출발지 혹은 도착지에 국가단위의 나라명이 입력될 경우. 좌석 등급 및 승객에서 유소아의 나이를 미 입력할 경우 &amp; 성인수 보다 0~1살의 유소아가 더 많을 경우 재검색 시 의존성 검사 유효성 검사 구현 위치 SearchButton.jsx redux modules places.js passenger.js ErrorBox 가 열리는 조건 실제 스카이 스캐너측에서도 항공권 검색 버튼을 클릭할 경우 빨간색 ErrorBox가 생겼습니다. 그전에는 출발지와 도착지를 같게 고르던 좌석등급 및 승객을 마구잡이로 조작하던 전혀 문제가 없었습니다. 즉, 검색 버튼을 클릭함에 따라 유효성검사를 하여 에러유무를 판단하고 에러가 1개라도 있다면 ErrorBox가 열리게 됩니다. 조건은 다음과 같습니다. 1. 출발지와 도착지가 같을 경우 &amp; 출발지와 도착지가 비워있을 경우 2. 출발지 혹은 도착지에 국가단위의 나라명이 입력될 경우. (Browse Search를 구현한다면 제거해야함) 3. 좌석 등급 및 승객에서 유소아의 나이를 미 입력할 경우 &amp; 성인수 보다 0~1살의 유소아가 더 많을 경우 4. 재검색 시 의존성 검사 재검색할 때도 모든 에러를 표시할 수 있습니다. 유효성 검사 구현 위치 ​ 모든 유효성 검사는 항공권검색 버튼을 눌렀을 때, 즉,SearchButton 컴포넌트에서 1번, 각 redux module에서 1번 이렇게 총 2번을 검사합니다. 모든 에러는 Redux Store에 저장이 되고 2번 검사를 하는 이유는 Errorbox가 화면에 렌더링 후부터는 반응형으로 항공권검색을 누르지 않아도 에러에 해당되는 사항들을 해결할 수록 에러가 즉시 제거되기 때문입니다. 따라서 SearchButton 컴포넌트 redux module 에서 유효성 검사를 진행합니다. 첫 시작은 항상 SearchButton 컴포넌트 에서 이뤄어지고 여기서 유효성 검사를 통해 에러의 유무에 따라 Errorbox가 화면에 렌더링할 안할지 판단하며 에러가 존재한다면 session은 생성되지 않습니다. redux module 에서는 Errorbox 가 화면에 렌더링 되어있다면 에러에 대한 문제를 해결 즉시 에러가 필터링 되어 삭제되고 화면에 렌더링 됩니다. SearchButton.jsx 위치 : src/components/Main/SearchButton.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677...function SearchButton(&#123; children, allInfo, createSession, setError &#125;) &#123; // 에러 id를 순차적으로 증가해주는 함수 const generatedId = useCallback(errorLists =&gt; &#123; return Math.max(0, ...errorLists.map(errorList =&gt; errorList.id)) + 1; &#125;, []); // 세션 생성 함수 const create = () =&gt; &#123; const errorLists = []; // 유효성 검사 : 출발지 혹은 도착지가 비워있을 경우 if (!allInfo.places.inBoundId || !allInfo.places.outBoundId) &#123; errorLists.push(&#123; id: generatedId(errorLists), type: 'Incorrect places', message: '출발지 혹은 도착지를 입력해주세요.' &#125;); &#125; // 유효성 검사 : 출발지 혹은 도착지가 같을 경우 if (allInfo.places.inBoundId === allInfo.places.outBoundId) &#123; errorLists.push(&#123; id: generatedId(errorLists), type: 'PlaceId is same', message: '출발지와 도착지가 같으면 검색이 불가능합니다.' &#125;); &#125; // 유효성 검사 : 유/소아의 나이를 입력하지 않을 경우 if ( allInfo.passenger.children.filter(child =&gt; child.type === undefined) .length &gt;= 1 ) &#123; errorLists.push(&#123; id: generatedId(errorLists), type: 'Age not selected', message: '모든 유/소아의 나이를 입력해주세요.' &#125;); &#125; // 유효성 검사 : 0~1세의 유/소아의 수가 성인의 수 보다 많을 경우 if (allInfo.passenger.children.filter(child =&gt; child.age &lt; 2).length &gt;= 2) &#123; if ( allInfo.passenger.adults &lt; allInfo.passenger.children.filter(child =&gt; child.age &lt; 2).length ) &#123; errorLists.push(&#123; id: generatedId(errorLists), type: 'No matching adult', message: '성인 한 사람당 유/소아 1명(만 0 - 2세)만 허용됩니다.' &#125;); &#125; &#125; // 유효성 검사 : 출발지 혹은 도착지에 국가단위를 선택했을 경우 if ( allInfo.places.inBoundId.length === 2 || allInfo.places.outBoundId.length === 2 ) errorLists.push(&#123; id: generatedId(errorLists), type: 'No Country', message: '실시간 항공권 검색은 도시 단위까지만 가능합니다.' &#125;); &#125; if (errorLists.length &gt;= 1) &#123; setError(errorLists); &#125; else &#123; clearError(); createSession(allInfo); &#125; &#125;; return &lt;button onClick=&#123;create&#125;&gt;&#123;children&#125;&lt;/button&gt;;&#125;.... redux modules SearchButton.jsx에서 유효성 검사를 통해 에러가 발생이 되었다면 Redux Store의 에러 객체가 존재 할 것입니다. 에러가 존재한다면 화면에 errorbox가 렌더링 되었을 것이고 각 리덕스 모듈(places, passenger)에서는 Redux Store의 에러가 존재하므로 재차 유효성검사를 하여 문제가 해결될 시 비동기적으로 Redux Store의 에러를 필터할 것입니다. 따라서 Redux Saga를 이용해 미들웨어로 처리하여 UI의 상태를 반응형으로 처리하도록 설계하였습니다. places.js 위치 : src/redux/modules/places.js 1234567891011121314151617181920212223242526272829303132333435363738...export function* fetchPlaces(action) &#123; const error = yield select(state =&gt; state.error); try &#123; yield put(&#123; type: FETCH_PLACE, places: action.places &#125;); if (error.errorOccurred) &#123; const places = yield select(state =&gt; state.places); let newErrors = error.errors; // 리덕스 스토어에 에러가 존재할 경우 if (newErrors !== null) &#123; // 유효성 검사 : 출발지 혹은 도착지가 비워있을 경우 if (places.inBoundId &amp;&amp; places.outBoundId) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'Incorrect places'); &#125; // 유효성 검사 : 출발지 혹은 도착지가 같을 경우 if (places.inBoundId !== places.outBoundId) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'PlaceId is same'); &#125; // 유효성 검사 : 출발지 혹은 도착지에 국가단위를 선택했을 경우 if (places.inBoundId.length !== 2 &amp;&amp; places.outBoundId.length !== 2) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'No Country'); &#125; newErrors.length === 0 || newErrors === null ? yield put(&#123; type: SET_ERROR, errors: null &#125;) : yield put(&#123; type: SET_ERROR, errors: newErrors &#125;); &#125; &#125; &#125; catch (error) &#123; console.log(error); &#125;&#125;... passenger.js 위치 : src/redux/modules/passenger.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869...export function* fetchChildAge(action) &#123; try &#123; yield put(&#123; type: FETCH_CHILD_AGE, id: action.id, age: action.age &#125;); const error = yield select(state =&gt; state.error); if (error.errorOccurred) &#123; const passengerInfo = yield select(state =&gt; state.passenger); let newErrors = error.errors; if (newErrors !== null) &#123; // 유효성 검사 : 0~1세의 유/소아의 수가 성인의 수 보다 많을 경우 if ( passengerInfo.children.filter(child =&gt; child.type === undefined) .length === 0 ) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'Age not selected'); &#125; // 유효성 검사 : 유/소아의 나이를 입력하지 않을 경우 if ( passengerInfo.adults &gt;= passengerInfo.children.filter(child =&gt; child.age &lt; 2).length ) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'No matching adult'); &#125; newErrors.length === 0 || newErrors === null ? yield put(&#123; type: SET_ERROR, errors: null &#125;) : yield put(&#123; type: SET_ERROR, errors: newErrors &#125;); &#125; &#125; &#125; catch (error) &#123; console.log(error); &#125;&#125;export function* fetchChildren(action) &#123; try &#123; yield put(&#123; type: FETCH_CHILDREN, mode: action.mode &#125;); const error = yield select(state =&gt; state.error); // 유효성 검사 : 유/소아의 나이를 입력하지 않을 경우, 유소아 탭에서 입력하지않고 그냥 탭을 닫아버릴 경우 if (error.errorOccurred) &#123; const passengerInfo = yield select(state =&gt; state.passenger); let newErrors = error.errors; if ( passengerInfo.children.filter(child =&gt; child.type === undefined) .length === 0 ) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'Age not selected'); &#125; else if (passengerInfo.children.length === 0) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'Age not selected'); &#125; newErrors.length === 0 || newErrors === null ? yield put(&#123; type: SET_ERROR, errors: null &#125;) : yield put(&#123; type: SET_ERROR, errors: newErrors &#125;); &#125; &#125; catch (error) &#123; console.log(error); &#125;&#125;...","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"SkyPrinter - Search -","slug":"SkyPrinter-Search","date":"2020-03-12T05:23:41.000Z","updated":"2020-03-13T12:27:44.025Z","comments":true,"path":"2020/03/12/SkyPrinter-Search/","link":"","permalink":"https://hyeok999.github.io/2020/03/12/SkyPrinter-Search/","excerpt":"","text":"SearchBox 항공권(국가, 도시, 지역) 검색영역 SkyPrinter 검색 영역 SkyPrinter 바로가기 목차 SearchBox 폴더구조 Search API 알아보기 - List Places - Redux Module 파악하기 places module PlacesContainer SearchBox 컴포넌트 파악하기 상태 정리 결과 검색 리스트 불러오기 및 하이라이팅 처리 국가, 도시, 공항 기준 이미지 및 CSS 적용하기 SearchBox 폴더 구조 index.jsx BoundSearchBox.jsx RenderPlaceList.jsx ParseWord.jsx BoundChangeBox.jsx CheckBox.jsx Search API 알아보기 - List Places -사용자 입력한 검색어를 통해 API를 호출하여 출발지와 도착지의 리스트를 보여줍니다. country : 국가language: 언어area : 입력한 장소isDestination : 출발지 도착지 여부 12345678910111213141516import axios from 'axios';const SELECT_AREA_API_URL = 'https://www.skyscanner.co.kr/g/autosuggest-flights';export default class SearchService &#123; static async SelectArea(country, language, area, isDestination) &#123; return await axios.get( `$&#123;SELECT_AREA_API_URL&#125;/$&#123;country&#125;/$&#123;language&#125;/$&#123;area&#125;`, &#123; isDestination: isDestination, // 출발지 도착지 여부 enable_general_search_v2: true, &#125;, ); &#125;&#125; Redux Module 파악하기 비동기 처리(유효성 검사)가 필요한 부분은 미들웨어(Redux Saga)로 처리를 하였습니다. places module 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// src/redux/modules/places.jsximport &#123; takeEvery, put, select &#125; from 'redux-saga/effects';import &#123; SET_ERROR &#125; from './error';// ACTIONSexport const SET_PLACE = 'skyprinter/places/SET_PLACE';export const FETCH_PLACE = 'skyprinter/places/FETCH_PLACE';export const SWITCH_PLACES = 'skyprinter/places/SWITCH_PLACES';export const INITIALIZE_PLACES = 'skyprinter/places/INITIALIZE_PLACES';// ACTION CREATORSexport const initializePlaces = () =&gt; (&#123; type: INITIALIZE_PLACES&#125;);export const setPlace = places =&gt; (&#123; type: SET_PLACE, places &#125;);export const switchPlaces = () =&gt; (&#123; type: SWITCH_PLACES &#125;);export function* fetchPlaces(action) &#123; const error = yield select(state =&gt; state.error); try &#123; yield put(&#123; type: FETCH_PLACE, places: action.places &#125;); // 유효성 검사 if (error.errorOccurred) &#123; const places = yield select(state =&gt; state.places); let newErrors = error.errors; if (newErrors !== null) &#123; if (places.inBoundId &amp;&amp; places.outBoundId) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'Incorrect places'); &#125; if (places.inBoundId !== places.outBoundId) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'PlaceId is same'); &#125; if (places.inBoundId.length !== 2 &amp;&amp; places.outBoundId.length !== 2) &#123; newErrors = newErrors.filter(e =&gt; e.type !== 'No Country'); &#125; newErrors.length === 0 || newErrors === null ? yield put(&#123; type: SET_ERROR, errors: null &#125;) : yield put(&#123; type: SET_ERROR, errors: newErrors &#125;); &#125; &#125; &#125; catch (error) &#123; console.log(error); &#125;&#125;// ROOT SAGAexport function* placesSaga() &#123; yield takeEvery(SET_PLACE, fetchPlaces);&#125;// INIITIAL STATEconst initialState = &#123; inBoundId: '', inBoundName: '', outBoundId: '', outBoundName: ''&#125;;// REDUCERexport default function places(state = initialState, action) &#123; switch (action.type) &#123; case INITIALIZE_PLACES: return initialState; case FETCH_PLACE: const &#123; places &#125; = action; if (places.type === 'inBound') &#123; return &#123; inBoundId: places.PlaceId, inBoundName: places.PlaceName, outBoundId: state.outBoundId, outBoundName: state.outBoundName &#125;; &#125; else &#123; return &#123; inBoundId: state.inBoundId, inBoundName: state.inBoundName, outBoundId: places.PlaceId, outBoundName: places.PlaceName &#125;; &#125; case SWITCH_PLACES: return &#123; inBoundId: state.outBoundId, inBoundName: state.outBoundName, outBoundId: state.inBoundId, outBoundName: state.inBoundName &#125;; default: return state; &#125;&#125; PlacesContainer 컨테이너를 두어 리덕스의 상태와 액션들을 실제로 사용할 컴포넌트에게 전달해줍니다. 12345678910111213141516171819202122// src/containers/PlacesContainer.jsximport &#123; connect &#125; from 'react-redux';import &#123; switchPlaces, setPlace &#125; from '../redux/modules/places';import SearchBox from '../components/Main/SearchBox';const mapStateToProps = state =&gt; &#123; return &#123; places: state.places, &#125;;&#125;;const mapDispatchToProps = dispatch =&gt; (&#123; setPlace: places =&gt; &#123; dispatch(setPlace(places)); &#125;, switchPlaces: () =&gt; &#123; dispatch(switchPlaces()); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(SearchBox); SearchBox 컴포넌트 파악하기 index.jsx BoundSearchBox.jsx - 출발지 RenderPlaceList.jsx ParsePlaceList.jsx BoundChangeBox.jsx BoundSearchBox.jsx - 도착지 (출발지와 동일) RenderPlaceList.jsx ParseWord.jsx CheckBox.jsx 상태 정리 index.jsx 선언한 상태 ➤ bound → BoundSearchBox.jsx 초기값 : 리덕스에는 Name, Id를 모두 저장합니다. Name만 지역 상태로 만든 이유는 switch한 결과를 props를 통해 내려주고 BoundSearchBox에서 라이브러리가 확인할 수 있게 하기 위함입니다. 1234const [bound, setBound] = useState(&#123; inBoundName: places.inBoundName, outBoundName: places.outBoundName,&#125;); 상태 변경 함수 : selectBound → BoundSearchBox.jsx 123const selectBound = (PlaceId, PlaceName, type) =&gt; &#123; setPlace(&#123; PlaceId, PlaceName, type &#125;); // 컨테이너에서 전달받은 액션 &#125;; 상태 변경 함수 : changeBound → BoundChangeBox.jsx 1234567const changeBound = () =&gt; &#123; setBound(&#123; // 컨테이너에서 전달받은 액션 inBoundName: places.outBoundName, outBoundName: places.inBoundName, &#125;); switchPlaces(); // boundName을 서로 교환해줍니다.&#125;; BoundSearchBox (출발지/도착지) 선언한 상태 ➤ suggestions → RenderPlaceList.jsx 초기값 1[] 상태 변경 함수 : searchPlace → BoundSearchBox.jsx 12345678910111213const searchPlace = async value =&gt; &#123; try &#123; const &#123; data &#125; = await SearchService.SelectArea( 'KR', 'ko-KR', value, isDestination, ); setSuggestions(data); &#125; catch (e) &#123; console.error(e); &#125;&#125;; 물려받은 상태 및 물려받은 상태 변경 함수 ➤ index.jsx : bound , Fn: selectBound 사용 서비스 ➤ SearchService 사용 라이브러리 ➤ AutoSuggest 키보드 접근성 엔터키 추가하기 12345678910const pressEnter = (e, type) =&gt; &#123; if (e.keyCode === 13 &amp;&amp; e.target.nodeName === 'INPUT') &#123; const form = e.target.form; const index = Array.prototype.indexOf.call(form, e.target); type === 'inBound' ? form.elements[index + 3].focus() : form.elements[index + 2].focus(); e.preventDefault(); &#125;&#125;; RenderPlaceList 선언한 상태 없음 물려받은 상태 및 물려받은 상태 변경 함수 ➤ BoundSearchBox.jsx : suggestions 사용 라이브러리 ➤ dompurify : 검색어 하이라이팅을 적용하기 위해서 사용하였습니다. 처음에는 for문을 반복해서 하이라이팅의 배열에 적혀있는 문자열을 파싱해오고 그 결과를 따로 저장해서 화면에 뿌려주는 방식을 채택했으나 비정상적으로 많은 반복문을 돌게 되면서 프로그램의 성능저하가 우려되 dompurify를 이용하여 innerHTML을 채택하는 방식을 사용했습니다. XSS스크립트 공격을 방지하면서 dangerouslySetInnerHTML 속성을 이용할 수 있습니다. 12345678const sanitizer = dompurify.sanitize;const Result = ParsePlaceList(place, suggestion);...&lt;span dangerouslySetInnerHTML=&#123;&#123; __html: sanitizer(Result.CountryName), &#125;&#125;/&gt; ParsePlaceList.jsx RenderPlaceList에서 가져온 장소명을 하이라이팅 처리해주는 함수입니다 하이라이팅 처리가된 배열에게 &lt;strong&gt;&lt;/strong&gt; 태그를 앞 뒤로 삽입합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const ParsePlaceList = (place, suggestion) =&gt; &#123; const Result = &#123;&#125;; const insertTag = (highlightings, str) =&gt; &#123; const starts = []; const ends = []; highlightings.forEach(highlighting =&gt; &#123; starts.push(highlighting[0]); ends.push(highlighting[1]); &#125;); return str .split('') .map((chr, pos) =&gt; &#123; if (starts.indexOf(pos) !== -1) chr = '&lt;strong&gt;' + chr; if (ends.indexOf(pos) !== -1) chr = '&lt;/strong&gt;' + chr; return chr; &#125;) .join(''); &#125;; const WordArray = insertTag( suggestion.Highlighting, suggestion.ResultingPhrase, ); if (place === 'Country') &#123; Result.CountryName = WordArray.split('|'); &#125; else &#123; const ResultingArray = WordArray.split('|'); Result.PlaceName = ResultingArray[0].includes(',') ? ResultingArray[0].split(',')[0].split('(')[0] : ResultingArray[0]; Result.CountryName = ResultingArray[ResultingArray.length - 1]; &#125; return Result;&#125;;export default ParsePlaceList;const ParsePlaceList = (place, suggestion) =&gt; &#123; const Result = &#123;&#125;; const insertTag = (highlightings, str) =&gt; &#123; const starts = []; const ends = []; highlightings.forEach(highlighting =&gt; &#123; starts.push(highlighting[0]); ends.push(highlighting[1]); &#125;); return str .split('') .map((chr, pos) =&gt; &#123; if (starts.indexOf(pos) !== -1) chr = '&lt;strong&gt;' + chr; if (ends.indexOf(pos) !== -1) chr = '&lt;/strong&gt;' + chr; return chr; &#125;) .join(''); &#125;; const WordArray = insertTag( suggestion.Highlighting, suggestion.ResultingPhrase, ); if (place === 'Country') &#123; Result.CountryName = WordArray.split('|'); &#125; else &#123; const ResultingArray = WordArray.split('|'); Result.PlaceName = ResultingArray[0].includes(',') ? ResultingArray[0].split(',')[0].split('(')[0] : ResultingArray[0]; Result.CountryName = ResultingArray[ResultingArray.length - 1]; &#125; return Result;&#125;;export default ParsePlaceList; BoundChangeBox.jsx 선언한 상태 없음 물려받은 상태 및 물려받은 상태 변경 함수 ➤ index.jsx : Fn: changeBound 123456789const changeBound = () =&gt; &#123; if (!(bound.inBoundName || bound.outBoundName)) return;\\ setBound(&#123; inBoundId: bound.outBoundId, outBoundId: bound.inBoundId, inBoundName: bound.outBoundName, outBoundName: bound.inBoundName, &#125;);&#125;; 결과 검색 리스트 불러오기 및 하이라이팅 처리 입력한 내용에 따라 자동으로 리스트를 불러오기 입력한 내용에 맞춰 글자가 굵어지는 하이라이팅 처리 키보드 접근성 준수(화살표 방향키, Tab키, 엔터키) 국가, 도시, 공항 기준 이미지 및 CSS 적용하기 국가는 깃발모양, 도시는 건물모양, 공항역은 비행기모양의 svg 이미지가 각각 렌더링 됩니다. 12345678910111213// src/components/Main/SearchBox/BoundSearchBox.jsx// 도시 예...const CityName = useRef(null);...return ( &lt;RenderPlaceList place=\"AirStation\" suggestion=&#123;suggestion&#125; hasCity=&#123;suggestion.CityId === CityName.current&#125; /&gt;);... 1234567891011121314151617181920212223242526// src/components/Main/SearchBox/RenderPlaceList.jsx switch (place) &#123; case 'Country': &#123; return ( &lt;ListSection&gt; ... &lt;/ListSection&gt; ); &#125; case 'City': &#123; return ( &lt;ListSection&gt; ... &lt;/ListSection&gt; ); &#125; default: &#123; // AirPort return ( &lt;ListSection hasCity=&#123;hasCity&#125;&gt; ... &lt;/ListSection&gt; ); &#125; &#125;&#125;);","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Sky Printer","slug":"SkyPrinter-main","date":"2020-03-12T02:15:23.000Z","updated":"2020-04-02T14:23:27.461Z","comments":true,"path":"2020/03/12/SkyPrinter-main/","link":"","permalink":"https://hyeok999.github.io/2020/03/12/SkyPrinter-main/","excerpt":"","text":"Sky PrinterSky Scanner 클론 1. 팀 소개 팀명 : Skyprinter 팀원 : 김진현, 김재헌, 김준혁, 2. 팀 주제 Sky Scanner 메인페이지 및 검색 결과 페이지 클론 3. 주제 선정 이유 Front : Sky Scanner 페이지 자체가 React로 구성되어 있고 적은 페이지에 선택한 조건에 따른 상호작용성이 높고, 반응형 페이지이기 때문에 HTML, CSS 적인 관점도 중요하지만 JavaScript, React등의 개발적인 요소를 활용하기에 매우 적합하다고 생각되었습니다. Back : 현재 프로젝트를 진행함에 있어 팀원들이 Front-End 개발을 지향하고 있기 때문에 Back-End를 동시에 공부하기에는 어려울것 같다는 생각이 들었습니다. 따라서 공개 API를 이용하여 Back-End를 구축할 시간을 최대한 적게 줄이고자 하였습니다. Sky Scanner Api의 항공권에 대한 내용은 개발 학습에 있어 복잡성이 뛰어나고 요청 또한 무제한이기 때문에 결정하게 되었습니다. 4. 프로젝트 요구 사항 W3C에서 제공한 MarkUp Validation Service 에서 이상이 없을 것. 최대한 시멘틱 하게 작성. 여러 라이브러리 경험. Git flow를 사용하여 협업을 할 것. Git Convention을 최대한 지킬 것. SkyPrinter API 사용. 리액트 컴포넌트 간의 최적화. 5. MVP 실시간 항공권 검색 기능 항공권 필터 기능 URL 공유 기능 실제 티켓 구매 리다이렉트 6. API 및 문서 정리 RapidAPISkyscanner-API-Documentation Mainpage-Documentation &amp; Use cases SearchBox ErrorBox CreateSession ProgressBar FilterArea 7. Flow Chart 8. Wire Frame 9. 구현 일정2020년 2월 1일 ~ 2020년 2월 28일 + 2020년 2월 29일 ~ 2020년 3월 6일 : 추가작업 - URL Selec, Bug fix 등등 10. 프로젝트 구현 영상 맡은 구현 목록 김준혁 메인 페이지 전체적인 레이아웃 및 퍼블리싱 검색 영역 및 재검색 영역 퍼블리싱 및 기능 구현(재검색 기능 포함) (SearchBox 참조) 검색 영역 페이지 에러 박스 퍼블리싱 및 검색에 대한 유효성 검사 기능 구현 (ErrorBox 참조) session 생성 기능, URL 공유 기능 (CreateSession, FilterArea 참조) 프로그레스바 퍼블리싱 및 기능 구현 (ProgressBar, FilterArea 참조) 티켓 검색 결과 페이지 필터 영역 퍼블리싱 및 기능 구현 (FilterArea 참조) 느낀점 실제로 사용되는 API 답게 복잡성이 높은 것을 느꼈습니다. 사전조사(API, 실제 운영사이트의 퍼블리싱 및 기능)의 중요성을 크게 깨닫게 되었습니다. 사전조사 때는 구현방법이 전혀 생각이 안났지만 구현 해보면서 “어떻게 구현하지? “라는 의문점이 풀리기도 하였습니다. 검색 영역을 개발하면서 사용자의 경험(키보드접근성)이나 속도 측면을 크게 고려하면서, 개발도 중요하지만 최적화도 얼마나 중요한지 깨닫게 되었습니다. 변수, 함수 등등 모든 네이밍을 지을 때 생각하는 어려움이 있었습니다. 이유는 팀원은 3명이고 각자 이름짓는 컨벤션이 달랐기 때문이다. 위와 같은 이유로 개발 직전에 초기셋팅을 확실히 해두어야함을 느꼈습니다.(깃 컨벤션, 폴더구조 셋팅, 네이밍 컨벤션) 일정 조율을 확실히 하여 시간을 나누는 것에 대한 필요성을 느꼈습니다. 재사용성을 고려한 함수를 많이 만들어둘 경우 차후 개발이 훨씬 편리해짐을 크게 깨닫게 되었습니다. Redux Saga를 통한 비동기 처리에 대한 편리함을 크게 깨달았습니다. HOC를 통해 컴포넌트에 조건을 주어 내려줄 prop등을 결정하는 방법을 알게 되었습니다. React에 대해 자신감이 생겼습니다. React를 이용하여 반응형 페이지를 구축하는 방법을 알게되었습니다. React.memo 또는 useCallback을 이용한 최적화 방법을 알게되었습니다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Books Review - 프로젝트 마무리 -","slug":"books-review06","date":"2020-03-11T11:00:16.000Z","updated":"2020-03-12T11:04:52.898Z","comments":true,"path":"2020/03/11/books-review06/","link":"","permalink":"https://hyeok999.github.io/2020/03/11/books-review06/","excerpt":"","text":"개발 서적 평가 서비스- 프로젝트 마무리 -목차 새로고침되는 것처럼 보이는 에러 해결하기 Edit Saga 추가하기 Edit Book Container 추가하기 Get Book Modal Component 추가하기 thunk 코드 삭제하기 페이지네이션 추가하기 라이브러리 인스톨하기 Head Component 추가하기 Home에 Head 추가하기 새로고침되는 것처럼 보이는 에러 해결하기 문제 : 서적 추가했을 경우, 새로고침되듯 화면이 깜박이면서 렌더링 원인 : PENDING 상태일 때, books 스토어가 일시적으로 빈배열([])로 초기화됨. 해결 ▿ 12345678910111213141516171819202122232425// src/redux/modules/books.jsconst books = handleActions( &#123; // PENDING: (state, action) =&gt; (&#123; books: [], loading: true, error: null &#125;), PENDING: (state, action) =&gt; (&#123; books: state.books ? state.books : [], loading: true, error: null, &#125;), SUCCESS: (state, action) =&gt; (&#123; books: action.payload.books, loading: false, error: null, &#125;), FAIL: (state, action) =&gt; (&#123; books: [], loading: false, error: action.payload, &#125;), &#125;, initialState, options,);export default books; Edit Saga 추가하기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// src/redux/modules/books.jsexport const editBookSaga = createAction('EDIT_BOOK_SAGA');...function* editBook(books) &#123; const token = yield select(state =&gt; state.auth.token); try &#123; yield put(pending()); const res = yield call( BookService.editBook, token, books.payload.bookId, books.payload.book, ); console.log('aaa는용: ', res); // dispatch(setBooks(books.filter(book =&gt; book.bookId !== bookId))); yield put( success( books.payload.books.map(book =&gt; book.bookId === books.payload.bookId ? &#123; ...books.payload.book, &#125; : book, ), ), ); &#125; catch (error) &#123; yield put(fail(error)); &#125;&#125;const initialState = &#123; books: [], books: null, loading: false, error: null,&#125;;const books = handleActions( &#123; PENDING: (state, action) =&gt; (&#123; books: state.books ? state.books : [], ...state, loading: true, error: null, &#125;), SUCCESS: (state, action) =&gt; (&#123; books: action.payload.books, loading: false, error: null, &#125;), FAIL: (state, action) =&gt; (&#123; books: [], ...state, loading: false, error: action.payload, &#125;), &#125;, initialState, options,);export default books; Edit Book Container 추가하기 12345678910111213141516// src/containers/EditBookContainer.jsximport &#123; connect &#125; from 'react-redux';import &#123; editBookSaga &#125; from '../redux/modules/books';import EditBookModal from '../components/Home/EditBookModal';const mapStateToProps = state =&gt; (&#123; books: state.books.books,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; editBook: (books, bookId, book) =&gt; &#123; dispatch(editBookSaga(&#123; books, bookId, book &#125;)); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(EditBookModal); Edit Book Modal Component 추가하기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// src/components/Home/EditBookModal.jsximport React from 'react';import &#123; Button, Modal &#125; from 'antd';import InputBookInfo from './InputBookInfo';const EditBookModal = (&#123; visible, handleOk, handleCancel, books, book, editBook,&#125;) =&gt; &#123; const titleRef = React.createRef(); const messageRef = React.createRef(); const authorRef = React.createRef(); const urlRef = React.createRef(); const initValue = () =&gt; &#123; titleRef.current.state.value = ''; messageRef.current.state.value = ''; authorRef.current.state.value = ''; urlRef.current.state.value = ''; &#125;; const clickBtn = () =&gt; &#123; const bookRef = &#123; title: titleRef.current.state.value, message: messageRef.current.state.value, author: authorRef.current.state.value, url: urlRef.current.state.value, &#125;; function edit(bookRef) &#123; editBook(books, book.bookId, &#123; title: bookRef.title, message: bookRef.message, author: bookRef.author, url: bookRef.url, &#125;); &#125; edit(bookRef); initValue(); handleCancel(); &#125;; const cancelBtn = () =&gt; &#123; initValue(); handleCancel(); &#125;; return ( &lt;Modal title=\"Edit Book\" visible=&#123;visible&#125; onOk=&#123;handleOk&#125; onCancel=&#123;cancelBtn&#125; footer=&#123;[ &lt;Button key=\"back\" onClick=&#123;cancelBtn&#125;&gt; Cancel &lt;/Button&gt;, &lt;Button key=\"submit\" type=\"primary\" onClick=&#123;clickBtn&#125;&gt; Edit &lt;/Button&gt;, ]&#125; &gt; &lt;InputBookInfo info=\"Title\" reference=&#123;titleRef&#125; value=&#123;book.title&#125; /&gt; &lt;InputBookInfo info=\"Message\" reference=&#123;messageRef&#125; value=&#123;book.message&#125; /&gt; &lt;InputBookInfo info=\"Author\" reference=&#123;authorRef&#125; value=&#123;book.author&#125; /&gt; &lt;InputBookInfo info=\"URL\" reference=&#123;urlRef&#125; value=&#123;book.url&#125; /&gt; &lt;/Modal&gt; );&#125;;export default EditBookModal; Get Book Modal Component 추가하기 단일 조회는 따로 서비스를 이용하지않고 자체 필터를 이용해서 보여준다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from 'react';import &#123; Button, Modal &#125; from 'antd';import styled from 'styled-components';const GetBookModal = (&#123; visible, handleOk, handleCancel, book &#125;) =&gt; &#123; const clickBtn = () =&gt; &#123; handleCancel(); &#125;; const cancelBtn = () =&gt; &#123; handleCancel(); &#125;; const StyledAuthor = styled.p` font-style: italic; position: absolute; top: 16px; right: 60px; color: rgba(0, 0, 0, 0.3); `; const StyledMessage = styled.p` font-size: 15px; `; const StyledUrl = styled.a.attrs((&#123; url &#125;) =&gt; (&#123; target: '_blank', rel: 'noopener noreferrer', href: 'https://' + url, &#125;))` color: #1890ff; font-size: 12px; `; return ( &lt;Modal title=&#123;book.title&#125; visible=&#123;visible&#125; onOk=&#123;handleOk&#125; onCancel=&#123;cancelBtn&#125; footer=&#123;[ &lt;Button key=\"submit\" type=\"primary\" onClick=&#123;clickBtn&#125;&gt; Ok &lt;/Button&gt;, ]&#125; &gt; &lt;StyledAuthor&gt;&#123;book.author&#125;&lt;/StyledAuthor&gt; &lt;StyledMessage&gt;&#123;book.message&#125;&lt;/StyledMessage&gt; &lt;StyledUrl url=&#123;book.url&#125;&gt;&#123;book.url&#125;&lt;/StyledUrl&gt; &lt;/Modal&gt; );&#125;;export default GetBookModal; thunk 코드 삭제하기 1234567891011121314151617181920212223242526272829303132import &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './modules/reducer';// import thunk from 'redux-thunk';import &#123; composeWithDevTools &#125; from 'redux-devtools-extension';import &#123; createBrowserHistory &#125; from 'history';import &#123; routerMiddleware &#125; from 'connected-react-router';import createSagaMiddleware from 'redux-saga'; // 1. importimport rootSaga from './modules/saga';export const history = createBrowserHistory();const sagaMiddleware = createSagaMiddleware(); // 2. saga 미들웨어 생성const create = () =&gt; &#123; const token = localStorage.getItem('token'); const store = createStore( reducer(history), &#123; auth: &#123; token, loading: false, error: null, &#125;, &#125;, composeWithDevTools( // applyMiddleware(thunk, routerMiddleware(history), sagaMiddleware), applyMiddleware(routerMiddleware(history), sagaMiddleware), ), ); sagaMiddleware.run(rootSaga); return store;&#125;;// 지연 초기화 방식 : 함수 실행 시점을 직접 결정하기 위해서 사용한다.export default create; 페이지네이션 추가하기 antd의 Table컴포넌트를 이용하여 페이지네이션을 추가한다. setEditVisible , setGetVisible도 동시에 추가한다. setEditVisible : 수정 Modal을 보여주는 상태를 관리해주는 useSetState setGetVisible : 단일 Modal을 보여주는 상태를 관리해주는 useSetState 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// src/components/Home/ContentUI.jsximport &#123; Spin, Table &#125; from 'antd';import GetBookModal from './GetBookModal'; ... const [editVisible, setEditVisible] = useState(false); const [getVisible, setGetVisible] = useState(false); const [book, setBook] = useState(&#123;&#125;); const showEditModal = book =&gt; &#123; setEditVisible(true); setBook(book); &#125;; const showGetModal = book =&gt; &#123; setGetVisible(true); setBook(book); &#125;; const handleOk = e =&gt; &#123; setEditVisible(false); &#125;; const handleCancel = e =&gt; &#123; setEditVisible(false); &#125;; const handleOk2 = e =&gt; &#123; setGetVisible(false); &#125;; const handleCancel2 = e =&gt; &#123; setGetVisible(false); &#125;;... return ( &lt;StyledContent&gt; &#123;loading &amp;&amp; &lt;StyledSpin size=\"large\" /&gt;&#125; &lt;Table dataSource=&#123;books === null ? [] : books&#125; columns=&#123;[ &#123; title: 'Book', dataIndex: 'book', key: 'book', render: (text, record) =&gt; ( &lt;div className=\"list\" key=&#123;uuid.v4()&#125;&gt; &lt;div className=\"Read\"&gt; &lt;Icon type=\"read\" /&gt; &lt;/div&gt; &lt;StyledTitleh3&gt;&#123;record.title&#125;&lt;/StyledTitleh3&gt; &lt;StyledContentP&gt; &lt;span&gt;&#123;record.author&#125;&lt;/span&gt; &lt;span&gt;&#123;record.message&#125;&lt;/span&gt; &lt;span&gt;&#123;record.url&#125;&lt;/span&gt; &lt;/StyledContentP&gt; &lt;StyledSearchButton onClick=&#123;() =&gt; showGetModal(record)&#125;&gt; &lt;Icon type=\"search\" /&gt; &lt;/StyledSearchButton&gt; &lt;StyledEditButton onClick=&#123;() =&gt; showEditModal(record)&#125;&gt; &lt;Icon type=\"edit\" /&gt; &lt;/StyledEditButton&gt; &lt;StyledDeleteButton onClick=&#123;() =&gt; deleteBook(books, record.bookId)&#125; &gt; &lt;Icon type=\"delete\" /&gt; &lt;/StyledDeleteButton&gt; &lt;/div&gt; ), &#125;, ]&#125; loading=&#123;false&#125; showHeader=&#123;false&#125; pagination=&#123;&#123; size: 'small', pageSize: 10, align: 'center', &#125;&#125; bodyStyle=&#123;&#123; borderTop: '1px solid #e8e8e8', &#125;&#125; style=&#123;&#123; marginTop: 30, &#125;&#125; rowKey=\"bookId\" /&gt; &lt;EditBookContainer book=&#123;book&#125; visible=&#123;editVisible&#125; handleOk=&#123;handleOk&#125; handleCancel=&#123;handleCancel&#125; /&gt; &lt;GetBookModal book=&#123;book&#125; visible=&#123;getVisible&#125; handleOk=&#123;handleOk2&#125; handleCancel=&#123;handleCancel2&#125; /&gt; &lt;/StyledContent&gt; );&#125;; 라이브러리 인스톨하기 react-helmet 1npm i react-helmet Head Component 추가하기 123456789101112131415161718192021222324252627// src/components/Head.jsximport React from 'react';import &#123; Helmet &#125; from 'react-helmet';// default document 정보const Head = () =&gt; ( &lt;Helmet&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt; &lt;meta charSet=\"utf-8\" /&gt; &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"/static/favicon.ico\" /&gt; &lt;title&gt;Hyeok999's Books Review&lt;/title&gt; &lt;meta name=\"description\" content=\"description\" /&gt; &lt;meta name=\"keyword\" content=\"marktube\" /&gt; &lt;meta property=\"og:url\" content=\"https://\" /&gt; &lt;meta property=\"og:title\" content=\"title\" /&gt; &lt;meta property=\"og:type\" content=\"website\" /&gt; &lt;meta property=\"og:description\" content=\"description\" /&gt; &lt;meta property=\"og:image\" content=\"\" /&gt; &lt;meta property=\"og:image:width\" content=\"600\" /&gt; &lt;meta property=\"og:image:height\" content=\"315\" /&gt; &lt;/Helmet&gt;);export default Head; Home에 Head 추가하기 12345678910111213141516171819202122232425262728293031323334// src/pages/Home.jsximport HeaderContainer from '../containers/HeaderContainer';import BooksContainer from '../containers/BooksContainer';import AddBookContainer from '../containers/AddBookContainer';import Head from '../components/Head';const &#123; SubMenu &#125; = Menu;const &#123; Sider &#125; = Layout;const StyledSideMenu = styled(Menu).attrs(() =&gt; (&#123; mode: 'inline', defaultSelectedKeys: ['1'], defaultOpenKeys: ['sub1'],&#125;))` height: 100%; border-right: 0;`;const Home = () =&gt; &#123; const [visible, setVisible] = useState(false); const showModal = () =&gt; &#123; setVisible(true); &#125;; const handleOk = e =&gt; &#123; setVisible(false); &#125;; const handleCancel = e =&gt; &#123; setVisible(false); &#125;; return ( &lt;Layout&gt; &lt;Head /&gt; &#123;/* 추가 */&#125; &lt;HeaderContainer /&gt; &lt;Layout&gt; ... View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Books Review - 미들웨어 추가 Redux Saga -","slug":"books-review05","date":"2020-03-11T09:42:17.000Z","updated":"2020-03-12T10:57:34.378Z","comments":true,"path":"2020/03/11/books-review05/","link":"","permalink":"https://hyeok999.github.io/2020/03/11/books-review05/","excerpt":"","text":"개발 서적 평가 서비스- 미들웨어 추가하기 : Redux Saga -목차 라이브러리 인스톨하기 action, reducer, store 파일 삭제 모듈 만들기 auth.js books.js saga.js create.js HOC 수정하기 서비스 추가하기 Container 수정하기 AddBookContainer BooksContainer HeaderContainer SigninLoginForm Saga 적용하기 connected-react-router 적용하기 App.js index.js 라이브러리 인스톨하기 redux-action redux-saga connected-react-router 123npm i redux-actionnpm i redux-saganpm i connected-react-router action, reducer, store 파일 삭제 삭제할 파일들 src/actions.js src/reducer/**.js src/store.js 모듈 만들기 Redux Saga 적용. redux-actions으로 간편하게 액션 과 액션 함수 만들기. auth.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// src/redux/modules/auth.jsimport UserService from '../../services/UserService';import &#123; push &#125; from 'connected-react-router';import &#123; createAction, createActions, handleActions &#125; from 'redux-actions';import &#123; put, call, select, takeEvery, takeLatest &#125; from 'redux-saga/effects';const options = &#123; prefix: 'books-review/auth',&#125;;const &#123; success, pending, fail &#125; = createActions( &#123; SUCCESS: token =&gt; (&#123; token &#125;), &#125;, 'PENDING', 'FAIL', options,);export const loginSaga = createAction('LOG_IN_SAGA');export const logoutSaga = createAction('LOG_OUT_SAGA');function* login(auth) &#123; try &#123; yield put(pending()); const res = yield call( UserService.login, auth.payload.email, auth.payload.password, ); const &#123; token &#125; = res.data; localStorage.setItem('token', token); yield put(success(token)); yield put(push('/')); &#125; catch (error) &#123; yield put(fail(error)); &#125;&#125;function* logout() &#123; const token = yield select(state =&gt; state.auth.token); try &#123; yield call(UserService.logout, token); &#125; catch (error) &#123; yield put(fail(error)); &#125; yield put(success(null)); // 리덕스 토큰 지우기 localStorage.removeItem('token'); // 토큰 지우기&#125;// saga 함수를 등록하는 saga// 내가 만든 비동기로직 (나의 사가 함수 : getBooksSaga)을 동록하는 사가 함수export function* authSaga() &#123; // 인자 1. 액션타입 , 2. 사가함수 // yield takeEvery(START_BOOKS_SAGA, getBooksSaga); // yield takeLatest(START_BOOKS_SAGA, getBooksSaga); yield takeEvery('LOG_IN_SAGA', login); yield takeLatest('LOG_OUT_SAGA', logout);&#125;const initialState = &#123; token: null, loading: false, error: null,&#125;;const auth = handleActions( &#123; PENDING: (state, action) =&gt; (&#123; token: null, loading: true, error: null &#125;), SUCCESS: (state, action) =&gt; (&#123; token: action.payload.token, loading: false, error: null, &#125;), FAIL: (state, action) =&gt; (&#123; token: null, loading: false, error: action.payload, &#125;), &#125;, initialState, options,);export default auth; books.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// src/redux/modules/books.jsimport BookService from '../../services/BookService';import &#123; createAction, createActions, handleActions &#125; from 'redux-actions';import &#123; put, delay, call, select, takeLatest &#125; from 'redux-saga/effects';const options = &#123; prefix: 'books-review/books',&#125;;const &#123; success, pending, fail &#125; = createActions( &#123; SUCCESS: books =&gt; (&#123; books &#125;), &#125;, 'PENDING', 'FAIL', options,);export const getBooksSaga = createAction('GET_BOOKS_SAGA');export const deleteBookSaga = createAction('DELETE_BOOK_SAGA');export const addBookSaga = createAction('ADD_BOOK_SAGA');function* getBooks() &#123; // 비동기 로직을 수행가능하다. // const token = action.payload.token; const token = yield select(state =&gt; state.auth.token); try &#123; // dispatch(pending()); yield put(pending()); // await sleep(2000); yield delay(2000); // const res = await BookRequest.getBooks(token); const res = yield call(BookService.getBooks, token); // dispatch(success(res.data)); yield put(success(res.data)); &#125; catch (error) &#123; // dispatch(fail(error)); yield put(fail(error)); &#125;&#125;function* deleteBook(books) &#123; const token = yield select(state =&gt; state.auth.token); try &#123; yield put(pending()); const res = yield call(BookService.deleteBook, token, books.payload.bookId); if (res.data.success === true) &#123; // dispatch(setBooks(books.filter(book =&gt; book.bookId !== bookId))); yield put( success( books.payload.books.filter( book =&gt; book.bookId !== books.payload.bookId, ), ), ); &#125; &#125; catch (error) &#123; yield put(fail(error)); &#125;&#125;function* addBook(books) &#123; const token = yield select(state =&gt; state.auth.token); try &#123; yield put(pending()); console.log('5', books); const res = yield call(BookService.addBook, token, books.payload.book); yield put( success([...books.payload.books, &#123; ...res.data, deletedAt: null &#125;]), ); &#125; catch (error) &#123; yield put(fail(error)); &#125;&#125;// saga 함수를 등록하는 saga// 내가 만든 비동기로직 (나의 사가 함수 : getBooksSaga)을 동록하는 사가 함수export function* booksSaga() &#123; // 인자 1. 액션타입 , 2. 사가함수 // yield takeEvery(START_BOOKS_SAGA, getBooksSaga); // yield takeLatest(START_BOOKS_SAGA, getBooksSaga); yield takeLatest('GET_BOOKS_SAGA', getBooks); yield takeLatest('DELETE_BOOK_SAGA', deleteBook); yield takeLatest('ADD_BOOK_SAGA', addBook);&#125;// 초기값const initialState = &#123; books: [], loading: false, error: null,&#125;;const books = handleActions( &#123; PENDING: (state, action) =&gt; (&#123; books: [], loading: true, error: null &#125;), SUCCESS: (state, action) =&gt; (&#123; books: action.payload.books, loading: false, error: null, &#125;), FAIL: (state, action) =&gt; (&#123; books: [], loading: false, error: action.payload, &#125;), &#125;, initialState, options,);export default books; reducer.js 리듀서를 모아놓은 리듀서 (즉, combineReducer) 1234567891011121314// src/redux/modules/reducer.jsimport &#123; combineReducers &#125; from 'redux';import books from './books';import auth from './auth';import &#123; connectRouter &#125; from 'connected-react-router';const reducer = history =&gt; combineReducers(&#123; books, auth, router: connectRouter(history), &#125;);export default reducer; saga.js 12345678910// src/redux/modules/saga.js// 전체 사가를 모은다.import &#123; all &#125; from 'redux-saga/effects';import &#123; booksSaga &#125; from './books';import &#123; authSaga &#125; from './auth';export default function* rootSaga() &#123; yield all([booksSaga(), authSaga()]);&#125; create.js 123456789101112131415161718192021222324252627282930313233343536373839// src/redux/create.jsimport &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './modules/reducer';import thunk from 'redux-thunk';import &#123; composeWithDevTools &#125; from 'redux-devtools-extension';// react-router-dom 설치할떄 설치됨.import &#123; createBrowserHistory &#125; from 'history';import &#123; routerMiddleware &#125; from 'connected-react-router';import createSagaMiddleware from 'redux-saga'; // 1. importimport rootSaga from './modules/saga';export const history = createBrowserHistory();const sagaMiddleware = createSagaMiddleware(); // 2. saga 미들웨어 생성const create = () =&gt; &#123; const token = localStorage.getItem('token'); const store = createStore( reducer(history), &#123; auth: &#123; token, loading: false, error: null, &#125;, &#125;, composeWithDevTools( applyMiddleware(thunk, routerMiddleware(history), sagaMiddleware), ), ); sagaMiddleware.run(rootSaga); return store;&#125;;// 지연 초기화 방식 : 함수 실행 시점을 직접 결정하기 위해서 사용한다.export default create; HOC 수정하기 store가 변경되었으므로 코드를 수정한다. 123// src/hocs/withAuth.jsconst token = useSelector(state =&gt; state.token); // 전const token = useSelector(state =&gt; state.auth.token); // 후 서비스 추가하기 login, logout 서비스를 추가한다. 123456789101112131415161718192021// src/services/UserService.jsimport axios from 'axios';const USER_API_URL = 'https://api.marktube.tv/v1/me';export default class UserService &#123; static login(email, password) &#123; return axios.post(USER_API_URL, &#123; email, password, &#125;); &#125; static logout(token) &#123; return axios.delete(USER_API_URL, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125;&#125; Container 수정하기 thunk 제거 saga 추가 AddBookContainer 1234567891011121314151617// src/containers/AddBookContainer.jsximport &#123; connect &#125; from 'react-redux';import &#123; addBookSaga &#125; from '../redux/modules/books';import AddBookModal from '../components/Home/AddBookModal';const mapStateToProps = state =&gt; (&#123; books: state.books.books,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; addBook: (books, book) =&gt; &#123; dispatch(addBookSaga(&#123; books, book &#125;)); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(AddBookModal); BooksContainer 12345678910111213141516171819202122// src/containers/BooksContainer.jsximport &#123; connect &#125; from 'react-redux';import &#123; getBooksSaga, deleteBookSaga &#125; from '../redux/modules/books';import ContentUI from '../components/Home/ContentUI';const mapStateToProps = state =&gt; (&#123; books: state.books.books, token: state.books.token, loading: state.books.loading, error: state.books.error,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; getBooks: () =&gt; &#123; dispatch(getBooksSaga()); &#125;, deleteBook: (books, bookId) =&gt; &#123; dispatch(deleteBookSaga(&#123; books, bookId &#125;)); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(ContentUI); HeaderContainer 1234567891011121314// src/containers/HeaderContainer.jsximport &#123; connect &#125; from 'react-redux';import Header from '../components/Home/Header';import &#123; logoutSaga &#125; from '../redux/modules/auth';export default connect( state =&gt; (&#123; token: state.auth.token &#125;), dispatch =&gt; (&#123; signOut: () =&gt; &#123; dispatch(logoutSaga()); &#125;, &#125;),)(Header); SigninLoginFormContainer 1234567891011121314151617// src/containers/SigninLoginFormContainer.jsximport &#123; connect &#125; from 'react-redux';import SigninLoginForm from '../components/Signin/SigninForm/SigninLoginForm';import &#123; loginSaga &#125; from '../redux/modules/auth';export default connect( state =&gt; (&#123; loading: state.auth.loading, error: state.auth.error, &#125;), dispatch =&gt; (&#123; signIn: (email, password) =&gt; &#123; dispatch(loginSaga(&#123; email, password &#125;)); &#125;, &#125;),)(SigninLoginForm); SigninLoginForm Saga 적용하기 123456789101112131415161718192021222324252627282930// src/components/Signin/SigninForm/SigninLoginForm.jsximport React, &#123; useEffect &#125; from 'react';import styled from 'styled-components';import &#123; Button, message &#125; from 'antd';const SigninLoginForm = (&#123; className, loading, signIn, error &#125;) =&gt; &#123; const emailRef = React.createRef(); const passwordRef = React.createRef(); async function click() &#123; const email = emailRef.current.value; const password = passwordRef.current.value; signIn(email, password); &#125; useEffect(() =&gt; &#123; if (error === null) return; if (error === 'USER_NOT_EXIST') &#123; message.error('유저가 없습니다.'); &#125; else if (error === 'PASSWORD_NOT_MATCH') &#123; message.error('비밀번호가 틀렸습니다.'); &#125; else &#123; message.error('로그인에 문제가 있습니다.'); &#125; &#125;, [error]); async function press(e) &#123; if (e.key !== 'Enter') return; click(); &#125;... // 동일 connected-react-router 적용하기 Redux에서 주소를 변경 및 확인하기 위해 history객체를 관리하며 필요에 의해 꺼내쓸 수 있는 유용한 라이브러리 특징 ▿ 단방향 흐름을 통해 리덕스에서 router상태를 동기화 할 수 있다. (history객체 -&gt; store-&gt; router-&gt; component) react Router 버전 v4, v5를 지원한다. 함수형 컴포넌트를 지원한다. redux-thunk나 redux-saga를 통해 히스토리 객체를 dispatch할 수 있다. App.js 12345678910111213141516171819202122232425// src/App.jsimport React from 'react';import &#123; Switch, Route &#125; from 'react-router-dom';import Home from './pages/Home';import Signin from './pages/Signin';import NotFound from './pages/NotFound';import ErrorBoundary from 'react-error-boundary';import &#123; ConnectedRouter &#125; from 'connected-react-router';import &#123; history &#125; from './redux/create';const ErrorFallbackComponent = (&#123; error &#125;) =&gt; &lt;div&gt;&#123;error.message&#125;&lt;/div&gt;;const App = () =&gt; ( &lt;ErrorBoundary FallbackComponent=&#123;ErrorFallbackComponent&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route exact path=\"/signin\" component=&#123;Signin&#125; /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/ConnectedRouter&gt; &lt;/ErrorBoundary&gt;);export default App; index.js 1234567891011121314151617// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import 'antd/dist/antd.css';import './index.css';import App from './App';import create from './redux/create';import &#123; Provider &#125; from 'react-redux';const store = create();ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'),); View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Books Review - 미들웨어 추가 Redux Thunk -","slug":"books-review04","date":"2020-03-11T05:10:55.000Z","updated":"2020-03-12T10:57:40.262Z","comments":true,"path":"2020/03/11/books-review04/","link":"","permalink":"https://hyeok999.github.io/2020/03/11/books-review04/","excerpt":"","text":"개발 서적 평가 서비스- 미들웨어 추가하기 : Redux Thunk -목차 라이브러리 인스톨하기 action에 dispatch 추가하기 + redux-thunk 적용 Store 수정하기 리듀서 추가 및 수정 Books Reducer 추가 Combine Reducer 수정 - books 리듀서 추가 Loading Reducer 수정 Services 추가 HOC Code 수정 Container 추가하기 SigninLoginFormContainer AddBookContainer BooksContainer HeaderContainer Home 관련 Component 추가하기 AddBookModal Component ContentUI Component Header Component SigninLoginForm 에 thunk 도입하기 라이브러리 인스톨하기 redux-thunk redux-devtools-extension 12npm i redux-thunknpm i redux-devtools-extension action에 dispatch 추가하기 + redux-thunk 적용 액션 타입과, 액션, 리듀서 한 세트(Ducks 패턴)를 만드는 작업 추가 미들웨어 redux-thunk 적용 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// src/actions.jsimport axios from 'axios';import BookService from './services/BookService';export const SET_TOKEN = 'SET_TOKEN';export const REMOVE_TOKEN = 'REMOVE_TOKEN';export const START_LOADING = 'START_LOADING';export const END_LOADING = 'END_LOADING';export const SET_ERROR = 'SET_ERROR';export const CLEAR_ERROR = 'CLEAR_ERROR';export const SET_BOOKS = 'SET_BOOKS';export const setToken = token =&gt; (&#123; type: SET_TOKEN, token,&#125;);export const removeToken = () =&gt; (&#123; type: REMOVE_TOKEN,&#125;);export const startLoading = () =&gt; (&#123; type: START_LOADING,&#125;);export const endLoading = () =&gt; (&#123; type: END_LOADING,&#125;);export const setError = error =&gt; (&#123; type: SET_ERROR, error,&#125;);export const clearError = () =&gt; (&#123; type: CLEAR_ERROR,&#125;);export const setBooks = books =&gt; (&#123; type: SET_BOOKS, books,&#125;);// Thunkexport const loginThunk = (email, password) =&gt; async dispatch =&gt; &#123; try &#123; dispatch(clearError()); dispatch(startLoading()); const response = await axios.post('https://api.marktube.tv/v1/me', &#123; email, password, &#125;); const &#123; token &#125; = response.data; dispatch(endLoading()); localStorage.setItem('token', token); dispatch(setToken(token)); &#125; catch (err) &#123; dispatch(endLoading()); dispatch(setError(err.response.data.error)); throw err; &#125;&#125;;export const logoutThunk = token =&gt; async dispatch =&gt; &#123; try &#123; await axios.delete('https://api.marktube.tv/v1/me', &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125; catch (error) &#123; console.log(error); &#125; localStorage.removeItem('token'); // 토큰 지우기 dispatch(removeToken()); // 리덕스 토큰 지우기&#125;;export const setBooksThunk = token =&gt; async dispatch =&gt; &#123; try &#123; dispatch(startLoading()); dispatch(clearError()); const res = await BookService.getBooks(token); dispatch(endLoading()); dispatch(setBooks(res.data)); &#125; catch (error) &#123; dispatch(endLoading()); dispatch(setError(error)); &#125;&#125;;export const addBookThunk = (token, books, book) =&gt; async dispatch =&gt; &#123; try &#123; dispatch(startLoading()); dispatch(clearError()); const res = await BookService.addBook(token, book); dispatch(endLoading()); dispatch(setBooks([...books, &#123; ...res.data, deletedAt: null &#125;])); &#125; catch (error) &#123; dispatch(endLoading()); dispatch(setError(error)); &#125;&#125;;export const deleteBookThunk = (token, books, bookId) =&gt; async dispatch =&gt; &#123; try &#123; dispatch(startLoading()); dispatch(clearError()); const res = await BookService.deleteBook(token, bookId); dispatch(endLoading()); if (res.data.success === true) &#123; dispatch(setBooks(books.filter(book =&gt; book.bookId !== bookId))); &#125; &#125; catch (error) &#123; dispatch(endLoading()); dispatch(setError(error)); &#125;&#125;; Store 수정하기 create함수의 2번째 인자 제거 123456789101112131415161718// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import 'antd/dist/antd.css';import './index.css';import App from './App';import create from './store';import &#123; Provider &#125; from 'react-redux';const token = localStorage.getItem('token');const store = create(&#123; token &#125;);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'),); applyMiddleware 에 redux-thunk 추가 12345678910111213// src/store.jsimport &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './reducer';import &#123; composeWithDevTools &#125; from 'redux-devtools-extension';import thunk from 'redux-thunk';export default function create(initialState) &#123; return createStore( reducer, initialState, composeWithDevTools(applyMiddleware(thunk)), );&#125; 리듀서 추가 및 수정 Books Reducer 추가 123456789101112131415// src/reducer/books.jsimport &#123; SET_BOOKS &#125; from '../actions';const initialState = [];const books = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case SET_BOOKS: return [...action.books]; default: return state; &#125;&#125;;export default books; Combine Reducer 수정 - books 리듀서 추가 1234567891011121314// src/reducer/index.jsimport token from './token';import loading from './loading';import error from './error';import books from './books';const reducer = combineReducers(&#123; token, loading, error, books,&#125;);export default reducer; Loading Reducer 수정 초기값을 null로 변경 로딩이 끝날 경우 false아닌 null로 변경 12345678910111213// src/reducer/loading.jsimport &#123; START_LOADING, END_LOADING &#125; from '../actions';const initialState = null;const loading = (state = initialState, action) =&gt; &#123; if (action.type === START_LOADING) &#123; return true; &#125; else if (action.type === END_LOADING) &#123; return null; &#125; return state;&#125;; Services 추가 XHR 부분을 따로 Service로 만들어 별도 관리한다. 전체 조회 : getBooks 단일 조회 : getBook 삭제 : deleteBook 추가 : addBook 수정 : editBook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// src/services/BookService.jsimport axios from 'axios';const BOOK_API_URL = 'https://api.marktube.tv/v1/book';export default class BookService &#123; static async getBooks(token) &#123; return axios.get(BOOK_API_URL, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125; static async getBook(token, bookId) &#123; return axios.get(`$&#123;BOOK_API_URL&#125;/$&#123;bookId&#125;`, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125; static async deleteBook(token, bookId) &#123; return axios.delete(`$&#123;BOOK_API_URL&#125;/$&#123;bookId&#125;`, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125; static async addBook(token, book) &#123; return axios.post(BOOK_API_URL, book, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125; static async editBook(token, bookId, book) &#123; return axios.patch(`$&#123;BOOK_API_URL&#125;/$&#123;bookId&#125;`, book, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125; static;&#125; HOC Code 수정 withAuth 의 코드를 수정한다. 123456789101112131415161718192021222324// src/hocs/withAuth.jsimport &#123; Redirect &#125; from 'react-router-dom';import &#123; useSelector &#125; from 'react-redux';function withAuth(Component, loggedin = true) &#123; function WrappedComponent(props) &#123; const token = useSelector(state =&gt; state.token); if (loggedin) &#123; if (token === null) &#123; return &lt;Redirect to=\"/signin\" /&gt;; &#125; return &lt;Component &#123;...props&#125; token=&#123;token&#125; /&gt;; &#125; else &#123; if (token !== null) &#123; return &lt;Redirect to=\"/\" /&gt;; &#125; return &lt;Component &#123;...props&#125; /&gt;; &#125; &#125; WrappedComponent.displayName = `withAuth($&#123;Component.name&#125;)`; return WrappedComponent;&#125;export default withAuth; Container 추가하기 컴포넌트에서 화면에 뿌려질 데이터만을 작성한다. 모든 로직, 데이터 가공은 Container에서 처리하여 컴포넌트에게 전달한다. SigninLoginFormContainer 12345678910111213141516// src/containers/SigninLoginFormContainer.jsximport &#123; connect &#125; from 'react-redux';import SigninLoginForm from '../components/Signin/SigninForm/SigninLoginForm';import &#123; loginThunk &#125; from '../actions';export default connect( state =&gt; (&#123; loading: state.loading, error: state.error, &#125;), dispatch =&gt; (&#123; loginThunk: (email, password) =&gt; &#123; dispatch(loginThunk(email, password)); &#125;, &#125;),)(SigninLoginForm); AddBookContainer 1234567891011121314151617// src/containers/AddBookContainer.jsximport &#123; connect &#125; from 'react-redux';import &#123; addBookThunk &#125; from '../actions';import AddBookModal from '../components/Home/AddBookModal';const mapStateToProps = state =&gt; (&#123; books: state.books, token: state.token,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; addBook: async (token, books, book) =&gt; &#123; dispatch(addBookThunk(token, books, book)); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(AddBookModal); BooksContainer 12345678910111213141516171819202122// src/containers/BooksContainer.jsximport &#123; connect &#125; from 'react-redux';import &#123; setBooksThunk, deleteBookThunk &#125; from '../actions';import ContentUI from '../components/Home/ContentUI';const mapStateToProps = state =&gt; (&#123; books: state.books, token: state.token, loading: state.loading, error: state.error,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; setBooks: async token =&gt; &#123; dispatch(setBooksThunk(token)); &#125;, deleteBook: async (token, books, bookId) =&gt; &#123; dispatch(deleteBookThunk(token, books, bookId)); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(ContentUI); HeaderContainer 1234567891011121314// src/containers/HeaderContainer.jsximport &#123; connect &#125; from 'react-redux';import Header from '../components/Home/Header';import &#123; logoutThunk &#125; from '../actions';export default connect( state =&gt; (&#123; token: state.token &#125;), dispatch =&gt; (&#123; logoutThunk: token =&gt; &#123; dispatch(logoutThunk(token)); &#125;, &#125;),)(Header); Home 관련 Component 추가하기. AddBookModal Component 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// src/components/Home/AddBookModal.jsximport React from 'react';import &#123; Button, Modal &#125; from 'antd';import InputBookInfo from './InputBookInfo';const AddBookModal = (&#123; visible, handleOk, handleCancel, addBook, token, books,&#125;) =&gt; &#123; const titleRef = React.createRef(); const messageRef = React.createRef(); const authorRef = React.createRef(); const urlRef = React.createRef(); const initValue = () =&gt; &#123; titleRef.current.state.value = ''; messageRef.current.state.value = ''; authorRef.current.state.value = ''; urlRef.current.state.value = ''; &#125;; const click = () =&gt; &#123; const book = &#123; title: titleRef.current.state.value, message: messageRef.current.state.value, author: authorRef.current.state.value, url: urlRef.current.state.value, &#125;; async function add(token, book) &#123; try &#123; await addBook(token, books, &#123; title: book.title, message: book.message, author: book.author, url: book.url, &#125;); &#125; catch (error) &#123; console.log(error); &#125; &#125; add(token, book); initValue(); handleCancel(); &#125;; return ( &lt;Modal title=\"Add Book List\" visible=&#123;visible&#125; onOk=&#123;handleOk&#125; onCancel=&#123;handleCancel&#125; footer=&#123;[ &lt;Button key=\"back\" onClick=&#123;handleCancel&#125;&gt; Cancel &lt;/Button&gt;, &lt;Button key=\"submit\" type=\"primary\" onClick=&#123;click&#125;&gt; Add &lt;/Button&gt;, ]&#125; &gt; &lt;InputBookInfo info=\"Title\" reference=&#123;titleRef&#125; /&gt; &lt;InputBookInfo info=\"Message\" reference=&#123;messageRef&#125; /&gt; &lt;InputBookInfo info=\"Author\" reference=&#123;authorRef&#125; /&gt; &lt;InputBookInfo info=\"URL\" reference=&#123;urlRef&#125; /&gt; &lt;/Modal&gt; );&#125;;export default AddBookModal; ContentUI Component 기존 ContentUI Component를 수정. 12345678910111213141516171819202122232425262728293031323334353637383940// src/components/Home/ContentUI.jsximport React from 'react';import uuid from 'uuid';import styled from 'styled-components';import &#123; Layout, Button, Icon &#125; from 'antd';import &#123; useEffect &#125; from 'react';const &#123; Content &#125; = Layout;... // style componentsconst ContentUI = (&#123; token, books, setBooks, deleteBook, editBook &#125;) =&gt; &#123; useEffect(() =&gt; &#123; setBooks(token); &#125;, [token, setBooks]); return ( &lt;StyledContent&gt; &lt;ul&gt; &#123;books &amp;&amp; books.map(book =&gt; ( &lt;li key=&#123;uuid.v4()&#125;&gt; &lt;div&gt; &lt;Icon type=\"read\" /&gt; &lt;/div&gt; &lt;StyledTitleh3&gt;&#123;book.title&#125;&lt;/StyledTitleh3&gt; &lt;StyledContentP&gt; &lt;span&gt;&#123;book.author&#125;&lt;/span&gt; &lt;span&gt;&#123;book.message&#125;&lt;/span&gt; &lt;span&gt;&#123;book.url&#125;&lt;/span&gt; &lt;/StyledContentP&gt; &lt;StyledDeleteButton onClick=&#123;() =&gt; deleteBook(token, books, book.bookId)&#125; &gt; &lt;Icon type=\"delete\" /&gt; &lt;/StyledDeleteButton&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; Header Component 12345678910111213141516// src/components/Home/Header.jsximport React from 'react';import HeaderUI from './HeaderUI';const Header = (&#123; token, logoutThunk &#125;) =&gt; &#123; function logout() &#123; logoutThunk(token); &#125; return ( &lt;&gt; &lt;HeaderUI logout=&#123;logout&#125;&gt;&lt;/HeaderUI&gt; &lt;/&gt; );&#125;;export default Header; SigninLoginForm 에 thunk 도입하기 주석 친 부분은 제거한다. redux-thunk를 도입한다. 기존 코드들은 Container에서 대부분 처리하고 미들웨어인 thunk에서 서비스를 처리한다. 123456789101112131415161718192021222324252627282930313233// src/components/Signin/SigninForm/SigninLoginForm.jsximport &#123; useHistory &#125; from 'react-router-dom';import &#123; Button, message &#125; from 'antd';// const SigninLoginForm = (&#123; className, loading, login, error &#125;) =&gt; &#123;const SigninLoginForm = (&#123; className, loading, loginThunk, error &#125;) =&gt; &#123; const history = useHistory(); const emailRef = React.createRef(); const passwordRef = React.createRef(); async function click() &#123; const email = emailRef.current.value; const password = passwordRef.current.value; try &#123; await loginThunk(email, password); history.push('/'); &#125; catch &#123;&#125; // try &#123; // // setLoading(true); // await login(email, password); // history.push('/'); // await login(email, password); // // history.push('/'); // &#125; catch (error) &#123;&#125; &#125; useEffect(() =&gt; &#123; if (error === null) return; if (error === 'USER_NOT_EXIST') &#123; message.error('유저가 없습니다.'); ... // 동일 View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Books Review - Redux 적용하기 -","slug":"books-review03","date":"2020-03-10T14:10:55.000Z","updated":"2020-03-12T10:46:30.652Z","comments":true,"path":"2020/03/10/books-review03/","link":"","permalink":"https://hyeok999.github.io/2020/03/10/books-review03/","excerpt":"","text":"개발 서적 평가 서비스- Redux 적용하기 -목차 라이브러리 인스톨하기 action 추가하기 Store 생성하기 Reducer 추가하기 Combine Reducer Loading Reducer Token Reducer Error Reducer Logout 기능 추가 HOC(High Order Component) 추가 Singin Login Form Container 작성 라이브러리 인스톨하기 redux react-redux 12npm i react-reduxnpm i redux action 추가하기 토큰 생성 및 제거 에러 생성 및 초기화(Clear) 로딩 시작 및 끝 1234567891011121314151617181920212223242526272829303132export const SET_TOKEN = 'SET_TOKEN';export const REMOVE_TOKEN = 'REMOVE_TOKEN';export const START_LOADING = 'START_LOADING';export const END_LOADING = 'END_LOADING';export const SET_ERROR = 'SET_ERROR';export const CLEAR_ERROR = 'CLEAR_ERROR';export const setToken = token =&gt; (&#123; type: SET_TOKEN, token,&#125;);export const removeToken = () =&gt; (&#123; type: REMOVE_TOKEN,&#125;);export const startLoading = () =&gt; (&#123; type: START_LOADING,&#125;);export const endLoading = () =&gt; (&#123; type: END_LOADING,&#125;);export const setError = error =&gt; (&#123; type: SET_ERROR, error,&#125;);export const clearError = () =&gt; (&#123; type: CLEAR_ERROR,&#125;); Store 생성하기 Store에 reducer, initialState, devtools를 적용 123456789101112// src/store.jsimport &#123; createStore &#125; from 'redux';import reducer from './reducer';export default function create(initialState) &#123; return createStore( reducer, initialState, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__(), );&#125; index.js 에서 store 의 create함수를 import index.js 에서 하위 컴포넌트에게 속성으로 store를 모두 전달 12345678910111213141516171819// src/index.jsimport './index.css';import App from './App';import * as serviceWorker from './serviceWorker';import create from './store';import &#123; Provider &#125; from 'react-redux';const token = localStorage.getItem('token');const store = create( &#123; token &#125;, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__(),);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'),); Reducer 추가하기 Combine Reducer 12345678910111213// src/reducer/index.jsimport &#123; combineReducers &#125; from 'redux';import token from './token';import loading from './loading';import error from './error';const reducer = combineReducers(&#123; token, loading, error,&#125;);export default reducer; Loading Reducer 초기값 : false 123456789101112131415// src/reducer/loading.jsimport &#123; START_LOADING, END_LOADING &#125; from '../actions';const initialState = false;const loading = (state = initialState, action) =&gt; &#123; if (action.type === START_LOADING) &#123; return true; &#125; else if (action.type === END_LOADING) &#123; return false; &#125; return state;&#125;;export default loading; Token Reducer 초기값 : null 123456789101112131415// src/reducer/token.jsimport &#123; SET_TOKEN, REMOVE_TOKEN &#125; from '../actions';const initialState = null;const token = (state = initialState, action) =&gt; &#123; if (action.type === SET_TOKEN) &#123; return action.token; &#125; else if (action.type === REMOVE_TOKEN) &#123; return null; &#125; return state;&#125;;export default token; Error Reducer 초기값 : null 123456789101112131415// src/reducer/error.js import &#123; SET_ERROR, CLEAR_ERROR &#125; from '../actions';const initialState = null;const error = (state = initialState, action) =&gt; &#123; if (action.type === SET_ERROR) &#123; return action.error; &#125; else if (action.type === CLEAR_ERROR) &#123; return null; &#125; return state;&#125;;export default error; Logout 기능 추가 Home.jsx에 useDispatch, removeToken 추가 로컬스토리지의 토큰키를 지우는 작업 추가. 토큰키를 지우고 signin페이지로 강제이동. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// src/pages/Home.jsximport InputBookInfo from '../components/Home/InputBookInfo';import HeaderUI from '../components/Home/HeaderUI';import ContentUI from '../components/Home/ContentUI';import &#123; useDispatch &#125; from 'react-redux';import &#123; removeToken &#125; from '../actions';const &#123; SubMenu &#125; = Menu;const &#123; Sider &#125; = Layout;const StyledSideMenu = styled(Menu).attrs(() =&gt; (&#123; mode: 'inline', defaultSelectedKeys: ['1'], defaultOpenKeys: ['sub1'],&#125;))` height: 100%; border-right: 0;`;const Home = (&#123; token, history &#125;) =&gt; &#123; const [books, setBooks] = useState([]); const dispatch = useDispatch(); const [visible, setVisible] = useState(false); const titleRef = React.createRef(); const messageRef = React.createRef(); const authorRef = React.createRef(); const urlRef = React.createRef(); useEffect(() =&gt; &#123; async function getBookList() &#123; try &#123; const response = await axios.get('https://api.marktube.tv/v1/book', &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); setBooks(response.data); &#125; catch (error) &#123; console.log(error); &#125; &#125; getBookList(); &#125;, [token]); async function logout() &#123; try &#123; await axios.delete('https://api.marktube.tv/v1/me', &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125; catch (error) &#123; console.log(error); &#125; localStorage.removeItem('token'); history.push('/signin'); // 로그아웃시 보여줄 페이지 dispatch(removeToken()); &#125;... HOC(High Order Component) 추가 displayName 설정 해주어야 함.(display 이름 설정(디버깅시 이름을 유지시켜주기위함.) token 키가 없다면 /signin 페이지로 리다이렉트 함. 123456789101112131415161718import React from 'react';import &#123; Redirect &#125; from 'react-router-dom';import &#123; useSelector &#125; from 'react-redux';function withAuth(Component) &#123; function WrappedComponent(props) &#123; // const token = localStorage.getItem('token'); const token = useSelector(state =&gt; state.token); if (token === null) &#123; return &lt;Redirect to=\"/signin\" /&gt;; &#125; return &lt;Component &#123;...props&#125; token=&#123;token&#125; /&gt;; &#125; WrappedComponent.displayName = `withAuth($&#123;Component.name&#125;)`; return WrappedComponent;&#125;export default withAuth;// 관련없는 props는 패스해주어라. Singin Login Form Container 작성 SigninForm 컴포넌트에서 할 작업들을 Container에서 작업하고 connect를 통해 store와 함께 내려준다. 12345678910111213141516171819202122232425262728293031323334353637import &#123; connect &#125; from 'react-redux';import SigninLoginForm from '../components/Signin/SigninForm/SigninLoginForm';import &#123; setToken, startLoading, endLoading, setError, clearError,&#125; from '../actions';import axios from 'axios';export default connect( state =&gt; (&#123; loading: state.loading, error: state.error, &#125;), dispatch =&gt; (&#123; login: async (email, password) =&gt; &#123; try &#123; dispatch(startLoading()); const response = await axios.post('https://api.marktube.tv/v1/me', &#123; email, password, &#125;); const &#123; token &#125; = response.data; dispatch(endLoading()); localStorage.setItem('token', token); dispatch(setToken(token)); dispatch(clearError()); &#125; catch (err) &#123; dispatch(endLoading()); dispatch(setError(err.response.data.error)); throw err; &#125; &#125;, &#125;),)(SigninLoginForm); View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Books Review - 로그인 디자인하기 -","slug":"books-review02","date":"2020-03-10T09:31:24.000Z","updated":"2020-03-12T10:35:47.757Z","comments":true,"path":"2020/03/10/books-review02/","link":"","permalink":"https://hyeok999.github.io/2020/03/10/books-review02/","excerpt":"","text":"개발 서적 평가 서비스-로그인 화면 디자인-목차 라이브러리 인스톨하기 Ant Design 초기설정 Font 설정하기 App.js에서 &lt;Link&gt;를 Home.jsx로 이동하기 Signin 페이지 스타일링 하기 Component 폴더 및 파일 생성하기 Component 추가하기 -SigninBg- Component 추가하기 -SigninForm- Component 추가하기 -SigninLoginForm- Component 추가하기 -SigninSupportUl- 설정한 스타일 컴포넌트를 Signin에서 불러오기 라이브러리 인스톨하기 Styled-components Ant Design npm ci CI(Continous Integration) 환경을 위한 npm ci command 모듈 설명 공식 npm ci 123nvm use (옵션 : 설정된 노드 버전을 이용.)npm i cinpm i styled-components antd Ant Design 초기설정 Ant Design 라이브러리에서 css 전역 설정해주기 index.js 12345678910import React from 'react';import ReactDOM from 'react-dom';import 'antd/dist/antd.css'; // 추가import './index.css';import App from './App';import * as serviceWorker from './serviceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));serviceWorker.unregister(); Font 설정하기 Roboto폰트 적용하기 ▶︎ 구글 폰트 - Roboto 설정 해주기 ( index.html / index.css ) index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; ... &lt;link href=\"https://fonts.googleapis.com/css?family=Roboto&amp;display=swap\" rel=\"stylesheet\" /&gt; ... &lt;/head&gt; &lt;body&gt;...&lt;/body&gt;&lt;/html&gt; index.css 123456body &#123; margin: 0; font-family: 'Roboto', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; App.js에서 &lt;Link&gt;를 Home.jsx로 이동하기 App.js에서 아래 부분을 제거(혹은 잘라내기) 한다. 123456789// App.js 아래 부분 잘라내기.&lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;홈&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/signin\"&gt;로그인&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; src/pages/Home.jsx 에서 잘라낸 부분을 붙여넣는다. 123456789101112131415161718// src/pages/Home.jsx import React from 'react';import &#123; Link &#125; from 'react-router-dom';const Home = props =&gt; &#123; return ( &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;홈&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/signin\"&gt;로그인&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );&#125;;export default Home; Signin 페이지 스타일링 하기 Signin.jsx 부분을 스타일링 한다. antd 가 지원해주는 그리드 레이아웃을 이용한다. ( Row, Col ) 스타일 컴포넌트를 이용해 디자인한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React from 'react';import styled from 'styled-components';import &#123; Row, Col &#125; from 'antd';const StyledRow = styled(Row).attrs(() =&gt; (&#123; type: 'flex', align: 'middle',&#125;))` height: 100vh;`;const StyledCol = styled(Col).attrs(() =&gt; (&#123; span: 24,&#125;))``;const StyledTitle = styled.div` text-align: center; font-size: 40px; font-weight: bold; color: #642828; text-transform: uppercase;`;const StyledSubTitle = styled.div` text-align: center; font-size: 27px; font-weight: bold; text-transform: uppercase;`;const StyledUnderline = styled.div` width: 200px; height: 8px; margin-right: auto; margin-left: auto; margin-top: 20px; background: linear-gradient(to right, #803b32, #ddb49b);`;const StyledContents = styled(Row).attrs(() =&gt; (&#123; type: 'flex',&#125;))` margin-top: 50px; background-color: #f3f7f8; margin-left: auto; margin-right: auto; width: 800px;`;const Signin = () =&gt; ( &lt;StyledRow&gt; &lt;StyledCol&gt; &lt;StyledTitle&gt;Review Service For Books&lt;/StyledTitle&gt; &lt;StyledSubTitle&gt; Please Share Your Opinion on Web Development Books. &lt;/StyledSubTitle&gt; &lt;StyledUnderline /&gt; &lt;StyledContents&gt; &lt;/StyledContents&gt; &lt;/StyledCol&gt; &lt;/StyledRow&gt;);export default Signin; Component 폴더 및 파일 생성하기 src 하위에 components라는 파일을 추가한다. components폴더 안에 Signin이라는 폴더를 생성한다. Signin 폴더 안에 SigninBg.jsx파일을 생성한다. (메인 - 왼쪽) Signin 폴더 안에 SigninForm이라는 폴더를 생성한다. SigninForm폴더 안에 SigninForm.jsx파일을 생성한다. (메인 - 오른쪽) SigninForm폴더 안에 SigninLoginForm.jsx파일을 생성한다. SigninForm폴더 안에 SigninSupportUl.jsx파일을 생성한다. Component 추가하기 -SigninBg- 위 LoginPage이미지 중 왼쪽에 해당되는 그림을 추가한다. public 폴더에 이미지를 추가해준다. (나는 book.jpg 라는 이미지를 추가함.) 스타일 컴포넌트를 이용하여 스타일링 하고 반환한다. src/components/Signin/SigninBg.jsx 1234567891011121314151617181920import React from 'react';import &#123; Col &#125; from 'antd';import styled from 'styled-components';const StyledCol = styled(Col).attrs(() =&gt; (&#123; span: 12,&#125;))``;const StyledImg = styled.img` width: 100%; height: 100%;`;const SigninBg = () =&gt; ( &lt;StyledCol&gt; &lt;StyledImg src=\"/book.jpg\" alt=\"Signin\" /&gt; &lt;/StyledCol&gt;);export default SigninBg; Component 추가하기 -SigninForm- 스타일 컴포넌트를 이용하여 스타일링 하고 반환한다. 크게 두 단락으로 나뉘어서 진행한다. Form 태그로 묶은 단락( 로그인, 패스워드 입력창과 버튼 ) Ul로 태그로 묶은 단락( 설명문구, 버튼 ) src/components/Signin/SigninForm/SigninForm.jsx 12345678910111213141516171819202122232425262728293031// SigninForm.jsximport React from 'react';import &#123; Col &#125; from 'antd';import styled from 'styled-components';import SigninLoginForm from './SigninLoginForm';import SigninSupportUl from './SigninSupportUl';const StyledCol = styled(Col).attrs(() =&gt; (&#123; span: 12,&#125;))` padding: 30px; font-weight: 600; vertical-align: top;`;const StyledLoginTitle = styled.h2` text-align: center; padding: 50px 0 30px 0px; margin: 0; font-weight: inherit;`;const SigninForm = () =&gt; ( &lt;StyledCol&gt; &lt;StyledLoginTitle&gt;LOG IN. START SEARCHING.&lt;/StyledLoginTitle&gt; &lt;SigninLoginForm&gt;&lt;/SigninLoginForm&gt; &lt;SigninSupportUl&gt;&lt;/SigninSupportUl&gt; &lt;/StyledCol&gt;);export default SigninForm; Component 추가하기 -SigninLoginForm- Form 태그로 묶은 단락( 로그인, 패스워드 입력창과 버튼 )을 구현하고 스타일링 하여 반환한다. 스타일 컴포넌트로 스타일링 하는 방법은 여러가지 있지만 여기서는 styled(컴포넌트)를 이용한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import React from 'react';import styled from 'styled-components';const SigninLoginForm = (&#123; className &#125;) =&gt; &#123; return ( &lt;form className=&#123;className&#125;&gt; &lt;fieldset&gt; &lt;div&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input autoFocus type=\"email\" placeholder=\"Enter your E-mail\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;Password&lt;/label&gt; &lt;input type=\"password\" placeholder=\"Enter your Password\" /&gt; &lt;/div&gt; &lt;button&gt;SIGN IN&lt;/button&gt; &lt;/fieldset&gt; &lt;/form&gt; );&#125;;const StyledLoginForm = styled(SigninLoginForm)` padding: 50px 0 25px 0; label, input, button &#123; font-weight: inherit; &#125; label::after &#123; content: '*'; color: red; &#125; input &#123; margin: 10px 0 20px; display: block; width: 100%; height: 30px; background-color: rgb(227, 238, 253); border: rgba(117, 117, 117, 0.2) solid 1px; &#125; input::placeholder &#123; font-style: italic; color: rgba(19, 19, 19, 0.3); font-weight: 600; padding-left: 10px; &#125; input:focus &#123; background-color: #fff; outline: none !important; border-color: #719ece; box-shadow: 0 0 10px #719ece; &#125; button &#123; background-color: rgb(30, 74, 94); border: none; color: rgb(241, 246, 247); font-size: 16px; padding: 6px 30px; &#125; button:hover &#123; color: rgb(30, 74, 94); background-color: rgb(241, 246, 247); box-shadow: 1px 1px rgb(30, 74, 94), -1px -1px rgb(30, 74, 94), 1px -1px rgb(30, 74, 94), -1px 1px rgb(30, 74, 94); &#125;`;export default StyledLoginForm; Component 추가하기 -SigninSupportUl- Ul로 태그로 묶은 단락( 설명문구, 버튼 )을 구현하고 스타일링 하여 반환한다. 스타일 컴포넌트로 스타일링 하는 방법은 여러가지 있지만 여기서는 styled(컴포넌트)를 이용한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react';import styled from 'styled-components';const SigninSupportUl = (&#123; className &#125;) =&gt; &#123; return ( &lt;ul className=&#123;className&#125;&gt; &lt;li&gt; &lt;span&gt;Need to create an account?&lt;/span&gt; &lt;button&gt;SIGN UP&lt;/button&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;Forgot your password&lt;/span&gt; &lt;button&gt;RECOVERY&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; );&#125;;const StyledSupportUl = styled(SigninSupportUl)` list-style: none; padding: 25px 0 0; margin: 0; border-top: rgba(233, 233, 233) solid 1px; li &#123; display: flex; justify-content: space-between; align-items: center; &#125; li:nth-child(2) &#123; margin-top: 25px; &#125; span &#123; margin: 0; margin-bottom: 0; font-size: 15px; &#125; button &#123; background-color: inherit; padding: 5px 20px; border: rgb(29, 74, 93) 2px solid; color: rgb(71, 107, 123); font-weight: 600; &#125; button:hover &#123; color: rgb(241, 246, 247); background-color: rgb(29, 74, 93); &#125;`;export default StyledSupportUl; 설정한 스타일 컴포넌트를 Signin에서 불러오기 SigninBg SigninForm 두 컴포넌트를 불러와서 Signin에 삽입한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from 'react';import styled from 'styled-components';import &#123; Row, Col &#125; from 'antd';import SigninBg from '../components/Signin/SigninBg';import SigninForm from '../components/Signin/SigninForm/SigninForm';const StyledRow = styled(Row).attrs(() =&gt; (&#123; type: 'flex', align: 'middle',&#125;))` height: 100vh;`;const StyledCol = styled(Col).attrs(() =&gt; (&#123; span: 24,&#125;))``;const StyledTitle = styled.div` text-align: center; font-size: 40px; font-weight: bold; color: #642828; text-transform: uppercase;`;const StyledSubTitle = styled.div` text-align: center; font-size: 27px; font-weight: bold; text-transform: uppercase;`;const StyledUnderline = styled.div` width: 200px; height: 8px; margin-right: auto; margin-left: auto; margin-top: 20px; background: linear-gradient(to right, #803b32, #ddb49b);`;const StyledContents = styled(Row).attrs(() =&gt; (&#123; type: 'flex',&#125;))` margin-top: 50px; background-color: #f3f7f8; margin-left: auto; margin-right: auto; width: 800px;`;const Signin = () =&gt; ( &lt;StyledRow&gt; &lt;StyledCol&gt; &lt;StyledTitle&gt; Review Service For Books &lt;/StyledTitle&gt; &lt;StyledSubTitle&gt; Please Share Your Opinion on Web Development Books. &lt;/StyledSubTitle&gt; &lt;StyledUnderline /&gt; &lt;StyledContents&gt; &lt;SigninBg /&gt; &lt;SigninForm /&gt; &lt;/StyledContents&gt; &lt;/StyledCol&gt; &lt;/StyledRow&gt;);export default Signin; View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Books Review - 라우팅 설정하기 -","slug":"books-review01","date":"2020-03-10T06:35:43.000Z","updated":"2020-03-12T10:30:16.330Z","comments":true,"path":"2020/03/10/books-review01/","link":"","permalink":"https://hyeok999.github.io/2020/03/10/books-review01/","excerpt":"","text":"개발 서적 평가 서비스-라우팅 설정하기-목차 프로젝트 생성 라이브러리 인스톨하기 nvm 설정파일 생성하기 package.json 설정 추가하기 prettier 설정파일 생성하기 라우터 설정하기 pages 폴더 만들고 컴포넌트 설정하기 프로젝트 생성 1npx create-react-app books-review 라이브러리 인스톨하기 1234cd books-reviewnpm i react-router-domnpm i react-error-boundarynpm i prettier eslint-config-prettier husky lint-staged -D nvm 설정파일 생성하기 .nvmrc 파일 생성 (위치 : .gitignore 랑 같은 위치) 112.11.1 package.json 설정 추가하기 &quot;scripts&quot;: {...} 아래에 삽입 123456789101112131415161718\"eslintConfig\": &#123; \"extends\": [ \"react-app\", \"prettier\" ]&#125;,\"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125;&#125;,\"lint-staged\": &#123; \"**/*.&#123;js,jsx&#125;\": [ \"eslint --fix\", \"prettier --write\", \"git add\" ]&#125;, prettier 설정파일 생성하기 .prettierrc 파일 생성 (위치 : .gitignore 랑 같은 위치) 1234&#123; \"trailingComma\": \"all\", \"singleQuote\": true&#125; 라우터 설정하기 path 에러가 날 경우 특정 컴포넌트로 이동하도록 &lt;ErrorBoundary FallbackComponent={ErrorFallbackComponent}&gt;를 설정한다. BrowserRouter 로 Route 들을 감싸준다. (브라우저 라우팅을 위한 react-router-dom에서 지원해주는 jsx 태그) 브라우저에서 요청한 경로에 Route 의 path 가 들어있으면(매치가 되면) 해당 component 를 보여준다. exact : 주어진 경로와 정확히 맞아 떨어져야만 설정한 컴포넌트를 보여준다. &lt;Link&gt; 리액트에서 사용되는 &lt;a&gt; (단, 서버와 통신을 하지않고 단순히 URL을 바꾸는 역할) Switch 컴포넌트에 감싸면 매칭되는 첫번째 라우트만 보여주고 나머지는 보여주지 않는다. 1234567891011121314151617181920212223242526272829303132// App.jsimport React from 'react';import &#123; BrowserRouter, Switch, Route, Link &#125; from 'react-router-dom';import Home from './pages/Home';import Signin from './pages/Signin';import NotFound from './pages/NotFound';import ErrorBoundary from 'react-error-boundary';const ErrorFallbackComponent = (&#123; error &#125;) =&gt; &lt;div&gt;&#123;error.message&#125;&lt;/div&gt;;const App = () =&gt; ( &lt;ErrorBoundary FallbackComponent=&#123;ErrorFallbackComponent&#125;&gt; &lt;BrowserRouter&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;홈&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/signin\"&gt;로그인&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path=\"/signin\" component=&#123;Signin&#125; /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/ErrorBoundary&gt;);export default App; pages 폴더 만들고 컴포넌트 설정하기 구체적으로 설정은 안하고 초기 설정만 해준다. 12345678// Home.jsximport React from 'react';const Home = props =&gt; &#123; return &lt;div&gt;Home&lt;/div&gt;;&#125;;export default Home; 12345678// NotFound.jsximport React from 'react';const NotFound = props =&gt; &#123; return &lt;div&gt;NotFound&lt;/div&gt;;&#125;;export default NotFound; 12345678// Signin.jsximport React from 'react';const Signin = props =&gt; &#123; return &lt;div&gt;Signin&lt;/div&gt;;&#125;;export default Signin; View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"Books Review - 개발 서적 평가 서비스 -","slug":"cas-react-main","date":"2020-03-10T03:05:13.000Z","updated":"2020-03-12T11:04:24.373Z","comments":true,"path":"2020/03/10/cas-react-main/","link":"","permalink":"https://hyeok999.github.io/2020/03/10/cas-react-main/","excerpt":"","text":"개발 서적 평가 서비스목차 목차를 클릭하면 자세한 개발 코드 및 코멘트를 확인하실 수 있습니다. Develop 1 프로젝트 생성 라이브러리 인스톨하기 nvm 설정파일 생성하기 package.json 설정 추가하기 prettier 설정파일 생성하기 라우터 설정하기 pages 폴더 만들고 컴포넌트 설정하기 Develop 2 라이브러리 인스톨하기 Ant Design 초기설정 Font 설정하기 App.js에서 &lt;Link&gt;를 Home.jsx로 이동하기 Signin 페이지 스타일링 하기 Component 폴더 및 파일 생성하기 Component 추가하기 -SigninBg- Component 추가하기 -SigninForm- Component 추가하기 -SigninLoginForm- Component 추가하기 -SigninSupportUl- 설정한 스타일 컴포넌트를 Signin에서 불러오기 Develop 3 라이브러리 인스톨하기 action 추가하기 Store 생성하기 Reducer 추가하기 Combine Reducer Loading Reducer Token Reducer Error Reducer Logout 기능 추가 HOC(High Order Component) 추가 Singin Login Form Container 작성 Develop 4 라이브러리 인스톨하기 action에 dispatch 추가하기 + redux-thunk 적용 Store 수정하기 리듀서 추가 및 수정 Books Reducer 추가 Combine Reducer 수정 - books 리듀서 추가 Loading Reducer 수정 Services 추가 HOC Code 수정 Container 추가하기 SigninLoginFormContainer AddBookContainer BooksContainer HeaderContainer Home 관련 Component 추가하기 AddBookModal Component ContentUI Component Header Component SigninLoginForm 에 thunk 도입하기 Develop 5 라이브러리 인스톨하기 action, reducer, store 파일 삭제 모듈 만들기 auth.js books.js saga.js create.js HOC 수정하기 서비스 추가하기 Container 수정하기 AddBookContainer BooksContainer HeaderContainer SigninLoginForm Saga 적용하기 connected-react-router 적용하기 App.js index.js Develop 6 새로고침되는 것처럼 보이는 에러 해결하기 Edit Saga 추가하기 Edit Book Container 추가하기 Get Book Modal Component 추가하기 thunk 코드 삭제하기 페이지네이션 추가하기 라이브러리 인스톨하기 Head Component 추가하기 Home에 Head 추가하기 구현 영상 구현 사이트 바로가기해당 사이트는 AWS의 S3 버킷을 통해 배포되고 있습니다. 해당 사이트의 회원가입은 Personal로 관리되고 있습니다. 따라서 사이트 회원가입이 별도로 안되므로 iasg2004@naver.com 혹은 이슈로 코멘트를 달아주시면 둘러보실수 있는 ID/PW를 드리겠습니다. ( 이미지 클릭 시 구현 사이트로 이동됩니다. ) View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://hyeok999.github.io/tags/Redux/"}]},{"title":"GitHub Commit 독려 애플리케이션 ver.React","slug":"React-Carrot-And-Stick","date":"2020-03-09T09:03:07.000Z","updated":"2020-03-09T09:11:31.264Z","comments":true,"path":"2020/03/09/React-Carrot-And-Stick/","link":"","permalink":"https://hyeok999.github.io/2020/03/09/React-Carrot-And-Stick/","excerpt":"","text":"Carrot And Stick Ver.React해커톤 주제 기존 Vanila JS로 제작된 Carrot And Stick를 리액트로 리펙토링 + 로그인/로그아웃 구현 1. 팀 소개 팀명 : 채찍과 당근 팀장 : 김준혁 팀원 : 정다희 2. 팀 주제Git Commit 수에 따른 캐릭터 표정 변화 어플리케이션 입니다. 사용자의 학습 욕구를 도모하기 위해 만들었습니다. 3. 팀 목표&gt; 1차 목표 페이지 접속하자마자 Signin 페이지로 리다이렉트 됩니다. GitHub oAuth를 사용하여 로그인 토큰을 받아오고 그것을 토대로 로그인 페이지를 구현합니다. 로컬 스토리지에 토큰을 저장하고 토큰이 존재 할 경우 Home으로 바로 이동하게끔 구현합니다. &gt; 2차 목표 Carrot And Stick은 GitHub Api를 이용하여 Git에 회원가입이 된 닉네임을 토대로 하여 데이터를 불러오고 데이터의 특정 조건으로 커밋수를 검색 해 커밋수가 일정 이상일 시 캐릭터의 모습이 단계별로 렌더링되는 어플리케이션입니다. Carrot And Stick은 사용자의 학습 욕구를 도모하기 위해 만들어졌습니다. 로그인 성공 시 Home 화면으로 이동되는데 Home 화면은 Carrot And Stick을 React로 리펙토링하여 구현합니다. &gt; 3차 목표 로그아웃 기능을 구현합니다.(로컬스토리지 토큰 제거) 토큰의 유무에 따라 페이지를 라우팅 합니다. ( Signin, Home ) 로딩 페이지를 구현합니다. Not Found 페이지를 구현합니다. 4. 주제 선정 이유기능적인 측면 : GITHUB 관리를 위해 자신의 목표 커밋 수에 따라 스스로를 채찍질 하고, 스스로에게 칭찬(당근)을 할 수 있는 애플리케이션이 있다면 좋지 않을까? 기술적인 측면 : 지금까지 학습한 React 기술을 Vanila JS에 적용해보면서 React를 학습할 수 있습니다. 지난 번 Javascript 프로젝트를 하면서 생겼던 문제점(Git Hub Api 제한)을 로그인 및 로그아웃 기능, 토큰기능을 이용해 해결하고 UI를 좀 더 깔끔하게 할 수 있습니다. 5. 프로젝트 요구 사항 W3C에서 제공한 MarkUp Validation Service 에서 이상이 없을 것. 최대한 시멘틱 하게 작성할 것. Express 로 백엔드 구축 (GitHub oAuth 사용, CORS에러 방지) 여러 라이브러리 경험 GitHub API 로드 및 가공 캐릭터 및 로고 렌더링 ( SVG 활용 ) todo list 기능을 이용한 닉네임별로 관리되는 Git Daily Planner 개발 JS코드를 React로 리펙토링 할 것. Git 컨벤션을 최대한 지킬 것. 6. 구현 기술Front End HTML CSS SVG JavaScript React Back End Express.js Etc counterup2 Typed.js GitHub OAuth 7. 프로젝트 구현 영상 8. 느낀점 시간에 쫒기면서 하는 개발이다보니까 생각보다 사소한 실수가 많았던 것 같습니다. 백엔드를 구축하기에는 시간이 너무 모잘랐습니다. UI와 React에 초점을 두어야 했기 때문에 Express를 이용하여 간단하게 서버를 구축했습니다. GitHub Api에서 제공하는 oAuth를 구현하는데 시간이 지체되었습니다. 이유는 oAuth를 사용하기 위해서 단순히 API만 끌어다 쓰려했지만 CORS Error를 유발했기 때문입니다. 따라서 처음 계획과는 다르게 기획을 변경해야하는 문제가 있었습니다. React로 변경 작업 중 1박자 늦게 상태가 변화되는 문제를 발견했습니다. 문제의 원인은 비동기 통신에 대한 문제였고 게속 promise상태로 값을 받아왔기 때문에 일어났습니다. 해당 문제를 해결하고자 초기상태를 함수로 만들어 해결하였습니다. 로그인 토큰 기능을 이용해 토큰이 있을 경우 게속 로그인이 되어있도록 설정하였습니다. JS -&gt; React로 변환되면서 사소한 CSS 스타일이 작동이 안되는 원인이 있었습니다. 추가로, JS라이브러리(Typed.js, Coutup2.js)등이 제대로 작동되지 않는 문제점에서 시간이 지체 되었습니다. 해커톤을 진행하면서, JS로 작성된 코드를 리액트로 옮기는 방법을 습득하였습니다. 또한 초기 기획이 얼마나 중요하고 팀과의 소통을 통해서 컨벤션을 미리 작성해두어 프로젝트를 준비하는 것이 좋겠다는 생각을 가지게 되었습니다. View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"},{"name":"oAuth","slug":"oAuth","permalink":"https://hyeok999.github.io/tags/oAuth/"},{"name":"github oAhut","slug":"github-oAhut","permalink":"https://hyeok999.github.io/tags/github-oAhut/"}]},{"title":"ReactStudy-10","slug":"ReactStudy-10","date":"2020-02-28T09:16:33.000Z","updated":"2020-03-17T14:29:39.724Z","comments":true,"path":"2020/02/28/ReactStudy-10/","link":"","permalink":"https://hyeok999.github.io/2020/02/28/ReactStudy-10/","excerpt":"","text":"React Re-Study : 10 SPA 프로젝트 배포 이해하기 serve 패키지로 React Wep App 배포하기 AWS S3 버킷 에 React Wep App 배포하기 node.js express로 React Wep App 배포하기 NginX 서버사이드 렌더링 이해하기 Optimizing Performance React Study with Mark - Deploy &amp; Optimizing Performance - SPA 프로젝트 배포 이해하기 serve 패키지로 React Wep App 배포하기 AWS S3 에 React Wep App 배포하기 node.js express 로 React Wep App 배포하기 NginX 로 React Wep App 배포하기 서버사이드 렌더링 이해하기 모든 배포에는 build 폴더가 필요하다. npm run build 폴더에 build 폴더가 생긴다. build 폴더는 배포용, 나머지는 파일들은 개발자용 build 된 파일들을 웹서버를 통해 사용자가 접근할 수 있도록 처리 SPA 프로젝트 배포 이해하기 모든 요청을 서버에 하고 받아오는 형태가 아니다. 라우팅 경로에 상관없이 리액트 App을 받아서 실행한다. 라우팅은 받아온 리액트 App을 실행 후 적용한다. static파일을 제외한 모든 요청을 Index.html로 응답해주도록 작업한다. serve -s build AWS S3에 배포 node.js express NginX serve 패키지로 React Wep App 배포하기 12npm install serve -gserve -s build serve 라는 패키지를 전역으로 설치한다. serve 명령어를 -s 옵션으로 build 폴더를 지정하여 실행한다. -s 옵션은 어떤 라우팅으로 요청해도 index.html 을 응답하도록 한다. AWS S3 버킷 에 React Wep App 배포하기 Amazon S3 버킷 정적 웹 사이트 호스팅 버킷 정책 설정12345678910111213141516&#123; \"Version\": \"2012-10-17\", \"Statement\": [ &#123; \"Sid\": \"PublicReadGetObject\", \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": [ \"s3:GetObject\" ], \"Resource\": [ \"arn:aws:s3:::s3버킷명/*\" ] &#125; ]&#125; node.js express로 React Wep App 배포하기 1npm i express package.json 에 script 추가 “start:server”: “node server.js” Nest.js 123456789101112const express = require('express');const path = require('path');const app = express();app.use(express.static(path.join(__dirname, 'build')));// app.get('/', function(req, res) &#123;app.get('*', function(req, res) &#123; res.sendFile(path.join(__dirname, 'build', 'index.html'));&#125;);app.listen(9000); NginX Nginx는 웹 서버 소프트웨어 가벼움과 높은 성능을 목표로 한다. 트래픽을 최초로 받아주는 문지기 역할 리눅스 계열 , 도커, AWS EC2 등등에서 많이 사용됨. 서버사이드 렌더링 이해하기 차이점: 동작은 안되지만 잠깐 먼저 보이는 것 - 리액트 앱이 실행되는 순간 리액트 앱에 따라 바뀜 서버에서 응답을 가져올때, 기존 처럼 static file 만을 가져오는 것이 아니고, 먼저 서버에서 응답 값을 만들어서 내려주고, 그 후에 static file 을 내려준다. static file 을 다 내려받고, 리액트 앱을 브라우저에서 실행한 뒤에는 SPA 처럼 동작하게 된다. Next.js isomorphic javascript : 서버와 클라이언트 모두에서 돌 수 있는 자바스크립트여야 한다. React Server Side Rendering React Component 를 브라우저가 아니라 Node.js 에서 사용 ReactDOMServer.renderToString(); 결과가 문자열 -&gt; 응답으로 내려준다. 라우팅, 리덕스 와 같은 처리를 서버에서 진행하고 내려준다.(복잡하고 어려움) JSX 가 포함된 리액트 코드를 서버에서 읽을 수 있도록 babel 설정을 해야 한다. Next.js 추후 학습을 꼭 해볼 것. Optimizing Performance 필요할 때만 렌더하도록 하자. (예 - 값을 메모라이징 하여 비교후 변경될 경우 렌더링한다.) Reconciliation 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어 낸다. 개발자가 key prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해줄 수 있음 다른 엘리먼트일 때 같은 엘리먼트일 때 같은 컴포넌트일 때 렌더가 다시되는 경우 props가 바뀔 때 state가 바뀔 때 부모가 바뀔 때(첫번째와 동일하지만 상황이 다름) 자식에 대한 재귀적 처리(2)와 같은 상황 때문에 key를 씀 리액트는 맨 위에 추가된건지 마지막에 추가된건지 구분을 못하므로 shouldComponentUpdate에서 기존에 있던 컴포넌트는 또 렌더를 하지 않도록 리턴 타입 : boolean 타입 요즘은 useMemo","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"ReactStudy-09","slug":"ReactStudy-09","date":"2020-02-27T14:16:33.000Z","updated":"2020-03-16T14:19:19.149Z","comments":true,"path":"2020/02/27/ReactStudy-09/","link":"","permalink":"https://hyeok999.github.io/2020/02/27/ReactStudy-09/","excerpt":"","text":"React Re-Study : 9 Unit Test facebook/jest jest 3가지 문법 it (= test), describe, expect .not.to jest는 기본으로 한 테스트가 5초로 설정되어 있다. react-component-test 실습 컴포넌트 테스트 짜보기 Button 컴포넌트 enzyme 컨테이너 테스트 React Study with Mark - React Testing - JavaScript Unit Test Jest 리액트 컴포넌트 테스트 react-testing-library 활용하기 리덕스 / 비동기작업의 테스트 Unit Test TDD : Test Driven Development - 테스트 주도 개발→ 코딩이 아니라 테스트코드를 먼저 작성 하는 개발 방식. 통합테스트에 비해 빠르고 쉽다. 통합테스트를 진행하기 전에 문제를 찾아낼 수 있다. 그렇다고, 통합테스트가 성공하리란 보장은 없다. 테스트 코드가 살아있는(동작을 설명하는) 명세가 된다. 테스트를 읽고 어떻게 동작하는지도 예측 가능하다. (선 코딩 후, (몰아서) 단위테스트가 아닌…) 소프트웨어 장인이 되려면 TDD를 해야한다. facebook/jest Jest : Test Runner (실행) Mocha에 비해 느리지만, npx로 만든 react프로젝트를 생성할 경우 기본 탑재되어있다. 리액트의 영향이 크겠지만 가장 핫한 테스트 도구 👩🏻‍💻 Easy Setup 🏃🏽 Instant Feedback 고친 파일만 빠르게 테스트 다시 해주는 기능 등 📸 Snapshot Testing 컴포넌트 테스트에 중요한 역할을 하는 스냅샷 jest 3가지 문법 assert.equal(a, b); → node.js의 내장 API expect(a).toBe(b); → jest는 기본적으로 expect 제공 a.should.be(b); → Chai 라이브러리 it (= test), describe, expect 테스트의 단위 설정 describe는 카테고리화를 의미한다. expect().toBe()는 원시값. expect().toEqual()는 참조값.(객체) 123456789101112131415161718192021222324252627describe('expect test', () =&gt; &#123; it('37 to equal 37', () =&gt; &#123; const received = 37; const expected = 37; expect(received).toBe(expected); &#125;); it('&#123;age: 37&#125; to equal &#123;age: 37&#125;', () =&gt; &#123; const received = &#123; age: 37, &#125;; const expected = &#123; age: 37, &#125;; expect(received).toBe(expected); &#125;); it('&#123;age: 37&#125; to equal &#123;age: 37&#125;', () =&gt; &#123; const received = &#123; age: 37, &#125;; const expected = &#123; age: 37, &#125;; expect(received).toEqual(expected); &#125;);&#125;); .not.to 의미상으로 37은 36이 아니어야 한다/37은 36이 아니다가 다름 12345678910111213141516describe('.not.to~ test', () =&gt; &#123; it('.not.toBe', () =&gt; &#123; expect(37).not.toBe(36); &#125;); it('.not.toBeFalsy', () =&gt; &#123; expect(true).not.toBeFalsy(); expect(1).not.toBeFalsy(); expect('hello').not.toBeFalsy(); expect(&#123;&#125;).not.toBeFalsy(); &#125;); it('.not.toBeGreaterThan', () =&gt; &#123; expect(10).not.toBeGreaterThan(10); &#125;);&#125;); jest는 기본으로 한 테스트가 5초로 설정되어 있다. 그 이상을 원할 경우 jest.setTimeout(30000)과 같이 별도의 값을 설정해야 한다. react-component-test 마틴 파울러, 켄트 백, Kent C. Dodde(테스팅 라이브러리) 테스트를 통과하는 최소한의 행동만 함. ‘버튼이 눌렸다’ 같은 행동은 onClick같은 이벤트 핸들러를 생각 하면 안된다. (일단은 텍스트만 넣고 다음 단계로 넘어가면서 문제가 생길 때 해결해야 한다.) 5초 지난 후 워닝 메시지가 뜰 경우, timer를 null로 초기화. 처음 클릭할 때 넘어가서 메시지 셋팅되고 셋타임아웃을 한 인티저가 들어가서 언마운트 될 때 인티저(넘버)면 clearTimeout을 해준다. functinal conponent안에 let을 써서 해결하는 경우는 없다.(let timer XXXX → ref를 이용해서 해결) 앞의 렌더와 뒤의 렌더는 서로 공유될 수 없다. 렌더가 다시 되어도 Referrence가 유지되어야 한다 -&gt; useRef 테스트 종료 후 코드를 수정할 때 앞의 테스트가 깨지지 않으면 된다.(회귀 테스트) 실습 컴포넌트 테스트 짜보기 Given - When - Then 으로 작성한다. bash 명령어 : npm test “scripts”: { … , “test”: “react-scripts test”, … } 12345678910111213// 예시 it(`버튼을 클릭하면, p 태그 안에 \"버튼이 방금 눌렸다.\" 라고 쓰여진다.`, () =&gt; &#123; // Given const &#123; getByText &#125; = render(&lt;Button /&gt;); const button = getByText('button'); // When fireEvent.click(button); // Then const p = getByText('버튼이 방금 눌렸다.'); expect(p).toBeInstanceOf(HTMLParagraphElement); &#125;); Button 컴포넌트 컴포넌트가 정상적으로 생성된다. *”button” 이라고 쓰여있는 엘리먼트는 HTMLButtonElement 이다.* 버튼을 클릭하면, p 태그 안에 “버튼이 방금 눌렸다.” 라고 쓰여진다. 버튼을 클릭하기 전에는, p 태그 안에 “버튼이 눌리지 않았다.” 라고 쓰여진다. 버튼을 클릭하고 5초 뒤에는, p 태그 안에 “버튼이 눌리지 않았다.” 라고 쓰여진다. 버튼을 클릭하면, 5초 동안 버튼이 비활성화 된다. 컴포넌트가 정상적으로 생성된다. 123456789101112131415// src/components/Button.test.jsimport React from \"react\";import Button from \"./Button\";import &#123; render &#125; from \"@testing-library/react\";describe(\"Button 컴포넌트 (@testing-library/react)\", () =&gt; &#123; it(\"컴포넌트가 정상적으로 생성된다.\", async () =&gt; &#123; render(&lt;Button /&gt;); &#125;);&#125;);// src/components/Button.jsximport React from \"react\";const Button = () =&gt; &lt;&gt;&lt;/&gt;;export default Button; *”button” 이라고 쓰여있는 엘리먼트는 HTMLButtonElement 이다.* 123456789101112131415// src/components/Button.test.jsdescribe(\"Button 컴포넌트\", () =&gt; &#123; // ... it(`\"button\" 이라고 쓰여있는 엘리먼트는 HTMLButtonElement 이다.`, () =&gt; &#123; const &#123; getByText &#125; = render(&lt;Button /&gt;); const buttonElement = getByText(\"button\"); expect(buttonElement).toBeInstanceOf(HTMLButtonElement); &#125;);&#125;);// src/components/Button.jsximport React from \"react\";const Button = () =&gt; &lt;button&gt;button&lt;/button&gt;;export default Button; 버튼을 클릭하면, p 태그 안에 “버튼이 방금 눌렸다.” 라고 쓰여진다. 1234567891011121314151617181920212223// src/components/Button.test.jsdescribe(\"Button 컴포넌트 (@testing-library/react)\", () =&gt; &#123; // ... it(`버튼을 클릭하면, p 태그 안에 \"버튼이 방금 눌렸다.\" 라고 쓰여진다.`, () =&gt; &#123; const &#123; getByText &#125; = render(&lt;Button /&gt;); const button = getByText(\"button\"); fireEvent.click(button); const p = getByText(\"버튼이 방금 눌렸다.\"); expect(p).not.toBeNull(); expect(p).toBeInstanceOf(HTMLParagraphElement); &#125;);&#125;);// src/components/Button.jsximport React from \"react\";const Button = () =&gt; ( &lt;&gt; &lt;button&gt;button&lt;/button&gt; &lt;p&gt;버튼이 방금 눌렸다.&lt;/p&gt; &lt;/&gt;);export default Button; 버튼을 클릭하기 전에는, p 태그 안에 “버튼이 눌리지 않았다.” 라고 쓰여진다. 123456789101112131415161718192021222324252627282930// src/components/Button.test.jsdescribe(\"Button 컴포넌트 (@testing-library/react)\", () =&gt; &#123; // ... it(`버튼을 클릭하기 전에는, p 태그 안에 \"버튼이 눌리지 않았다.\" 라고 쓰여진다.`, () =&gt; &#123; const &#123; getByText &#125; = render(&lt;Button /&gt;); const p = getByText(\"버튼이 눌리지 않았다.\"); expect(p).not.toBeNull(); expect(p).toBeInstanceOf(HTMLParagraphElement); &#125;);&#125;);// src/components/Button.jsximport React, &#123; useState &#125; from \"react\";const Button = () =&gt; &#123; const [message, setMessage] = useState(\"버튼이 눌리지 않았다.\"); function click() &#123; setMessage(\"버튼이 방금 눌렸다.\"); &#125; return ( &lt;&gt; &lt;button onClick=&#123;click&#125;&gt;button&lt;/button&gt; &lt;p&gt;&#123;message&#125;&lt;/p&gt; &lt;/&gt; );&#125;;export default Button; 버튼을 클릭하고 5초 뒤에는, p 태그 안에 “버튼이 눌리지 않았다.” 라고 쓰여진다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// src/components/Button.test.jsjest.useFakeTimers();describe(\"Button 컴포넌트 (@testing-library/react)\", () =&gt; &#123; // ... it(`버튼을 클릭하고 5초 뒤에는, p 태그 안에 \"버튼이 눌리지 않았다.\" 라고 쓰여진다.`, async () =&gt; &#123; const &#123; getByText &#125; = render(&lt;Button /&gt;); const button = getByText(\"button\"); fireEvent.click(button); act(() =&gt; &#123; jest.advanceTimersByTime(5000); &#125;); const p = getByText(\"버튼이 눌리지 않았다.\"); expect(p).not.toBeNull(); expect(p).toBeInstanceOf(HTMLParagraphElement); &#125;);&#125;);// src/components/Button.jsximport React, &#123; useState, useEffect, useRef &#125; from \"react\";const Button = () =&gt; &#123; const [message, setMessage] = useState(\"버튼이 눌리지 않았다.\"); const timer = useRef(null); function click() &#123; if (timer.current !== null) clearTimeout(timer); setMessage(\"버튼이 방금 눌렸다.\"); timer.current = setTimeout(() =&gt; &#123; setMessage(\"버튼이 눌리지 않았다.\"); &#125;, 5000); &#125; useEffect(() =&gt; &#123; return () =&gt; &#123; if (timer.current !== null) clearTimeout(timer.current); &#125;; &#125;, []); return ( &lt;&gt; &lt;button onClick=&#123;click&#125;&gt;button&lt;/button&gt; &lt;p&gt;&#123;message&#125;&lt;/p&gt; &lt;/&gt; );&#125;;export default Button; 버튼을 클릭하면, 5초 동안 버튼이 비활성화 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// src/components/Button.test.jsjest.useFakeTimers();describe(\"Button 컴포넌트 (@testing-library/react)\", () =&gt; &#123; // ... it(`버튼을 클릭하면, 5초 동안 버튼이 비활성화 된다.`, () =&gt; &#123; const &#123; getByText &#125; = render(&lt;Button /&gt;); const button = getByText(\"button\"); fireEvent.click(button); // expect(button).toBeDisabled(); expect(button.disabled).toBeTruthy(); act(() =&gt; &#123; jest.advanceTimersByTime(5000); &#125;); // expect(button).not.toBeDisabled(); expect(button.disabled).toBeFalsy(); &#125;);&#125;);// src/components/Button.jsximport React, &#123; useState, useEffect, useRef &#125; from \"react\";const Button = () =&gt; &#123; const [message, setMessage] = useState(\"버튼이 눌리지 않았다.\"); const timer = useRef(null); function click() &#123; if (timer.current !== null) clearTimeout(timer); setMessage(\"버튼이 방금 눌렸다.\"); timer.current = setTimeout(() =&gt; &#123; setMessage(\"버튼이 눌리지 않았다.\"); &#125;, 5000); &#125; useEffect(() =&gt; &#123; return () =&gt; &#123; if (timer.current !== null) clearTimeout(timer.current); &#125;; &#125;, []); return ( &lt;&gt; &lt;button onClick=&#123;click&#125; disabled=&#123;message === \"버튼이 방금 눌렸다.\"&#125;&gt; button &lt;/button&gt; &lt;p&gt;&#123;message&#125;&lt;/p&gt; &lt;/&gt; );&#125;;export default Button; enzyme 렌더를 시킨다음에 렌더된 결과물을 래퍼라고 하는 클래스형태로 래퍼해놓은 다른 데이터 객체를 사용 리액트 버전에 따라 래핑된 데이터 구조가 다를 수 있기 때문에 리액트 버전을 맞춰 주어야 함 jest는 테스트 프레임워크 enzyme는 테스트 라이브러리 enzyme에는 adapter를 적용하는 configure를 제외하면 크게 세 가지 메소드가 있다. shallow, mount, render (API) shallow: 간단한 컴포넌트를 메모리 상에 렌더링한다. 단일 컴포넌트를 테스트할 때 유용하다. mount: HOC나 자식 컴포넌트까지 전부 렌더링한다. 다른 컴포넌트와의 관계를 테스트할 때 유용하다. render: 컴포넌트를 정적인 html로 렌더링한다. 컴포넌트가 브라우저에 붙었을 때 html로 어떻게 되는지 판단할 때 사용한다. 컨테이너 테스트 1234567891011121314151617181920212223242526272829import React from \"react\";import Enzyme, &#123; mount &#125; from \"enzyme\";import BooksContainer from \"./BooksContainer\";import configureMockStore from \"redux-mock-store\";import Adapter from \"enzyme-adapter-react-16\";Enzyme.configure(&#123; adapter: new Adapter() &#125;);describe(\"BookContainer\", () =&gt; &#123; const mockStore = configureMockStore(); // 가짜 스토어 만들기 let store = mockStore(&#123; books: [], loading: false, error: null, token: \"\", router: &#123; location: &#123; pathname: \"/\" &#125; &#125; &#125;); it(\"renders properly\", () =&gt; &#123; const component = mount(&lt;BooksContainer store=&#123;store&#125; /&gt;); expect(component).toMatchSnapshot(); &#125;);&#125;); 12345678910111213141516171819202122232425262728293031323334353637// Jest Snapshot v1, https://goo.gl/fbAQLPexports[`BookContainer renders properly 1`] = `&lt;Connect(Books) store=&#123; Object &#123; \"clearActions\": [Function], \"dispatch\": [Function], \"getActions\": [Function], \"getState\": [Function], \"replaceReducer\": [Function], \"subscribe\": [Function], &#125; &#125;&gt; &lt;Books books=&#123;Array []&#125; error=&#123;null&#125; loading=&#123;false&#125; requestBooksPromise=&#123;[Function]&#125; requestBooksSaga=&#123;[Function]&#125; requestBooksThunk=&#123;[Function]&#125; store=&#123; Object &#123; \"clearActions\": [Function], \"dispatch\": [Function], \"getActions\": [Function], \"getState\": [Function], \"replaceReducer\": [Function], \"subscribe\": [Function], &#125; &#125; &gt; &lt;div /&gt; &lt;/Books&gt;&lt;/Connect(Books)&gt;`;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"ReactStudy-08","slug":"ReactStudy-08","date":"2020-02-26T11:59:59.000Z","updated":"2020-03-10T12:02:20.583Z","comments":true,"path":"2020/02/26/ReactStudy-08/","link":"","permalink":"https://hyeok999.github.io/2020/02/26/ReactStudy-08/","excerpt":"","text":"React Re-Study : 8 Ducks Pattern 규칙 connect with hooks 기존방식 -&gt; src/containers/BooksContainer.jsx Hooks방식 -&gt; src/containers/BooksContainer.jsx react-router와 redux함께 쓰기 redux-saga 제너레이터 redux-actions React Study with Mark - Redux Advanced (2) - Ducks Pattern 전에는 action 폴더에 ActionType, Action을 모아놓고 reducer폴더에 Reducer를 모아놓았다. 이렇게 될 경우 단점은, 하나의 기능을 수정하더라도로 2개의 파일을 전부다 왔다 갔다 해야만 한다. ( Redux 공식 문서에서는 ActionType,Action, Reducer 전부 따로 관리하기에 3개의 파일을 수정해야함 ) 이러한 단점을 상쇄하고자 기능별로 ActionType, Action, Reducer 를 묶어 놓는 방식인 Ducks Pattern 을 사용하도록 한다. 하나의 파일에 액션, 액션 생성자, 리듀서가 있음. 규칙 use case에 따라 {actionTypes, actions, reducer} 한 벌(한 조각)을 하나의 독립된 모듈로 묶어서 관리하도록한다. 하나의 모듈은… 항상 reducer()란 이름의 함수를 export default 해야한다. 항상 모듈의 action 생성자들을 함수형태로 export 해야한다. 항상 npm-module-or-app/reducer/ACTION_TYPE 형태의 action 타입을 가져야 한다. 어쩌면 action 타입들을 UPPER_SNAKE_CASE로 export 할 수 있다. 만약, 외부 reducer가 해당 action들이 발생하는지 계속 기다리거나, 재사용할 수 있는 라이브러리로 퍼블리싱할 경우. 재사용가능한 Redux 라이브러리 형태로 공유하는 {actionType, action, reducer} 묶음에도 위 규칙을 추천한다. src/redux/modules/books.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// src/redux/modules/books.jsimport BookService from '../../services/BookService';// 액션 타입 정의 (\"app 이름\"/\"reducer 이름\"/\"로컬 ACTION_TYPE\") =&gt; 겹치지 않게 하기 위함 (덕스 규칙)const PENDING = 'reactjs-books-review/books/PENDING';const SUCCESS = 'reactjs-books-review/books/SUCCESS';const FAIL = 'reactjs-books-review/books/FAIL';// 리듀서 초기값const initialState = &#123; books: [], loading: false, error: null,&#125;;// 액션 생성자 함수const start = () =&gt; (&#123; type: PENDING &#125;);const success = books =&gt; (&#123; type: SUCCESS, books &#125;);const fail = error =&gt; (&#123; type: FAIL, error &#125;);// thunk 함수export const getBooks = token =&gt; async dispatch =&gt; &#123; dispatch(start()); try &#123; await sleep(2000); const res = await BookService.getBooks(token); dispatch(success(res.data)); &#125; catch (error) &#123; dispatch(fail(error)); &#125;&#125;;// 리듀서const books = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case PENDING: return &#123; books: [], loading: true, error: null, &#125;; case SUCCESS: return &#123; books: [...action.books], loading: false, error: null, &#125;; case FAIL: return &#123; books: [], loading: false, error: action.error, &#125;; default: return state; &#125;&#125;;export default books;function sleep(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, ms); &#125;);&#125; src/redux/modules/reducer.js 해당 파일은 모든 reducer들을 하나로 묶는 combinReducers 역할을 한다. 12345678910import &#123; combineReducers &#125; from 'redux';import auth from './auth';import books from './books';const reducer = combineReducers(&#123; auth, books,&#125;);export default reducer; src/redux/create.js store.js 에 있던 내용을 create.js 에 옮겨준다. 1234567891011121314151617181920212223import &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './modules/reducer';import &#123; composeWithDevTools &#125; from 'redux-devtools-extension';import thunk from 'redux-thunk';export default function create(token) &#123; const initialState = &#123; books: undefined, auth: &#123; token, loading: false, error: null, &#125;, &#125;; const store = createStore( reducer, initialState, composeWithDevTools(applyMiddleware(thunk)), ); return store;&#125; connect with hooks connect함수 대신에 hooks을 이용하여 기존방식 -&gt; src/containers/BooksContainer.jsx123456789101112131415161718import &#123; connect &#125; from 'react-redux';import Books from '../components/Books';import &#123; getBooks &#125; from '../redux/modules/books';const mapStateToProps = state =&gt; (&#123; token: state.auth.token, books: state.books.books, loading: state.books.loading, error: state.books.error,&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; getBooks: token =&gt; &#123; dispatch(getBooks(token)); &#125;,&#125;);export default connect(mapStateToProps, mapDispatchToProps)(Books); Hooks방식 -&gt; src/containers/BooksContainer.jsx 주의 할 점: useCallback을 쓰지 않으면 계속 getBooks라는 함수를 만들기 때문에 계속 실행됨 12345678910111213141516171819202122232425262728293031import React, &#123; useCallback &#125; from 'react';import &#123; useSelector, useDispatch &#125; from 'react-redux';import Books from '../components/Books';import &#123; getBooks as getBooksAction &#125; from '../redux/modules/books';const BooksContainer = props =&gt; &#123; const token = useSelector(state =&gt; state.auth.token); const &#123; books, loading, error &#125; = useSelector(state =&gt; state.books); const dispatch = useDispatch(); /* const getBooks = useCallback(() =&gt; &#123; dispatch(getBooksAction(token)); &#125;, [token, dispatch]); // token 을 보낼 필요 없다. */ const getBooks = useCallback(() =&gt; &#123; dispatch(getBooksAction()); // token 을 thunk 안에서 처리 &#125;, [dispatch]); return ( &lt;Books &#123;...props&#125; books=&#123;books&#125; loading=&#123;loading&#125; error=&#123;error&#125; getBooks=&#123;getBooks&#125; /&gt; );&#125;;export default BooksContainer; react-router와 redux함께 쓰기 npm install connected-react-router 단방향 흐름 (예 : 히스토리-&gt; 저장소-&gt; 라우터-&gt; 구성 요소)을 통해 라우터 상태를 redux 저장소와 동기화한다. 즉, 이제부터는 router를 redux로 관리한다. 적용 순서는 다음과 같다. reducer.js에 router 라는 state를 combine creat.js에 store에 routerMiddleware를 추가 App.js에 ConnectedRouter를 추가 auth.js에 history.push() 대신 dispatch(push())를 추가 reducer.js에 router 라는 state를 combine 123456789101112131415// src/redux/modules/reducer.jsimport &#123; combineReducers &#125; from 'redux';import auth from './auth';import books from './books';import &#123; connectRouter &#125; from 'connected-react-router';const reducer = history =&gt; combineReducers(&#123; auth, books, router: connectRouter(history), &#125;);export default reducer; creat.js에 store에 routerMiddleware를 추가 1234567891011121314151617181920212223242526272829// src/redux/create.jsimport &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './modules/reducer';import &#123; composeWithDevTools &#125; from 'redux-devtools-extension';import thunk from 'redux-thunk';import &#123; createBrowserHistory &#125; from 'history';import &#123; routerMiddleware &#125; from 'connected-react-router';export const history = createBrowserHistory();export default function create(token) &#123; const initialState = &#123; books: undefined, auth: &#123; token, loading: false, error: null, &#125;, &#125;; const store = createStore( reducer(history), initialState, composeWithDevTools(applyMiddleware(thunk, routerMiddleware(history))), ); return store;&#125; App.js에 ConnectedRouter를 추가 123456789101112131415161718192021222324import React from 'react';import &#123; Switch, Route &#125; from 'react-router-dom';import Home from './pages/Home';import Signin from './pages/Signin';import NotFound from './pages/NotFound';import ErrorBoundary from 'react-error-boundary';import &#123; ConnectedRouter &#125; from 'connected-react-router';import &#123; history &#125; from './redux/create';const ErrorFallbackComponent = (&#123; error &#125;) =&gt; &lt;div&gt;&#123;error.message&#125;&lt;/div&gt;;const App = () =&gt; ( &lt;ErrorBoundary FallbackComponent=&#123;ErrorFallbackComponent&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route exact path=\"/signin\" component=&#123;Signin&#125; /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/ConnectedRouter&gt; &lt;/ErrorBoundary&gt;);export default App; auth.js에 history.push() 대신 dispatch(push())를 추가 1234567891011121314// src/redux/modules/auth.jsexport const login = (email, password) =&gt; async dispatch =&gt; &#123; try &#123; dispatch(start()); const res = await UserService.login(email, password); const &#123; token &#125; = res.data; localStorage.setItem('token', token); dispatch(success(token)); dispatch(push('/')); &#125; catch (error) &#123; dispatch(fail(error)); &#125;&#125;; redux-saga npm install redux-saga thunk함수는 함수를 리턴, saga는 그냥 보통 일반적인 액션을 디스패치. 미들웨어. 제너레이터 객체를 만들어 내는 제네레이터 생성 함수를 이용한다. 만드는 순서 사가 미들웨어를 리덕스 미들웨어로 설정 사가 함수 만들기 사가함수를 실행하는 사가 만들기 여러 사가 모듈을 합친 rootSaga 만들기 rootSaga 를 사가 미들웨어로 실행 나의 사가 함수를 시작하게 할 액션을 디스패치 제너레이터redux-saga/effects에는 다양한 리덕스-사가 이펙츠가 있는데 이것을 사용하기 위해서는 제너레이터를 사용해야만 한다. 123456789101112131415161718192021222324// saga 함수function* getBooksSaga() &#123; // 비동기 로직을 수행가능하다. // const token = action.payload.token; const token = yield select(state =&gt; state.auth.token); try &#123; // dispatch(pending()); yield put(pending()); // await sleep(2000); yield delay(2000); // const res = await BookRequest.getBooks(token); const res = yield call(BookRequest.getBooks, token); // dispatch(success(res.data)); yield put(success(res.data)); &#125; catch (error) &#123; // dispatch(fail(error)); yield put(fail(error)); &#125;&#125;export function* booksSaga() &#123; yield takeEvery(START_BOOKS_SAGA, getBooksSaga) // 어떤 함수를 실행하면 어떤 액션이 실행된다. (액션타입, 사가이름)&#125; thunk는 비동기 로직을 직접 실행 하고 다뤄야 하지만, saga는 비동기 로직을 대신 다뤄준다. 비동기 로직 중간에 행해야 할 일들(비동기 중단, 다시하기, 딜레이 등등)을 정의할 수 있다. 만드는 순서 사가 미들웨어를 리덕스 미들웨어로 설정 12345678910111213141516171819202122232425262728293031323334// src/redux/create.jsimport &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './modules/reducer';import &#123; composeWithDevTools &#125; from 'redux-devtools-extension';import thunk from 'redux-thunk';import &#123; createBrowserHistory &#125; from 'history';import &#123; routerMiddleware &#125; from 'connected-react-router';import createSagaMiddleware from 'redux-saga'; // 1. importexport const history = createBrowserHistory();const sagaMiddleware = createSagaMiddleware(); // 2. saga 미들웨어 생성export default function create(token) &#123; const initialState = &#123; books: undefined, auth: &#123; token, loading: false, error: null, &#125;, &#125;; const store = createStore( reducer(history), initialState, composeWithDevTools( applyMiddleware(thunk, routerMiddleware(history), sagaMiddleware), // 3. 리덕스 미들웨어에 saga 미들웨어 추가 ), ); return store;&#125; *사가 함수 만들기 * 12345678910111213141516// src/redux/modules/books.jsimport &#123; delay, put, call &#125; from 'redux-saga'; // 사가 이펙트 추가// saga 함수function* getBooksSaga(action) &#123; const token = action.payload.token; yield put(start()); try &#123; yield delay(2000); const res = yield call(BookService.getBooks, token); yield put(success(res.data)); &#125; catch (error) &#123; yield put(fail(error)); &#125;&#125; 사가함수를 실행하는 사가 만들기 123456789101112131415161718192021222324252627// src/redux/modules/books.jsimport &#123; delay, put, call, takeEvery &#125; from 'redux-saga/effects'; // 사가 이펙트 추가// saga 함수function* getBooksSaga(action) &#123; const token = action.payload.token; yield put(start()); try &#123; yield delay(2000); const res = yield call(BookService.getBooks, token); yield put(success(res.data)); &#125; catch (error) &#123; yield put(fail(error)); &#125;&#125;// getBooksSaga 를 시작하는 액션 타입 정의const START_SAGA = 'START_SAGA';// getBooksSaga 를 시작하는 액션 생성 함수export const startSaga = token =&gt; (&#123; type: START_SAGA, payload: &#123; token &#125; &#125;);// saga 함수를 등록하는 sagaexport function* booksSaga() &#123; yield takeEvery(START_SAGA, getBooksSaga);&#125; 여러 사가 모듈을 합친 rootSaga 만들기 12345678// src/redux/modules/saga.jsimport &#123; all &#125; from 'redux-saga/effects';import &#123; booksSaga &#125; from './books';export default function* rootSaga() &#123; yield all([booksSaga()]);&#125; rootSaga 를 사가 미들웨어로 실행 123456789101112131415161718192021222324252627282930313233343536// src/redux/create.jsimport &#123; createStore, applyMiddleware &#125; from 'redux';import reducer from './modules/reducer';import &#123; composeWithDevTools &#125; from 'redux-devtools-extension';import thunk from 'redux-thunk';import &#123; createBrowserHistory &#125; from 'history';import &#123; routerMiddleware &#125; from 'connected-react-router';import createSagaMiddleware from 'redux-saga';import rootSaga from './modules/saga'; // 나의 사가 가져오기export const history = createBrowserHistory();const sagaMiddleware = createSagaMiddleware();export default function create(token) &#123; const initialState = &#123; books: undefined, auth: &#123; token, loading: false, error: null, &#125;, &#125;; const store = createStore( reducer(history), initialState, composeWithDevTools( applyMiddleware(thunk, routerMiddleware(history), sagaMiddleware), ), ); sagaMiddleware.run(rootSaga); // 나의 사가들을 실행 return store;&#125; 나의 사가 함수를 시작하게 할 액션을 디스패치 1234567891011121314151617181920212223242526272829// src/containers/BooksContainer.jsximport React, &#123; useCallback &#125; from 'react';import &#123; useSelector, useDispatch &#125; from 'react-redux';import Books from '../components/Books';import &#123; startSaga &#125; from '../redux/modules/books';const BooksContainer = props =&gt; &#123; const token = useSelector(state =&gt; state.auth.token); const &#123; books, loading, error &#125; = useSelector(state =&gt; state.books); const dispatch = useDispatch(); const getBooks = useCallback(() =&gt; &#123; dispatch(startSaga(token)); // 이제 token이 필요없다. &#125;, [token, dispatch]); // 이제 token이 필요없다. return ( &lt;Books &#123;...props&#125; books=&#123;books&#125; loading=&#123;loading&#125; error=&#123;error&#125; getBooks=&#123;getBooks&#125; /&gt; );&#125;;export default BooksContainer; redux-actions npm i redux-actions 모듈 만드는 방법을 쉽게 제공한다. 모듈 내에서 액션과 액션타입을 동시에 정의가 가능하다. ( createActions ) 12345678910const &#123; success, pending, fail &#125; = createActions(&#123; SUCCESS: books =&gt; (&#123; books &#125;),&#125;, 'PENDING', 'FAIL', &#123; prefix: 'reactjs-books-review/books', namespace: '/' // default값이 /, -붙으면 reactjs-books-review/books-PENDING&#125;);console.log(pending());console.log(success(['hello']));console.log(fail(new Error)); createAction은 이름이 변경 가능하다. (createActions는 불가능.) handleActions은 기존의 reducer를 대체한다. 123456789101112131415const options = &#123; prefix: 'reactjs-books-review/books', namespace: '/' // default값이 /, -붙으면 reactjs-books-review/books-PENDING&#125;;const books = handleActions(&#123; PENDING: (state, action) =&gt; (&#123; books: [], loading: true, error: null &#125;), SUCCESS: (state, action) =&gt; (&#123; books: action.payload.books, loading: false, error: null &#125;), FAIL: (state, action) =&gt; (&#123; books: [], loading: true, error: action.payload &#125;), // 페이로드에 에러객체&#125;, initialState, options);export default books;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"ReactStudy-07","slug":"ReactStudy-07","date":"2020-02-25T11:15:22.000Z","updated":"2020-03-10T11:58:15.283Z","comments":true,"path":"2020/02/25/ReactStudy-07/","link":"","permalink":"https://hyeok999.github.io/2020/02/25/ReactStudy-07/","excerpt":"","text":"React Re-Study : 7 시작하기 앞서 정리하기 프리젠테이셜 컴포넌트 와 컨테이너 컴포넌트 프리젠테이셔널 컴포넌트 컨테이너 컴포넌트 이 구조의 장점 어떤걸 컨테이너로 만들어야할까? Async Action with Redux 비동기 처리를 위한 액션 추가 및 dispatch (예시) 리덕스 미들웨어 미들웨어 만들어보기 Redux Dev Tools redux-thunk 실습 서비스 분리 HOC에 옵션을 주는 방법 React Study with Mark - Redux Advanced (1) -시작하기 앞서 정리하기 컴포넌트의 모습을 결정하는 요인 2가지 props state 만약 다른것에 의해 컴포넌트가 다른 모습을 띈다면 컴포넌트를 신뢰할 수 없음(ex. error) side effect side effect란 ? 함수가 일관된 결과를 보장하지 못하거나, 함수 외부 어디든지 조금이라도 영향을 주는 경우 모두 사이드 이펙트를 갖는 것 history.push 역시 side effect → React Re-Study : 8에서 디스패치로 해겨한다. 프리젠테이셜 컴포넌트 와 컨테이너 컴포넌트 리덕스를 사용하는 프로젝트에서 자주 사용되는 구조 Dumb 컴포넌트와 Smart 컴포넌트로도 알려져있다. 프리젠테이셔널 컴포넌트 프리젠테이셔널 컴포넌트는 오직 뷰만을 담당하는 컴포넌트이다. DOM 엘리먼트, 스타일을 갖고 있으며, 프리젠테이셔널 컴포넌트나 컨테이너 컴포넌트를 가지고 있을 수도 있다. 하지만, 리덕스의 스토어에는 직접적인 접근 권한이 없으며 오직 props 로만 데이터를 가져올수 있다. 또한, 대부분의 경우 state 를 갖고있지 않으며, 갖고 있을 경우엔 데이터에 관련된 것이 아니라 UI 에 관련된 것이어야 한다. 주로 함수형 컴포넌트로 작성되며, state 를 갖고있어야하거나, 최적화를 위해 LifeCycle 이 필요해질때 클래스형 컴포넌트로 작성된다. 컨테이너 컴포넌트 프리젠테이셔널 컴포넌트들과 컨테이너 컴포넌트들을 관리하는것을 담당한다. 주로 내부에 DOM 엘리먼트가 직접적으로 사용되는 경우는 적으며 사용되는 경우는 감싸는 용도일때만 사용 된다. 스타일을 가지고있지 않아야 한다. 스타일들은 모두 프리젠테이셔널 컴포넌트에서 정의되어야 한다. 상태를 가지고 있을 때가 많으며, 리덕스에 직접적으로 접근 할 수 있다. 이 구조의 장점 UI 쪽과 Data 쪽이 분리되어 프로젝트를 이해하기가 쉬워지며, 컴포넌트의 재사용률을 높여준다. 어떤걸 컨테이너로 만들어야할까? 페이지 리스트 헤더 사이드바 내부의 컴포넌트 때문에 props가 여러 컴포넌트를 거쳐야 하는 경우 Async Action with Redux Q : 비동기 작업을 어디서 하느냐 ? A : dispatch 를 할 때 해준다. 당연히 리듀서는 동기적인 것 → Pure dispatch 도 동기적인 것 비동기 처리를 위한 액션 추가 및 dispatch (예시) 123456789101112131415161718192021222324// 액션 정의export const START_RECEIVE_BOOKS = 'START_RECEIVE_BOOKS';export const END_RECEIVE_BOOKS = 'END_RECEIVE_BOOKS';export const ERROR_RECEIVE_BOOKS = 'ERROR_RECEIVE_BOOKS';// 액션 생성자 함수export function startReceiveBooks() &#123; return &#123; type: START_RECEIVE_BOOKS, &#125;;&#125;export function endReceiveBooks(books) &#123; return &#123; type: END_RECEIVE_BOOKS, books, &#125;;&#125;export function errorReceiveBooks() &#123; return &#123; type: ERROR_RECEIVE_BOOKS, &#125;;&#125; 123456789101112131415161718192021// mapDispatchToProps =&gt; dispatch// 위치 : 컨테이너 혹은 해당 페이지const mapDispatchToProps = dispatch =&gt; (&#123; requestBooks: async token =&gt; &#123; dispatch(startLoading()); dispatch(clearError()); try &#123; const res = await axios.get(\"https://api.marktube.tv/v1/book\", &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;); dispatch(setBooks(res.data)); dispatch(endLoading()); &#125; catch (error) &#123; console.log(error); dispatch(setError(error)); dispatch(endLoading()); &#125; &#125;&#125;); 123456789101112131415161718192021// Book.jsx 컴포넌트import React, &#123; useEffect &#125; from \"react\";const Book = props =&gt; &lt;div&gt;title : &#123;props.title&#125;&lt;/div&gt;;const Books = (&#123; token, loading, error, books, requestBooks &#125;) =&gt; &#123; useEffect(() =&gt; &#123; requestBooks(token); // 컨테이너로 로직을 옮겼음. &#125;, [token, requestBooks]); return ( &lt;div&gt; &#123;loading &amp;&amp; &lt;p&gt;loading...&lt;/p&gt;&#125; &#123;error !== null &amp;&amp; &lt;p&gt;&#123;error.message&#125;&lt;/p&gt;&#125; &#123;books.map(book =&gt; ( &lt;Book title=&#123;book.title&#125; key=&#123;book.bookId&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;;export default Books; 리덕스 미들웨어 dispatch가 일어나는 순간 dispatch의 앞과 뒤에 코드를 추가할 수 있게 해주는 것. 미들웨어는 보통 행동이 일어나는 앞 뒤에 해야할 일을 붙여준다. 미들웨어가 여러개면 순차적으로 실행 만드는 방법 2가지 스토어를 만들 때 미들웨어를 설정한다. ({createStore, applyMiddleware} from redux) dispatch가 호출될 때 실제로 미들웨어를 통과하는 부분(직접 미들웨어를 만들 때 사용) 미들웨어 만들어보기 createStore에는 인자가 3개 들어갈 수 있다. (reducer, initialState, applyMiddleware) initialState를 설정안하고 applyMiddleware를 삽입해도 인식한다. dispatch를 안했는데 뜬다면 → 초기화할 때 실행되는 것. 123456789101112131415161718192021222324252627282930313233const middleware1 = store =&gt; &#123; console.log(store); // &#123;getState: ƒ, dispatch: ƒ&#125; return (next) =&gt; &#123;&#125;; // next는 함수&#125;// 코드를 이렇게 추가해보자const middleware1 = store =&gt; &#123; console.log(store); return (next) =&gt; &#123; return action =&gt; &#123; console.log('middleware1', 1, action); const value = next(action); // next는 dispatch console.log('middleware1', 2, action); return value; &#125; &#125;;&#125;const middleware2 = store =&gt; &#123; console.log(store); return (next) =&gt; &#123; return action =&gt; &#123; console.log('middleware2', 1, action); const value = next(action); // next는 dispatch console.log('middleware2', 2, action); return value; &#125; &#125;;&#125;export default function create(initialState) &#123; return createStore(reducer, initialState, applyMiddleware(middleware1, middleware2));&#125; Redux Dev Tools npm install --save redux-devtools-extension 현재 리덕스 관리하고 있는 상태 및 Action들을 크롬 개발자 도구를 통해 확인할 수 있는 툴 redux-thunk 리덕스 미들웨어 리덕스를 만든 사람이 만듬(Dan) 리덕스에서 비동기 처리를 위한 라이브러리 액션 생성자를 활용하여 비동기를 처리한다. (컨테이너에 있던 비동기 함수를 액션으로 이동) 액션 생성자가 액션을 리턴하지 않고, 함수를 리턴함. thunk는 인자로 1. dispatch 2.현재 스테이트 를 받아올 수 있다. export const setBooksThunk = token =&gt; async dispatch, getState 즉, 컨테이너에서도 dispatch를 제거한다. —- 기존 redux-thunk container redux의 state, dispatch 처리 redux의 state, thunk를 사용 Action action 타입, 생성자 정의 action 타입, 생성자 정의, thunk를 정의(dispatch) 실습 npm i redux-thunk Books에서 직접 데이터를 가져온다. 프리젠테이션 컴포넌트에서 하지 않는다 → 컨테이너로 이동 thunk로 action을 넘겨서 깔끔하게 처리함. action에 비동기 로직을 모두 포함한다. redux-thunk 설정 1234567891011import &#123; createStore, applyMiddleware &#125; from \"redux\";import reducers from \"./reducers\";import &#123; composeWithDevTools &#125; from \"redux-devtools-extension\";import thunk from \"redux-thunk\"; // importconst store = createStore( reducers, composeWithDevTools(applyMiddleware(thunk)) // 미들웨어 설정);export default store; Before Using thunk 1234567891011121314151617181920// BooksContainer.jsx , dispatch를 컨테이너에서 설정함.const mapDispatchToProps = dispatch =&gt; (&#123; requestBooks: async token =&gt; &#123; dispatch(startLoading()); dispatch(clearError()); try &#123; const res = await axios.get(\"https://api.marktube.tv/v1/book\", &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;); dispatch(setBooks(res.data)); dispatch(endLoading()); &#125; catch (error) &#123; console.log(error); dispatch(setError(error)); dispatch(endLoading()); &#125; &#125;&#125;); Use thunk 1234567891011121314151617181920212223242526 BooksContainer.jsxconst mapDispatchToProps = dispatch =&gt; (&#123; requestBooks: async token =&gt; &#123;...&#125;, requestBooksThunk: token =&gt; &#123; dispatch(setBooksThunk(token)); // thunk만 로드 &#125;&#125;);// actions/index.jsexport const setBooksThunk = token =&gt; async dispatch =&gt; &#123; dispatch(startLoading()); dispatch(clearError()); try &#123; const res = await axios.get(\"https://api.marktube.tv/v1/book\", &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;); dispatch(setBooks(res.data)); dispatch(endLoading()); &#125; catch (error) &#123; console.log(error); dispatch(setError(error)); dispatch(endLoading()); &#125;&#125;; 서비스 분리 HTTP Request 통신 코드들만 모아놓는다. (axios, promise …) 특정한 side effect의 관심사들을 모아놓은 계층. 타 컨테이너나 컴포넌트에서 사용하던 axios의 의존성을 제거해줄 수 있다. Dependency injection 123456789101112131415161718192021// src/services/UserService.jsimport axios from 'axios';const USER_API_URL = 'https://api.marktube.tv/v1/me';export default class UserService &#123; static login(email, password) &#123; return axios.post(USER_API_URL, &#123; email, password, &#125;); &#125; static logout(token) &#123; return axios.delete(USER_API_URL, &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;`, &#125;, &#125;); &#125;&#125; HOC에 옵션을 주는 방법 withRouter(Component), createFragment(Component, option), connect(option)(Component) 언마운트 직전의 리퀘스트를 날려야 한다. (로그인 되는데 로그아웃하면 안되기 때문) 로그인, 로그아웃을 하나의 서비스로 처리한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"다시 공부하는 React -06-","slug":"ReactStudy-06","date":"2020-02-14T14:14:42.000Z","updated":"2020-02-14T14:21:54.138Z","comments":true,"path":"2020/02/14/ReactStudy-06/","link":"","permalink":"https://hyeok999.github.io/2020/02/14/ReactStudy-06/","excerpt":"","text":"React Re-Study : 6 Flux 문제점 해결책 Redux 개요 Redux 만들기 Action - 액션 액션 생성자 리덕스의 액션은 어떤 일을 하는가? 액션의 준비과정 Reducer - 리듀서 createStore - 스토어를 만드는 함수 store 사용법 로직을 추가하기 action을 정의 action 생성자를 생성 reducer를 수정 dispatch ( 액션 → 리듀서 : 액션을 리듀서에게 전달하는 함수 ) 추가로 - 애플리케이션 확장 → state의 복잡성 증가 한번에 모두 처리하는 리듀서 분리된 리듀서 + 리듀서 합치기 combineReducers React에 적용하기 react-redux 사용하기 간단 예제 Provider Component from react-redux Consumer from react-redux connect function from react-redux HOC(connect)가 아닌 hook을 사용한 Redux React Study with Mark - Redux Basic - Flux Flux는 애플리케이션에서 데이터를 취급하기 위한 패턴의 일종 Flux는 개념, redux와 같지 않다. 문제점 페이스북의 알림 버그를 해결하기 위한 개념으로 성장했다. 기존의 어플리케이션 방식은 모델 → 뷰로 흐르는 방식 사용자와의 상호작용은 오직 뷰에서 일어났는데 뷰가 가끔씩 모델을 업데이트해야할 필요성이 생김(사용자의 입력) 여기서 특정 모델의 업데이트는 의존성에 의해 다른 모델을 추가로 업데이트 시켜야하는 경우가 생김 이런 현상이 무수히 많아지게 되면서 결국 데이터의 흐름을 잡기가 어려워짐 ( +비동기 ) 위와 같은 문제들로 인하여 Flux 라는 개념이 등장함. 해결책 데이터 흐름을 단방향으로 만들기 Action → Dispatcher → Store → View → Action … 반복 Redux 개요 기존의 React State 접근 방식 Redux Store를 이용한 React State 접근 방식 MobX는 전역 Store가 여러개다. Redux는 단일 전역 Store Redux 만들기 단일 스토어를 만드는 법 리액트에서 스토어 사용하는 법을 익히는 시간 [만들기] 단일 스토어 사용 준비하기 import redux 액션을 정의하고, 액션을 사용하는, 리듀서를 만들고, 리듀서들을 합치기 최종 합쳐진 리듀서를 인자로, 단일 스토어를 만든다. [사용하기] 준비한 스토어를 리액트 컴포넌트에서 사용하기 import react-redux connect 함수(HOC)를 이용해서 컴포넌트에 연결 최근에는 HOC가 훅(Redux Hook)으로 대체되고 있는 상황 스토어가 너무 커지고 복잡하면 쪼개서 사용함 Action - 액션 액션은 명세표의 역할 리듀서에게 행해야할 일을 적은 명세서. 코드 관점에서 보았을 때, 액션은 단순 그냥 Object(객체) 다. 두 가지 형태의 액션이 존재한다. { type: &#39;TEST&#39; } - payload 없는 액션 { type: &#39;TEST&#39;, params: &#39;hello&#39; } - payload 있는 액션 type 만이 필수 프로퍼티이며, type 은 문자열 액션 생성자 액션을 생성하는 함수를 “액션 생성자 (Action Creator)” 라고 한다.함수를 통해 액션을 생성해서, 액션 객체를 리턴 1function 액션생성자(...args) &#123; return 액션; &#125; 리덕스의 액션은 어떤 일을 하는가? 액션 생성자를 통해 액션 생성 만들어낸 액션 객체를 리덕스 스토어에 보냄 리덕스 스토어가 액션 객체를 받으면 스토어의 상태 값이 변경 변경된 상태 값에 의해 상태를 이용하고 있는 컴포넌트가 변경 액션은 스토어에 보내는 일종의 인풋이라 생각할 수 있음 액션의 준비과정 액션의 타입을 정의하여 변수로 빼는 단계 강제는 아님(옵션) 그냥 타입을 문자열로 넣기에는 실수를 유발할 가능성이 크다 미리 정의한 변수를 사용하면, 스펠링에 주의를 덜 기울여도 된다. 액션 객체를 만들어 내는 함수를 만드는 단계 하나의 액션 객체를 만들기 위해 하나의 함수를 만들어낸다. 액션의 타입은 미리 정의한 타입 변수로 부터 가져와서 사용한다. 12345678910// 액션의 type 정의// 액션의 타입 =&gt; 액션 생성자 이름// ADD_TODO =&gt; addTodoexport const ADD_TODO = 'ADD_TODO';// 액션 생산자// 액션의 타입은 미리 정의한 타입으로 부터 가져와서 사용하며, 사용자가 인자로 주지 않는다.export function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;; // &#123; type: ADD_TODO, text: text &#125;&#125; Reducer - 리듀서 액션을 주면, 그 액션이 적용되어 달라진 결과를 만들어냄. (액션에 따라 값이 그대로인 결과를 만들수도 있다.) 코드 관점에 보았을 때 단순 그냥 Function(함수) 다. Pure Function Immutable 리듀서를 통해 스테이트가 달라졌음을 리덕스가 인지하는 방식. 123function 리듀서(previousState, action) &#123; return newState;&#125; 액션을 받아서 스테이트를 리턴하는 구조 인자로 들어오는 previousState 와 리턴되는 newState 는 다른 참조를 가져야 한다. 123456789101112// reducers.jsimport &#123; ADD_TODO &#125; from './actions';export function todoApp(previousState, action) &#123; if (previousState === undefined) &#123; return []; &#125; if (action.type === ADD_TODO) &#123; return [...previousState, &#123; text: action.text &#125;]; &#125; return previousState;&#125; createStore - 스토어를 만드는 함수 1const store = createStore(리듀서); createStore(reducer: Reducer,preloadedState: S,enhancer?: StoreEnhancer): Store; 물음표는 옵션을 의미한다. 스토어 생성 -&gt; Subscribe : 구독(함수 안은 실행되지 않음) -&gt; 액션 추가 하면 -&gt; 스테이트가 변했으므로 console.log(subscribe)가 실행 -&gt; 구독을 하지 않을 순간이 오면 unsubscribe(); 실행 1234567891011121314151617181920212223242526272829// store.jsimport &#123; todoApp &#125; from './reducers';import &#123; createStore &#125; from 'redux';import &#123; addTodo &#125; from './actions';const store = createStore(todoApp);console.log(store);console.log(store.getState());setTimeout(() =&gt; &#123; store.dispatch(addTodo('hello'));&#125;, 1000);export default store;// index.jsimport React from 'react';import ReactDOM from 'react-dom';import App from './App';import store from './store';store.subscribe(() =&gt; &#123; const state = store.getState(); console.log('store changed', state);&#125;);ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); store 사용법 store.getState(); store.dispatch(액션명); / store.dispatch(액션생성자()); const unsubscribe = store.subscribe(() =&gt; {}); 리턴이 unsubscribe 라는 것에 주의. store.subscribe의 리턴값은 함수로 unsubscribe에 담아줌 unsubscribe( ); 하면 제거 unsubscribe는 구독을 끊을 때 사용, (대상이 없는데 계속 구독하는)메모리 누수를 막기 위해 store.replaceReducer(다른 리듀서); 로직을 추가하기 action 을 정의하고,action 생성자를 만들고,reducer 를 수정 1. action을 정의 1234567891011121314// actions.js// 액션의 type 정의// 액션의 타입 =&gt; 액션 생성자 이름// ADD_TODO =&gt; addTodoexport const ADD_TODO = 'ADD_TODO';export const COMPLETE_TODO = 'COMPLETE_TODO';// 액션 생산자// 액션의 타입은 미리 정의한 타입으로 부터 가져와서 사용하며,// 사용자가 인자로 주지 않습니다.export function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;; // &#123; type: ADD_TODO, text: text &#125;&#125; 2. action 생성자를 생성 123456789101112131415161718// actions.js// 액션의 type 정의// 액션의 타입 =&gt; 액션 생성자 이름// ADD_TODO =&gt; addTodoexport const ADD_TODO = 'ADD_TODO';export const COMPLETE_TODO = 'COMPLETE_TODO';// 액션 생산자// 액션의 타입은 미리 정의한 타입으로 부터 가져와서 사용하며,// 사용자가 인자로 주지 않습니다.export function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;; // &#123; type: ADD_TODO, text: text &#125;&#125;export function completeTodo(index) &#123; return &#123; type: COMPLETE_TODO, index &#125;; // &#123; type: COMPLETE_TODO, index: index&#125;&#125; 3. reducer를 수정 12345678910111213141516171819202122import &#123; ADD_TODO, COMPLETE_TODO &#125; from './actions';export function todoApp(previousState, action) &#123; if (previousState === undefined) &#123; return []; &#125; if (action.type === ADD_TODO) &#123; return [...previousState, &#123; text: action.text, completed: false &#125;]; &#125; if (action.type === COMPLETE_TODO) &#123; const newState = []; for (let i = 0; i &lt; previousState.length; i++) &#123; newState.push( i === action.index ? &#123; ...previousState[i], completed: true &#125; : &#123; ...previousState[i] &#125;, ); &#125; return newState; &#125; return previousState;&#125; 4. dispatch ( 액션 → 리듀서 : 액션을 리듀서에게 전달하는 함수 ) 123456789101112131415161718// store.jsimport &#123; todoApp &#125; from './reducers';import &#123; createStore &#125; from 'redux';import &#123; addTodo, completeTodo &#125; from './actions';const store = createStore(todoApp);console.log(store);console.log(store.getState());setTimeout(() =&gt; &#123; store.dispatch(addTodo('hello')); setTimeout(() =&gt; &#123; store.dispatch(completeTodo(0)); &#125;, 1000);&#125;, 1000);export default store; 추가로 - 애플리케이션 확장 → state의 복잡성 증가 리듀서를 크게 만들고, state 를 변경하는 모든 로직을 담을 수도 있다. 리듀서를 분할해서 만들고, 합치는 방법을 사용할 수 있다. todos 만 변경하는 액션들을 처리하는 A 라는 리듀서 함수를 만들고, filter 만을 변경하는 액션들을 처리하는 B 라는 리듀서 함수를 만들고, A 와 B 를 합친다. 한번에 모두 처리하는 리듀서 12345678910111213141516171819202122232425import &#123; ADD_TODO, COMPLETE_TODO &#125; from './actions';export function todoApp(previousState, action) &#123; if (previousState === undefined) &#123; return &#123; todos: [], filter: 'SHOW_ALL' &#125;; &#125; if (action.type === ADD_TODO) &#123; return &#123; todos: [...previousState.todos, &#123; text: action.text, completed: false &#125;], filter: previousState.filter, &#125;; &#125; if (action.type === COMPLETE_TODO) &#123; const todos = []; for (let i = 0; i &lt; previousState.todos.length; i++) &#123; todos.push( i === action.index ? &#123; ...previousState.todos[i], completed: true &#125; : &#123; ...previousState.todos[i] &#125;, ); &#125; return &#123; todos, filter: previousState.filter &#125;; &#125; return previousState;&#125; 분리된 리듀서 + 리듀서 합치기 리듀서 분리 123456789101112131415161718192021222324252627export function todos(previousState, action) &#123; if (previousState === undefined) &#123; return []; &#125; if (action.type === ADD_TODO) &#123; return [...previousState.todos, &#123; text: action.text, completed: false &#125;]; &#125; if (action.type === COMPLETE_TODO) &#123; const newState = []; for (let i = 0; i &lt; previousState.length; i++) &#123; newState.push( i === action.index ? &#123; ...previousState[i], completed: true &#125; : &#123; ...previousState[i] &#125;, ); &#125; return newState; &#125; return previousState;&#125;export function filter(previousState, action) &#123; if (previousState === undefined) &#123; return 'SHOW_ALL'; &#125; return previousState;&#125; 리듀서 합치기 123456export function todoApp(previousState = &#123;&#125;, action) &#123; return &#123; todos: todos(previousState.todos, action), filter: filter(previousState.filter, action), &#125;;&#125; combineReducers 리덕스에서 제공하는 combineReducers 사용 123456import &#123; combineReducers &#125; from 'redux';const todoApp = combineReducers(&#123; todos, filter,&#125;); React에 적용하기 useEffect에서 리덕스 스토어가 변하는 것. (스토어의 state가 변하는게 아니다.) cleanup 시점에 구독이 끊긴다. 123456789useEffect(() =&gt; &#123; const unsubscribe = store.subscribe(() =&gt; &#123; setTodos(store.getState().todos); &#125;); return () =&gt; &#123; unsubscribe(); &#125;&#125;, [store]); react-redux 사용하기 npm i react-redux Provider 컴포넌트를 제공해준다. connect 함수를 통해 “컨테이너”를 만들어준다. 컨테이너는 스토어의 state 와 dispatch(액션) 를 연결한 컴포넌트에 props 로 넣어주는 역할을 한다. 그렇다면 필요한 것은 ? 어떤 state 를 어떤 props 에 연결할 것인지에 대한 정의 어떤 dispatch(액션) 을 어떤 props 에 연결할 것인지에 대한 정의 그 props 를 보낼 컴포넌트를 정의 간단 예제 12345678910// index.jsReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'));// App.jsimport &#123; connect &#125; from 'react-redux'; state가 방대해지면, 그 중에 이 컴포넌트에서 사용할 것만 사용하겠다고 설정을 해줘야 한다. (Provider) connect 설정 connect(App, option); const fn = connect(option); fn(App); connect(option)(App); store의 state를 → App의 props로 변경 store의 dispatch를 → App의 props로 변경 1234567891011121314const mapStateToProps = (state) =&gt; (&#123; todos: state.todos&#125;);const mapDispatchToProps = (dispatch) =&gt; (&#123; addTodo: (text) =&gt; &#123; dispatch(addTodo(text)); // App에서 호출할 때 넣어주므로 인자를 전달 &#125;&#125;);export default connect(mapStateToProps, mapDispatchToProps)(App); // 보낼 컴포넌트 설정.// App 컴포넌트에서 인자로 todos와 addTodo를 받을 수 있다.function App(&#123; todos, addTodo &#125;) &#123; Provider Component from react-redux 1234567891011121314// index.jsimport React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import store from './store';import &#123; Provider &#125; from 'react-redux';ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'),); Consumer from react-redux 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, &#123; useContext, useEffect, useState &#125; from 'react';import &#123; ReactReduxContext &#125; from 'react-redux';import './App.css';import &#123; addTodo &#125; from './actions';import Button from './Button';class App extends React.Component &#123; render() &#123; console.log(this.props); return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;p&gt;&#123;JSON.stringify(this.props.todos)&#125;&lt;/p&gt; &lt;Button add=&#123;this.props.add&#125; /&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;import React from 'react';export default function Button(&#123; add &#125;) &#123; return &lt;button onClick=&#123;() =&gt; add('hello')&#125;&gt;추가&lt;/button&gt;;&#125;// App 컨테이너function AppContainer(props) &#123; const &#123; store &#125; = useContext(ReactReduxContext); const [state, setState] = useState(store.getState()); function add(text, dispatch) &#123; console.log(text, dispatch); dispatch(addTodo(text)); &#125; useEffect(() =&gt; &#123; const _unsubscribe = store.subscribe(() =&gt; &#123; setState(store.getState()); &#125;); return () =&gt; &#123; _unsubscribe(); &#125;; &#125;); return ( &lt;App &#123;...props&#125; todos=&#123;state.todos&#125; add=&#123;text =&gt; add(text, store.dispatch)&#125; /&gt; );&#125;export default AppContainer; connect function from react-redux 1234567891011121314151617181920212223242526272829303132333435363738import React from 'react';import './App.css';import &#123; addTodo &#125; from './actions';import &#123; connect &#125; from 'react-redux';import Button from './Button';class App extends React.Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;p&gt;&#123;JSON.stringify(this.props.todos)&#125;&lt;/p&gt; &lt;Button add=&#123;this.props.add&#125; /&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;// mapStateToProps, mapDispatchToPropsconst mapStateToProps = state =&gt; &#123; return &#123; todos: state.todos &#125;;&#125;;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; add: text =&gt; &#123; dispatch(addTodo(text)); &#125;, &#125;;&#125;;const AppContainer = connect( mapStateToProps, mapDispatchToProps,)(App);export default AppContainer; HOC(connect)가 아닌 hook을 사용한 Redux props로 꽂히지 않음 useSelector를 사용하여 값을 가져온다.(mapStateToProps) 12const todos = useSelector(state =&gt; state.todos);const loading = useSelector(state =&gt; state.loading); useDispatch를 통해 dispatch를 한다. 1const dispatch = useDispatch();","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"다시 공부하는 React -05-","slug":"ReactStudy-05","date":"2020-02-14T11:42:53.000Z","updated":"2020-02-14T14:18:48.271Z","comments":true,"path":"2020/02/14/ReactStudy-05/","link":"","permalink":"https://hyeok999.github.io/2020/02/14/ReactStudy-05/","excerpt":"","text":"React Re-Study : 5 클래스형 컴포넌트의 단점 Basic Hooks useState useEffect 의존성 배열과 cleanup 의존성 배열을 안쓰고 인자 받기 Custom Hooks useHasMounted vs withHasMounted HOC Hook Additional Hooks - 추가 훅 useReducer useMemo ReactMemo &amp; useCallback createRef vs useRef 하위 컴포넌트를 변경하기 상위 컴포넌트를 변경하기 하위 컴포넌트 전체에 데이터를 공유하는 법 Context API, useContext Set - 최상위 컴포넌트 Get - Consumer Get - 클래스로 하는 방법 Get - functional로 하는 방법 (hook) React Study with Mark - Hooks &amp; Context - 클래스형 컴포넌트의 단점 컴포넌트 사이에서 상태와 관련된 로직을 재사용하기 어렵다. 컨테이너 방식 말고, 상태와 관련된 로직 복잡한 컴포넌트들은 이해하기 어렵다. Class 는 사람과 기계를 혼동시킨다. 컴파일 단계에서 코드를 최적화하기 어렵게 만든다. this.state 는 로직에서 레퍼런스를 공유하기 때문에 문제가 발생할 수 있다. Basic Hooks useState useEffect useContext Hook이 나오기 전에는 Functional Component = Stateless Component Hook이 나온 이후에는 Functional Component != Stateless Component Stateless Component =&gt; Stateless Functional Component useState state 를 대체 할 수 있다. 숫자, 문자열등의 원시값을 상태로 가지고 있을 경우 const [count, setCount] = useState(0); const [스테이트 값, 스테이트 변경 함수] = useState(스테이트 초기값); 123456789101112131415161718import React, &#123; useState &#125; from 'react';const Example2 = () =&gt; &#123; const [count, setCount] = useState(0); function click() &#123; setCount(count + 1); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;click&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;;export default Example2; 객체나 배열등의 참조값을 상태로 가지고 있을 경우 const [state, setState] = useState({count: 0}); const [스테이트 값, 스테이트 변경 함수] = useState(스테이트 초기값); 123456789101112131415161718import React, &#123; useState &#125; from 'react';const Example3 = () =&gt; &#123; const [state, setState] = useState(&#123; count: 0 &#125;); function click() &#123; setState(&#123; count: state.count + 1 &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;click&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;;export default Example3; useEffect 라이프 사이클 훅을 대체 할 수 있다. componentDidMount : 렌더 직후 componentDidUpdate :state, props가 변경되었을 때 componentWillUnmount : 최초 마운트 됐을 때 12345678910111213141516171819202122import React, &#123; useState, useEffect &#125; from 'react';const Example5 = () =&gt; &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log('componentDidMount &amp; componentDidUpdate', count); // ComponentDidMount &#125;); function click() &#123; setCount(count + 1); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;click&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;;export default Example5; 의존성 배열과 cleanup props가 바뀌거나 state가 바뀔 경우에만 다시 렌더되므로 dependency 배열 안에는 props 와 state를 넣을 수 있다. dependency로 관리하므로 componentDidUpdate와 완전히 같지는 않다. depenency는 배열 형태로 작성한다. 빈배열([])일 때는 렌더 될 때 useEffect가 게속 일어난다. 아예 dependency를 작성하지 않을 경우 어떠한 변경이 일어나도 useEffect는 한 번밖에 실행이 안되므로 cleanup이 단 한 번만 일어남 return 내부를 componentWillUnmount처럼 사용할 경우에는 의존성 배열이 빈 배열이어야 한다. 1234567891011 useEffect(() =&gt; &#123; // componentDidUpdate &#125;, [count])// cleanup 단 한 번만 실행 useEffect(() =&gt; &#123; // componentDidMount &amp; componentDidUpdate return () =&gt; &#123; // cleanup &#125; &#125;, []) 의존성 배열을 안쓰고 인자 받기 기존에는 의존성 배열을 입력하라는 warning이 뜬다. 123456const [count, setCount] = useState(0);useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; setCount(count + 1); // 이렇게 쓸 경우 &#125;, 1000)&#125;, [count]) // count를 의존성 배열로 넣어줘야만 한다. 의존성 배열을 쓰지 않으려면 다음과 같이 한다. 123456const [count, setCount] = useState(0);useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; setCount(count =&gt; count + 1); // 이렇게 쓸 경우 &#125;, 1000)&#125;, []) // count를 의존성 배열로 넣지 않아도 됨 Custom Hooks useSomething 리액트를 사용할 수 있는 곳 : 컴포넌트 안, 훅 안 12345678910111213141516171819202122232425// hooks/useWindowWidth.jsximport &#123; useState, useEffect &#125; from 'react';// 현재 켜져있는 브라우저의 가로 길이를 알아본다.export default function useWindowWidth() &#123; // 여기서 초기화 // 초기 가로값 설정 const [width, setWidth] = useState(window.innerWidth); // 한 번만 실행되도록 useEffect(() =&gt; &#123; const resize = () =&gt; &#123; setWidth(window.innerWidth); &#125; window.addEventListener('resize', resize); // 더 이상 사용되지 않을 때 처리. return () =&gt; &#123; window.removeEventListener('resize', resize) &#125;; &#125;, []); return width;&#125;// App.jsconst width = useWindowWidth();&lt;p&gt;&#123;width&#125;&lt;/p&gt; Q : 의존성 배열이 빈칸이므로 단 한 번만 실행되는데 어떻게 브라우저 창이 바뀔때마다 width값이 바뀌는가? A :window.addEventListner 와 같은 이벤트 핸들러는 React가 아니라 DOM에 addEventListener를 걸어놨으므로 DOM이 변경되면 적용 된다. useHasMounted vs withHasMounted Hook 과 HOC의 차이점을 알아본다. HOC HOC는 컴포넌트를 받아서 새로운 컴포넌트를 리턴 한다.(선물세트) App을 withHasMounted로 감쌀 경우 App이 선물세트 안에 들어있다. HOC의 단점 : Wrapper Hell을 볼 가능성이 높다. 1234567891011121314151617181920212223242526272829// withHasMount.jsimport React from 'react';export default function withHasMounted(Component) &#123; class WrappedComponent extends React.Component &#123; state = &#123; hasMounted: false &#125;; componentDidMount() &#123; this.setState(&#123; hasMounted: true &#125;); &#125; render() &#123; const &#123; hasMounted &#125; = this.state; return &lt;Component &#123;...this.props&#125; hasMounted=&#123;hasMounted&#125; /&gt; &#125; &#125; WrappedComponent.displayName = `WrappedComponent($&#123;Component.name&#125;)`; return WrappedComponent;&#125;// App.jsfunction App(&#123; hasMounted &#125;) &#123; ... &lt;p&gt;&#123;hasMounted &amp;&amp; 'Mounted'&#125;&lt;/p&gt; ... &#125;export default withHasMounted(App); Hook HOC의 단점 : Wrapper Hell을 볼 가능성이 높다. 따라서, Hook을 사용한다. 123456789101112131415161718192021222324// useHasMount.jsimport &#123; useState, useEffect &#125; from 'react';export default function useHasMounted() &#123; // 초기화 const [HasMounted, setHasMounted] = useState(false); // 변경점 useEffect(() =&gt; &#123; // componentDidMount와 같은 시점에 작동 setHasMounted(true); &#125;, []); return HasMounted;&#125;// App.jsfunction App(&#123; hasMounted &#125;) &#123; const hasMounted2 = useHasMounted(); return ( .... &lt;p&gt;&#123;hasMounted2 &amp;&amp; 'Mounted'&#125;&lt;/p&gt; )&#125; Additional Hooks - 추가 훅 useReducer useCallback, useMemo useRef useReducer 다음의 경우 사용된다. 다수의 하윗값을 포함하는 복잡한 정적 로직을 만드는 경우 다음 state가 이전 state에 의존적인 경우 reducer 는 즉시 실행 순수 함수 외부환경에 영향을 받지않는다. 상태가 일정해야한다. 1234567891011121314151617181920212223242526272829303132333435import React, &#123; useReducer &#125; from 'react';// 여기서 인자로 받는 state는 previous state(이전 상태 값)const reducer = (state, action) =&gt; &#123; if (action.type === 'PLUS') &#123; return &#123; ...state, count: state.count + 1 &#125; &#125; return state;&#125;;const initialState = &#123; count: 0&#125;;const Example8 = () =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState); // reducer는 함수고, 즉시 실행 순수 함수이다. function click() &#123; dispatch(&#123; type: 'PLUS' &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;&#123;state.count&#125;&lt;/p&gt; &lt;button onClick=&#123;click&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;;export default Example8; useMemo 최적화할 때 주로 사용된다. 의존성을 통해 특정 값에 대한 변화의 조건을 줄 수있다. 전달된 함수는 렌더링 중에 실행된다는 것. React.memo와 다르다. 123456789101112131415161718192021222324252627282930313233// 리듀서 + 최적화import React, &#123; useState, useMemo &#125; from 'react';const Example9 = props =&gt; &#123; // input 태그는 컨트롤드 컴포넌트로 이용 const [value, setValue] = useState(''); const [persons] = useState([ &#123; name: 'Kim', age: 26 &#125;, &#123; name: 'June', age: 27 &#125;, ]); function change(e) &#123; setValue(e.target.value); &#125; function getSum(persons) &#123; console.log(JSON.stringify(persons)); return persons.map(person =&gt; person.age).reduce((l, r) =&gt; l + r, 0); &#125; // const sum = getSum(persons); const sum = useMemo(() =&gt; getSum(persons), [persons]); // 의존성 배열 입력 return ( &lt;div&gt; &lt;br /&gt; &lt;input value=&#123;value&#125; onChange=&#123;change&#125; /&gt; &lt;p&gt;&#123;sum&#125;&lt;/p&gt; &lt;/div&gt; );&#125;;export default Example9; React.Memo &amp; useCallback 함수가 매번 새로 생성되는 경우, 최적화의 어려움 123456789101112131415161718192021222324252627282930import React, &#123; useState &#125; from 'react';const Person = (&#123; name, age &#125;) =&gt; &#123; console.log(name, age); return &lt;li&gt;&#123;name&#125; &#123;age&#125;&lt;/li&gt;&#125;;const Example10 = () =&gt; &#123; // input을 controlled component로 관리할 것 const [value, setValue] = useState(''); const [persons] = useState([ &#123; name: 'Kim', age: 27 &#125;, &#123; name: 'JH', age: 29 &#125; ]); function change(e) &#123; setValue(e.target.value); &#125; return ( &lt;div&gt; &lt;input value=&#123;value&#125; onChange=&#123;change&#125; /&gt; &lt;ul&gt; &#123;persons.map((person, i) =&gt; &lt;Person key=&#123;i&#125; name=&#123;person.name&#125; age=&#123;person.age&#125;/&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; );&#125;;export default Example10; onChange이벤트를 걸어서 input에 입력하여 Person내부에 써놓은 콘솔로그를 계속 찍는다. Person에게 주는 input이 게속 바뀌니까 콘솔이 찍히는 상황 (props가 변경되었다고 판단했기 때문) 따라서 React.memo를 사용한다. 1234const Person = React.memo((&#123; name, age &#125;) =&gt; &#123; console.log(name, age); return &lt;li&gt;&#123;name&#125;, &#123;age&#125;&lt;/li&gt;&#125;); React.memo를 사용하면 함수 자체를 비교를 한다. React.memo는 파라미터로 받은 함수가 하나로 변경이 될 경우 실행해버린다. 문제는, input에 특정 값을 입력할 경우 set에 의해 객체가 변경된다. 객체는 참조값이기 떄문에 한개만 변경되어도 객체 자체가 새롭게 메모리에 작성되기 때문에 콘솔이 게속 찍히게 된다. 따라서 useCallback을 이용하여 값이 같을 경우 변경을 막고 &lt;li&gt;부분만 보여주도록 하게 해보자. 1234567891011121314151617 // function click() &#123;&#125; // 로그 계속 찍힘 const click = useCallback(index =&gt; &#123; setPersons(persons =&gt; &#123; const newPersons = [...persons]; newPersons[index].age = newPersons[index].age + 1; return newPersons; &#125;); &#125;, []); return ( &lt;div&gt; &lt;input value=&#123;value&#125; onChange=&#123;change&#125; /&gt; &lt;ul&gt; &#123;persons.map((person, i) =&gt; &lt;Person index=&#123;i&#125; key=&#123;i&#125; name=&#123;person.name&#125; age=&#123;person.age&#125; click=&#123;click&#125;/&gt;)&#125; &lt;/ul&gt; &lt;/div&gt;); createRef vs useRef 1234567891011121314151617181920212223import React, &#123; useRef, useEffect, useState &#125; from 'react';const Example11 = () =&gt; &#123; const [count, setCount] = useState(0); const inputCreateRef = React.createRef(); const inputUseRef = useRef(); console.log(inputCreateRef.current); console.log(inputUseRef.current); useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; setCount(count =&gt; count + 1); &#125;, 1000); &#125;); return ( &lt;div&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;input ref=&#123;inputCreateRef&#125; /&gt; &lt;input ref=&#123;inputUseRef&#125; /&gt; &lt;/div&gt; );&#125;;export default Example11; count를 변경시키면 return이 전부 재 렌더됨 둘다 DOM요소등을 직접 참조할 수 있다. 차이점 useRef는 current가 변경이 되어도 re-render가 되지 않는다. 컴포넌트가 마운트 될 때 참조값을 그대로 유지한다. 재 렌더링 되더라도 이전 reference를 가지고 있다. createRef는 current가 변경이 되면 re-render가 된다. 컴포넌트가 마운트 될 때마다 참조값을 새롭게 할당하고, 언마운트 될 경우 null이 들어간다. 하위 컴포넌트를 변경하기 A - B - C - D - E A 의 button 를 클릭하여 E 를 변경하기 컴포넌트에서 button 에 onClick 이벤트를 만들고, button 을 클릭하면, 의 state 를 변경하여, 로 내려주는 props 를 변경 B의 props 가 변경되면, 의 props 에 전달 C의 props 가 변경되면, 의 props 로 전달 D의 props 가 변경되면, 의 props 로 전달 상위 컴포넌트를 변경하기 A - B - C - D - E E 의 button 를 클릭하여 A 의 p 를 변경하려면 A에 함수를 만들고, 그 함수 안에 state 를 변경하도록 구현, 그 변경으로 인해 p 안의 내용을 변경. 만들어진 함수를 props 에 넣어서, 로 전달 B의 props 의 함수를 의 props 로 전달 C의 props 의 함수를 의 props 로 전달 D의 Props 의 함수를 의 props 로 전달, 에서 클릭하면 props 로 받은 함수를 실행 하위 컴포넌트 전체에 데이터를 공유하는 법 Context API, useContext 하위 컴포넌트 전체에 데이터를 공유하기 데이터를 Set하는 것 가장 상위 컴포넌트 → 프로바이더 데이터를 get하는 것 모든 하위 컴포넌트에서 접근 가능 컨슈머로 하는 방법 클래스 컴포넌트의 this.context로 하는 방법 펑셔널 컴포넌트의 useContext로 하는 방법 Set - 최상위 컴포넌트 일단 컨텍스트를 생성한다. 컨텍스트, 프로바이더 를 사용한다. value 를 사용 123456789101112131415161718// /contexts/PersonContext.jsimport React from 'react';const PersonContext = React.createContext();export default PersonContext;// index.jsconst persons = [ &#123; id: 0, name: 'Mark', age: 38 &#125;, &#123; id: 1, name: 'Hanna', age: 27 &#125;,];ReactDOM.render( &lt;PersonContext.Provider value=&#123;persons&#125;&gt; &lt;App /&gt; &lt;/PersonContext.Provider&gt;, document.getElementById('root')); Get - Consumer 컨텍스트를 가져온다. 컨텍스트.컨슈머를 사용한다. value 를 사용 123456789101112131415161718192021222324252627// ./components/Example1.jsimport React from 'react';import PersonContext from '../contexts/PersonContext';const Example1 = () =&gt; ( &lt;PersonContext.Consumer&gt; &#123;value =&gt; &lt;ul&gt;&#123;JSON.stringify(value)&#125;&lt;/ul&gt;&#125; &lt;/PersonContext.Consumer&gt;);export default Example1;// index.jsimport React from 'react';import Example1 from './components/Example1';function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;Example1 /&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; Get - 클래스로 하는 방법 static contextType 에 컨텍스트를 설정한다. this.context =&gt; value 이다. 1234567891011121314151617181920212223242526272829// ./components/Example2.jsimport React from 'react';import PersonContext from '../contexts/PersonContext';export default class Example2 extends React.Component &#123; static contextType = PersonContext; render() &#123; return &lt;ul&gt;&#123;JSON.stringify(this.context)&#125;&lt;/ul&gt;; &#125;&#125;// 5번째 줄 대신 이렇게 사용할 수도 있음// Example2.contextType = PersonContext;// index.jsimport React from 'react';import Example2 from './components/Example2';function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;Example2 /&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; 치명적인 단점 : 하나밖에 못 쓴다. HOC를 활용하면 여러개를 사용할 수 있지만 번거롭다. Get - functional로 하는 방법 (hook) useContext 로 컨텍스트를 인자로 호출한다. useContext 의 리턴이 value 이다. 123456789101112131415161718192021222324252627// ./components/Example3.jsimport React, &#123; useContext &#125; from 'react';import PersonContext from '../contexts/PersonContext';const Example3 = () =&gt; &#123; const value = useContext(PersonContext); return &lt;ul&gt;&#123;JSON.stringify(value)&#125;&lt;/ul&gt;;&#125;;export default Example3;// index.jsimport React from 'react';import Example3 from './components/Example3';function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;Example3 /&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"타입 스크립트 [02]","slug":"type-script-02","date":"2020-02-08T10:07:21.000Z","updated":"2020-02-08T10:10:26.628Z","comments":true,"path":"2020/02/08/type-script-02/","link":"","permalink":"https://hyeok999.github.io/2020/02/08/type-script-02/","excerpt":"","text":"TypeScript - 02 -목차 JavaScript Class 클래스 vs 생성자함수 JS 클래스는 문법적 설탕이 아닌 이유 JS 클래스의 단점 TypeScript 클래스 JS 클래스 → TS 클래스 접근 제한자 생성자 파라미터(매개변수)에 접근 제한자 선언 readonly 키워드 추상 클래스 추상 메소드란? TS 인터페이스 변수와 인터페이스 함수와 인터페이스 클래스와 인터페이스 선택적 프로퍼티 Type Alias 제네릭 JavaScript Class JS 에서 객체를 만드는 방법은 객체 리터럴, Object.create 함수, 생성자 함수, 클래스가 있다. 그 중 클래스에 대해 알아보자. 클래스 vs 생성자함수 클래스는 new 연산자 없이 호출 시 에러를 발생한다. 상속을 지원하는 extends 키워드 와 super키워드 제공 클래스는 호이스팅이 발생하지 않는 것처럼 동작함( 마치 let, const ) 암묵적으로 strict모드로 실행됨(해지 불가) 클래스의 메소드들은 모두 열거되지 않는다. 클래스 몸체(바디)에는 메소드들만 올 수 있다.( 키워드를 붙일 수 없다. ) JS 클래스는 문법적 설탕이 아닌 이유 생성자 함수를 기반으로 한 객체 생성 방식보다 견고하면서 명료하기 때문에 새로운 객체 생성 메카니즘이다. 근본적인 Method가 다르다. ES5시절에는 메소드가 없다. (단지, 편의를 위해 그렇게 칭했을 뿐) ES6 넘어오면서 메소드가 생김(일반 호출 불가, 생성자 함수로 사용할 수 없다.(new사용 불가)) Method 생성 방법 (ES5- { 프로퍼티 키: 무명함수 리터럴(그냥 함수) } / ES6 - { 메소드명() } ) 12345678910// ES5var o =&#123; x: f &#125;;var f = o.x(); // 이렇게 할 필요 없이 x();도 가능// ES6var o = &#123; x() &#123;&#125; // 메소드&#125;; JS 클래스의 단점 JS 클래스 몸체(바디)에는 메소드들만 올 수 있다.( 키워드를 붙일 수 없다. ) 클래스 몸체에 클래스 프로퍼티를 선언할 수 없고 반드시 생성자 내부에서 클래스 프로퍼티를 선언하고 초기화한다. 1234567891011// person.jsclass Person &#123; constructor(name) &#123; // 클래스 프로퍼티의 선언과 초기화 this.name = name; &#125; walk() &#123; console.log(`$&#123;this.name&#125; is walking.`); &#125;&#125; DOM과의 연동을 하기에 매우 불편하다. ( 이벤트를 사용하기가 매우 불편하다. - this가 꼬인다. ) TypeScript 클래스JS 클래스 → TS 클래스 예제는 ES6에서 문제없이 실행되는 코드이지만 위 파일의 확장자를 ts로 바꾸어 Typescript 파일로 변경한 후, 컴파일하면 아래와 같이 컴파일 에러가 발생한다. 12person.ts(4,10): error TS2339: Property 'name' does not exist on type 'Person'.person.ts(8,25): error TS2339: Property 'name' does not exist on type 'Person'. Typescript 클래스는 클래스 몸체에 클래스 프로퍼티를 사전 선언하여야 한다. 1234567891011121314151617// person.tsclass Person &#123; // 클래스 프로퍼티를 사전 선언하여야 한다 name: string; constructor(name: string) &#123; // 클래스 프로퍼티수에 값을 할당 this.name = name; &#125; walk() &#123; console.log(`$&#123;this.name&#125; is walking.`); &#125;&#125;const person = new Person('Lee');person.walk(); // Lee is walking 여기서 constructor가 없을 경우 초기화가 되지 않을 뿐 프로퍼티는 생성이 된다.(undefined상태) 12345678class Foo &#123; public x: string;/* constructor(x: string, y: string, z: string) &#123; this.x = x; &#125;*/&#125; 접근 제한자 기본적인 객체 지향언어는 접근 제한자 (public, private, protected)를 지원하고 있다. TypeScript 역시 접근제한자를 지원하고 있다. 단, 접근 제한자를 명시하지 않았을 때, 다른 클래스 기반 언어의 경우, 암묵적으로 protected로 지정되어 패키지 레벨로 공개되지만 Typescript의 경우, 접근 제한자를 생략한 클래스 프로퍼티와 메소드는 암묵적으로 public이 선언된다. 따라서 public으로 지정하고자 하는 멤버 변수와 메소드는 접근 제한자를 생략한다. 접근 가능성 public protected private 클래스 내부 ◯ ◯ ◯ 자식 클래스 내부 ◯ ◯ ✕ 클래스 인스턴스 ◯ ✕ ✕ 12345678910111213141516171819202122232425262728const foo = new Foo('x', 'y', 'z');// public 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조 가능하다.console.log(foo.x);// protected 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조할 수 없다.console.log(foo.y);// error TS2445: Property 'y' is protected and only accessible within class 'Foo' and its subclasses.// private 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조할 수 없다.console.log(foo.z);// error TS2341: Property 'z' is private and only accessible within class 'Foo'.class Bar extends Foo &#123; constructor(x: string, y: string, z: string) &#123; super(x, y, z); // public 접근 제한자는 자식 클래스 내부에서 참조 가능하다. console.log(this.x); // protected 접근 제한자는 자식 클래스 내부에서 참조 가능하다. console.log(this.y); // private 접근 제한자는 자식 클래스 내부에서 참조할 수 없다. console.log(this.z); // error TS2341: Property 'z' is private and only accessible within class 'Foo'. &#125;&#125; 생성자 파라미터(매개변수)에 접근 제한자 선언 접근 제한자가 사용된 생성자 파라미터(매개변수)는 암묵적으로 클래스 프로퍼티로 선언되고 생성자 내부에서 별도의 초기화가 없어도 암묵적으로 초기화가 수행된다. 1234567891011121314151617// 기존 TS 정의class Foo &#123; public x: string; constructor(x: string, y: string, z: string) &#123; this.x = x; &#125;&#125;// 다음과 같이 축약 가능class Foo &#123; /* 접근 제한자가 선언된 생성자 파라미터(매개변수) x는 클래스 프로퍼티로 선언되고 지동으로 초기화된다. public이 선언되었으므로 x는 클래스 외부에서도 참조가 가능하다. */ constructor(public x: string) &#123; &#125;&#125; 만일 매개변수에 접근 제한자를 선언하지 않으면 매개변수는 생성자 내부에서만 유효한 지역 변수가 되어 생성자 외부에서 참조가 불가능하게 된다. 즉, 전혀 다른 문법이라는 이야기. 123456789class Foo &#123; // x는 생성자 내부에서만 유효한 지역 변수이다. constructor(x: string) &#123; console.log(x); &#125;&#125;const foo = new Foo('Hello');console.log(foo); // Foo &#123;&#125; readonly 키워드 자바스크립트에선 사용 불가능. 읽기만 가능한 상태가 되므로 상수 선언에 사용한다. 인스턴스 프로퍼티 임. (프로토타입 프로퍼티 X 클래스 프로퍼티 X) 123class Foo &#123; private readonly MAX_LEN: number = 5; private readonly MSG: string; 추상 클래스 1개 이상의 추상 메소드 와 일반 메소드를 포함한 클래스 JS 내부와 거의 유사하다. 대규모 프로젝트를 위한 문법. 추상 메소드란 ? 내용이 없고 메소드 이름과 타입만이 선언된 메소드. abstract키워드를 사용한다. 직접 인스턴스를 생성할 수 없고 상속만을 위해 사용된다. 추상 클래스를 상속한 클래스는 추상 클래스의 추상 메소드를 반드시 구현하여야 한다. 1234567891011121314151617181920212223abstract class Animal &#123; // 추상 메소드 abstract makeSound(): void; // 일반 메소드 move(): void &#123; console.log('roaming the earth...'); &#125;&#125;// 직접 인스턴스를 생성할 수 없다.// new Animal();// error TS2511: Cannot create an instance of the abstract class 'Animal'.class Dog extends Animal &#123; // 추상 클래스를 상속한 클래스는 추상 클래스의 추상 메소드를 반드시 구현하여야 한다 makeSound() &#123; console.log('bowwow~~'); &#125;&#125;const myDog = new Dog();myDog.makeSound();myDog.move(); TS 인터페이스 일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용 인터페이스는 인터페이스를 상속할 수 있음 인터페이스에 선언된 프로퍼티 또는 메소드의 구현을 강제하여 일관성을 유지할 수 있도록 하는 것. 직접 인스턴스를 생성할 수 없고 모든 메소드는 추상 메소드. abstract 키워드를 사용하지 않는다. 변수와 인터페이스 인터페이스는 변수의 타입으로 사용할 수 있다. 인터페이스를 타입으로 선언한 변수는 해당 인터페이스를 준수하여야 한다. 이것은 새로운 타입을 정의하는 것과 유사하다. 123456789101112// 인터페이스의 정의interface Todo &#123; id: number; content: string; completed: boolean;&#125;// 변수 todo의 타입으로 Todo 인터페이스를 선언하였다.let todo: Todo;// 변수 todo는 Todo 인터페이스를 준수하여야 한다.todo = &#123; id: 1, content: 'typescript', completed: false &#125;; 함수와 인터페이스 인터페이스는 함수의 타입으로 사용할 수 있다. 함수의 인터페이스에는 타입이 선언된 파라미터 리스트와 리턴 타입을 정의한다. 함수 인테페이스를 구현하는 함수는 인터페이스를 준수하여야 한다. 1234567891011// 함수 인터페이스의 정의interface SquareFunc &#123; (num: number): number;&#125;// 함수 인테페이스를 구현하는 함수는 인터페이스를 준수하여야 한다.const squareFunc: SquareFunc = function (num: number) &#123; return num * num;&#125;console.log(squareFunc(10)); // 100 클래스와 인터페이스 클래스 선언문의 implements 키워드 뒤에 인터페이스를 선언하면 해당 클래스는 지정된 인터페이스를 반드시 구현하여야 한다. 인터페이스를 구현하는 클래스의 일관성을 유지할 수 있는 장점을 갖는다. 인터페이스는 프로퍼티와 메소드를 가질 수 있다는 점에서 클래스와 유사하나 직접 인스턴스를 생성할 수는 없다. 12345678910111213141516171819// 인터페이스의 정의interface ITodo &#123; id: number; content: string; completed: boolean;&#125;// Todo 클래스는 ITodo 인터페이스를 구현하여야 한다.class Todo implements ITodo &#123; constructor ( public id: number, public content: string, public completed: boolean ) &#123; &#125;&#125;const todo = new Todo(1, 'Typescript', false);console.log(todo); 인터페이스는 프로퍼티뿐만 아니라 메소드도 포함할 수 있다.단, 모든 메소드는 추상 메소드이어야 한다.인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현하여야 한다. 12345678910111213141516171819202122232425// 인터페이스의 정의interface IPerson &#123; name: string; sayHello(): void;&#125;/*인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현하여야 한다.*/class Person implements IPerson &#123; // 인터페이스에서 정의한 프로퍼티의 구현 constructor(public name: string) &#123;&#125; // 인터페이스에서 정의한 추상 메소드의 구현 sayHello() &#123; console.log(`Hello $&#123;this.name&#125;`); &#125;&#125;function greeter(person: IPerson): void &#123; person.sayHello();&#125;const me = new Person('Lee');greeter(me); // Hello Lee 선택적 프로퍼티 인터페이스의 프로퍼티는 반드시 구현되어야 한다. 하지만 인터페이스의 프로퍼티가 선택적으로 필요한 경우가 있을 수 있다. 선택적 프로퍼티(Optional Property)는 프로퍼티명 뒤에 ?를 붙이며 생략하여도 에러가 발생하지 않는다. 12345678910111213interface UserInfo &#123; username: string; password: string; age? : number; address?: string;&#125;const userInfo: UserInfo = &#123; username: 'ungmo2@gmail.com', password: '123456'&#125;console.log(userInfo); 이렇게 선택적 프로퍼티를 사용하면 사용 가능한 프로퍼티를 파악할 수 있어서 코드를 이해하기 쉬워진다. Type Alias 타입 앨리어스는 새로운 타입을 정의한다. 타입으로 사용할 수 있다는 점에서 타입 앨리어스는 인터페이스와 유사하다. 하지만 다음과 같은 차이점이 존재한다. 인터페이스는 extends 또는 implements될 수 있지만 타입 앨리어스는 extends 또는 implements될 수 없다. 상속을 통해 확장이 필요하다면 타입 앨리어스보다는 인터페이스가 유리하지만 인터페이스로 표현할 수 없거나 유니온 또는 튜플을 사용해야한다면 타입 앨리어스를 사용하는 것이 좋다. 12345678910111213141516171819202122232425// 문자열 리터럴로 타입 지정type Str = 'Lee';// 유니온 타입으로 타입 지정type Union = string | null;// 문자열 유니온 타입으로 타입 지정type Name = 'Lee' | 'Kim';// 숫자 리터럴 유니온 타입으로 타입 지정type Num = 1 | 2 | 3 | 4 | 5;// 객체 리터럴 유니온 타입으로 타입 지정type Obj = &#123;a: 1&#125; | &#123;b: 2&#125;;// 함수 유니온 타입으로 타입 지정type Func = (() =&gt; string) | (() =&gt; void);// 인터페이스 유니온 타입으로 타입 지정type Shape = Square | Rectangle | Circle;// 튜플로 타입 지정type Tuple = [string, boolean];const t: Tuple = ['', '']; // Errorconst t2: Tuple = ['', true]; // Ok 튜플은 리액트의 useState에 사용할 수 있다. ( type Tuple = [any, function]; ) 제네릭 12345678910111213141516171819class Queue &#123; protected data = []; // data: any[] push(item) &#123; this.data.push(item); &#125; pop() &#123; return this.data.shift(); &#125;&#125;const queue = new Queue();queue.push(0);queue.push('1'); // 의도하지 않은 실수!console.log(queue.pop().toFixed()); // 0console.log(queue.pop().toFixed()); // Runtime error 위와 같이 구현했다고 가정하자. any[] 타입은 배열 요소의 타입이 모두 같지 않다는 문제를 가지게 된다.위 예제의 경우 data 프로퍼티는 number 타입만을 포함하는 배열이라는 기대 하에 각 요소에 대해 Number.prototype.toFixed를 사용하였다.따라서 number 타입이 아닌 요소의 경우 런타임 에러가 발생한다. 여기서 문제 해결을 위해 만약 item에 타입 한가지를 줘버리면 범용성을 잃게된다. 그래서 상속을 받아 새로운 클래스를 만들 수 있다. 12345678910111213141516171819202122// Queue 클래스를 상속하여 number 타입 전용 NumberQueue 클래스를 정의class NumberQueue extends Queue &#123; // number 타입의 요소만을 push한다. push(item: number) &#123; super.push(item); &#125; pop(): number &#123; return super.pop(); &#125;&#125;const queue = new NumberQueue();queue.push(0);// 의도하지 않은 실수를 사전 검출 가능// [ts] Argument of type '\"1\"' is not assignable to parameter of type 'number'.// queue.push('1');queue.push(+'1'); // 실수를 사전 인지하고 수정할 수 있다console.log(queue.pop().toFixed()); // 0console.log(queue.pop().toFixed()); // 1 constructor가 없고 setter가 오직 push,pop은 getter 하지만 string[]도 만들고, 다양한 타입의 배열이 추가된다면 너무 많은 클래스가 생겨날 것이다. 따라서 제네릭을 이용한다. 123456789101112131415161718192021222324252627282930313233343536class Queue&lt;T&gt; &#123; protected data: Array&lt;T&gt; = []; push(item: T) &#123; this.data.push(item); &#125; pop(): T &#123; return this.data.shift(); &#125;&#125;// number 전용 Queueconst numberQueue = new Queue&lt;number&gt;();numberQueue.push(0);// numberQueue.push('1'); // 의도하지 않은 실수를 사전 검출 가능numberQueue.push(+'1'); // 실수를 사전 인지하고 수정할 수 있다console.log(numberQueue.pop().toFixed()); // 0console.log(numberQueue.pop().toFixed()); // 1// string 전용 Queueconst stringQueue = new Queue&lt;string&gt;();stringQueue.push('Hello');stringQueue.push('World');console.log(stringQueue.pop().toUpperCase()); // HELLOconsole.log(stringQueue.pop().toUpperCase()); // WORLD// 커스텀 객체 전용 Queueconst myQueue = new Queue&lt;&#123;name: string, age: number&#125;&gt;();myQueue.push(&#123;name: 'Lee', age: 10&#125;);myQueue.push(&#123;name: 'Kim', age: 20&#125;);console.log(myQueue.pop()); // &#123; name: 'Lee', age: 10 &#125;console.log(myQueue.pop()); // &#123; name: 'Kim', age: 20 &#125; *제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법. * (외부의 값에 따라 결정됨) 한 번의 선언으로 다양한 타입에 재사용이 가능하다는 장점. T는 제네릭을 선언할 때 관용적으로 사용되는 식별자로 타입 파라미터(Type parameter). T는 Type의 약자로 반드시 T를 사용하여야 하는 것은 아니다. 함수에서도 제네릭을 이용할 수 있다. 123function reverse&lt;T&gt;(items: T[]): T[] &#123; return items.reverse();&#125; reverse 옆의 &lt;T&gt;는 문법, 클래스도 식별자 옆에 써준다. reverse 함수는 인수의 타입에 의해 타입 매개변수가 결정된다. reverse 함수는 다양한 타입의 요소로 구성된 배열을 인자로 전달받는다. 예를 들어 number 타입의 요소를 갖는 배열을 전달받으면 타입 매개변수는 number가 된다. 12345678function reverse&lt;T&gt;(items: T[]): T[] &#123; return items.reverse();&#125;const arg = [1, 2, 3, 4, 5];// 인수에 의해 타입 매개변수가 결정된다.const reversed = reverse(arg);console.log(reversed); // [ 5, 4, 3, 2, 1 ] 만약 {name: string} 타입의 요소를 갖는 배열을 전달받으면 타입 매개변수는 {name: string}가 된다. 12345678function reverse&lt;T&gt;(items: T[]): T[] &#123; return items.reverse();&#125;const arg = [&#123; name: 'Lee' &#125;, &#123; name: 'Kim' &#125;];// 인수에 의해 타입 매개변수가 결정된다.const reversed = reverse(arg);console.log(reversed); // [ &#123; name: 'Kim' &#125;, &#123; name: 'Lee' &#125; ]","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"TypeScript","slug":"Develop/TypeScript","permalink":"https://hyeok999.github.io/categories/Develop/TypeScript/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"},{"name":"typescript","slug":"typescript","permalink":"https://hyeok999.github.io/tags/typescript/"}]},{"title":"타입 스크립트 [01]","slug":"type-script-01","date":"2020-02-08T08:41:33.000Z","updated":"2020-02-08T10:04:58.550Z","comments":true,"path":"2020/02/08/type-script-01/","link":"","permalink":"https://hyeok999.github.io/2020/02/08/type-script-01/","excerpt":"","text":"TypeScript - 01 -목차 동적 타입 언어 vs 정적 타입 언어 자바스크립트의 특징 자바스크립트의 배열 타입스크립트 타입스크립트 설치 타입스크립트 타입 타입 추론 동적 타입 언어 vs 정적 타입 언어 JavaScript는 동적 타입 언어이다. 변수에는 타입이 없고 값이 할당되면 타입 추론으로 타입이 정해진다. 재할당이 가능한 경우, 재할당하면 타입 추론을 다시 하게 됨 12345var x; // 타입이 없다.x = 1; // 숫자 타입.var y = 'abc' // 문자열 타입.var z = 5; // 숫자 타입.z = 'abcd' // 문자열타입으로 변경됨. 정적인 언어에서는 위와 같이 동적으로 타입이 결정되지 않는다. 정적 타입 언어에서 타입을 정해주는 이유는 메모리에 값을 집어넣기 위해 얼마만큼의 공간이 필요한가를 알기 위함이다. 아래의 경우는 Java에서 변수를 선언할 때 예이다. 12int a = 5;String b = 'abc'; 타입 Java JS int 4바이트 x (부동소수점 8바이트로 대체) float 4바이트 8바이트 부동소수점(정수 없음) double 8바이트 8바이트 부동소수점(정수 없음) char 2바이트 x (String타입이 대신 존재한다. - 2바이트) 자바스크립트의 숫자타입은 정수가 없다. 자바스크립트에서 문자열을 원시값이라고 배웠지만, 실제로 문자열은 원시값이 아니라 한 개 이상의 문자로 이루어진 배열이다. char형은 본래 1바이트이지만 한글등 여러 나라 언어를 표기하는 문제로 인해 유니코드를 사용한다.(2바이트) 이모지 2~4 바이트 현대 자바스크립트는 애플리케이션 개발 언어가 되었다. 자바스크립트는 암묵적 처리가 많아 대규모 작업시 오히려 이해하기가 어려워졌다. 자바스크립트의 특징 Prototype-based Object Oriented Language Scope와 this 동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely typed) 언어 자바스크립트의 배열 배열을 getOwnPropertyDescriptor로 확인할 경우 객체임을 확인할 수있다.(유사배열) 원론적인 의미의 배열과 자바스크립트의 배열은 다르다, 원론적으로 요소의 타입이 통일되어 있어야 한다,(메모리 공간이 연속되어 있도록-접근이 빠르다) 자바스크립트에서는 단지 프로퍼티의 value이므로 [100, ‘apple’, true]와 같이 모든 값이 올 수 있다.(엄밀히 말하면 배열이 아니다.) 타입스크립트 JS는 대규모 프로젝트에서 코드가 복잡해질 수 있고 디버그와 테스트 공수가 증가하는 등의 문제를 일으킬 수 있다. 타입스크립트 = 자바스크립트의 Superset(상위확장) TypeScript 또한 자바스크립트 대체 언어의 하나로써 자바스크립트(ES5)의 Superset(상위확장) ES6(ECMAScript 2015)의 클래스, 모듈 등과 ES7의 Decorator 등을 지원한다. Babel과 같은 별도 트랜스파일러(Transpiler)를 사용하지 않아도 ES6의 새로운 기능을 기존의 자바스크립트 엔진(현재의 브라우저 또는 Node.js)에서 실행할 수 있다. 모든 기존 코드를 호환한다.(단, 클래스는 타입스크립트 문법을 따라야 한다.) 1234567// 클래스는 TS문법을 따라야한다.class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125;&#125; 에디터와의 호환성 JS에 경우 값을 할당하고나서 타입 추론으로 에디터를 통해 코드 어시스트를 받지만, 정적 타입은 변수 선언부터 에디터의 코드 어시스트, 타입 체크, 리펙토링 을 받을 수 있다. 강력한 객체지향 프로그래밍 지원 대규포 프로젝트에서 자주 사용되는 객체 프로그래밍을 지원받을 수 있다. 인터페이스 제네릭 타입스크립트 설치 npm 전역 설치 1$ npm install -g typescript 버전확인 1$ tsc -v 타입스크립트 컴파일 파일명.ts -&gt; 파일명.js로 분리함. 1$ tsc 파일명 config 설정 config파일 생성 (tsconfig.json) 1$ tsc --init “target” : “es5” (컴파일 할 버전) “module” : “commonjs” config 설정 완료 후 tsc만 입력해도 컴파일이 됨. (모든 ts파일 자동 컴파일) tsc 파일명 작성 시 tsconfig.json 설정 무시하고 해당 명령어 우선 실행 코드 저장 시 자동 tsc 명령 설정 ( tsconfig.json 있어야함. ) 1$ tsc -w 타입스크립트 타입 any[] : 배열 내부에 어떤 값이 와도 된다. (number[] -&gt; 배열 내부에 숫자타입만 허용된다.) tuple : 만드는 배열의 요소 개수를 정하고, 요소의 타입을 fix한다. enum : [키 : 값] 형태에서 키는 값의 이름으로서 중요성을 나타내지만 enum은 키의 이름 자체에 의미를 두는것. 대표적인 예로 조이스틱의 UP, DOWN, LEFT, RIGHT 등이 있다. never: 함수에 리턴 값이 없을 때 사용. (생략 가능) 특정 객체 타입을 지정해줄 때는 앞글자를 대문자로 한다. (Date, String 등등) 123let objectStr: String;objectStr = 'hello'; // OKobjectStr = new String('hello'); // OK TypeScript는 ES5, ES6의 Superset(상위확장)이므로 자바스크립트의 타입을 그대로 사용할 수 있다. 자바스크립트의 타입 이외에도 TypeScript 고유의 타입이 추가로 제공된다. Type JS TS Description boolean ◯ ◯ true와 false null ◯ ◯ 값이 없다는 것을 명시 undefined ◯ ◯ 값을 할당하지 않은 변수의 초기값 number ◯ ◯ 숫자(정수와 실수, Infinity, NaN) string ◯ ◯ 문자열 symbol ◯ ◯ 고유하고 수정 불가능한 데이터 타입이며 주로 객체 프로퍼티들의 식별자로 사용(ES6에서 추가) object ◯ ◯ 객체형(참조형) array ◯ 배열 tuple ◯ 고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현 enum ◯ 열거형. 숫자값 집합에 이름을 지정한 것이다. any ◯ 타입 추론(type inference)할 수 없거나 타입 체크가 필요없는 변수에 사용. var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당 가능. void ◯ 일반적으로 함수에서 반환값이 없을 경우 사용한다. never ◯ 결코 발생하지 않는 값 다양한 타입을 사전 선언하는 방법. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// booleanlet isDone: boolean = false;// nulllet n: null = null;// undefinedlet u: undefined = undefined;// numberlet decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;// stringlet color: string = \"blue\";color = 'red';let myName: string = `Lee`; // ES6 템플릿 문자열let greeting: string = `Hello, my name is $&#123; myName &#125;.`; // ES6 템플릿 대입문// objectconst obj: object = &#123;&#125;;// arraylet list1: any[] = [1, 'two', true];let list2: number[] = [1, 2, 3];let list3: Array&lt;number&gt; = [1, 2, 3]; // 제네릭 배열 타입// tuple : 고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현let tuple: [string, number];tuple = ['hello', 10]; // OKtuple = [10, 'hello']; // Errortuple = ['hello', 10, 'world', 100]; // Errortuple.push(true); // Error// enum : 열거형은 숫자값 집합에 이름을 지정한 것이다.enum Color1 &#123;Red, Green, Blue&#125;;let c1: Color1 = Color1.Green;console.log(c1); // 1enum Color2 &#123;Red = 1, Green, Blue&#125;;let c2: Color2 = Color2.Green;console.log(c2); // 2enum Color3 &#123;Red = 1, Green = 2, Blue = 4&#125;;let c3: Color3 = Color3.Blue;console.log(c3); // 4/*any: 타입 추론(type inference)할 수 없거나 타입 체크가 필요 없는 변수에 사용한다.var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당할 수 있다.*/let notSure: any = 4;notSure = 'maybe a string instead';notSure = false; // okay, definitely a boolean// void : 일반적으로 함수에서 반환값이 없을 경우 사용한다.function warnUser(): void &#123; console.log(\"This is my warning message\");&#125;// never : 결코 발생하지 않는 값function infiniteLoop(): never &#123; while (true) &#123;&#125;&#125;function error(message: string): never &#123; throw new Error(message);&#125; 타입 추론 만약 타입 선언을 생략하면 값이 할당되는 과정에서 동적으로 타입이 결정된다. 1let foo = 123; // foo는 number 타입 위 코드를 보면 변수 foo에 타입을 선언하지 않았으나 타입 추론에 의해 변수의 타입이 결정되었다. 동적 타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있다. 하지만 정적 타입 언어는 타입이 결정된 후에는 타입을 변경할 수 없다. TypeScript는 정적 타입 언어이므로 타입 추론으로 타입이 결정된 이후, 다른 타입의 값을 할당하면 에러가 발생한다. 12let foo = 123; // foo는 number 타입foo = 'hi'; // error: Type '\"hi\"' is not assignable to type 'number'.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"TypeScript","slug":"Develop/TypeScript","permalink":"https://hyeok999.github.io/categories/Develop/TypeScript/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"},{"name":"typescript","slug":"typescript","permalink":"https://hyeok999.github.io/tags/typescript/"}]},{"title":"Immer를 사용한 더 쉬운 불변성 관리","slug":"react-velo-21","date":"2020-02-03T14:11:11.000Z","updated":"2020-02-04T06:04:43.437Z","comments":true,"path":"2020/02/03/react-velo-21/","link":"","permalink":"https://hyeok999.github.io/2020/02/03/react-velo-21/","excerpt":"","text":"React with Velopert - 21 - Immer 불변성의 예 Immer 미사용의 경우, Immer 사용의 경우, Immer 기본 사용법 리듀서에서 Immer 사용하기 Immer 와 함수형 업데이트 Chap 21. Immer를 사용한 더 쉬운 불변성 관리Immer 리액트에서는 배열이나 객체를 업데이트 해야 할 때에는 직접 수정하면 안되고 불변성을 지켜주면서 업데이트를 해야 한다. 불변성의 예 잘못된 경우, 123456const object = &#123; a: 1, b: 2&#125;;object.b = 3; 올바른 경우, 123456789const object = &#123; a: 1, b: 2&#125;;const nextObject = &#123; ...object, // 객체를 스프레드문법을 이용해 분해하고 있다. b: 3&#125;; 배열도 마찬가지로, push, pop, shift, unshift, splice 등의 함수를 사용하거나 n 번째 항목을 직접 수정하면 안되고 다음과 같이 concat, filter, map 등의 함수를 사용해야 한다. (원본을 해손하지않고 새로운 배열을 반환하는 함수들) 1234567891011121314151617181920212223242526272829const todos = [ &#123; id: 1, text: '할 일 #1', done: true &#125;, &#123; id: 2 text: '할 일 #2', done: false &#125;];const inserted = todos.concat(&#123; id: 3, text: '할 일 #3', done: false&#125;);const filtered = todos.filter(todo =&gt; todo.id !== 2);const toggled = todos.map( todo =&gt; todo.id === 2 ? &#123; ...todo, done: !todo.done, &#125; : todo); 대부분의 경우 ... 연산자 또는 배열 내장함수를 사용하는건 그렇게 어렵지는 않지만 데이터의 구조가 조금 까다로워지면 불변성을 지켜가면서 새로운 데이터를 생성해내는 코드가 조금 복잡해진다. Immer 미사용의 경우, 다음과 같은 객체가 있다고 가정하자. 123456789101112131415161718192021222324252627const state = &#123; posts: [ &#123; id: 1, title: '제목입니다.', body: '내용입니다.', comments: [ &#123; id: 1, text: '와 정말 잘 읽었습니다.' &#125; ] &#125;, &#123; id: 2, title: '제목입니다.', body: '내용입니다.', comments: [ &#123; id: 2, text: '또 다른 댓글 어쩌고 저쩌고' &#125; ] &#125; ], selectedId: 1&#125;; posts배열 내에 있는 id가 1인 post객체를 찾아서, comments에 새로운 댓글 객체를 추가해줘야 한다고 가정해보자. 1234567891011121314const nextState = &#123; ...state, // 불변성을 유지하기 위해 기존의 값을 스프레드로 뿌려주었다. posts: state.posts.map(post =&gt; post.id === 1 ? &#123; ...post, comments: post.comments.concat(&#123; id: 3, text: '새로운 댓글' &#125;) &#125; : post )&#125;; 만약 immer 라이브러리를 이용할 경우, 다음처럼 더 쉽게 작업이 가능하다. 1234567const nextState = produce(state, draft =&gt; &#123; const post = draft.posts.find(post =&gt; post.id === 1); post.comments.push(&#123; id: 3, text: '와 정말 쉽다!' &#125;);&#125;); Immer 를 사용하면 우리가 상태를 업데이트 할 때, 불변성을 신경쓰지 않으면서 업데이트를 해주면 Immer 가 불변성 관리를 대신 해준다. Immer 사용의 경우, Immer 기본 사용법기존에 만들었던 사용자 관리 프로젝트에 Immer 를 적용해보면서 Immer 의 사용법을 알아보자. immer 설치하기 1npm install immer --save immer 불러오기 1import produce from 'immer'; produce 함수를 사용 시 첫번째 파라미터 : 수정하고 싶은 상태 두번째 파라미터 : 어떻게 업데이트하고 싶을지 정의하는 함수 두번째 파라미터에 넣는 함수에서는 불변성에 대해서 신경쓰지 않고 그냥 업데이트 해주면 다 알아서 해준다. (완전 편리하다. ++) 1234567891011const state = &#123; number: 1, dontChangeMe: 2&#125;;const nextState = produce(state, draft =&gt; &#123; draft.number += 1;&#125;);console.log(nextState);// &#123; number: 2, dontChangeMe: 2 &#125; 리듀서에서 Immer 사용하기 참고로, Immer를 사용한다 해서 무조건 코드가 짧아지고 좋아지는 것은 아니다. Immer 를 사용해서 간단해지는 업데이트가 있고, 오히려 코드가 길어지는 업데이트 들이 있다. 예를들어서 전에 만들었던 프로젝트의 상태의 경우 users 배열이 객체의 깊은곳에 위치하지 않기 때문에 새 항목을 추가하거나 제거 할 때는 Immer 를 사용하는 것 보다 concat 과 filter 를 사용하는것이 더 코드가 짧고 편하다. 우선, 학습을 위해 이번 업데이트는 Immer 를 사용하여 처리를 해보자. App.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React, &#123; useReducer, useMemo &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';import produce from 'immer';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; // immer 적용하기 switch (action.type) &#123; case 'CREATE_USER': return produce(state, draft =&gt; &#123; draft.users.push(action.user); &#125;); case 'TOGGLE_USER': return produce(state, draft =&gt; &#123; const user = draft.users.find(user =&gt; user.id === action.id); user.active = !user.active; &#125;); case 'REMOVE_USER': return produce(state, draft =&gt; &#123; const index = draft.users.findIndex(user =&gt; user.id === action.id); draft.users.splice(index, 1); &#125;); default: return state; &#125;&#125;export const UserDispatch = React.createContext(null);function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const &#123; users &#125; = state; const count = useMemo(() =&gt; countActiveUsers(users), [users]); return ( &lt;UserDispatch.Provider value=&#123;dispatch&#125;&gt; &lt;CreateUser /&gt; &lt;UserList users=&#123;users&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; &lt;/UserDispatch.Provider&gt; );&#125;export default App; TOGGLE_USER 액션의 경우엔 확실히 Immer 를 사용하니 코드가 깔끔해졌지만 나머지의 경우에는 오히려 코드가 좀 복잡해졌다. 상황에 따라 잘 선택하여 사용해야 한다. Immer 를 사용한다고 해서 모든 업데이트 로직에서 사용을 하실 필요는 없다. Immer 와 함수형 업데이트 이전에 useState 를 사용 할 때 함수형 업데이트란걸 할 수 있다고 배웠다. 1234567891011const [todo, setTodo] = useState(&#123; text: 'Hello', done: false&#125;);const onClick = useCallback(() =&gt; &#123; setTodo(todo =&gt; (&#123; ...todo, done: !todo.done &#125;));&#125;, []); 함수에 업데이트를 해주는 함수를 넣음으로써, 만약 useCallback 을 사용하는 경우 두번째 파라미터인 deps 배열에 todo 를 넣지 않아도 된다. 위 처럼, 함수형 업데이트를 하는 경우에, Immer 를 사용하면 상황에 따라 더 편하게 코드를 작성 할 수 있다. 만약에 produce 함수에 두개의 파라미터를 넣게 된다면, 첫번째 파라미터에 넣은 상태를 불변성을 유지하면서 새로운 상태를 만들어주지만, 만약에 첫번째 파라미터를 생략하고 바로 업데이트 함수를 넣어주게 된다면, 반환 값은 새로운 상태가 아닌 상태를 업데이트 해주는 함수가 된다. 12345678910111213const todo = &#123; text: 'Hello', done: false&#125;;const updater = produce(draft =&gt; &#123; draft.done = !draft.done;&#125;);const nextTodo = updater(todo);console.log(nextTodo);// &#123; text: 'Hello', done: true &#125; 결국 produce 가 반환하는것이 업데이트 함수가 되기 때문에 useState 의 업데이트 함수를 사용 할 떄 다음과 같이 구현 할 수 있게 된다. (즉 produce가 반환하는 것은 함수이므로 화살표 함수를 반환한것과 같다는 것 - Immer는 함수형 업데이트 ) 123456789101112const [todo, setTodo] = useState(&#123; text: 'Hello', done: false&#125;);const onClick = useCallback(() =&gt; &#123; setTodo( produce(draft =&gt; &#123; draft.done = !draft.done; &#125;) );&#125;, []); 이러한 속성을 잘 알아두시고, 나중에 필요할때 잘 사용하시면 되겠습니다. Immer 은 분명히 정말 편한 라이브러리이다. 하지만, 확실히 알아둘 점은, 성능적으로는 Immer 를 사용하지 않은 코드가 조금 더 빠르다는 점 이다. 조사 결과, 50,000개의 원소중에서 5,000 개의 원소를 업데이트 하는 코드를 비교 했을때의 결과로, Immer 의 경우 31ms 걸리는 작업이 (map 을 사용하는) Native Reducer 에서는 6ms 걸린 것을 확인 할 수 있다. (생각보다 차이가 있다.) 추가로, Immer 는 JavaScript 엔진의 Proxy 라는 기능을 사용하는데, 구형 브라우저 및 react-native 같은 환경에서는 지원되지 않으므로 (Proxy 처럼 작동하지만 Proxy는 아닌) ES5 fallback 을 사용하게 된다. ES5 fallback 을 사용하게 되는경우는 191ms 정도로, 꽤나 느려지게 되는데, 여전히 데이터가 별로 없다면 크게 걱정 할 필요는 없다. Immer 라이브러리는 확실히 편하기 때문에, 데이터의 구조가 복잡해져서 불변성을 유지하면서 업데이트하려면 코드가 복잡해지는 상황이 온다면, 이를 사용하는 것을 권장한다. 다만, 무조건 사용을 하진 마시고, 가능하면 데이터의 구조가 복잡해지게 되는 것을 방지하자. 어쩔 수 없을 때에만 Immer 를 사용하는것이 좋다. Immer 를 사용한다고 해도, 필요한곳에만 쓰고, 간단히 처리 될 수 있는 곳에서는 그냥 일반 JavaScript 로 구현하는 것을 권한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"Context API를 사용한 전역 값 관리","slug":"react-velo-20","date":"2020-02-01T14:45:56.000Z","updated":"2020-02-01T14:46:33.453Z","comments":true,"path":"2020/02/01/react-velo-20/","link":"","permalink":"https://hyeok999.github.io/2020/02/01/react-velo-20/","excerpt":"","text":"React with Velopert - 20 - Context API를 사용한 전역 값 관리 Context API 만들어보기 App.js UserList.js 수정하기 CreateUser.js 수정하기 Chap 20. Context API를 사용한 전역 값 관리Context API를 사용한 전역 값 관리 현재 프로젝트들은 App 컴포넌트에서 onToggle, onRemove 가 구현이 되어있고 이 함수들은 UserList 컴포넌트를 거쳐서 각 User 컴포넌트들에게 전달 되는 방식으로 구현되어 있다. 여기서 UserList 컴포넌트의 경우에는 onToggle 과 onRemove 를 전달하기 위하여 중간 다리역할만 한다. UserList.js 1234567891011121314function UserList(&#123; users, onRemove, onToggle &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; ))&#125; &lt;/div&gt; );&#125; UserList 에서는 해당 함수들을 직접 사용하는 일도 없다. 특정 함수를 특정 컴포넌트를 거쳐서 원하는 컴포넌트에게 전달하는 작업은 리액트로 개발을 하다보면 자주 발생 할 수 있는 작업이다. 컴포넌트 한개정도를 거쳐서 전달하는건 사실 그렇게 큰 불편함도 없지만, 만약 3~4개 이상의 컴포넌트를 거쳐서 전달을 해야 하는 일이 발생하게 된다면 이는 매우 번거로울 것이다. 그럴 땐, 리액트의 Context API 와 이전 섹션에서 배웠던 dispatch 를 함께 사용하면 이러한 복잡한 구조를 해결 할 수 있다. 리액트의 Context API 를 사용하면, 프로젝트 안에서 전역적으로 사용 할 수 있는 값을 관리 할 수 있다. 여기서 “상태” 가 아닌 “값” 이라고 언급을 했는데, 이 값은 꼭 상태를 가르키지 않아도 된다. 이 값은 함수일수도 있고, 어떤 외부 라이브러리 인스턴스일수도 있고 심지어 DOM 일 수도 있다. 물론, Context API 를 사용해서 프로젝트의 상태를 전역적으로 관리 할 수도 있긴한데, 이에 대해서는 나중에 더 자세히 알아보도록 한다. 우선, Context API 를 사용해여 새로운 Context 를 만드는 방법을 알아보자. Context API 만들어보기 Context 를 만들 땐 다음과 같이 React.createContext() 라는 함수를 사용한다. 1const UserDispatch = React.createContext(null); createContext 의 파라미터에는 Context 의 기본값을 설정할 수 있다. 여기서 설정하는 값은 Context 를 쓸 때 값을 따로 지정하지 않을 경우 사용되는 기본 값이다. Context 를 만들면, Context 안에 Provider 라는 컴포넌트가 들어있는데 이 컴포넌트를 통하여 Context 의 값을 정할 수 있다. 이 컴포넌트를 사용할 때, value 라는 값을 설정해주면 된다. 1&lt;UserDispatch.Provider value=&#123;dispatch&#125;&gt;...&lt;/UserDispatch.Provider&gt; 설정 후 Provider 에 의하여 감싸진 컴포넌트 중 어디서든지 Context 의 값을 다른 곳에서 바로 조회해서 사용 할 수 있다. App 컴포넌트 에서 Context 를 만들고, 사용하고, 내보내는 작업을 해보자. App.js UserDispatch 라는 Context만들기. (어디서든지 dispatch를 꺼내 쓸 수 있도록 준비) 12345// UserDispatch 라는 이름으로 내보낸다.export const UserDispatch = React.createContext(null);// 나중에 사용하고 싶을 때 다음과 같이 불러와서 사용 할 수 있다.import &#123; UserDispatch &#125; from './App'; Context 를 다 만들었으면, App 에서 onToggle 과 onRemove 를 지우고, UserList 에게 props를 전달하는것도 지운다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import React, &#123; useRef, useReducer, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';import useInputs from './hooks/useInputs';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'CREATE_USER' : return &#123; inputs: initialState.inputs, users: state.users.concat(action.user) &#125;; case 'TOGGLE_USER' : return &#123; ...state, users: state.users.map(user =&gt; user.id === action.id ? &#123;...user, active: !user.active&#125; : user ) &#125;; case 'REMOVE_USER' : return &#123; ...state, users : state.users.filter(user =&gt; user.id !== action.id) &#125;; default: return state; &#125;&#125;// UserDispatch 라는 이름으로 내보내보낸다.export const UserDispatch = React.createContext(null);function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const nextId = useRef(4); const &#123; users &#125; = state; const [&#123; username, email &#125;, onChange, reset] = useInputs(&#123; username : '', email : '' &#125;); const onCreate = useCallback(() =&gt; &#123; dispatch(&#123; type: 'CREATE_USER', user: &#123; id: nextId.current, username, email &#125; &#125;); reset(); nextId.current += 1; &#125;, [username, email, reset]); // const onToggle = useCallback(id =&gt; &#123; // dispatch(&#123; // type: 'TOGGLE_USER', // id // &#125;); // &#125;, []); // const onRemove = useCallback(id =&gt; &#123; // dispatch(&#123; // type: 'REMOVE_USER', // id // &#125;); // &#125;, []); const count = useMemo(() =&gt; countActiveUsers(users), [users]); return ( &lt;UserDispatch.Provider value=&#123;dispatch&#125;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &#123;/* &lt;UserList users=&#123;users&#125; onToggle=&#123;onToggle&#125; onRemove=&#123;onRemove&#125; /&gt; */&#125; &lt;UserList users=&#123;users&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; &lt;/UserDispatch.Provider&gt; );&#125;export default App; UserList.js 수정하기 UserList 컴포넌트에서 에서 onToggle 과 onRemove 와 관련된 코드들을 지운다. 1234567891011121314151617181920212223242526272829303132import React from 'react';const User = React.memo(function User(&#123; user &#125;) &#123; return ( &lt;div&gt; &lt;b style=&#123;&#123; cursor: 'pointer', color: user.active ? 'green' : 'black' &#125;&#125; onClick=&#123;() =&gt; &#123;&#125;&#125; &gt; &#123;user.username&#125; &lt;/b&gt; &amp;nbsp; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;삭제&lt;/button&gt; &lt;/div&gt; );&#125;);function UserList(&#123; users &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default React.memo(UserList); User 컴포넌트에서 dispatch 를 사용 하도록 한다.dispatch를 사용하기 위해서는 useContext 라는 Hook 을 사용해서 전에 만든 UserDispatch Context 를 조회해야한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; useContext &#125; from 'react';import &#123; UserDispatch &#125; from './App';const User = React.memo(function User(&#123; user &#125;) &#123; const dispatch = useContext(UserDispatch); return ( &lt;div&gt; &lt;b style=&#123;&#123; cursor: 'pointer', color: user.active ? 'green' : 'black' &#125;&#125; onClick=&#123;() =&gt; &#123; dispatch(&#123; type: 'TOGGLE_USER', id: user.id &#125;); &#125;&#125; &gt; &#123;user.username&#125; &lt;/b&gt; &amp;nbsp; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: 'REMOVE_USER', id: user.id &#125;); &#125;&#125; &gt; 삭제 &lt;/button&gt; &lt;/div&gt; );&#125;);function UserList(&#123; users &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default React.memo(UserList); 결과적으로 Context API 를 사용해서 dispatch 를 어디서든지 조회해서 사용할 수 있게 되었다. CreateUser.js 수정하기 CreateUser.js에도 Context API를 적용해본다. 조건 CreateUser 에게는 어떤 props 도 전달하지 않을 것. CreateUser 컴포넌트 내부에서 useInputs 를 사용. useRef 를 사용한 nextId 값을 CreateUser 에서 관리할 것. App.js 에서 CreateUser 컴포넌트와 연관된 props , action들을 지운다. ref관리도 CreateUser에서 한다. App.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import React, &#123; useRef, useReducer, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'CREATE_USER' : return &#123; inputs: initialState.inputs, users: state.users.concat(action.user) &#125;; case 'TOGGLE_USER' : return &#123; ...state, users: state.users.map(user =&gt; user.id === action.id ? &#123;...user, active: !user.active&#125; : user ) &#125;; case 'REMOVE_USER' : return &#123; ...state, users : state.users.filter(user =&gt; user.id !== action.id) &#125;; default: return state; &#125;&#125;// UserDispatch 라는 이름으로 내보내줍니다.export const UserDispatch = React.createContext(null);function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const &#123; users &#125; = state; // const onCreate = useCallback(() =&gt; &#123; // dispatch(&#123; // type: 'CREATE_USER', // user: &#123; // id: nextId.current, // username, // email // &#125; // &#125;); // reset(); // nextId.current += 1; // &#125;, [username, email, reset]); // const onToggle = useCallback(id =&gt; &#123; // dispatch(&#123; // type: 'TOGGLE_USER', // id // &#125;); // &#125;, []); // const onRemove = useCallback(id =&gt; &#123; // dispatch(&#123; // type: 'REMOVE_USER', // id // &#125;); // &#125;, []); const count = useMemo(() =&gt; countActiveUsers(users), [users]); return ( &lt;UserDispatch.Provider value=&#123;dispatch&#125;&gt; &#123;/* &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; */&#125; &lt;CreateUser/&gt; &#123;/* &lt;UserList users=&#123;users&#125; onToggle=&#123;onToggle&#125; onRemove=&#123;onRemove&#125; /&gt; */&#125; &lt;UserList users=&#123;users&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; &lt;/UserDispatch.Provider&gt; );&#125;export default App; CreateUser에서 UserDispatch를 통해 받은 값들을 이용하여 dispatch를 구성한다. 또한 useRef를 여기서 사용하여 다음 Id값을 관리하기 시작한다. CreateUser.js 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; useRef, useContext &#125; from 'react';import &#123; UserDispatch &#125; from './App';import useInputs from '../20/hooks/useInputs';function CreateUser() &#123; const dispatch = useContext(UserDispatch); const nextId = useRef(4); const [&#123; username, email &#125;, onChange, reset] = useInputs(&#123; username : '', email : '' &#125;); return ( &lt;div&gt; &lt;input name=\"username\" placeholder=\"계정명\" onChange=&#123;onChange&#125; value=&#123;username&#125; /&gt; &lt;input name=\"email\" placeholder=\"이메일\" onChange=&#123;onChange&#125; value=&#123;email&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: 'CREATE_USER', user: &#123; id: nextId.current, username, email &#125; &#125;); reset(); nextId.current += 1;&#125; &#125; &gt;등록&lt;/button&gt; &lt;/div&gt; );&#125;export default React.memo(CreateUser);","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"useReactRouter Hook [5]","slug":"react-router-05","date":"2020-02-01T09:22:55.000Z","updated":"2020-02-01T14:44:11.890Z","comments":true,"path":"2020/02/01/react-router-05/","link":"","permalink":"https://hyeok999.github.io/2020/02/01/react-router-05/","excerpt":"","text":"React Router with Velopert - 05 - useReactRouter Hook RouterHookSample.js Profiles.js Chap 4. useReactRouter Hook useReactRouter HookwithRouter로 라우트를 사용하지 않은 컴포넌트에서도 match, location, history등을 조회할 수 있었다. withRouter대신 Hook을 이용해 구현할 수도 있다. 아직 공식적인 Hook지원은 아니다. 그래서 아직까지는 다른 라이브러리를 통해 사용해야한다. 사용 할 라이브러리의 이름은 use-react-router 이다. 1npm install use-react-router --save RouterHookSample.js123456789import useReactRouter from 'use-react-router';function RouterHookSample() &#123; const &#123; history, location, match &#125; = useReactRouter(); console.log(&#123; history, location, match &#125;); return null;&#125;export default RouterHookSample; 이제 이 컴포넌트를 Profiles 컴포넌트에서 WithRouterSample 하단에 렌더링해보자. Profiles.js123456789101112131415161718192021222324252627282930313233343536373839404142import React from 'react';import &#123; Route, NavLink &#125; from 'react-router-dom';import Profile from './Profile';import WithRouterSample from './WithRouterSample';import RouterHookSample from './RouterHookSample';const Profiles = () =&gt; &#123; return ( &lt;div&gt; &lt;h3&gt;유저 목록:&lt;/h3&gt; &lt;ul&gt; &lt;li&gt; &lt;NavLink to=\"/profiles/hyeok999\" activeStyle=&#123;&#123; background: 'black', color: 'white' &#125;&#125; &gt; hyeok999 &lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to=\"/profiles/homer\" activeStyle=&#123;&#123; background: 'black', color: 'white' &#125;&#125; &gt; homer &lt;/NavLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/profiles\" exact render=&#123;() =&gt; &lt;div&gt;유저를 선택해주세요.&lt;/div&gt;&#125; /&gt; &lt;Route path=\"/profiles/:username\" component=&#123;Profile&#125; /&gt; &lt;WithRouterSample /&gt; &lt;RouterHookSample /&gt; &lt;/div&gt; );&#125;;export default Profiles; 콘솔을 확인해보면. 위와 같이 프로필 목록 페이지를 열었을 때 location, match, history 객체들을 조회 할 수 있다. 이 Hook 이 정식 릴리즈는 아니기 때문에 만약에 withRouter 가 너무 불편하다고 느낄 경우에만 사용하시는 것을 권장한다. 사용 한다고 해서 나쁠 것은 없지만, 나중에 정식 릴리즈가 나오게 되면 해당 라이브러리를 제거하고 코드를 수정해야 하는 일이 발생 할 수도 있다. 적어도, withRouter 를 사용하셨다면, 레거시 코드로 유지해도 큰 문제는 없다. 물론 추후 useReactRouter 를 사용하는 코드도 방치해도 될 지도 모르지만, 불필요한 라이브러리의 코드가 프로젝트에 포함된다는점, 그리고 정식 릴리즈가 되는 순간부터 useReactRouter 의 유지보수가 더 이상 이루어지지 않을 것 이라는 점을 생각하면, 중요한 프로젝트라면 사용을 하지 않는 편이 좋을 수도 있다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://hyeok999.github.io/tags/Router/"}]},{"title":"라우터 부가기능 [4]","slug":"react-router-04","date":"2020-01-29T15:01:02.000Z","updated":"2020-01-29T15:03:10.845Z","comments":true,"path":"2020/01/30/react-router-04/","link":"","permalink":"https://hyeok999.github.io/2020/01/30/react-router-04/","excerpt":"","text":"React Router with Velopert - 04 - history 객체 src/HistorySample.js src/App.js withRouter HoC src/WithRouterSample.js src/Profiles.jsx Switch src/App.js NavLink src/Profiles.js 기타 Chap 4. 리액트 라우터 부가기능 history 객체 history 객체는 라우트로 사용된 컴포넌트에게 match, location 과 함께 전달되는 props 중 하나. 이 객체는, URL에 쿼리나 파라미터를 넘겨줌으로써(push) , 뒤로가기, 특정 경로로 이동, 이탈 방지 등 을 수행할 수 있다. 즉, 이 객체를 통해 컴포넌트 내에 구현하는 메소드에서 라우터에 직접 접근할 수 있다. src/HistorySample.jsuseEffect 는 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook 이다. 클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate 를 합친 형태로 보아도 무방함. 12345678910111213141516171819202122232425262728import React, &#123; useEffect &#125; from 'react';function HistorySample(&#123; history &#125;) &#123; const goBack = () =&gt; &#123; history.goBack(); &#125;; const goHome = () =&gt; &#123; history.push('/'); &#125;; useEffect(() =&gt; &#123; console.log(history); const unblock = history.block('정말 떠나실건가요?'); return () =&gt; &#123; unblock(); &#125;; &#125;, [history]); return ( &lt;div&gt; &lt;button onClick=&#123;goBack&#125;&gt;뒤로가기&lt;/button&gt; &lt;button onClick=&#123;goHome&#125;&gt;홈으로&lt;/button&gt; &lt;/div&gt; );&#125;export default HistorySample; 위 컴포넌트 예제를 App.js에 넣고 실행해보면 이탈방지 팝업창을 띄우게 된다. src/App.js1234567891011121314151617181920212223242526272829303132import React from 'react';import &#123; Route, Link &#125; from 'react-router-dom';import About from './About';import Home from './Home';import Profiles from './Profiles';import HistorySample from './HistorySample';const App = () =&gt; &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;홈&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;소개&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/profiles\"&gt;프로필 목록&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/history\"&gt;예제&lt;/Link&gt; //여기 &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route path=\"/\" exact=&#123;true&#125; component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/profiles\" component=&#123;Profiles&#125; /&gt; &lt;Route path=\"/history\" component=&#123;HistorySample&#125; /&gt; &lt;/div&gt; );&#125;; withRouter HoC withRouter HoC는 라우터 컴포넌트가 아닌 곳에서 match / location / history를 사용해야할 떄 사용된다. src/WithRouterSample.js123456789101112131415import React from 'react';import &#123; withRouter &#125; from 'react-router-dom';const WithRouterSample = (&#123; location, match, history &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h4&gt;location&lt;/h4&gt; &lt;textarea value=&#123;JSON.stringify(location, null, 2)&#125; readOnly /&gt; &lt;h4&gt;match&lt;/h4&gt; &lt;textarea value=&#123;JSON.stringify(match, null, 2)&#125; readOnly /&gt; &lt;button onClick=&#123;() =&gt; history.push('/')&#125;&gt;홈으로&lt;/button&gt; &lt;/div&gt; );&#125;;export default withRouter(WithRouterSample); 위와 같이 작성이 완료되면, 타 컴포넌트에서 &lt;Route&gt;태그를 이용하지 않더라도 match 와 location을 전달할 수 있다. src/Profiles.jsx1234567891011121314151617181920212223import React from 'react'import Profile from './Profile'import &#123; Link, Route &#125; from 'react-router-dom'import WithRouterSample from './WithRouterSample';const Profiles = (props) =&gt; &#123; return ( &lt;div&gt; &lt;h3&gt;사용자 목록&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/profiles/hyeok999'&gt;혁999&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/profiles/homer'&gt;homer&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path='/profiles' exact render=&#123;() =&gt; &lt;div&gt;사용자를 선택해주세요.&lt;/div&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path='/profiles/:username' component=&#123;Profile&#125; /&gt; &lt;WithRouterSample&gt;&lt;/WithRouterSample&gt; &lt;/div&gt; );&#125;export default Profiles; 단, match는 문제가 한가지 있다. 우선 App.js에서 Profiles 컴포넌트를 라우팅할 때 다음과 같은 path로 불러낸다. &lt;Route path=&#39;/profiles&#39; component={Profiles} /&gt; match는 라우터를 해주는 컴포넌트에서 path에 있는 파라미터를 보여주는데 App.js → Profiles.jsx 를 라우팅할때 파라미터가 설정되어있지 않으니 match의 결과는 빈배열이 나타나게 된다. 쉽게 이해하면 withRouter에서 match는 부모 라우터의 파라미터값을 의미한다는 것이다. 따라서 이 상황에서는 Profiles.jsx에서 &lt;WithRouterSample&gt;태그를 사용하는 것보다는 Profiles.jsx에 &lt;Route path=&#39;/profiles/:username&#39; component={Profile} /&gt;가 정의가 되어있기 때문에, Profile.jsx 컴포넌트에 정의하면 match값을 확인할 수 있다. Switch Switch는 여러 Route들을 감싸는 규칙중 하나이다. Switch 를 사용하면, 아무것도 일치하지 않았을때 보여줄 Not Found 페이지를 구현 할 수도 있다. src/App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445import React from 'react';import &#123; Switch, Route, Link &#125; from 'react-router-dom';import About from './About';import Home from './Home';import Profiles from './Profiles';import HistorySample from './HistorySample';const App = () =&gt; &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;홈&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;소개&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/profiles\"&gt;프로필 목록&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/history\"&gt;예제&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact=&#123;true&#125; component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/profiles\" component=&#123;Profiles&#125; /&gt; &lt;Route path=\"/history\" component=&#123;HistorySample&#125; /&gt; &lt;Route // path 를 따로 정의하지 않으면 모든 상황에 렌더링됨 render=&#123;(&#123; location &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;이 페이지는 존재하지 않습니다:&lt;/h2&gt; &lt;p&gt;&#123;location.pathname&#125;&lt;/p&gt; &lt;/div&gt; )&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;;export default App; NavLink NavLink 는 Link 랑 비슷한데, 만약 현재 경로와 Link 에서 사용하는 경로가 일치하는 경우 특정 스타일 혹은 클래스를 적용 할 수 있는 컴포넌트이다. 쉽게 말해서 Link에 스타일 혹은 클래스를 줄 수 있는 것. 만약에 인라인 스타일이 아니라 CSS 클래스를 적용하시고 싶으면 activeStyle 대신 activeClassName 을 사용하면 된다. Profiles.jsx 애서 사용하는 컴포넌트에서 Link 대신 NavLink 를 사용해보자. src/Profiles.js123456789101112131415161718192021222324252627282930313233343536373839404142import React from 'react';import &#123; Route, NavLink &#125; from 'react-router-dom';import Profile from './Profile';import WithRouterSample from './WithRouterSample';const Profiles = () =&gt; &#123; return ( &lt;div&gt; &lt;h3&gt;유저 목록:&lt;/h3&gt; &lt;ul&gt; &lt;li&gt; &lt;NavLink to=\"/profiles/velopert\" // 인라인 스타일 적용 activeStyle=&#123;&#123; background: 'black', color: 'white' &#125;&#125; &gt; velopert &lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to=\"/profiles/gildong\" // 인라인 스타일 적용 activeStyle=&#123;&#123; background: 'black', color: 'white' &#125;&#125; &gt; gildong &lt;/NavLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/profiles\" exact render=&#123;() =&gt; &lt;div&gt;유저를 선택해주세요.&lt;/div&gt;&#125; /&gt; &lt;Route path=\"/profiles/:username\" component=&#123;Profile&#125; /&gt; &lt;WithRouterSample /&gt; &lt;/div&gt; );&#125;;export default Profiles; 기타이 외에도 다른 기능들 Redirect: 페이지를 리디렉트 하는 컴포넌트 Prompt: 이전에 사용했던 history.block 의 컴포넌트 버전 Route Config: JSX 형태로 라우트를 선언하는 것이 아닌 Angular 나 Vue 처럼 배열/객체를 사용하여 라우트 정의하기 Memory Router 실제로 주소는 존재하지는 않는 라우터. 리액트 네이티브나, 임베디드 웹앱에서 사용하면 유용하다. 그 외의 것들은 공식 매뉴얼 을 참고.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://hyeok999.github.io/tags/Router/"}]},{"title":"다시 공부하는 React -04-","slug":"ReactStudy-04","date":"2020-01-29T10:26:38.000Z","updated":"2020-01-29T14:58:57.314Z","comments":true,"path":"2020/01/29/ReactStudy-04/","link":"","permalink":"https://hyeok999.github.io/2020/01/29/ReactStudy-04/","excerpt":"","text":"React Re-Study : 4 Controlled Component 와 Uncontrolled Component 상태를 가지고 있는 엘리먼트 Controlled Component 와 Uncontrolled Component 구분하기 Q. 만약 input엘리먼트를 hover 시 포커스를 먹일 수 있는 방법은? High Order Component 사용법 주의할 점 [Project] Login 요청하기 로그인 토큰 획득하기 로컬 스토리지(Local Storage) 토큰 유무로 라우팅 하기 HOC를 직접 만들기 HOC 사용하기 서적 목록 불러오기 Home.jsx 최종 코드 [Homework] : 책 추가하기, 로그아웃 추가하기 React Study with Mark - 리액트 실전 활용법 - Controlled Component 와 Uncontrolled Component 상태를 가지고 있는 엘리먼트 input select textarea 등등… 이러한 엘리먼트들은 onClick 과 같은 이벤트 핸들러를 가지고있다. Controlled Component 와 Uncontrolled Component 구분하기 엘리먼트의 ‘상태’ 를 누가 관리하느냐 로 결정한다. 엘리먼트를 가지고 있는 컴포넌트가 관리 ➤ Controlled 상태를 관리하고 있고, 이벤트 핸들러를 통해 상태를 변경시키고 있다면 Controlled Component다. 123456789101112131415161718192021222324import React from 'react';export default class Controlled extends React.Component &#123; state = &#123; value: '' &#125;; render() &#123; const &#123; value &#125; = this.state; return ( &lt;div&gt; &lt;input value=&#123;value&#125; onChange=&#123;this._change&#125; /&gt; &lt;button onClick=&#123;this._click&#125;&gt;전송&lt;/button&gt; &lt;/div&gt; ); &#125; _change = e =&gt; &#123; // console.log(e.target.value); this.setState(&#123; value: e.target.value &#125;); &#125;; _click = () =&gt; &#123; console.log('최종 결과', this.state.value); &#125;;&#125; 엘리먼트의 상태를 관리하지 않고, 엘리먼트의 참조만 컴포넌트가 소유 ➤ Uncontrolled 상태가 아닌 DOM요소를 직접적으로 사용한다면 Uncontrolled Component다. inputRef = React.createRef(); 만들어지면 객체이다. {current : null} 123456789101112131415161718import React from 'react';const Uncontrolled = () =&gt; &#123; const inputRef = React.createRef(); function click() &#123; console.log('최종 결과', inputRef.current.value); &#125; return ( &lt;div&gt; &lt;input ref=&#123;inputRef&#125; /&gt; &lt;button onClick=&#123;click&#125;&gt;전송&lt;/button&gt; &lt;/div&gt; );&#125;;export default Uncontrolled; Q. 만약 input엘리먼트를 hover 시 포커스를 먹일 수 있는 방법은? 여러가지 방법이 있지만, 해당 엘리먼트를 참조해서 Focus를 주는 방법이 제일 편하다. (Uncontrolled Component) 123456789101112131415161718192021222324252627// 클래스 버전import React from 'react';class Uncontrolled extends React.Component &#123; inputRef = React.createRef(); render() &#123; console.log(this.inputRef); return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;this.inputRef&#125; onMouseOver=&#123;this.mouseOver&#125; /&gt; &lt;button onClick=&#123;this.click&#125;&gt;전송&lt;/button&gt; &lt;/div&gt; ); &#125; click = () =&gt; &#123; console.log(this.inputRef); console.log(this.inputRef.current.value); &#125;; mouseOver = () =&gt; &#123; this.inputRef.current.focus(); &#125;;&#125;export default Uncontrolled; 12345678910111213141516171819202122232425// functional 버전import React from 'react';const Uncontrolled = () =&gt; &#123; const inputRef = React.createRef(); const click = () =&gt; &#123; console.log(inputRef); console.log(inputRef.current.value); &#125;; const mouseOver = () =&gt; &#123; inputRef.current.focus(); &#125;; console.log(inputRef); return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;inputRef&#125; onMouseOver=&#123;mouseOver&#125; /&gt; &lt;button onClick=&#123;click&#125;&gt;전송&lt;/button&gt; &lt;/div&gt; );&#125;;export default Uncontrolled; High Order Component &lt;컴포넌트&gt;를 인자로 받아 &lt;새로운 컴포넌트&gt;를 리턴하는 함수 작업이 항상 반복된다고 생각 될 때 만들면 좋다. 리액트 API가 아니다. 컴포넌트의 로직을 재사용하기 위한 Advanced Tech 1HOC = function(컴포넌트) &#123; return 새로운 컴포넌트; &#125; HOC의 대표적인 예 - with이라는 단어가 붙으면 HOC를 의심하자. react-router-dom - withRouter Redux - connect GraphQL Relay - createFragmentContainer 123456789101112131415// withRouterimport React from \"react\";import &#123; withRouter &#125; from \"react-router-dom\";const LoginButton = props =&gt; &#123; console.log(props); function login() &#123; setTimeout(() =&gt; &#123; props.history.push(\"/\"); &#125;, 1000); &#125; return &lt;button onClick=&#123;login&#125;&gt;로그인하기&lt;/button&gt;;&#125;;export default withRouter(LoginButton); // HOC 사용 대표적 사례 사용법 1. Use HOCs For (Cross-Cutting Concerns 횡단_관심사) 컴포넌트를 만들때 중복되는 부분이 많이 나올 경우 사용을 고려 헤보아라. 2. Don’t Mutate the Original Component. Use Composition. Mutate는 원형을 변경하는 것. (커피를 선물 받았는데, 우유를 섞어서 라뗴로 주는 것) HOC는 기존을 유지해야 한다. (커피를 선물 받았는데, 커피는 그대로 주고, 쿠키를 같이 주는 것) 3. Pass Unrelated Props Through to the Wrapped Component 기존의 Props를 유지해주어라. 4. Maximizing Composability 기존 내용을 돌려줄떄, 무언가를 조합으로 추가해서 주어라. (2번 내용과 동일) 5.Wrap the Display Name for Easy Debugging 디버깅을 하기 위해서 Display Name을 붙여서 사용하도록 한다. 주의할 점 1. Don’t Use HOCs Inside the render Method Render 메소드 사이에 사용하지 말 것. (그래서, 보통 export부분에서 많이 사용함) 2. Static Methods Must Be Copied Over 정적 메소드는 반드시 복사해서 전달하라. (컴포지션으로 전달되지 않으므로) 3. Refs Aren’t Passed Through (feat. React.forwardRef) Refs는 HOC로 전달하지 말 것. (레퍼런스는 그 페이지 안에서만 레퍼런스 가능) [Project] Login 요청하기 E-mail: 제출한 이메일 , PW: fcschool antd 엘리먼트의 경우에는 passwordRef.current.value(antd는 Undefined) 가 아니라 passwordRef.current.state.value 라고 써야 제대로 값을 받아올 수 있다. npm i axios ( CRUD - GET, POST, DELETE, PUT, PETCH ) axios 결과물은 Promise이므로 .then을 사용할 수 있다. 123456789// axios.http메소드(경로, 바디, 헤더(옵션))axios.post('경로', &#123; email, password,&#125;).then(response =&gt; &#123; console.log(response.data);&#125;).catch(error =&gt; &#123; console.log(error);&#125;); 12345678910111213// async/await 이용시try &#123; const response = await axios.post( '경로', &#123; email, // email: email password, // password: password &#125;, ); console.log(response.data);&#125; catch (error) &#123; console.log(error);&#125; 로그인 토큰 획득하기 로그인을 POST로 요청시 Token을 획득 할 수 있다. 이전에 로그인은 쿠키/세션을 많이 사용했다. (트렌드의 변화로 Token을 이용하는 방식이 많이 채택됨.) 토큰은 DB에 저장되어 있다. 만약 책 목록을 요청시(토큰을 함께 보내고), 토큰이 유효하면 로그인 유무를 확인하여 책 목록을 서버에서 준다. 12345678910111213141516171819try &#123; // 리퀘스트 보내기 전 로딩 시작 setLoading(true); const response = await axios.post('경로', &#123; email, password, &#125;) console.log(response.data); const &#123; token &#125; = response.data; // 성공 후 로딩 끝 setLoading(false); history.push('/');&#125; catch (error) &#123; console.log(error); // 에러 후 로딩 끝 setLoading(false); // antd의 message는 메소드(첫글자가 대문자면 컴포넌트) message.error(`This is not valid info.`);&#125; 로컬 스토리지(Local Storage) localStorage는 브라우저 종료해도 데이터가 보존되고. sessionStorage 는 브라우저 종료시 데이터가 없어진다. 로그인 시 로컬 스토리지에 토큰 저장하는 코드를 추가한다. 로그인 중 잘못된 입력을 하여 에러가 날 경우, antd의 message 콤퍼넌트를 이용하여 화면에 표시해준다. 1234567891011121314151617181920212223242526272829303132333435const SigninForm = () =&gt; &#123; const history = useHistory(); const emailRef = React.createRef(); const passwordRef = React.createRef(); const [loading, setLoading] = useState(false); async function click() &#123; const email = emailRef.current.state.value; const password = passwordRef.current.state.value; try &#123; setLoading(true); const response = await axios.post( '경로', &#123; email, // email: email password, // password: password &#125;, ); const &#123; token &#125; = response.data; setLoading(false); localStorage.setItem('token', token); history.push('/'); &#125; catch (error) &#123; setLoading(false); if (error.response.data.error === 'USER_NOT_EXIST') &#123; message.error('유저가 없다.'); &#125; else if (error.response.data.error === 'PASSWORD_NOT_MATCH') &#123; message.error('비밀번호가 틀림'); &#125; else &#123; message.error('로그인에 문제가 있다.'); &#125; &#125; &#125; Home에서 토큰 값을 확인하기 위해 다음과 같이 쓸 수 있다. 특정 함수(여기선, getItem)에 커맨드 누르고 가리키면 반환 타입 알 수 있다 - 타입을 확인하는 습관을 가지자 123// Home.jsxconst token = localStorage.getItem('token');console.log(token); 토큰 유무로 라우팅 하기 HOC를 직접 만들기 토큰에 따라 로그인 상태인지를 확인하기 위해서 HOC를 작성한다. 반복적인 컴포넌트 작업을 줄이기 위해서 HOC를 작성한다. token이 null이면 로그인 화면으로 Redirect props 와 token을 받아서 &lt;Component /&gt;에 전부 전달한다. (props를 전달하는 이유: HOC 사용법 3번 ) 차후 디버깅을 위해 Display Name을 붙여준다. ( HOC 사용법 5번 ) WrappedComponent.displayName = withAuth(${Component.name}) 1234567891011121314151617181920212223// src/hocs/withAuth.jsimport React from 'react';import &#123; Redirect &#125; from 'react-router-dom';function withAuth(Component) &#123; function WrappedComponent(props) &#123; const token = localStorage.getItem('token'); if (token === null) &#123; return &lt;Redirect to=\"/signin\" /&gt;; &#125; return &lt;Component &#123;...props&#125; token=&#123;token&#125; /&gt;; &#125; WrappedComponent.displayName = `withAuth($&#123;Component.name&#125;)`; return WrappedComponent;&#125;export default withAuth;// 관련없는 props는 패스해주어라.// display 이름 설정을 해주어라. (디버깅시 이름을 유지시켜주기위함.) HOC 사용하기 Home 컴포넌트에서 HOC의 콜백함수로 컴포넌트를 넣어준다. 12345678910111213// Home.jsximport React from 'react';import withAuth from '../hocs/withAuth';const Home = (&#123; token &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;/div&gt; )&#125;;export default withAuth(Home); // HOC token을 물려 받은 적이 없으나 withAuth에 의해 token이 들어가게 되고 불필요한 반복 작업을 줄인다. 다른 페이지에서도 withAuth로 감싸게 되면 인증된 사용자만 들어갈 수 있게 된다. 서적 목록 불러오기 서적 목록을 불러올때, 토큰을 이용하여 불러온다. headers에 token을 대입하여 요청한다. Bearer은 조회 요청할 때 붙이는 규칙 같은 것. 12345678910// Home.jsxuseEffect(() =&gt; &#123; axios.get('경로', &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125; &#125;).then(res =&gt; &#123; console.log(res.data); &#125;)&#125;, []); // 의존성 배열이 빈배열일 경우, 최초 한 번만 실행 Home.jsx 최종 코드 12345678910111213141516171819202122232425262728293031// Home.jsximport React, &#123; useState, useEffect &#125; from 'react';import withAuth from '../hocs/withAuth';import axios from 'axios';const [books, setBooks] = useState([]);useEffect(() =&gt; &#123; axios.get('경로', &#123; headers: &#123; Authorization: `Bearer $&#123;token&#125;` &#125;, &#125;).then(res =&gt; &#123; console.log(res.data); setBooks(res.data); &#125;);&#125;, [token]); return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;ul&gt; &#123;books.map(book =&gt; ( &lt;li key=&#123;book.bookId&#125;&gt;&#123;book.title&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; );&#125;;export default withAuth(Home); [Homework]: 책 추가하기, 로그아웃 추가하기 app.js에 라우터 추가 /addbook src/pages/AddBook.jsx를 만들고, 인증된 사용자만 이용하도록 HOC - withAuth 사용한다. 폼 만들어서 입력받고 입력 마치면 홈으로 돌아가게 설정한다. 멋있게 만들고 싶으면: 라우터 추가하지말고 홈에서 모달창 띄워서 바로 책 등록하게끔 만들기. 로그아웃은 서버와 로컬스토리지 모두 token을 없애야 한다. ( DELETE로 요청하면 된다. ) 로그인 할 때와 마찬가지로 Authorization도 함께 보내야 한다. ( 어떤 토큰을 사라지게 해야하는지 알려야 함 ) 어떤 페이지에서도 로그아웃이 가능하도록 해야한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"다시 공부하는 React -03-","slug":"ReactStudy-03","date":"2020-01-28T12:09:12.000Z","updated":"2020-01-28T12:15:27.888Z","comments":true,"path":"2020/01/28/ReactStudy-03/","link":"","permalink":"https://hyeok999.github.io/2020/01/28/ReactStudy-03/","excerpt":"","text":"React Re-Study : 3React Component Styling React의 가장 큰 문제. CSS의 스타일이 컴포넌트간 침범이된다. 컴포넌트 스타일링 방법들 Style Loaders PostCSS CSS, SASS CSS SASS SASS 와 SCSS 의 차이 CSS Module, Sass Module CSS Module SASS Module classnames 사용하기 classnames 적용하기 classnames/bind 적용하기 Styled Component styled.태그 ${props =&gt; props.프롭스명 &amp;&amp; css스타일} styled(컴포넌트) styled(컴포넌트) - 컴포넌트를 반환 할 때 as=”태그” styled(‘태그’) = styled.태그 ${props =&gt; props.color || ‘’} :hover {스타일} ::before {스타일} | ::after {스타일} &amp;:hover {스타일} [&amp; ~ &amp; {스타일}, &amp; + &amp; {스타일} &amp;.클래스 {스타일} .클래스 {스타일} createGlobalStyle ‘스타일’ styled.태그.attrs(props =&gt; ({속성들})) - 중요 keyframes’키프레임’ Ant Design 사용법 또 다른 사용법 Ant Design 레이아웃 -그리드- Row gutter Col offset 레이아웃 flex를 이용한 수직 정렬 Ant Design 레이아웃 -양식- React Study with Mark - React Router -컴포넌트 스타일링 방법들 리액트는 style을 전역으로 관리하여 서로 간에 오염되므로 사람이 혹은 자동으로 맞춰줘야한다. 순서상 : 전부 관리 - 덜 관리 - 거의 자동으로 관리 순으로 배워보자. CSS, Sass(SASS, SCSS) CSS, Sass Module Styled-components Ant Design Style Loaders 리액트에서는 공식적으로 4가지의 css를 지원한다. npx creat-app을 통해 만든 프로젝트는 자동으로 webpack과 babel을 포함하고 있다. webpack에는 babel이 트랜스 파일 할수 있게 style-loader 와 css-loader가 설정되어 있는데 해당 loader들은 각각 아래의 확장자 파일들을 index.css로 합쳐주는 역할을 한다. (오염의 원인) CSS CSS Module Sass(.scss, .sass) - Sass에는 sass, scss가 있음 → PostCSS : npm i node-sass 필요 Sass Module npm i node-sass 필요 PostCSS 자바스크립트 플러그인을 사용해서 SASS/SCSS 를 css로 변환시켜주는 도구를 PostCSS라 한다. PostCSS는 자바스크립트 기반의 플러그인을 사용하여 CSS 기능을 자동화하는 소프트웨어 개발 도구 PostCSS는 JS 플러그인을 사용하여 CSS를 변환시키는 툴 (위키피디아) 즉, PostCSS는 언어가 아닌 도구이다. PostCSS는 Babel을 통해 트랜스파일링되는 도구( loader )를 일컫는 말이다. CSS, SASS 컴포넌트의 독립적인 스타일을 최대한 유지하기 위해서, CSS 구조를 개선시키기 위한 CSS 개발 방법론을 이용한다. BEM : Block Element Modifire SMACSS OOCSS 여기서는 BEM에 대해서 다루도록 한다. ( Block, Element, Modifier ) BEM 화면에 보여질 블록(block)을 기준으로 첫번째 순서의 네이밍을 작성한다. 그 다음에 블록 안의 요소(elements)들을 “__”으로 연결해서 네이밍을 작성한다. 그 다음에 수식어(모양이나 상태)를 “–”으로 연결한 뒤 네이밍을 작성한다. 수식어는 boolean이나 key-value 형태로 넣을 수 있다. (-disable, -color-red) 예를 들면 .header _ _ logo 또는 .form _ _ button–disabled과 같은 식이다. 클래스명이 용도와 형태를 의미하므로 직관적인 것이 장점, 길고 복잡해지는 것이 단점이다. CSS 기존의 css는 아래처럼 작성한다. 12345678910111213141516171819202122.App &#123; text-align: center;&#125;.App-logo &#123; height: 40vmin;&#125;.App-header &#123; background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white;&#125;.App-link &#123; color: #09d3ac;&#125; 그런데, css를 블록별로 구별(BEM처럼)하여 분리할 수 있다. 즉, 클래스네임을 더 짧게 줄이는 장점이있다. 12345678910111213141516171819202122.App &#123; text-align: center;&#125;.App .logo &#123; height: 40vmin;&#125;.App .header &#123; background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white;&#125;.App .link &#123; color: #09d3ac;&#125; SCSS scss를 이용할 경우 위에 작성된 css를 훨씬 더 직관적이게 블록화를 할 수 있고, 코드도 더 짧아진다. 12345678910111213141516171819202122.App &#123; text-align: center; .logo &#123; /* .App .logo */ height: 40vmin; &#125; .header &#123; /* .App .header */ background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white; &#125; .link &#123; /* .App .link */ color: #09d3ac; &#125;&#125; SASS 와 SCSS 의 차이 {}(중괄호)와 ;(세미콜론)의 유무 sass/scss를 사용하기 위해서 npm i node-sass 필수. (PostCSS 이용) CSS Module, Sass Module CSS Module과Sass Module은 React 내장되어 있다. Module을 사용할 경우 렌더링 되어서 화면에 표시될 때 클래스네임 끝에 hash값이 붙어서 나온다. [filename]_[className]__[hash] CSS Module 123import styles from './App.module.css';console.log(styles); 1234567891011121314151617181920212223/* ./App.module.css */.App &#123; text-align: center;&#125;.App-logo &#123; height: 40vmin;&#125;.App-header &#123; background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white;&#125;.App-link &#123; color: #09d3ac;&#125; SASS Module 123import styles from './App.module.scss';console.log(styles); 12345678910111213141516171819202122232425262728293031323334/* ./App.module.scss */.App &#123; text-align: center; .logo &#123; animation: App-logo-spin infinite 20s linear; height: 40vmin; pointer-events: none; &#125; .header &#123; background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white; &#125; .link &#123; color: #61dafb; &#125;&#125;@keyframes App-logo-spin &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125; classnames 사용하기 CSS/SASS Module을 사용하기 시작하면서, className=&#39;스타일명&#39;라고 사용하는게 아니라, className={스타일 모듈명.스타일명} 으로 사용하기 시작햇다. 문제는 연속적인 스타일을 적용하기 시작할 때 문제가 생긴다.(예 - className=’abc def’ ) 1className='$&#123;styles.abc&#125; $&#123;styles.def&#125;' 이러한 문제를 classnames라는 라이브러리를 이용해 해결한다. npm i classnames 설치. 12345678910import classNames from 'classnames';console.log(classNames('foo', 'bar')); // \"foo bar\"console.log(classNames('foo', 'bar', 'baz')); // \"foo bar baz\"console.log(classNames(&#123; foo: true &#125;, &#123; bar: true &#125;)); // \"foo bar\"console.log(classNames(&#123; foo: true &#125;, &#123; bar: false &#125;)); // \"foo\"console.log(classNames(null, false, 'bar', undefined, 0, 1, &#123; baz: null &#125;, '')); // \"bar 1\"console.log(classNames(styles.button, styles.loading)); // Button_button__2Ce79 Button_loading__XEngF Button.module.css 123456789.button &#123; background: transparent; border-radius: 3px; border: 2px solid palevioletred; color: palevioletred; margin: 0 1em; padding: 0.25em 1em; font-size: 20px;&#125; Button.jsx &lt;button&gt; {props.children} &lt;/button&gt;; &lt;button {...props} /&gt;; &lt;button children={props.children}/&gt;; 은 같은 문법이다. 참고로 모든 태그에는 children 이라는 속성이 존재한다. 123456import React from 'react';import styles from './Button.module.css';const Button = props =&gt; &lt;button className=&#123;styles.button&#125; &#123;...props&#125; /&gt;;export default Button; classnames 적용하기 Button.jsx :import classNames from &#39;classnames&#39; 추가; 123456789101112131415161718192021222324252627282930import React from 'react';import styles from './Button.module.css';import classNames from 'classnames';export default class Button extends React.Component &#123; state = &#123; loading: false, &#125;; startLoading = () =&gt; &#123; console.log('start'); this.setState(&#123; loading: true &#125;); setTimeout(() =&gt; &#123; this.setState(&#123; loading: false &#125;); &#125;, 1000); &#125;; render() &#123; const &#123; loading &#125; = this.state; return ( &lt;button className=&#123; loading ? classNames(styles.button, styles.loading) : styles.button &#125; &#123;...this.props&#125; onClick=&#123;this.startLoading&#125; /&gt; ); &#125;&#125; classnames/bind 적용하기 classnames 사용시 { 스타일 모듈명.스타일명.해시: true }라는 조건을 이용해야 해서 단어가 길고 복잡했다. 따라서, classnames.bind()를 통해 함수로 리턴하여 더 짧게 줄여서 이용한다. 1const 변수명 = classnames.bind(스타일 모듈명) 123456789101112131415161718192021222324252627282930313233import React from 'react';import styles from './Button.module.css';import classNames from 'classnames/bind'; // 수정 classnames -&gt; classnames/bindconst cx = classNames.bind(styles);export default class Button extends React.Component &#123; state = &#123; loading: false, &#125;; startLoading = () =&gt; &#123; console.log('start'); this.setState(&#123; loading: true &#125;); setTimeout(() =&gt; &#123; this.setState(&#123; loading: false &#125;); &#125;, 1000); &#125;; render() &#123; const &#123; loading &#125; = this.state; return (//&lt;button className=&#123;loading ? classNames(styles.button, styles.loading) : styles.button&#125; &#123;...props&#125;&gt;버튼&lt;/button&gt;//&lt;button className=&#123;loading ? cx('button', 'loading') : cx('button')&#125; &#123;...props&#125;&gt;버튼&lt;/button&gt;//&lt;button className=&#123;cx('button', &#123;loading: loading&#125;)&#125; &#123;...props&#125;&gt;버튼&lt;/button&gt; &lt;button className=&#123;cx('button', &#123; loading &#125;)&#125; &#123;...this.props&#125; onClick=&#123;this.startLoading&#125; /&gt; ); &#125;&#125; cx(&#39;button&#39;, { loading })에서 ‘button’은 항상 truthy값이므로 붙고, loading은 현재 값 여부에 따라 붙거나 붙지 않음. 만약 loading과 css의 .loading이름이 다르다면{ test: loading }이 될것 ( loading값이 true면 test class추가) 여기서는 이름이 같으므로 간단하게 표기 가능하다. Styled Component 이 컴포넌트가 이 스타일이라고 스타일을 지정해주면 자동으로 클래스로 변환 1npm i styled-components styled.태그 123456789101112import styled from 'styled-components';const StyledButton = styled.button` background: transparent; border-radius: 3px; border: 2px solid palevioletred; color: palevioletred; margin: 0 1em; padding: 0.25em 1em;`;export default StyledButton; 브라우저에 버튼을 띄운 뒤 인스펙터로 찍어보면 알아서 클래스를 만들어준 것을 확인 할 수 있음. &lt;button class=&quot;sc-AykKC fmcvyS&quot;&gt;버튼&lt;/button&gt; App.js 에서는 &lt;StyledButton&gt;버튼&lt;/StyledButton&gt; 으로 사용. ${props =&gt; props.프롭스명 &amp;&amp; css스타일} 12345678910const StyledButton = styled.button` ~스타일~ $&#123;props =&gt; props.primary &amp;&amp; css` background: palevioletred; color: white; `&#125;;`; App.js에 &lt;StyledButton primary&gt;Primary 버튼&lt;/StyledButton&gt;가 있다고 가정함. props에primary가 있다면 css적용. 스타일 객체를 반환. styled(컴포넌트) 상속같은 개념? StyleComponent에 정의된 CSS들은 위에서 아래로 읽기 때문에 나중에 나온게 전에 나온걸 덮어씌운다. PrimaryStyledButton은 이전에 있던 StyleButton의 &#39;&#39; 제일 아래 내부에 기록을 한 것. 컴포넌트 끼리 export를 했기 때문에 적용은 따로된다. 12345678910111213const StyledButton = styled.button` background: transparent; border-radius: 3px; border: 2px solid palevioletred; color: palevioletred; margin: 0 1em; padding: 0.25em 1em;`;const PrimaryStyledButton = styled(StyledButton)` background: palevioletred; color: white;`; styled(컴포넌트) - 컴포넌트를 반환 할 때 컴포넌트를 미리 만들고 그걸 styled(컴포넌트)로 불러드렸을 경우. 상위 태그에 반드시 className을 붙여줘야 styled(컴포넌트)가 렌더링할때 class를 붙여준다. 부모 컴포넌트에 className을 주고 그 안에는 따로 네이밍해서 관리. 123456789101112131415161718192021222324252627282930313233343536373839// StyledButton.jsximport styled, &#123; css &#125; from 'styled-components';import React from 'react';function MyButton(&#123; className, children &#125;) &#123; return ( &lt;div className=&#123;className&#125; /*꼭 필요하다.*/&gt; &lt;button&gt;&#123;children&#125;&lt;/button&gt; &lt;/div&gt; );&#125;const StyledButton = styled(MyButton)` button &#123; background: transparent; border-radius: 3px; border: 2px solid palevioletred; color: palevioletred; margin: 0 1em; padding: 0.25em 1em; $&#123;props =&gt; props.primary &amp;&amp; css` background: palevioletred; color: white; `&#125;; &#125;`;const PrimaryStyledButton = styled(StyledButton)` button &#123; background: palevioletred; color: black; &#125;`;export default StyledButton;export &#123; PrimaryStyledButton &#125;; 12345678910111213141516// App.jsimport React from 'react';import StyledButton, &#123; PrimaryStyledButton &#125; from './components/StyledButton';import './App.scss';function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;StyledButton&gt;버튼&lt;/StyledButton&gt; &lt;StyledButton primary&gt;Primary 버튼&lt;/StyledButton&gt; &lt;PrimaryStyledButton&gt;Primary Styled Button 버튼&lt;/PrimaryStyledButton&gt; &lt;/div&gt; );&#125;export default App; as=”태그” 잘 쓰지 않는다. 링크를 거는 용도로 사용됨. 1&lt;StyledButton as=\"a\" href=\"/\"&gt;버튼&lt;/StyledButton&gt; styled(‘태그’) = styled.태그 123const StyledButton = styled('button')`~css~`; ${props =&gt; props.color || ‘’} 리턴 값이 문자열, 아까의 경우에는 css가 리턴 123456789const StyledButton = styled.button` background: transparent; border-radius: 3px; border: 2px solid $&#123;props =&gt; props.color || 'palevioletred'&#125;; color: $&#123;props =&gt; props.color || 'palevioletred'&#125;; margin: 0 1em; padding: 0.25em 1em; font-size: 1em;`; :hover {스타일} 123456789101112const StyledButton = styled.button` background: transparent; border-radius: 3px; border: 2px solid palevioletred; color: palevioletred; margin: 0 1em; padding: 0.25em 1em; :hover &#123; border: 2px solid red; &#125;`; ::before {스타일} | ::after {스타일} 가상요소선택자 123456789101112const StyledButton = styled.button` background: transparent; border-radius: 3px; border: 2px solid palevioletred; color: palevioletred; margin: 0 1em; padding: 0.25em 1em; ::before &#123; content: &apos;@&apos;; &#125;`; &amp;:hover {스타일} 앞의 &amp;는 부모 선택자 &amp; ~ &amp; {스타일}, &amp; + &amp; {스타일} 인접요소선택자 &amp;.클래스 {스타일} 자신에게 orange클래스를 적용. 123456789101112131415// App.jsimport React from 'react';import StyledButton from './components/StyledButton';function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;p&gt; &lt;StyledButton className=\"orange\"&gt;버튼&lt;/StyledButton&gt; &lt;/p&gt; &lt;/div&gt; );&#125;export default App; 12345678// StyledButton.jsxexport default const StyledButton = styled.button`~css~ &amp;.orange &#123; border: 2px solid orange; &#125;`; .클래스 {스타일} 아래 예제 기준으로는 StyledButton 하위 태그중 className=&quot;orange&quot;를 가지고 있는 태그에게 적용한다. 1234567const StyledButton = styled.button`~css~ .orange &#123; color: orange; &#125;`; 123&lt;StyledButton&gt; &lt;p className=\"orange\"&gt;hh&lt;/p&gt;버튼&lt;/StyledButton&gt; createGlobalStyle ‘스타일’ 1234567891011121314151617const GlobalStyle = createGlobalStyle` button$&#123;StyledButton&#125; &#123; color: palevioletred; &#125;`;function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;p&gt; &lt;GlobalStyle /&gt; &lt;StyledButton&gt;버튼&lt;/StyledButton&gt; &lt;button&gt;버튼&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; );&#125; styled.태그.attrs(props =&gt; ({속성들})) - 중요 인자를 props로 받고 object로 리턴. 속성들을 정의할 때 이용한다. 예를들어, a태그의 경우 href 등을 미리 정의해두거나 받아와서 사용할 수 있다. 1234567const StyledA = styled.a.attrs(props =&gt; (&#123; href: props.href || 'https://www.fastcampus.co.kr', color: props.color || 'palevioletred', target: '_BLANK', // 프롭스가 들어오던 말던 _BLANK&#125;))` color: $&#123;props =&gt; props.color&#125;;`; 어트리뷰트는 props와 같은 역할 default로 항상 넣어줘야 하는 값들이 있을 때 attrs를 쓰면 편하다. keyframes’키프레임’ 애니메이션 키프레임을 사용할 때 이용한다. 1234567891011121314151617181920const slide = keyframes` from &#123; margin-top: 0em; &#125; to &#123; margin-top: 1em; &#125;`;const StyledButton = styled.button` display: inline-block; color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px; animation: $&#123;slide&#125; 0.3s ease-in;`; Ant Design 가장 많이 쓰이는 component 라이브러리 디자인된 컴포넌트를 나눠서 줘야한다면 어떻게 줘야할지 알 수 있다. npm i antd API는 props에 대한 설명 사용법 전역에 스타일 추가하고 리액트 컴포넌트를 추가하여 사용 리액트 컴포넌트는 Ant Design - Components에 제시된게 많으니 가져다 사용한다. 12import 'antd/dist/antd.css'; // &lt;= index.js에 전역 스타일 추가import &#123; DatePicker &#125; from 'antd'; // &lt;= 날짜를 보여주는 리액트 컴포넌트 또 다른 사용법 modularized1 import &#39;antd/dist/antd.css&#39;;는 다른 컴포넌트에도 영향이 가는 단점이 있다. 이를 해결하기 위해서 좀 더 세세하게 불러와 import할 수 있다. 123// index에다 설정하는게 아니라 사용할 컴포넌트 파일에 설정해서 쓸 수 있다.import DatePicker from 'antd/es/date-picker';import 'antd/es/date-picker/style/css'; modularized2 modularized1 에서 설정 내용이 너무 길어서 짧게 줄이고자 할 때 쓰는 방법. 번거로워서 잘 사용하지는 않는다. npm run eject npm install babel-plugin-import --save-dev babel 플러그인 설정 12345678910111213141516171819&#123; ... \"babel\": &#123; \"presets\": [ \"react-app\" ], \"plugins\": [ [ \"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" &#125; ] ] &#125;, ...&#125; 12345678910111213// 사용할 컴포넌트 파일import React from 'react';import &#123; DatePicker &#125; from 'antd';function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;DatePicker /&gt; &lt;/div&gt; );&#125;export default App; Ant Design 레이아웃 -그리드- 그리드 row는 height값을 꼭 주어야만 한다. 1234567891011121314151617181920212223242526272829303132import React from 'react';import &#123; Row, Col &#125; from 'antd';const colStyle = () =&gt; (&#123; height: 50, backgroundColor: 'red', opacity: Math.round(Math.random() * 10) / 10,&#125;);function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;Row&gt; &lt;Col span=&#123;12&#125; style=&#123;colStyle()&#125; /&gt; &lt;Col span=&#123;12&#125; style=&#123;colStyle()&#125; /&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Col span=&#123;8&#125; style=&#123;colStyle()&#125; /&gt; &lt;Col span=&#123;8&#125; style=&#123;colStyle()&#125; /&gt; &lt;Col span=&#123;8&#125; style=&#123;colStyle()&#125; /&gt; &lt;/Row&gt; &lt;Row&gt; &lt;Col span=&#123;6&#125; style=&#123;colStyle()&#125; /&gt; &lt;Col span=&#123;6&#125; style=&#123;colStyle()&#125; /&gt; &lt;Col span=&#123;6&#125; style=&#123;colStyle()&#125; /&gt; &lt;Col span=&#123;6&#125; style=&#123;colStyle()&#125; /&gt; &lt;/Row&gt; &lt;/div&gt; );&#125;export default App; &lt;Col span={24 중에 어느정도 차지할 지 정수} /&gt; 12개 12개 나누니까 반반 나눔 8, 8, 8이므로 세칸으로 나눔 6으로 나누면 네칸 Row gutter gutter는 16 + 8n의 정수로 사용해야 함(전체 길이를 24등분으로 나누어야 하므로) Column에 left값을 일정하게 주는 느낌 1234&lt;Row gutter=&#123;16&#125;&gt; &lt;MyCol span=&#123;12&#125; /&gt; &lt;MyCol span=&#123;12&#125; /&gt;&lt;/Row&gt; Col offset Col offset={24 중 건너띄고 싶은 정수} 123&lt;Row gutter=&#123;16&#125;&gt; &lt;MyCol span=&#123;12&#125; offset=&#123;12&#125; /&gt;&lt;/Row&gt; 레이아웃 flex를 이용한 수직 정렬 &lt;Row type=&quot;flex&quot; justify=&quot;좌우정렬&quot; align=&quot;위아래정렬&quot; /&gt; justify ➤ “start” | “center” | “end” | “space-between” | “space-around” align ➤ “top” | “middle” | “bottom” 123456789101112131415161718192021222324252627function MyCol(&#123; span, offset &#125;) &#123; const opacity = Math.round(Math.random() * 10) / 10; return ( &lt;Col span=&#123;span&#125; offset=&#123;offset&#125;&gt; &lt;div style=&#123;&#123; height: 50, backgroundColor: 'red', opacity &#125;&#125; /&gt; &lt;/Col&gt; );&#125;export default function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;Row style=&#123;&#123; height: 300, &#125;&#125; type=\"flex\" justify=\"start\" align=\"top\" &gt; &lt;MyCol span=&#123;4&#125; /&gt; &lt;MyCol span=&#123;4&#125; /&gt; &lt;MyCol span=&#123;4&#125; /&gt; &lt;MyCol span=&#123;4&#125; /&gt; &lt;/Row&gt; &lt;/div&gt; ); Ant Design 레이아웃 -양식- import { Layout } from &#39;antd&#39;; 이미 짜여진 레이아웃 도안을 설정함. 정해진 레이아웃 대로 네이밍 설정시 클래스 네임이 알아서 붙지만 사용을 권장하지 않음. 레이아웃","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"서브 라우트 [3]","slug":"react-router-03","date":"2020-01-28T07:32:15.000Z","updated":"2020-01-28T12:11:35.239Z","comments":true,"path":"2020/01/28/react-router-03/","link":"","permalink":"https://hyeok999.github.io/2020/01/28/react-router-03/","excerpt":"","text":"React Router with Velopert - 03 - 서브 라우트 만들어보기 src/Profiles.jsx src/App.js src/Profile.jsx Chap 3. 서브라우트 라우트 내부에 라우트를 만드는 것. 컴포넌트를 만들고 Route 컴포넌트를 렌더링하면 된다. 서브 라우트 만들어보기src/Profiles.jsx 1234567891011121314151617181920212223242526import React from 'react';import &#123; Link, Route &#125; from 'reqct-router-dom';import Profile from './Profile';const Profiles = () =&gt; &#123; return ( &lt;div&gt; &lt;h3&gt;유저 목록:&lt;/h3&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/profiles/hyeok999\"&gt;hyeok999&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/profiles/homer\"&gt;homer&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/profiles\" exact render=&#123;() =&gt; &lt;div&gt;유저를 선택해주세요.&lt;/div&gt;&#125; /&gt; // render &lt;Route path=\"/profiles/:username\" component=&#123;Profile&#125; /&gt; &lt;/div&gt; );&#125;; Route 컴포넌트에서는 component 대신에 render가 사용되었다. render에서는 컴포넌트가 아니라, JSX 자체를 렌더링 해줄수 있으며, 상위 영역에서 props 나 기타 값들을 필요하면 전달해줄 수 있다. App.js에 Profiles 컴포넌트를 위한 링크와 라우트를 생성해준다. src/App.js 1234567891011121314151617181920212223242526272829import React from 'react';import &#123; Route, Link &#125; from 'react-router-dom';import About from './About';import Home from './Home';import Profiles from './Profiles';const App = () =&gt; &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;홈&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;소개&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/profiles\"&gt;프로필 목록&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route path=\"/\" exact=&#123;true&#125; component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/profiles\" component=&#123;Profiles&#125; /&gt; &lt;/div&gt; );&#125;;export default App; App.js 에 &lt;Route&gt;태그 안에 Profiles 컴포넌트가 있고 해당 컴포넌트에는 Profile 컴포넌트를 이어주는 &lt;Route&gt;태그 가 있다. 따라서, Profiles가 서브 라우터가 되는 것이다. src/Profile.jsx 12345678910111213141516171819202122232425262728293031323334import React from 'react'const profileData = &#123; hyeok999: &#123; name : '김준혁', description: 'Frontend Student' &#125;, homer: &#123; name : '호머 심슨', description: '심슨 가족 가장' &#125;&#125;// props.matchconst Profile = (&#123;match&#125;) =&gt; &#123; console.log(match.params); const &#123; username &#125; = match.params; const profile = profileData[username]; if(!profile) &#123; return &lt;div&gt;존재하지 않은 사용자입니다.&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h3&gt; &#123;username&#125;(&#123;profile.name&#125;) &lt;/h3&gt; &lt;p&gt;&#123;profile.description&#125;&lt;/p&gt; &lt;/div&gt; );&#125;export default Profile;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://hyeok999.github.io/tags/Router/"}]},{"title":"파라미터와 쿼리 [2]","slug":"react-router-02","date":"2020-01-27T00:46:50.000Z","updated":"2020-01-27T02:50:13.301Z","comments":true,"path":"2020/01/27/react-router-02/","link":"","permalink":"https://hyeok999.github.io/2020/01/27/react-router-02/","excerpt":"","text":"React Router with Velopert - 02 - 파라미터와 쿼리 URL Parameter Parameter 받아오기 Query QueryString 받아오기 Chap 2. 파라미터와 쿼리 파라미터와 쿼리Parameter : /profiles/:username 파라미터는 match 객체의 params 를 사용한다. 1const &#123; username &#125; = match.params; match 는 라우트 컴포넌트에서 물려받는다. Query : /about?detail=true 쿼리는 location 객체의 search 를 사용한다. location.search 는 그냥 사용하지는 못하고 문자열을 객체로 변환시켜야 하는데 그것은 qs라는 npm모듈을 이용한다. 1npm i query-string --save 다음과 같이 사용할 수 있다. 12const query = qs.parse(location &amp;&amp; location.search);const detail = query.detail === &apos;true&apos;; // 쿼리의 파싱결과값은 문자열입니다. location 는 라우트 컴포넌트에서 물려받는다. URL ParameterID, 유저 네임등의 특정 데이터 조회하기 위해 사용한다. 1/profiles/kim kim 프로파일을 달라. Parameter 받아오기Profile 이라는 컴포넌트를 만들어서 파라미터를 받아오는 예제 코드. src/Profile.js 123456789101112131415161718192021222324252627282930313233import React from 'react';// 프로필에서 사용 할 데이터const profileData = &#123; hyeok999: &#123; name: '혁999', description: 'Frontend Student' &#125;, homer: &#123; name: '호머 심슨', description: '호머 심슨' &#125;&#125;;const Profile = (&#123; match &#125;) =&gt; &#123; // 파라미터를 받아올 땐 match 안에 들어있는 params 값을 참조합니다. const &#123; username &#125; = match.params; const profile = profileData[username]; if (!profile) &#123; return &lt;div&gt;존재하지 않는 유저입니다.&lt;/div&gt;; &#125; return ( &lt;div&gt; &lt;h3&gt; &#123;username&#125;(&#123;profile.name&#125;) &lt;/h3&gt; &lt;p&gt;&#123;profile.description&#125;&lt;/p&gt; &lt;/div&gt; );&#125;;export default Profile; 파라미터를 받아올 땐 match 안에 들어있는 params 값을 참조한다. match 객체안에는 현재의 주소가 Route 컴포넌트에서 정한 규칙과 어떻게 일치하는지에 대한 정보가 들어있다. path 규칙에는 /profiles/:username 으로 적용시키면 Profile 컴포넌트에서 match props를 통해 전달받을 수 있다. src/App.js 123456789101112131415161718192021222324252627import React from 'react';import &#123; Route, Link &#125; from 'react-router-dom';import About from './About';import Home from './Home';import Profile from './Profile';const App = () =&gt; &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;홈&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;소개&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route path=\"/\" exact=&#123;true&#125; component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/profiles/:username\" component=&#123;Profile&#125; /&gt; &lt;/div&gt; );&#125;;export default App; 이제 /profiles/hyeok999 경로로 들어가보자. Query다양한 옵션을 주어서 검색할 때 많이 사용한다. 1/filter?type=book&amp;sort_by=date book 이라는 타입을 가진 데이터를 date로 정렬해서 보여달라. 쿼리는 라우트 컴포넌트에게 props 전달되는 location 객체에 있는 search 값에서 읽어올 수 있다. location 객체는 현재 앱이 갖고있는 주소에 대한 정보를 지니고있다. 123456789&#123; key: 'ac3df4', // not with HashHistory! pathname: '/somewhere' search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 여기서 중요한 것은 search 값이다. 문제는 search가 ? 로 시작되는 문자열이라 객체 형태로 변환을 따로 해주어야한다. 따라서 NPM 모듈을 설치하여 작업해주도록 한다. 1npm i query-string --save 위는 qs라는 라이브러리로 location.search의 문자열을 손쉽게 객체형태로 변환해준다. QueryString 받아오기About이라는 컴포넌트를 만들고 search 값에 있는 detail 값을 받아와서, 해당 값이 true 일때 추가정보를 보여주도록 구현해 본다. 123456789101112131415161718import React from 'react';import qs from 'query-string';function About (&#123; location &#125;) &#123; const query = qs.parse(location &amp;&amp; location.search); const detail = query.detail === 'true'; // 쿼리의 파싱결과값은 문자열입니다. return ( &lt;div&gt; &lt;h1&gt;소개&lt;/h1&gt; &lt;p&gt;이 프로젝트는 리액트 라우터 기초를 실습해보는 예제 프로젝트다.&lt;/p&gt; &#123;detail &amp;&amp; &lt;p&gt;detail 값이 true 입니다.!&lt;/p&gt;&#125; &lt;/div&gt; );&#125;export default About /about?detail=true 경로로 들어가보자.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://hyeok999.github.io/tags/Router/"}]},{"title":"다시 공부하는 React -02-","slug":"ReactStudy-02","date":"2020-01-27T00:41:37.000Z","updated":"2020-01-27T02:44:14.722Z","comments":true,"path":"2020/01/27/ReactStudy-02/","link":"","permalink":"https://hyeok999.github.io/2020/01/27/ReactStudy-02/","excerpt":"","text":"React Re-Study : 2 Component Lifecycle 변경 전 (&lt; v16.3) Component 생성 및 마운트 Component props, state 변경 componentWillReceiveProps shouldComponentUpdate (✸) componentWillUpdate componentDidUpdate Component 언마운트 변경 후 (&gt; v16.3) Component 라이프사이클 변경 목록 Component 생성 및 마운트 v16.3 Component props, state 변경 v16.3 Component 언마운트 (v16.3) Component 에러 캐치 react-error-boundary React의 라우팅 이해하기 SPA 라우팅 과정 Router 실습해보기 특정 경로에서 보여줄 컴포넌트를 준비한다. App.js 설정하기 exact 동적 라우팅 동적 라우팅 - Params (의무) 동적 라우팅 - 쿼리스트링 (옵셔널 - 있어도 되고, 없어도된다.) URLSearchParams query-string (라이브러리) Switch Link 태그 NavLink JS로 라우팅 이동하기 HOC(High Order Component) - withRouter() Redirect Route Hooks useHistory useLocation useParams useRouteMatch BrouserRouter의 내려주기. React developer tools React Study with Mark - React Router - Component Lifecycle 리액트 컴포넌트는 탄생 (Mount) 부터 죽음 (Unmount) 까지 여러 지점에서 개발자가 작업을 할 수 있도록 Class Component 의 라이프사이클 메서드를 “오버라이딩” 할 수 있게 해준다. render함수는 반드시 덮어씌워야 한다. (안할 시, 에러 유발 -&gt; 다른 함수는 상관없다.) Declarative 디클레러티브, 선언적인 프로그래밍을 한다. 필요한 부분만 오버라이딩을 하여 사용한다. 변경 전 (&lt; v16.3)Component 생성 및 마운트 컴포넌트를 사용하면 언제 마운트 되는지 알 수 있다. constructor componentWillMount render (최초 랜더) componentDidMount 12345678910111213141516171819202122232425262728293031323334353637383940class App extends React.Component &#123; _interval; constructor(props) &#123; console.log('App constructor'); //1번 super(props); this.state = &#123; age: 37, &#125;; &#125; componentWillMount() &#123; console.log('App componentWillMount'); //2번 &#125; componentDidMount() &#123; console.log('App componentDidMount'); // 3번 this._interval = window.setInterval(() =&gt; &#123; this.setState(&#123; age: this.state.age + 1, &#125;); &#125;, 1000); &#125; componentWillUnmount() &#123; console.log('App componentWillUnmount'); // 4번 clearInterval(this._interval); &#125; render() &#123; console.log('App render'); //3번 return ( &lt;div&gt; &lt;h2&gt; Hello &#123;this.props.name&#125; - &#123;this.state.age&#125; &lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Component props, state 변경 componentWillReceiveProps - props, 부모의 컴포넌트가 바뀌거나 forceUpdate(강제) 시 여기부터 시작. shouldComponentUpdate - state가 바뀌면 여기부터 시작. componentWillUpdate render componentDidUpdate 여기서 setState X - 렌더 후 재실행 되므로 무한 업데이트에 빠질 수 있다. (if로 방어코드를 쓰지말고 하지말자!) 리액트 애플리케이션이 호출할 때 인자를 넣어줌 - componentWillReceiveProps props 를 새로 지정했을 때 바로 호출된다. 여기는 state 의 변경에 반응하지 않는다. 여기서 props 의 값에 따라 state 를 변경해야 한다면, setState 를 이용해 state 를 변경한다. 그러면 다음 이벤트로 각각 가는것이 아니라 한번에 변경된다. - shouldComponentUpdate (✸) 이 메서드는 오직 성능 최적화만을 위한 것. 렌더링을 방지하는 목적으로 사용할 경우 버그로 이어질 수 있다. props 만 변경되어도 state 만 변경되어도 props &amp; state 둘다 변경되어도 (componentWillReceiveProps) newProps 와 new State 를 인자로 해서 호출 return type 이 boolean 이다. true 면 render false 면 render 가 호출되지 않는다. 이 함수를 구현하지 않으면, 디폴트는 true - componentWillUpdate 컴포넌트가 재 랜더링 되기 직전에 불립니다. 여기선 setState 같은 것을 쓰면 아니됩니다. - componentDidUpdate 컴포넌트가 재 랜더링을 마치면 불립니다. Component 언마운트 componentWillUnmount ( 타임을 걸어놓고 해제를 할 경우 많이 씀. ) 변경 후 (&gt; v16.3)Component 라이프사이클 변경목록 constructor componentWillMount → getDerivedStateFromProps static Method render componentDidMount componentWillReceiveProps → getDerivedStateFromProps Props로부터 state를 만들어냄. (리턴이 생김) shouldComponentUpdate render componentWillUpdate → getSnapshotBeforeUpdate v16.3 이전에는 render보다 먼저 실행되었지만, v16.3부터는 렌더 이후 실행됨. 실제로 렌더링 되기 전과 후에 비교해서 처리해야 될 상황에 사용. ( componentDidUpdate가 필요 ) 리턴의 형태는 state와 같아야 한다. Ex) 리스트가 10개에서 15개가 되었는데 기존 10개 위치에 머물러 있어야 한다면 필요가 없지만 15개의 위치로 내려가야하는 스크롤탑 위치가 조정되어야 할 경우에 필요함 (dom 에 적용) componentDidUpdate componentWillUnmount Component 생성 및 마운트 v16.3 constructor static getDerivedStateFromProps render (최초 랜더) componentDidMount Component props, state 변경 v16.3 static getDerivedStateFromProps (props 변경) shouldComponentUpdate (state 변경) render getSnapshotBeforeUpdate (componentDidUpdate 와 함께 사용) (dom 에 적용) componentDidUpdate Component 언마운트 (v16.3) componentWillUnmount Component 에러 캐치 React는 하나의 앱형태로 되어 있기 때문에, 한 곳의 에러가 발생할 경우 모든 곳에 영향을 주기 때문에 어플리케이션이 망가질수 있다. componentDidCatch : 가장 상위에 componentDidCatch를 두어야한다.(여기선 App) 문제가 발생할 것 같은 컴포넌트의 상위 컴포넌트에 작성해주어야 한다. 라이브러리도 존재한다. react-error-boundary 12345678910111213141516171819202122232425262728293031323334import React from 'react';class Button extends React.Component &#123; render() &#123; test(); // 말도 안되는 코드. test함수가 존재하지않는다. return &lt;div&gt;hello&lt;/div&gt;; &#125;&#125;class App extends React.Component &#123; state = &#123; hasError: false, &#125;; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service // logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; return &lt;div&gt;에러 화면&lt;/div&gt;; &#125; return ( &lt;div&gt; &lt;Button /&gt; &lt;/div&gt; ); &#125;&#125;export default App; - react-error-boundary (라이브러리) 123&lt;ErrorBoundary FallbackComponent=&#123;MyFallbackComponent&#125;&gt; &lt;ComponentThatMayError /&gt;&lt;/ErrorBoundary&gt; 에러가 발생할 경우, FallbackComponent={MyFallbackComponent} 으로 연결해준 컴포넌트를 보여준다. (즉 에러처리 화면) React의 라우팅 이해하기 SPA : Single Page Application react-router-dom 처음 진입점 : React App SPA 라우팅 과정 브라우저에서 최초에 ‘/‘ 경로로 요청을 하면, React Web App 을 내려준다. 내려받은 React App 에서 ‘/‘ 경로에 맞는 컴포넌트를 보여준다. React App 에서 다른 페이지로 이동하는 동작을 수행하면, 새로운 경로에 맞는 컴포넌트를 보여준다. 매치 옵션이 존재한다. 매치 알고리즘 : 브라우저의 주소창에 적혀진 주소와 route path,&lt;Link to&gt;에 적혀있는 것을 비교하는 것. ( 여러가지 매치방법이 있는데 ( sensitive, strict 등등) ) Router 실습해보기1npm i react-router-dom cra 에 기본 내장된 패키지가 아니다. ( 아마, 지원안해줄 확률이 매우 높다. 리액트는 단순히 View만 신경쓰기 때문 ) react-router-dom 은 Facebook 의 공식 패키지는 아니다. 가장 대표적인 라우팅 패키지. 특정 경로에서 보여줄 컴포넌트를 준비한다. ‘/‘ → Home 컴포넌트 ‘/profile‘ → Profile 컴포넌트 ‘/about‘ → About 컴포넌트 App.js 설정하기123456789101112131415161718// src/App.jsimport React from 'react';import &#123; BrowserRouter, Route &#125; from 'react-router-dom';import Home from './pages/Home';import Profile from './pages/Profile';import About from './pages/About';function App() &#123; return ( &lt;BrowserRouter&gt; &lt;Route path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;/BrowserRouter&gt; );&#125;export default App; Route 컴포넌트에 경로(path) 와 컴포넌트(component) 를 설정하여 나열해준다. BrowserRouter 로 Route 들을 감싸준다. (브라우저 라우팅을 위한 react-router-dom에서 지원해주는 jsx 태그) 브라우저에서 요청한 경로에 Route 의 path 가 들어있으면(매치가 되면) 해당 component 를 보여준다. exact exact는 100%일치해야되기 때문에 값이 변하는 변수를 사용할 수 없다. 위 상황을 해결하기 위해서 exact키워드를 사용한다. 1&lt;Route path=\"/\" exact component=&#123;Home&#125; /&gt; 동적 라우팅 &lt;BrouserRouter&gt; 의 하위 &lt;Route&gt; 컴포넌트들에게 history, location,match로 이루어진 props 객체를 내려준다. history 는 url을 변경시켜 다른 컴포넌트로 이동하는 역할 match는 Params 데이터를 가지고있다. loacation은 query-string(?로 시작하는 키=값) 을 가지고 있다. 동적 라우팅 - Params (의무)1&lt;Route path=\"/profile/:id\" component=&#123;Profile&#125; /&gt; /profile/1 이 주소에서 1은 Params 라고 부른다. Params는 [String] Type이다. Params를 가지고 오는 방법. match는 위에서 언급한 매치 알고리즘을 의미한다. 12345678910import React from \"react\";export default function Profile(props) &#123; console.log(props.match.params); return ( &lt;div&gt; &lt;h2&gt;Profile&lt;/h2&gt; &lt;/div&gt; );&#125; 동적 라우팅 - 쿼리스트링 (옵셔널 - 있어도 되고, 없어도된다.)1&lt;Route path=\"/about\" component=&#123;About&#125; /&gt; 위 처럼 설정을 해두고, 검색창에 /about?name=mark라고 검색해서 props를 찍어보면 location.search에 들어있다. Params 처럼 별도의 설정이 path=&quot;/about/:id&quot;같이 적어줄 필요가 없다. 1. URLSearchParams IE 사용불가능… (IE 🤬) 12345678910111213141516import React from 'react';const About = props =&gt; &#123; const searchParams = new URLSearchParams(props.location.search); const name = searchParams.get('name'); console.log(searchParams); return ( &lt;div&gt; &lt;h1&gt;About&lt;/h1&gt; &#123;name &amp;&amp; &lt;p&gt;name 는 &#123;name&#125; 입니다.&lt;/p&gt;&#125; &lt;/div&gt; );&#125;;export default About; 2. query-string (라이브러리) URLSearchParams의 단점을 상쇄하고자 사용함. 123456789101112131415161718import React from 'react';import queryString from 'query-string';const About = props =&gt; &#123; console.log(props); const query = queryString.parse(props.location.search); console.log(query); const &#123; name &#125; = query; return ( &lt;div&gt; &lt;h1&gt;About&lt;/h1&gt; &#123;name &amp;&amp; &lt;p&gt;name 는 &#123;name&#125; 입니다.&lt;/p&gt;&#125; &lt;/div&gt; );&#125;;export default About; Switch 여러 Route 중 순서대로 먼저 맞는 하나만 보여준다. exact 를 뺄 수 있는 로직을 만들 수 있다. 가장 작은 단위의 컴포넌트를 상단으로 작성한다. 가장 마지막에 어디 path 에도 맞지 않으면 보여지는 컴포넌트를 설정해서, Not Found 페이지를 만들 수 있다. 12345678910111213141516171819202122import React from \"react\";import &#123; BrowserRouter, Route, Switch &#125; from \"react-router-dom\";import Home from \"./pages/Home\";import Profile from \"./pages/Profile\";import About from \"./pages/About\";import NotFound from \"./pages/NotFound\";function App() &#123; return ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/profile/:id\" component=&#123;Profile&#125; /&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; );&#125;export default App; Link 태그 &lt;a&gt; 태그를 쓰면 Reload(서버와의 통신)가 발생하므로 &lt;Link&gt;태그를 이용해서 단순히 컴포넌트만을 변경하는 방식을 이용함. 내부적으로는 &lt;a&gt;태그이므로 css에서 &lt;a&gt;태그에 속성을 추가하면 &lt;Link&gt;태그에도 추가된다. 1234567891011121314151617181920212223242526import React from 'react';import &#123; Link &#125; from 'react-router-dom';function Links() &#123; return ( &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/profile/1\"&gt;Profile/1&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about?name=mark\"&gt;About?name=mark&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );&#125;export default Links; NavLink &lt;NavLink&gt;를 이용해서 스타일을 사용할 수 있음. 기본값으로 className=&quot;active&quot;가 설정되어 있다. ( defaultprops ) activeClassName, activeStyle 처럼 active 상태에 대한 스타일 지정이 가능하다. Route 의 path 처럼 동작하기 때문에 exact 가 있다. 12345678&lt;li&gt; &lt;NavLink to=\"/\" exact activeStyle=&#123;&#123; color: \"green\" &#125;&#125;&gt;Home&lt;/NavLink&gt;&lt;/li&gt; 위 소스대로 설정할 경우, QueryString으로 보내는 주소는 같은 Active 스타일이 적용 된다. (/about , /about?name=mark) 이를 방지하기 위해 아래처럼 작성한다. isActive할 때 pathname이 맞아야 match객체가 들어온다. location.search가 비워있는지 안비웠는지 판단한다. 12345678910111213141516171819202122&lt;li&gt; &lt;NavLink to=\"/about\" isActive=&#123;(match, location) =&gt; &#123; console.log(match, location); // 다른데 누를 때 마다 계속 찍히는데 라우팅이 바뀔때마다 체크한다는 뜻 if (match === null) &#123; return false; &#125; console.log(location.search); return location.search === '' ? true : false; &#125;&#125;&gt; About &lt;/NavLink&gt;&lt;/li&gt;&lt;li&gt; &lt;NavLink to=\"/about?name=mark\" isActive=&#123;(match, location) =&gt; &#123; if (match === null) &#123; return false; &#125; return location.search === '?name=mark'; &#125;&#125;&gt; About?name=mark &lt;/NavLink&gt;&lt;/li&gt; JS로 라우팅 이동하기props.history.push(&quot;/&quot;); history는 url을 바꿀때, 읽어올 때 사용. props에 history가 포함되어 있다. HOC(High Order Component) - withRouter()시나리오 : 만약, &lt;Route&gt; 에 있는 path 속성에 적혀진 component가 아니라면 훅 때문에 잘 사용하지 않음 123import &#123; withRouter &#125; from &apos;react-router-dom&apos;;...export default withRouter(LoginButton); Login에서 history를 props로 보내주지 않아도 LoginButton에서 알아서 받아다 씀! 그냥 함수인데 input을 컴포넌트로 받고 output을 새로운 컴포넌트로 강제된 라이브러리가 아니라 룰이 있음 - 만들 때 룰에 주의하며 만들어야 함 - 다다음 시간에 배울 것 withRouter라고 이름을 붙여서 넣어준 것 connect도 HOC - 리덕스 연결에 사용 - 컴포넌트를 받아 컴포넌트를 리턴 relay 라이브러리에 createFragmentContainer도 HOC Redirect path가 로그인인데, 이미 로그인 되었을 경우 redirect를 렌더하게 끔 할 때 사용. 특정 페이지에 접속했을 때 조건에 따라 다른 페이지로 바로 넘어가는 것. Route Hooks useHistory useLocation useParams useRouteMatch useHistory withRouter없이 사용 가능하다. 1const history = useHistory(); useLocation12const location = useLocation();const &#123; name &#125; = queryString.parse(location.search); useParams1const &#123; id &#125; = useParams(); useRouteMatch 현재 url과 기준이 되는 url을 비교해야만 한다. 방법1) string으로 던지기 방법2) object로 던지기 12345const match = useRouteMatch(&#123; path: '/book/:id', strict: true, // 매치 옵션 sensitive: true // 매치 옵션&#125;); BrouserRouter의 내려주기.123&lt;BrowserRouter&gt;...&lt;/BrowserRouter&gt; &lt;BrowserRouter&gt;로 감싸면 위의 hooks들을 전역에 들고 있는 것과 같음 - 가져다 쓸 수 있도록 하는 것. React developer tools Google Chrome 에 설치하는 익스텐션 F12 개발자도구 - Profiler 에서 렌더링 되는 시간들을 알아볼 수 있다. - 퍼포먼스 최적화에 유용 F12 개발자도구 - Component 에서 트리를 볼 수 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"다시 공부하는 React -01-","slug":"ReactStudy-01","date":"2020-01-25T13:51:32.000Z","updated":"2020-01-25T15:55:16.159Z","comments":true,"path":"2020/01/25/ReactStudy-01/","link":"","permalink":"https://hyeok999.github.io/2020/01/25/ReactStudy-01/","excerpt":"","text":"React Re-Study : 1 리액트를 위한 JS 문법정리 에러는 에러 객체를 상속받아서 throw 한다. (throw new Error) let 은 변경 가능, const 는 불가능 arrow function 함수.bind(this) 디스트럭처링 callback Promise 객체 Generator 객체 React 프로젝트 프로젝트 구성 지식 프록젝트 구성하기 React 짧은 리뷰 React 핵심 모듈 React Component 만드는 법 props와 state Event Handling 인라인 함수를 작성하면 안되는 이유 해결방안 React Study with Mark - 리액트를 위한 JS 문법정리 - 리액트를 위한 JS 문법정리 이 정도의 개념은 알고 있어야 최소한의 React 개발이 가능하다…. 에러 const let template string arrow function .bind(this) const {children} = this.props; …props Promise async await Generator 에러는 에러 객체를 상속받아서 throw 한다. (throw new Error) SyntaxError : 코드를 분석하는 중 잘못된 구문을 만났음을 나타내는 오류 ReferenceError : 잘못된 참조를 했음을 나타내는 오류 TypeError : 변수나 매개변수가 유효한 자료형이 아님을 나타내는 오류 RangeError : 숫자 변수나 매개변수가 유효한 범위를 벗어났음을 나타내는 오류 등등… let 은 변경 가능, const 는 불가능 Primitive : 원시값 Reference : 객체값 arrow function 자신의 this 를 만들지 않는다. 생성자로 사용할 수 없다. 항상 익명 함수 리턴만 있으면, {} 생략 인자가 하나면, () 생략 123456789101112131415// arrow.jsfunction Foo() &#123; this.name = 'Mark'; setTimeout(function() &#123; console.log(this.name); // undefined &#125;, 1000); setTimeout(() =&gt; &#123; console.log(this.name); // Mark &#125;, 1000);&#125;const foo = new Foo(); 함수.bind(this) 함수가 가르키는 this를 인자에 적히 this로 변경한다. 호출은 하지 않는다. (호출 - apply, call) 1234567891011121314151617function hello() &#123; console.log(`안녕하세요 $&#123;this.name&#125;`);&#125;const mark = &#123; name: 'Mark',&#125;;const helloMark = hello.bind(mark);helloMark(); // 안녕하세요 Markconst anna = &#123; name: 'Anna',&#125;;const helloAnna = hello.bind(anna);helloAnna(); // 안녕하세요 Anna 디스트럭처링 구조 분해 할당 (객체 , 배열) 디스트럭처링은 1레벨 깊이까지만 변화시킨다. 딥카피의 제일 쉬운 방법은 json.stringify를 이용하여 문자열로 변환시켜 복사하는 방법이다. (단, 엄청 느리다.) 1234567891011const obj1 = &#123; a: &#123; b: 100 &#125; &#125;;const obj1Cloned = &#123; ...obj1 &#125;;obj1Cloned.a.b = 200;console.log(obj1, obj1Cloned); // 1레벨// &#123; a: &#123;b: 200&#125; &#125; &#123; a: &#123;b: 200&#125; &#125; // &#123;b : 200&#125;으로 같이 변경되었음.const obj2 = &#123; a: &#123; b: 100 &#125; &#125;;const obj2Cloned = &#123; ...obj2, a: &#123; ...obj2.a &#125; &#125;;obj2Cloned.a.b = 200; // 2레벨 깊이까지 복사했기 때문에 독리접이다.console.log(obj2, obj2Cloned); // 2레벨// &#123; a: &#123;b: 100&#125; &#125; &#123; a: &#123;b: 200&#125; &#125; callback 비동기 처리를 위한 선택 고차 함수 내부에서 호출하는 함수 12345678910111213141516// callback.jsfunction foo(callback) &#123; // foo는 고차함수다. setTimeout(() =&gt; &#123; // 로직 callback(); &#125;, 1000);&#125;foo(() =&gt; &#123; console.log('end');&#125;);console.log('이것이 먼저 실행');// 이것이 먼저 실행// undefined : 실행결과임// end Promise 객체 Promise 객체를 만들고, 로직 처리 후 성공과 실패를 알려준다. then 과 catch 를 통해 메인 로직에 전달한다. Promise는 3가지 상태를 지닌다. Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태 Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태 (resolve) Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태 (reject) new Promise() 호출 시 Pending 상태가 된다. new Promise() 메서드 호출 시 콜백함수의 인자로 resolve 혹은 reject 에 접근할 수 있다. 12345678910111213141516// Promisefunction foo() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, 1000); &#125;);&#125;foo().then(() =&gt; &#123; console.log('end');&#125;);console.log('이것이 먼저 실행');// 이것이 먼저 실행// undefined : 실행결과임// end Generator 객체 function키워드 뒤에 *이 적혀진 함수를 호출해서 반환되는 객체다. ( Generator객체(표준 내장 객체) ) function* 에서yield 를 호출하여, 다시 제어권을 넘겨준다. 제너레이터 객체에 next() 함수를 호출하면, 다음 yield 지점까지 간다. 1234567891011121314151617// generator.jsfunction* foo() &#123; console.log(0.5); yield 1; console.log(1.5); yield 2; console.log(2.5); yield 3; console.log(3.5);&#125;const g = foo(); // g는 Generate 객체이다.console.log(g.next().value); // 0.5 1console.log(g.next().value); // 1.5 2console.log(g.next().value); // 3 3.5console.log(g.next().value); // undefinedconsole.log(g.next().value); // undefined next()는 두 개의 프로퍼티를 가진 객체를 반환한다. done (boolean) Iterator(반복자)가 마지막 반복 작업을 마쳤을 경우 true. 만약 iterator(반복자)에 return 값이 있다면 value의 값으로 지정된다. Iterator(반복자)의 작업이 남아있을 경우 false. Iterator(반복자)에 done 프로퍼티 자체를 특정짓지 않은 것과 동일하다. value Iterator(반복자)으로부터 반환되는 모든 자바스크립트 값이며 done이 true일 경우 생략될 수 있다. 12345678910111213141516171819// generator.js// 핸들let handle = null;// 비동기 함수function bar() &#123; setTimeout(() =&gt; &#123; handle.next('hello'); &#125;, 1000);&#125;// 핸들을 통해 컨트롤을 넘기는 제너레이터 함수function* baz() &#123; const text = yield bar(); console.log(text); // hello&#125;handle = baz();handle.next(); // &#123;value: undefined, done: false&#125; React 프로젝트프로젝트 구성 지식 npm run build : 실제 배포를 위한 명령어. (build 폴더를 만든다.) npm install serve -g : 파일들을 서버로 올릴 수 있도록 하는 패키지(ZEIT)serve -s build : -s는 Singlepage Application 의 약자로 어떠한 라우팅에도 index.html을 응답함 npm test: 테스트 파일 생성 npm run eject : npx를 해제하여 수많은 패키지들이 나온다. 예전에 SASS가 안될 때 사용했고, 세부적인 설정을 작업할 때 사용한다. 한번 실행 시 돌이킬 수 없다. webpack은 bundler / babel은 transfiler 이미지 파일 로딩 방법 2가지(퍼블릭 폴더에 넣는 방식, import로 불러오는 방식) package-lock.json 은 개발했던 마지막 상태를 의미한다. 따라서 마지막 개발 상황을 똑같이 재현해야한다면 npm i 가 아니라 npm ci를 해야한다. CRA : npx create-react-app 정말 간편하게 react프로젝트를 만들어준다. ESLint : JS 혹은 JSX에서 플러그 가능한 Linting 유틸리티.( 문법검사를 더불어 코드 작성 추천 제시 ) Prettier : 코드 자동 정리 Formatter ( Beutify와 충돌이 난다. 1개만 선택할 것 ) husky : Git hooks 을 사용하기 쉽게 만들어주는 툴 (커밋시, ESLint와 Prettier를 적용시켜 올리게할 수 있다.) 프록젝트 구성하기 npx create-react-app 프로젝트명 (ESLint 포함 설치됨) npm i prettier -D .prettierrc 파일 생성 및 설정 1234567// .prettierrc&#123; \"trailingComma\": \"all\", \"tabWidth\": 2, \"semi\": true, \"singleQuote\": true&#125; npm i huskey -D npm i lint-staged -D package.json 파일 설정 추가 12345678910111213// package.json 의 scripts 객체 아래에 작성\"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125;&#125;,\"lint-staged\": &#123; \"**/*.js\": [ \"eslint --fix\", \"prettier --write\", \"git add\" ]&#125; React 짧은 리뷰 View 라이브러리 (오직 렌더링 및 업데이트만 진행) 컴포넌트 단위 개발 : JS에 웹 컴포넌트가 정의되어 있다. Virtual DOM을 이용한 개발 (반대 : Svelte) State Chage → Compute Diff → Re-Render JSX ( Templates은 String형태로 바뀌는 것. / JSX는 하나의 표기법, JS의 트랜스파일 ) CSR &amp; SSR (상황에 맞게 골라서 사용한다.) CSR(Client Side Rendering) html, js파일을 전부 내려받을 때까지 loading상태. loading 완료 시 react가 execute후 보여진다. (JS작동 동시 실행) SSR(Server Side Rendering) html요청시 서버에 있는 리액트 앱이 컴포넌트들을 String으로 해서 html로 내려주고, 이게 html에 바로 보여짐(JS 작동은 내려받는 중이므로 동작은 되지 않는다.) JS 다운 완료 후 react가 execute된 후부터 작동 가능. React 핵심 모듈 ‘react’ : JSX문법을 쓸 수 있도록 지원해준다. ‘react-dom’ : 만들어진 리액트 컴포넌트를 실제 DOM 에 연결할 때 사용한다. React Component 만드는 법 class : 기존에 있는 메소드 render를 오버라이드 해서 사용 하는 것. 컴포넌트 내부 상태가 있다면 - class 컴포넌트 내부 상태가 없지만 라이프사이클을 사용 - class 컴포넌트 내부 상태가 없고 라이프사이클과 관련X - function 1234567891011// classimport React from 'react';class ClassComponent extends React.Component &#123; render() &#123; return (&lt;div&gt;Hello&lt;/div&gt;); &#125;&#125;// 사용&lt;ClassComponent /&gt; hooks : 새로 도입된 React 패러다임. (All - function) 1234567// hooksimport React from 'react';const FunctionComponent = () =&gt; (&lt;div&gt;Hello&lt;/div&gt;);// 사용&lt;HooksComponent /&gt; props와 state Props 와 State는 를 바탕으로 컴포넌트를 그림 Props 와 State 가 변경되면, 컴포넌트를 다시 그림 컴포넌트를 그리는 방법을 기술하는 함수가 랜더 함수 외부에서 보내는 데이터가 변화를 일으킬 경우에만 Props 사용. Props는 객체 State를 바로 변경하지 못하게 한 이유는? 스테이트가 변경되면 렌더를 다시해줘야 하므로 객체를 바로 변경하게(state.s = Apple) 하지 않고 this.setState를 통해 여기서 state가 바뀌니까 명시적으로 다시 렌더하라고 알려주는 것 Event Handling HTML DOM 에 클릭하면 이벤트가 발생하고, 발생하면 그에 맞는 변경이 일어나도록 해야함. JSX 에 이벤트를 설정할 수 있다. 이벤트 핸들링시 인라인 함수를 작성해서는 안된다. 1&lt;button onClick=&#123;() =&gt; console.log('abc')&#125;&gt;test&lt;/button&gt; // X 인라인 함수로 작성했을 경우, DOM에는 크게 문제가 없다. 인라인 함수를 작성하면 안되는 이유 인라인 함수로 작성했을 경우, DOM에는 크게 문제가 없다. 1&lt;button onClick=&#123;() =&gt; console.log('abc')&#125;&gt;test&lt;/button&gt; // X 위와 같은 인라인 함수를 작성하게 될 경우 매 렌더링 시 새로운 익명함수를 만들어서 반환한다. (즉, 참조값이 달라진다.) 당장의 해당 컴포넌트에서 사용하기에는 전혀 문제가 없지만 props를 통해 자식 컴포넌트에게 내려주게 될 경우 큰 문제가 발생한다. PureComponent 최적화 문제 기본적인 React.Component 의 경우 props 혹은 state 가 바뀔 때 마다, 하위 컴포넌트 역시 새롭게 렌더링한다.React.PureComponent 의 경우 내부에서 props와 state를 shallow level 안에서 비교 하여, 변경된 값이 있을 시에만 리렌더링 하도록 되어 있다. 문제는 새롭게 참조값을 매번 반환하므로 PureComponent의 의미가 전혀 없다. React.memo 최적화 문제 React.memo 역시 동일한 문제를 가지고 있다. 컴퍼넌트를 렌더링(rendering) 한 뒤, 이전 렌더된 결과와 비교하여 DOM 업데이트를 결정한다. 여기서 결과상으로 같은 값을 props로 준 것 임에도 참조값이 다르므로 React.memo 역시 사용된 의미가 전혀없게 된다. 1234567891011121314151617181920212223242526// App.js&lt;Person &#123;...p&#125; key=&#123;p.id&#125; onClick=&#123;() =&gt; &#123;&#125;&#125; /&gt;// Person.js - PureComponent 최적화 문제class Person extends React.PureComponent &#123; render() &#123; console.log(\"Person render\"); const &#123; name, age &#125; = this.props; return ( &lt;ul&gt; &#123;name&#125; / &#123;age&#125; &lt;/ul&gt; ); &#125;&#125;// Person.js - React.memo 최적화 문제const Person = React.memo(props =&gt; &#123; console.log(\"Person render\"); const &#123; name, age &#125; = props; return ( &lt;ul&gt; &#123;name&#125; / &#123;age&#125; &lt;/ul&gt; );&#125;); 해결방안 useCallback 이용 인라인 함수 말고 클래스면 맴버 함수를, 펑셔널이면 내부에 함수를 만들어서 넘겨준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"SPA 와 react-router [1]","slug":"react-router-01","date":"2020-01-25T11:25:35.000Z","updated":"2020-01-25T15:49:01.073Z","comments":true,"path":"2020/01/25/react-router-01/","link":"","permalink":"https://hyeok999.github.io/2020/01/25/react-router-01/","excerpt":"","text":"React Router with Velopert - 01 - SPA SPA 란? non-SPA SPA 장점 SPA 단점 주로 사용되는 리액트 라우터 라이브러리 리액트 라우터 react-router next 리액트 라우터 react-router BrowserRouter HashRouter MemoryRouter StaticRouter Route Link Chap 1. SPA 와 react-router SPASPA 란?Single Page Application의 html 페이지가 1개인것을 의미한다. (화면이 한개라는 의미는 아니다.) SPA에서는 라우팅을 클라이언트가 담당한다. 여기서 라우팅은 어떤 주소에 어떤 UI를 보여줄지 에 규칙을 정하는 작업이다. non-SPAnon-SPA에서는 서버에서 라우팅 작업을 담당했다. non-SPA, 즉 정통적인 웹 어플리케이션은 특정 데이터의 처리에 대한 응답을 하기 위해서 반드시 html 페이지를 반환해야 되기 때문에 자연스럽게 웹페이지가 많아지게 되었고, 새로고침을 지속적으로 일으켜야만 했다. 이러한 서버측의 처리는 서버자원을 많이 소비하게 되었고, 불필요한 트래픽도 낭비하게 되었다. SPA 장점SPA에서는 어떤 주소에서 어떤 UI를 보여줄지는 클라이언트가 담당한다. 서버는 그저 클라이언트가 선택한 페이지에 필요한 데이터만 응답해주면 되기 떄문에, 서버쪽은 서버자원을 많이 아끼고 사용자는 UX가 향상될 수 있다. SPA 단점 앱의 규모가 커지면 JS파일의 크기가 커질 수 있다. (Code Splitting 으로 해결가능) Code Splitting : 각 기능별로 파일을 나누어놓고 필요한 시점에 해당 파일을 불러올 수 있다. 브라우저에서 JS가 구동되지 않으면 UI를 볼 수 없다. -&gt; 검색엔진에서 크롤링이 불가능해진다.( Server Side Rendering으로 해결 ) 주로 사용되는 리액트 라우터 라이브러리 react-router next 리액트 라우터 컴포넌트 기반 라우팅 라우터 컴포넌트를 만들고 라우터 컴포넌트의 props에 컴포넌트를 렌더링하는 방식 next 서버 사이드 렌더링을 쉽게 구현 가능하다. 파일 경로, 이름을 기반으로 라우팅을 한다. 리액트 라우터 react-router 써드 파티 라이브러리, 라우팅으로 가장 많이 사용되고 있는 라이브러리. 클라이언트 사이드에서 이뤄지는 라우팅을 간단하게 해준다. 주요 컴포넌트 : &lt;BrowserRouter&gt; , &lt;HashRouter&gt;, &lt;MemoryRouter&gt;, &lt;StaticRouter&gt;, &lt;Route&gt;, &lt;Link&gt; 1. BrowserRouter 가장 많이 사용되는 컴포넌트. HTML5에는 History API라는 것이 있다. 위 API는 브라우저의 주소표시줄에 나타나는 경로를 바꿀 수 있다. 여기서, 주소만 바꾸는 것이고 서버에 요청을 하지않는다. 즉, 페이지를 새로 로드하지는 않는다. 2. HashRouter 엣날에 자주 쓰이던 라우팅 방식. 주소 뒤에 # 태그를 넣는 방법을 이용한다. ( example.com/#/path/to/route ) 엣날 브라우저에서도 작동하는 장점이 있다. (BrowserRouter는 IE 6 ~ 9 에서 사용 할 수 없다.) 3. MemoryRouter 브라우저의 주소와는 전혀 관계가 없다. 브라우저가 아닌 환경에 사용하기 좋다. 테스트 환경, 임베디드 웹앱 ( 웹 어플리케이션이 전부 리액트가 아니라 일부분만 리액트 일 경우 ), 리액트 네이티브에서 사용한다. 4. StaticRouter 서버 사이드 렌더링에 이용 5. Route 라우트를 정의할 때 사용하는 컴포넌트. 어떤 경로로 들어왔을 때, 어떤 컴포넌트를 보여줄것인지 설정할 수 있다.(path) 6. Link a 태그로 구성되어 있다. 하지만 Router의 주소만 바꿔줄 뿐, 새로고침 하지는 않는다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://hyeok999.github.io/tags/Router/"}]},{"title":"GraphQL Schema, Type","slug":"GraphQL-BACK","date":"2020-01-24T07:53:23.000Z","updated":"2020-01-24T07:55:38.561Z","comments":true,"path":"2020/01/24/GraphQL-BACK/","link":"","permalink":"https://hyeok999.github.io/2020/01/24/GraphQL-BACK/","excerpt":"","text":"Graph QL - SCHEMAS &amp; TYPES - SCHEMAS &amp; TYPES 타입 시스템 Type system 타입 언어 Type Language 객체 타입과 필드 인자 Arguments 쿼리 타입 &amp; 뮤테이션 타입 The Query and Mutation Types 스칼라 타입 Scalar Types 열거형 타입 Enumeration Types 리스트와 Non-Null / Lists and Non-Null 인터페이스 Interfaces 유니온 타입 Union Types 입력 타입 Input Types SCHEMAS &amp; TYPES 스키마를 설계하는 것은 백엔드 개발자의 몫. (회사마다 다르지만, 보통의 경우 백엔드 개발자가 담당함. 예외의 경우에 대비하여 학습한다.) GraphQL 타입 시스템과 데이터를 표현하는 방법을 익힌다. GraphQL은 어떠한 백엔드 프레임워크나 프로그래밍 언어든 함께 사용할 수 있다. 타입 시스템 Type system GraphQL 쿼리 언어는 기본적으로 객체의 필드를 선택한다. 12345678910111213141516171819&#123; hero &#123; name appearsIn &#125;&#125;##############&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;appearsIn&quot;: [ &quot;NEWHOPE&quot;, &quot;EMPIRE&quot;, &quot;JEDI&quot; ] &#125; &#125;&#125; root 객체로 시작. hero 필드를 선택. hero 에 의해 반환된 객체에 대해 name 과 appearIn 필드를 선택. GraphQL 쿼리의 형태가 결과와 거의 일치하기 때문에 서버에 대해 모르는 상태에서 쿼리가 반환할 결과를 예측할 수 있다. 하지만 서버에 요청할 수 있는 데이터에 대한 정확한 표현을 갖는 것이 좋다. 어떤 필드를 선택할 수 있는지, 어떤 종류의 객체를 반환할 수 있는지, 하위 객체에서 사용할 수 있는 필드는 무엇인지, 이것이 바로 스키마가 필요한 이유이다. 모든 GraphQL 서비스는 해당 서비스에서 쿼리 가능한 데이터들을 완벽하게 설명하는 타입들을 정의하고, 쿼리가 들어오면 해당 스키마에 대해 유효성이 검사된 후 실행된다. 타입 언어 Type Language GraphQL 서비스는 어떤 언어로든 작성할 수 있다. GraphQL 스키마 언어(GraphQL schema language) 를 사용할 것. 이것은 쿼리 언어와 비슷하며, GraphQL 스키마를 언어에 의존적이지 않은 방식으로 표현할 수 있게 해준다. 객체 타입과 필드 Object Types and Fields GraphQL 스키마의 가장 기본적인 구성 요소는 객체 타입. 객체 타입은 서비스에서 가져올 수 있는 객체의 종류와 그 객체의 필드를 나타낸다. GraphQL 스키마 언어에서는 다음과 같이 표현할 수 있다. 1234type Character &#123; name: String! appearsIn: [Episode]!&#125; Character 는 GraphQL 객체 타입이다. 즉, 필드가 있는 타입을 의미한다. 스키마의 대부분의 타입은 객체 타입이다. name 과 appearIn 은 Character 타입의 필드. 즉 name 과 appearIn 은 GraphQL 쿼리의 Character 타입 어디서든 사용할 수 있는 필드를 의미한다. String 은 내장된 스칼라 타입 중 하나. 이는 스칼라 객체로 해석되는 타입이며 쿼리에서 하위 선택을 할 수 없다. String! 은 필드가 non-nullable 임을 의미. 즉, 이 필드를 쿼리할 때 GraphQL 서비스가 항상 값을 반환한다는 것을 의미. 타입 언어에서는 이것을 느낌표로 나타냅니다. [Episode]! 는 Episode 객체의 배열(array) 을 나타낸다. 또한 non-nullable 이기 때문에 appearIn 필드를 쿼리할 때 항상(0개 이상의 아이템을 가진) 배열을 기대할 수 있다. 인자 Arguments GraphQL 객체 타입의 모든 필드는 0개 이상의 인수를 가질 수 있다.(예: 아래 length 필드). 12345type Starship &#123; id: ID! name: String! length(unit: LengthUnit = METER): Float&#125; 모든 인수에는 이름이 있다. 함수가 순서있는 인자를 가져오는 JavaScript나 Python과 같은 언어와 달리 GraphQL의 모든 인자는 특별한 이름으로 전달된다.(즉, 객체식) 이 경우, length 필드는 하나의 인자 unit 을 가진다. 인자는 필수거나 옵셔널일 수 있다. 인자가 옵셔널인 경우 기본값 을 정의할 수 있다. unit 인자가 전달되지 않으면 기본적으로 METER 로 설정된다. 쿼리 타입 &amp; 뮤테이션 타입 The Query and Mutation Types 스키마 대부분의 타입은 일반 객체 타입이지만 스키마 내에는 특수한 두 가지 타입이 있다. 1234schema &#123; query: Query mutation: Mutation&#125; 모든 GraphQL 서비스는 query 타입을 가지며 mutation 타입은 가질 수도 있고 가지지 않을 수도 있다. 이러한 타입은 일반 객체 타입과 동일하지만 모든 GraphQL 쿼리의 진입점(entry point) 을 정의하므로 특별하다. 따라서 다음과 같은 쿼리를 볼 수 있다. 12345678910111213141516171819query &#123; hero &#123; name &#125; droid(id: &quot;2000&quot;) &#123; name &#125;&#125;####################################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125;, &quot;droid&quot;: &#123; &quot;name&quot;: &quot;C-3PO&quot; &#125; &#125;&#125; 즉, GraphQL 서비스는 hero 및 droid 필드가 있는 Query 타입이 있어야한다. 1234type Query &#123; hero(episode: Episode): Character droid(id: ID!): Droid&#125; 뮤테이션도 비슷한 방식으로 작동한다. 즉, Mutation 타입의 필드를 정의하면 쿼리에서 호출할 수 있는 루트 뮤테이션 필드로 사용할 수 있다. 스키마에 대한 진입점 이라는 특수한 점 이외의 쿼리 타입과 뮤테이션 타입은 다른 GraphQL 객체 타입과 동일하며 해당 필드는 정확히 동일한 방식으로 작동한다는 점을 기억하자. 스칼라 타입 Scalar Types GraphQL 객체 타입은 이름과 필드를 가지지만, 어떤 시점에서 이 필드는 구체적인 데이터로 해석되어야한다. 이것이 스칼라 타입이 필요한 이유. 즉, 쿼리의 끝을 나타낸다. 다음 쿼리에서 name 과 appearIn 은 스칼라 타입으로 해석될 것이다. 12345678910111213141516171819&#123; hero &#123; name appearsIn &#125;&#125;#########################################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;appearsIn&quot;: [ &quot;NEWHOPE&quot;, &quot;EMPIRE&quot;, &quot;JEDI&quot; ] &#125; &#125;&#125; 해당 필드에 하위 필드가 없기 때문에 이를 알 수 있다. 이 필드는 쿼리의 끝부분이다. GraphQL 에서는 스칼라 타입들이 기본 제공된다. Int: 부호가 있는 32비트 정수. Float: 부호가 있는 부동소수점 값. String: UTF-8 문자열. Boolean: true 또는 false. ID: ID 스칼라 타입은 객체를 다시 요청하거나 캐시의 키로써 자주 사용되는 고유 식별자를 나타낸다. ID 타입은 String 과 같은 방법으로 직렬화되지만, ID 로 정의하는 것은 사람이 읽을 수 있도록 하는 의도가 아니라는 것을 의미함. 대부분의 GraphQL 구현에는 커스텀 스칼라 타입을 지정하는 방법이 있다. 예를 들면, Date 타입을 정의할 수 있다. 1scalar Date 해당 타입을 직렬화, 역 직렬화, 유효성 검사하는 방법을 구현할 수 있다. 예를 들어, Date 타입을 항상 정수형 타임스탬프로 직렬화해야 한다는 것을 지정할 수 있다. 그리고 클라이언트는 모든 날짜 필드에 대해 해당 타입을 기대할 수 있을 것이다. 열거형 타입 Enumeration Types Enums 라고도 하는 열거형 타입은 특정 값들로 제한되는 특별한 종류의 스칼라이다. 타입의 인자가 허용된 값 중 하나임을 검증한다. 필드가 항상 값의 열거형 집합 중 하나가 될 것임을 타입 시스템을 통해 의사소통한다. GraphQL 스키마 언어에서 열거형 타입 정의 ▾ 12345enum Episode &#123; NEWHOPE EMPIRE JEDI&#125; 즉, 스키마에서 Episode 타입을 사용할 때마다 정확히 NEWHOPE, EMPIRE, JEDI 중 하나일 것이다. 다양한 언어로 작성된 GraphQL 서비스 구현은 열거형 타입을 처리 할 수 있는 언어별 고유한 방법을 갖는다. enum 을 지원하는 언어에서는 구현시 이를 활용할 수 있다. 열거형 타입이 없는 JavaScript와 같은 언어에서 이러한 값은 내부적으로 정수 집합에 매핑될 수 있다. 하지만 이러한 세부 정보는 클라이언트에 노출되지 않으며, 열거형 값의 문자열로만 작동한다. 리스트와 Non-Null / Lists and Non-Null 스키마의 다른 부분이나 쿼리 변수 선언에서 타입을 사용하면 해당 값의 유효성 검사를 할 수 있는 타입 수정자(type modifiers) 를 적용할 수 있다. 즉 특정 타입에 대해서 null에 대한 유효성 검사를 적용할 수 있다. 1234type Character &#123; name: String! appearsIn: [Episode]!&#125; String 타입을 사용하고 타입 뒤에 느낌표 ! 를 추가하여 Non-Null 로 표시했다. 즉, 서버는 항상 이 필드에 대해 null이 아닌 값을 반환할 것을 기대하며, null값이 발생되면 GraphQL 실행 오류가 발생하고, 클라이언트에게 무언가 잘못되었음을 알린다. Non-Null 타입 수정자는 필드에 대한 인자를 정의할 때도 사용할 수 있다. 이는 GraphQL 서버가 문자열이나 변수 상관없이 null 값이 해당 인자로 전달되는 경우, 유효성 검사 오류를 반환하게 한다. 1234567891011121314151617181920212223query DroidById($id: ID!) &#123; droid(id: $id) &#123; name &#125;&#125;# VARIABLES&#123; &quot;id&quot;: null&#125;#######################################&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;Variable \\&quot;$id\\&quot; of required type \\&quot;ID!\\&quot; was not provided.&quot;, &quot;locations&quot;: [ &#123; &quot;line&quot;: 1, &quot;column&quot;: 17 &#125; ] &#125; ]&#125; 리스트도 비슷한 방식으로 동작한다. 타입 수정자를 사용하여 타입을 List 로 표시할 수 있다. 이 필드는 해당 타입의 배열을 반환한다. 스키마 언어에서, 배열을 대괄호 [] 로 묶는 것으로 표현된다. 유효성 검사 단계에서 해당 값에 대한 배열이 필요한 인자에 대해서도 동일하게 작동한다. Non-Null 및 List 수정자를 결합할 수도 있다. 예를 들면, Null이 아닌 문자열 리스트를 가질 수 있다. 1myField: [String!] 즉, list 자체는 null 일 수 있지만, null 을 가질 수 없다. 예를 들면, 1234myField: null // validmyField: [] // validmyField: ['a', 'b'] // validmyField: ['a', null, 'b'] // error null 이 아닌 문자열 리스트를 정의했다고 가정해자. 1myField: [String]! 목록 자체는 null 일 수 없지만, null 값을 포함할 수 있다. 1234myField: null // errormyField: [] // validmyField: ['a', 'b'] // validmyField: ['a', null, 'b'] // valid 필요에 따라 여러개의 Null, List 수정자를 중첩할 수 있다. 인터페이스 Interfaces 여러 타입 시스템과 마찬가지로 GraphQL도 인터페이스를 지원한다. 인터페이스 는 이를 구현하기 위해 타입이 포함해야하는 특정 필드들을 포함하는 추상 타입이다. Java의 인터페이스와는 다르게 GraphQL의 인터페이스는 상속받는 타입들이 해당 인터페이스를 모두 작성해야만 한다. 즉, Java의 인터페이스는 중복회피로 사용되었다면, GraphQL의 인터페이스는 반드시 사용되어야한다는 조건을 사용된다. 예를 들면, Star Wars 3부작의 모든 캐릭터들을 표현하는 Character 인터페이스를 가질 수 있다. 123456interface Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]!&#125; 이것은 Character 를 구현한(implements) 모든 타입은 이러한 인자와 리턴 타입을 가진 정확한 필드를 가져야한다는 것을 의미한다. 다음은 Character 를 구현한 몇 가지 타입 예제이다. 1234567891011121314151617# 위 Character 인터페이스를 모두 상속받았지만, 전부 인터페이스 내용이 작성되었다.type Human implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! starships: [Starship] totalCredits: Int&#125;type Droid implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String&#125; 두 타입 모두 Character 인터페이스의 모든 필드를 가지고 있다. 또한 특정 캐릭터에 추가 필드 totalCredits,starships, primaryFunction 을 가질 수도 있다. 인터페이스는 객체나 객체리스트를 반환하려는 경우에 유용하지만, 다양한 다른 타입이 있을 수도 있다. 예를 들면, 다음 쿼리는 오류를 반환한다. 123456789101112131415161718192021222324query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name primaryFunction &#125;&#125;# VARIABLES&#123; &quot;ep&quot;: &quot;JEDI&quot;&#125;########################&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;Cannot query field \\&quot;primaryFunction\\&quot; on type \\&quot;Character\\&quot;. Did you mean to use an inline fragment on \\&quot;Droid\\&quot;?&quot;, &quot;locations&quot;: [ &#123; &quot;line&quot;: 4, &quot;column&quot;: 5 &#125; ] &#125; ]&#125; hero 필드는 Character 타입을 반환하는데, episode 인자에 따라 Human, Droid 중 하나일 수 있다. 위 쿼리는 primaryFunction 을 포함하지 않는 Character 인터페이스에 존재하는 필드만 요청할 수 있다. 특정 객체 타입의 필드를 요청하려면 인라인 프래그먼트을 사용해야한다. 123456789101112131415161718192021query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name ... on Droid &#123; primaryFunction &#125; &#125;&#125;# VARIABLES&#123; &quot;ep&quot;: &quot;JEDI&quot;&#125;####################################################3&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;primaryFunction&quot;: &quot;Astromech&quot; &#125; &#125;&#125; 쿼리 가이드의 인라인 프래그먼트 장을 참조. 유니온 타입 Union Types 유니온 타입은 인터페이스와 매우 유사하지만, 타입 간에 공통 필드를 특정하지 않는다. 1union SearchResult = Human | Droid | Starship 스키마에서 SearchResult 타입을 반환 할 때마다, Human, Droid, Starship 을 얻을 수 있다. 유니온 타입의 멤버는 구체적인 객체 타입이어야 한다. 인터페이스나 유니온 타입에서 다른 유니온 타입을 사용할 수 없다. 이 경우, SearchResult 유니언 타입을 반환하는 필드를 쿼리하면, 어떤 필드라도 쿼리할 수 있는 조건부 프래그먼트를 사용해야한다. 1234567891011121314151617181920212223242526272829303132333435&#123; search(text: &quot;an&quot;) &#123; ... on Human &#123; name height &#125; ... on Droid &#123; name primaryFunction &#125; ... on Starship &#123; name length &#125; &#125;&#125;##################################&#123; &quot;data&quot;: &#123; &quot;search&quot;: [ &#123; &quot;name&quot;: &quot;Han Solo&quot;, &quot;height&quot;: 1.8 &#125;, &#123; &quot;name&quot;: &quot;Leia Organa&quot;, &quot;height&quot;: 1.5 &#125;, &#123; &quot;name&quot;: &quot;TIE Advanced x1&quot;, &quot;length&quot;: 9.2 &#125; ] &#125;&#125; 123456789101112131415161718// APOLLO 에서 다음과 같이 사용된다.const &#123; gql &#125; = require('apollo-server');const typeDefs = gql` union Result = Book | Author type Book &#123; title: String &#125; type Author &#123; name: String &#125; type Query &#123; search: [Result] &#125;`; 입력 타입 Input Types 지금까지는 열거형 타입이나 문자열과 같은 스칼라 값을 인자로 필드에 전달하는 방법에 대해서만 설명했다. 하지만 복잡한 객체도 쉽게 전달할 수 있다. 이는 뮤테이션에서 특히 유용하다. 뮤테이션은 생성될 전체 객체를 전달하고자 할 수 있다. GraphQL 스키마 언어에서 입력 타입은 일반 객체 타입과 같지만, type 대신 input 을 사용한다.(통신 메소드같은 느낌) 1234input ReviewInput &#123; stars: Int! commentary: String&#125; 뮤테이션에서 입력 객체 타입을 사용하는 방법. 1234567891011121314151617181920212223mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125;# VARIABLES&#123; &quot;ep&quot;: &quot;JEDI&quot;, &quot;review&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125;&#125;#######################################&#123; &quot;data&quot;: &#123; &quot;createReview&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125; &#125;&#125; 입력 객체 타입의 입력란은 입력 객체 타입을 참조할 수 있지만, 입력 및 출력 타입을 스키마에 혼합할 수는 없다.또한 필드에 인자를 가질 수 없다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"GraphQL","slug":"Develop/GraphQL","permalink":"https://hyeok999.github.io/categories/Develop/GraphQL/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://hyeok999.github.io/tags/GraphQL/"},{"name":"Schema","slug":"Schema","permalink":"https://hyeok999.github.io/tags/Schema/"},{"name":"Type","slug":"Type","permalink":"https://hyeok999.github.io/tags/Type/"}]},{"title":"GraphQL Query, Mutation","slug":"GraphQL-FRONT","date":"2020-01-24T03:33:29.000Z","updated":"2020-01-24T07:51:57.050Z","comments":true,"path":"2020/01/24/GraphQL-FRONT/","link":"","permalink":"https://hyeok999.github.io/2020/01/24/GraphQL-FRONT/","excerpt":"","text":"Graph QL - QUERY , MUTATION - QUERY , MUTATION 필드 Fields 인자 Arguments 별칭 Aliases 프래그먼트 Fragments 프래그먼트 내에서 변수 사용하기 Using variables inside fragments 작업 이름 Operation name 변수 Variables 변수 정의 Variable definitions 변수 기본값 Default variables 지시어 Directives 뮤테이션 Mutations 뮤테이션의 다중 필드 Multiple fields in mutations 인라인 프래그먼트 Inline Fragments 메타 필드 Meta fields QUERY , MUTATION 서버에 쿼리하는 방법들을 소개하는 기술서. 모든 예제는 GraphQL 공식홈페이지를 참조하였다. 모든 예제의 ###을 구분으로 위는 쿼리 요청 , 아래는 쿼리 응답 필드 Fields 객체에 대한 특정 필드를 요청하기. GraphQL 쿼리는 연관된 객체와 필드를 탐색 할 수 있으므로 클라이언트는 기존 REST 구조처럼 여러번 요청을 수행하는 대신 한번의 요청으로 많은 데이터를 가져올 수 있다. GraphQL에서 쿼리 내부의 주석으로 # 을 이용할 수 있다. 12345678910111213&#123; hero &#123; name &#125;&#125;##############&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125; &#125;&#125; 인자 Arguments 필드에 인자를 전달하는 기능을 추가하여, 훨씬 다양한 일을 할 수 있다. REST와 같은 시스템에서는 요청에 쿼리 파라미터와 URL 세그먼트같은 단일 인자들만 전달할 수 있다. 하지만, GraphQL에서는 모든 필드와 중첩된 객체가 인자를 가질 수 있으므로 GraphQL은 여러번의 API fetch를 완벽하게 대체할 수 있다. 필드에 인자를 전달하면, 모든 클라이언트에서 개별적으로 처리하는 대신 서버에서 데이터 변환을 한 번만 구현할 수도 있다. 12345678910111213141516&#123; human(id: &quot;1000&quot;) &#123; name height # height(unit:METER) &#125;&#125;###########&#123; &quot;data&quot;: &#123; &quot;human&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot;, &quot;height&quot;: 1.72 &#125; &#125;&#125; 별칭 Aliases 중복된 필드의 이름을 방지하고자 할 때 사용. 한 요청에 서로 다른 인자를 통해 결과를 얻고자 할 때. 한 요청에 같은 이름의 필드가 반복될 때 12345678910111213141516171819&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125;####################&#123; &quot;data&quot;: &#123; &quot;empireHero&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125;, &quot;jediHero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125; &#125;&#125; 위 예제에서 두 hero 필드는 서로 충돌하지만, 서로 다른 이름의 별칭을 지정할 수 있으므로 한 요청에서 두 결과를 모두 얻을 수 있다. 프래그먼트 Fragments 재사용 가능한 필드를 정의 프래그먼트를 사용하면 필드셋을 구성한 다음 필요한 쿼리에 포함시킬 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#123; leftComparison: hero(episode: EMPIRE) &#123; ...comparisonFields &#125; rightComparison: hero(episode: JEDI) &#123; ...comparisonFields &#125;&#125;fragment comparisonFields on Character &#123; name appearsIn friends &#123; name &#125;&#125;#######################&#123; &quot;data&quot;: &#123; &quot;leftComparison&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot;, &quot;appearsIn&quot;: [ &quot;NEWHOPE&quot;, &quot;EMPIRE&quot;, &quot;JEDI&quot; ], &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125;, &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125;, &#123; &quot;name&quot;: &quot;C-3PO&quot; &#125;, &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125; ] &#125;, &quot;rightComparison&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;appearsIn&quot;: [ &quot;NEWHOPE&quot;, &quot;EMPIRE&quot;, &quot;JEDI&quot; ], &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125;, &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125; ] &#125; &#125;&#125; 필드가 반복될 경우 위 쿼리가 꽤 반복될 것을 알 수 있다. 프래그먼트 개념은 복잡한 응용 프로그램의 데이터 요구사항을 작은 단위로 분할하는데 사용된다. 특히 청크가 다른 여러 UI 구성 요소를 하나의 초기 데이터 fetch로 통합해야하는 경우에 많이 사용된다. 프래그먼트 내에서 변수 사용하기 Using variables inside fragments 변수($로 선언된)를 프래그먼트에서 사용할 수 있다. 쿼리나 뮤테이션에 선언된 변수는 프래그먼트에 접근할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071query HeroComparison($first: Int = 3) &#123; leftComparison: hero(episode: EMPIRE) &#123; ...comparisonFields &#125; rightComparison: hero(episode: JEDI) &#123; ...comparisonFields &#125;&#125;fragment comparisonFields on Character &#123; name friendsConnection(first: $first) &#123; totalCount edges &#123; node &#123; name &#125; &#125; &#125;&#125;####################&#123; &quot;data&quot;: &#123; &quot;leftComparison&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot;, &quot;friendsConnection&quot;: &#123; &quot;totalCount&quot;: 4, &quot;edges&quot;: [ &#123; &quot;node&quot;: &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125; &#125;, &#123; &quot;node&quot;: &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125; &#125;, &#123; &quot;node&quot;: &#123; &quot;name&quot;: &quot;C-3PO&quot; &#125; &#125; ] &#125; &#125;, &quot;rightComparison&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;friendsConnection&quot;: &#123; &quot;totalCount&quot;: 3, &quot;edges&quot;: [ &#123; &quot;node&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125; &#125;, &#123; &quot;node&quot;: &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125; &#125;, &#123; &quot;node&quot;: &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125; &#125; ] &#125; &#125; &#125;&#125; 작업 이름 Operation name 좋아하는 프로그래밍 언어의 함수명처럼 쿼리의 작업명을 지정할 수 있다. 지금까지는 query 키워드와 query 이름을 모두 생략 한 단축 문법을 사용했지만, 실제 애플리케이션에서는 코드를 덜 헷갈리게 작성하는 것이 좋다. 다음은 query 를 작업 타입, HeroNameAndFriends 를 작업 이름 으로한 예제이다. 123456789101112131415161718192021222324252627query HeroNameAndFriends &#123; hero &#123; name friends &#123; name &#125; &#125;&#125;########################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125;, &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125; ] &#125; &#125;&#125; 작업 타입 은 쿼리(query), 뮤테이션(mutation), 구독(subscription) 이 될 수 있으며, 어떤 작업의 타입인지를 기술한다. 작업 이름 은 의미있고 명시적인 작업의 이름이다. 디버깅이나 서버 측에서 로깅하는데에 매우 유용 할 수 있다. 네트워크 로그나 GraphQL 서버에 문제가 발생하면 내용을 확인하는 대신 코드에서 쿼리 이름을 찾아내는 것이 더 쉽다. 예를 들어, JavaScript에서는 쉽게 익명 함수를 사용할 수 있지만, 함수에 이름을 부여하면 코드를 디버깅하고 호출되었을 때 로깅하는 것이 더 쉽다. 같은 방식으로, GraphQL 쿼리와 뮤테이션 이름과 프래그먼트 이름은 서버 측에서 Graph 요청을 식별하는데 유용한 디버깅 도구가 될 수 있다. 변수 Variables 클라이언트 측 코드는 쿼리 문자열을 런타임에 동적으로 조작하고 이를 GraphQL의 특정한 포맷으로 직렬화해야하기 때문에 이러한 동적 인자를 쿼리 문자열에 직접 전달하는 것은 좋은 방법이 아니다. 대신 GraphQL은 동적 값을 쿼리에서 없애고, 이를 별도로 전달하는 방법을 제공한다. 이러한 값을 변수 라고 한다. 변수를 사용하기 위해서는 다음 세 가지 작업을 해야 한다. 쿼리안의 정적 값을 $variableName 으로 변경. $variableName 을 쿼리에서 받는 변수로 선언. 별도의 전송규약(일반적으로는 JSON) 변수에 variableName: value 을 전달. 다음과 같은 형태를 띄게된다. 12345678910111213141516171819202122232425262728293031query HeroNameAndFriends($episode: Episode) &#123; hero(episode: $episode) &#123; # episode : &quot;JEDI&quot;가 된다. name friends &#123; name &#125; &#125;&#125;# VARIABLES&#123; &quot;episode&quot;: &quot;JEDI&quot;&#125;#################################################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125;, &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125; ] &#125; &#125;&#125; 이제 클라이언트 코드에서 완전히 새로운 쿼리를 작성하지 않고 간단하게 다른 변수를 전달할 수 있다. 이는 일반적으로 쿼리의 어떤 인자가 동적인지를 나타내는 좋은 방법이기도하다. 사용자가 제공한 값으로 $을 사용해서는 안된다. 변수 정의 Variable definitions 변수 정의는 위 쿼리에서 ($episode: Episode) 정적타입 언어의 함수에 대한 인자 정의와 동일하다. $ 접두사가 붙은 모든 변수를 나열하고 그 뒤에 타입(이 경우 Episode)이 온다. 선언된 모든 변수는 스칼라, 열거형, input object type이어야 한다. 복잡한 객체를 필드에 전달하려면 서버에서 일치하는 입력 타입을 알아야한다. 변수 정의는 옵셔널이거나 필수일 수 있다. 위의 경우 Episode 타입 옆에 ! 가 없으므로 옵셔널이다. 그러나 변수를 전달할 필드에 null이 아닌 인자가 요구된다면 변수가 필요하게 된다. 변수 기본값 Default variables 타입 선언 다음에 기본값을 명시하여 쿼리의 변수에 기본값을 할당할 수도 있다. 12345678query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) &#123; hero(episode: $episode) &#123; name friends &#123; name &#125; &#125;&#125; 모든 변수에 기본값이 제공되면 변수를 전달하지 않고도 쿼리를 호출할 수 있다. 변수가 전달되면 변수는 기본값을 덮어씌운다. 지시어 Directives 변수를 사용하여 쿼리의 구조와 형태을 동적으로 변경하는 방법이 필요할 수도 있다. 지시어는 프로그래밍 언어로 가정할 경우, 조건문에 해당된다. 이러한 구성 요소에 대한 쿼리를 작성해 보자. 123456789101112131415161718192021query Hero($episode: Episode, $withFriends: Boolean!) &#123; hero(episode: $episode) &#123; name friends @include(if: $withFriends) &#123; # $withFriends가 flase 이기 때문에 name 미출력 name &#125; &#125;&#125;# VARIABLES&#123; &quot;episode&quot;: &quot;JEDI&quot;, &quot;withFriends&quot;: false # false&#125;####################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125; &#125;&#125; 지시어 라는 GraphQL의 새로운 기능을 사용해야 한다. 지시어는 필드나 프래그먼트 안에 삽입될 수 있으며 서버가 원하는 방식으로 쿼리 실행에 영향을 줄 수 있다. 코어 GraphQL 사양에는 두 가지 지시어가 포함되어 있으며, 이는 GraphQL 서버에서 지원해야 한다. @include(if: Boolean): 인자가 true 인 경우에만 이 필드를 결과에 포함. @skip(if: Boolean) 인자가 true 이면 이 필드를 건너뜀. 지시어는 쿼리의 필드를 추가하고 제거하기 위해 문자열을 조작을 해야하는 상황을 피하는데 유용할 수 있다. 서버에서는 새로운 지시어를 정의하여 실험적인 기능을 추가할 수도 있다. 뮤테이션 Mutations CUD , CREATE, UPDATE, DELETE - 데이터의 변경 REST에서는 모든 요청이 서버에 몇 가지 사이드이펙트을 일으킬 수 있지만 규칙에 따라 데이터 수정을 위해 GET 요청을 사용하지 않는다. GraphQL도 마찬가지이다. 기술적으로는 어떠한 쿼리든 데이터를 수정할 수도 있다. 하지만 변경을 발생시키는 작업이 명시적으로 뮤테이션를 통해 전송되어야 한다는 규칙을 정하는 것이 좋다. 쿼리와 마찬가지로 뮤테이션 필드가 객체 타입을 반환하면 중첩 필드를 요청할 수 있다. 이는 변경된 객체의 새로운 상태를 가져오는 데에 유용하다. 1234567891011121314151617181920212223mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125;# VARIABLES&#123; &quot;ep&quot;: &quot;JEDI&quot;, &quot;review&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125;&#125;################################&#123; &quot;data&quot;: &#123; &quot;createReview&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125; &#125;&#125; createReview 필드가 새로 생성된 리뷰의 stars 와 commentary 필드를 반환한다. 이는 하나의 요청으로 필드의 새 값을 변경하고 쿼리할 수 있기 때문에 기존 데이터를 변경하는 경우(예: 필드를 증가시킬 때) 특히 유용하다. 이 예제에서 전달한 review 변수는 스칼라값이 아니다. 인자로 전달될 수 있는 특별한 종류의 객체 타입인 input object type 이다. 뮤테이션의 다중 필드 Multiple fields in mutations 뮤테이션은 쿼리와 마찬가지로 여러 필드를 포함할 수 있다. 쿼리와 뮤테이션 사이에 중요한 차이점이 있습니다. 쿼리 필드는 병렬로 실행되지만 뮤테이션 필드는 하나씩 차례대로 실행된다. 즉, 하나의 요청에서 두 개의 incrementCredits 뮤테이션를 보내면 첫 번째는 두 번째 요청 전에 완료되는 것이 보장된다. 인라인 프래그먼트 Inline Fragments 다른 여러 타입 시스템과 마찬가지로 GraphQL 스키마에는 인터페이스와 유니온 타입을 정의하는 기능이 포함되어 있다. 인터페이스나 유니언 타입을 반환하는 필드를 쿼리하는 경우, 인라인 프래그먼트 을 사용해야한다. 12345678910111213141516171819202122232425query HeroForEpisode($ep: Episode!) &#123; hero(episode: $ep) &#123; name # primaryFunction - 이렇게 사용하면 오류 ... on Droid &#123; primaryFunction &#125; ... on Human &#123; height &#125; &#125;&#125;# VARIABLES&#123; &quot;ep&quot;: &quot;JEDI&quot;&#125;###############################################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;primaryFunction&quot;: &quot;Astromech&quot; &#125; &#125;&#125; 이 쿼리에서 hero 필드는 Character 를 반환하는데, episode 인자에 따라서 Human이나 Droid 중 하나일 수 있다. 필드를 직접 선택할 때에는 name 과 같이 Character 인터페이스에 존재하는 필드만 요청할 수 있다. 특정한 타입의 필드를 요청하려면 타입 조건과 함께 인라인 프래그먼트 을 사용해야한다. 첫 번째 프래그먼트는 ... on Droid 라는 레이블이 붙어있기 때문에 primaryFunction 필드는 hero 에서 반환된 Character 가 Droid 타입인 경우에만 실행된다. Human 타입의 height 필드도 마찬가지이다. 메타 필드 Meta fields GraphQL 서비스에서 리턴될 타입을 모르는 상황이 발생하면 클라이언트에서 해당 데이터를 처리하는 방법을 결정할 방법이 필요하다. GraphQL을 사용하면 쿼리의 어느 지점에서나 메타 필드인 __typename 을 요청하여 그 시점에서 객체 타입의 이름을 얻을 수 있다. 1234567891011121314151617181920212223242526272829303132333435# union SearchResult = Human | Droid | Starship&#123; search(text: &quot;an&quot;) &#123; __typename ... on Human &#123; name &#125; ... on Droid &#123; name &#125; ... on Starship &#123; name &#125; &#125;&#125;##########################&#123; &quot;data&quot;: &#123; &quot;search&quot;: [ &#123; &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Han Solo&quot; &#125;, &#123; &quot;__typename&quot;: &quot;Human&quot;, &quot;name&quot;: &quot;Leia Organa&quot; &#125;, &#123; &quot;__typename&quot;: &quot;Starship&quot;, &quot;name&quot;: &quot;TIE Advanced x1&quot; &#125; ] &#125;&#125; 위 쿼리에서 search 는 3 가지 중 하나인 유니언 타입을 반환한다. __typename 필드가 없으면 클라이언트가 다른 타입을 구별하는 것은 불가능할 것이다. GraphQL 서비스는 몇 가지 메타 필드를 제공하며, 나머지는 Introspection(검사) 시스템을 노출하는 데 사용된다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"GraphQL","slug":"Develop/GraphQL","permalink":"https://hyeok999.github.io/categories/Develop/GraphQL/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://hyeok999.github.io/tags/GraphQL/"},{"name":"Query","slug":"Query","permalink":"https://hyeok999.github.io/tags/Query/"},{"name":"Mutation","slug":"Mutation","permalink":"https://hyeok999.github.io/tags/Mutation/"}]},{"title":"커스텀 Hooks 만들기","slug":"react-velo-19","date":"2020-01-23T07:53:41.000Z","updated":"2020-01-23T07:58:34.730Z","comments":true,"path":"2020/01/23/react-velo-19/","link":"","permalink":"https://hyeok999.github.io/2020/01/23/react-velo-19/","excerpt":"","text":"React with Velopert - 19 - 커스텀 Hooks 만들기 폴더 및 파일 생성 커스텀 Hook 만들기 - useInputs.js useCallback 복습 커스텀 Hook 불러오기 - App.js 커스텀 Hook에서 Reducer 사용하기 - useInputs.js Chap 19. 커스텀 Hooks 만들기커스텀 Hooks 만들기 컴포넌트를 만들다보면, 반복되는 로직이 자주 발생한다. 예를 들어서 input 을 관리하는 코드는 관리 할 때마다 꽤나 비슷한 코드가 반복되죠. 이번에는 그러한 상황에 커스텀 Hooks 를 만들어서 반복되는 로직을 쉽게 재사용하는 방법을 알아보자. ####폴더 및 파일 생성 src/hooks 디렉터리를 만들고, 그 안에 useInputs.js 라는 파일을 만들자. 커스텀 Hooks 를 만들 때, 보통 use 라는 키워드로 시작하는 파일을 만들고 그 안에 함수를 작성한다. 커스텀 Hooks 를 만드는 방법은 간단하다. 그냥, 그 안에서 useState, useEffect, useReducer, useCallback 등 Hooks 를 사용하여 원하는 기능을 구현해주고, 컴포넌트에서 사용하고 싶은 값들을 반환해주면 된다. 커스텀 Hook 만들기 - useInputs.js 1234567891011121314import &#123; useState, useCallback &#125; from 'react';function useInputs(initialForm) &#123; const [form, setForm] = useState(initialForm); // change const onChange = useCallback(e =&gt; &#123; const &#123; name, value &#125; = e.target; setForm(form =&gt; (&#123; ...form, [name]: value &#125;)); &#125;, []); const reset = useCallback(() =&gt; setForm(initialForm), [initialForm]); return [form, onChange, reset];&#125;export default useInputs; useCallback 복습useCallback 은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다. 12useCallback( fn , [deps] )useCallback( () =&gt; &#123;&#125;,[deps] ) useCallback 은 첫번째 파라미터로 함수를(호출X) 받고, 두번쨰 파라미터로 의존성 배열을 받는다. 커스텀 Hook 불러오기 - App.js useReducer쪽에서 사용하는inputs를 없애고 이에 관련된 작업을useInputs` 를 대체해주자. 새로운 항목을 추가 할 때 input 값을 초기화해야 하므로 데이터 등록 후 reset() 을 호출해야한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import React, &#123; useRef, useReducer, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';import useInputs from './src/hooks/useInputs';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; // inputs: &#123; // username: '', // email: '' // &#125;, // 제거 users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; switch (action.type) &#123; // case 'CHANGE_INPUT': // return &#123; // ...state, // inputs: &#123; // ...state.inputs, // [action.name]: action.value // &#125; // &#125;; // 제거 case 'CREATE_USER' : return &#123; inputs: initialState.inputs, users: state.users.concat(action.user) &#125;; case 'TOGGLE_USER' : return &#123; ...state, users: state.users.map(user =&gt; user.id === action.id ? &#123;...user, active: !user.active&#125; : user ) &#125;; case 'REMOVE_USER' : return &#123; ...state, users : state.users.filter(user =&gt; user.id !== action.id) &#125;; default: return state; &#125;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const nextId = useRef(4); const &#123; users &#125; = state; const [&#123; username, email&#125;, onChange, reset] = useInputs(&#123; username: '', email: '' &#125;); // 추가 // const &#123; username, email &#125; = state.inputs; // const onChange = useCallback(e =&gt; &#123; // const &#123; name, value &#125; = e.target; // dispatch(&#123; // type: 'CHANGE_INPUT', // name, // value // &#125;); // &#125;, []); //제거 const onCreate = useCallback(() =&gt; &#123; dispatch(&#123; type: 'CREATE_USER', user: &#123; id: nextId.current, username, email &#125; &#125;); reset(); // 추가 nextId.current += 1; &#125;, [username, email]); const onToggle = useCallback(id =&gt; &#123; dispatch(&#123; type: 'TOGGLE_USER', id &#125;); &#125;, []); const onRemove = useCallback(id =&gt; &#123; dispatch(&#123; type: 'REMOVE_USER', id &#125;); &#125;, []); const count = useMemo(() =&gt; countActiveUsers(users), [users]); return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onToggle=&#123;onToggle&#125; onRemove=&#123;onRemove&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App; 커스텀 Hook에서 Reducer 사용하기 - useInputs.js 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; useReducer, useCallback &#125; from 'react'const reducer = (state, action) =&gt; &#123; switch(action.type) &#123; case 'CHANGE_INPUT' : return &#123; ...state, [action.name] : action.value &#125; case 'RESET' : return Object.keys(state).reduce((acc,current) =&gt; &#123; acc[current] = ''; return acc; &#125; ,&#123;&#125;); default : return state; &#125;&#125;const useInputs = (initForm) =&gt; &#123; const [form , dispatch] = useReducer(reducer, initForm); const onChange = useCallback(e =&gt; &#123; const &#123;name, value&#125; = e.target; dispatch(&#123; type : 'CHANGE_INPUT', name, value &#125;) &#125;, []); const reset = useCallback(() =&gt; &#123; dispatch(&#123; type : 'RESET' &#125;) &#125;, []); return [form, onChange, reset]&#125;export default useInputs;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"useReducer 를 사용하여 상태 업데이트 로직 분리하기","slug":"react-velo-18","date":"2020-01-23T03:30:17.000Z","updated":"2020-01-23T07:54:27.335Z","comments":true,"path":"2020/01/23/react-velo-18/","link":"","permalink":"https://hyeok999.github.io/2020/01/23/react-velo-18/","excerpt":"","text":"React with Velopert - 18 - useReducer 이해하기 reducer 란? useReducer 사용 방법 useReducer 파라미터 연습 : Counter.js App 컴포넌트를 useReducer로 구현하기 ( App.js ) 초기값 설정, useReducer 변수(비구조화) 할당, rudecer 만들기 onChange 구현 ( App.js ) onCreate 구현 ( App.js ) onToggle 과 onRemove 구현 ( App.js ) 활성 사용자 수 구현 ( App.js ) useReducer vs useState Chap 18. useReducer 를 사용하여 상태 업데이트 로직 분리하기useReducer 이해하기 이전에 만든 사용자 리스트 기능에서의 주요 상태 업데이트 로직은 App 컴포넌트 내부에서 이루어졌다. 상태를 업데이트 할 때에는 useState를 사용해서 새로운 상태를 설정하고, 상태를 관리하게 될 때는 useState를 사용하는 것 말고는 다른 방법이 없었다. 여기서 상태를 관리하는 추가적인 방법이 바로 useReducer이다. 이 Hook 함수를 사용하면 컴포넌트의 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있다. 상태 업데이트 로직을 컴포넌트 바깥에 작성 할 수도 있고, 심지어 다른 파일에 작성 후 불러와서 사용 할 수도 있다. reducer 란? reducer 는 현재 상태와 Action 객체를 파라미터로 받아와서 새로운 상태를 반환해주는 함수. 12345function reducer(state, action) &#123; // 새로운 상태를 만드는 로직 // const nextState = ... return nextState;&#125; reducer 에서 반환하는 상태는 곧 컴포넌트가 지닐 새로운 상태가 된다. 여기서 action 은 업데이트를 위한 정보를 가지고 있다.주로 type 값을 지닌 객체 형태로 사용하지만, 꼭 따라야 할 규칙은 따로 없다. action의 객체의 형태는 자유이다. type값을 대문자와 _로 구성하는 케이스가 존재하긴 하지만, 필수는 아니다. 다음은 action의 예시이다. 1234567891011121314151617181920212223// 카운터에 1을 더하는 액션&#123; type: 'INCREMENT'&#125;// 카운터에 1을 빼는 액션&#123; type: 'DECREMENT'&#125;// input 값을 바꾸는 액션&#123; type: 'CHANGE_INPUT', key: 'email', value: 'tester@react.com'&#125;// 새 할 일을 등록하는 액션&#123; type: 'ADD_TODO', todo: &#123; id: 1, text: 'useReducer 배우기', done: false, &#125;&#125; useReducer 사용 방법 1const [state, dispatch] = useReducer(reducer, initialState); state : 앞으로 컴포넌트에서 사용 할 수 있는 상태 dispatch는 action을 발생시키는 함수 이 함수는 다음과 같이 사용할 수 있다. 1dispatch(&#123; type: 'INCREMENT' &#125;) useReducer 파라미터 첫번째 파라미터는 reducer 함수 두번째 파라미터는 초기 상태 연습 : Counter.js 먼저 바로 App.js에 적용하지 않고 Counter.js 에 적용해보자. 기존의 Counter.js 1234567891011121314151617181920212223import React, &#123;useState&#125; from 'react'const Counter = (props) =&gt; &#123; const [number, setNumber] = useState(0); const onIncrease = () =&gt; &#123; setNumber(preveNumber =&gt; preveNumber + 1); &#125; const onDecrease = () =&gt; &#123; setNumber(preveNumber =&gt; preveNumber - 1); &#125; return ( &lt;div&gt; &lt;button onClick=&#123;onIncrease&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onDecrease&#125;&gt;-1&lt;/button&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;export default Counter; Reducer를 적용한 Counter.js 12345678910111213141516171819202122232425262728293031323334import React, &#123; useReducer &#125; from 'react';function reducer(state, action) &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;function Counter() &#123; const [number, dispatch] = useReducer(reducer, 0); const onIncrease = () =&gt; &#123; dispatch(&#123; type: 'INCREMENT' &#125;); &#125;; const onDecrease = () =&gt; &#123; dispatch(&#123; type: 'DECREMENT' &#125;); &#125;; return ( &lt;div&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrease&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onDecrease&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; );&#125;export default Counter; App 컴포넌트를 useReducer로 구현하기 ( App.js ) App 컴포넌트에 있던 상태 업데이트 로직들을 useState 가 아닌 useReducer 를 사용하여 구현해보자. 우선, App 에서 사용 할 초기 상태를 컴포넌트 바깥으로 분리해주고, App 내부의 로직들을 모두 제거해야한다. 1. 초기값 설정, useReducer 변수(비구조화) 할당, rudecer 만들기. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; useReducer, useRef, useState, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; inputs: &#123; username: '', email: '' &#125;, users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; return state;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const &#123; users &#125; = state; const &#123; username, email &#125; = state.inputs; return ( &lt;&gt; &lt;CreateUser /&gt; &lt;UserList users=&#123;[]&#125; /&gt; &lt;div&gt;활성사용자 수 : 0&lt;/div&gt; &lt;/&gt; );&#125;export default App; 2. onChange 구현 ( App.js ) App() 함수내부에 onChange이벤트와 action을 작성한다. 변화 되는 value 값과 선택된 input 박스 name을 비구조화 할당하여 변수로 만들고 dispatch를 통해 리듀서에게 전달한다. 리듀서에서는 CHANGE_INPUT 이라는 action 객체를 사용하여 inputs 상태를 업데이트해주었다. reducer 함수에서 새로운 상태를 만들 때에는 불변성을 지켜주어야 하기 때문에 위 형태와 같이 spread 연산자를 사용해주었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React, &#123; useRef, useReducer, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; inputs: &#123; username: '', email: '' &#125;, users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; // 추가 switch (action.type) &#123; case 'CHANGE_INPUT': return &#123; ...state, inputs: &#123; ...state.inputs, [action.name]: action.value &#125; &#125;; default: return state; &#125;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const &#123; users &#125; = state; const &#123; username, email &#125; = state.inputs; const onChange = useCallback(e =&gt; &#123; // 추가 const &#123; name, value &#125; = e.target; dispatch(&#123; type: 'CHANGE_INPUT', name, value &#125;); &#125;, []); return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; /&gt; // 추가 &lt;UserList users=&#123;users&#125; /&gt; &lt;div&gt;활성사용자 수 : 0&lt;/div&gt; &lt;/&gt; );&#125;export default App; 3. onCreate 구현 ( App.js ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import React, &#123; useRef, useReducer, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; inputs: &#123; username: '', email: '' &#125;, users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'CHANGE_INPUT': return &#123; ...state, inputs: &#123; ...state.inputs, [action.name]: action.value &#125; &#125;; case 'CREATE_USER': // 추가 return &#123; inputs: initialState.inputs, users: state.users.concat(action.user) &#125;; default: return state; &#125;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const nextId = useRef(4); const &#123; users &#125; = state; const &#123; username, email &#125; = state.inputs; const onChange = useCallback(e =&gt; &#123; const &#123; name, value &#125; = e.target; dispatch(&#123; type: 'CHANGE_INPUT', name, value &#125;); &#125;, []); const onCreate = useCallback(() =&gt; &#123; // cㅜ가 dispatch(&#123; type: 'CREATE_USER', user: &#123; id: nextId.current, username, email &#125; &#125;); nextId.current += 1; &#125;, [username, email]); return ( &lt;&gt; &lt;CreateUser // 추가 username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; /&gt; &lt;div&gt;활성사용자 수 : 0&lt;/div&gt; &lt;/&gt; );&#125;export default App; 여기까지 진행했으면 수정 및 데이터 등록이 잘 될 것이다. 4. onToggle 과 onRemove 구현 ( App.js ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import React, &#123; useRef, useReducer, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; inputs: &#123; username: '', email: '' &#125;, users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'CHANGE_INPUT': return &#123; ...state, inputs: &#123; ...state.inputs, [action.name]: action.value &#125; &#125;; case 'CREATE_USER': return &#123; inputs: initialState.inputs, users: state.users.concat(action.user) &#125;; case 'TOGGLE_USER': // 추가 return &#123; ...state, users: state.users.map(user =&gt; user.id === action.id ? &#123; ...user, active: !user.active &#125; : user ) &#125;; case 'REMOVE_USER': // 추가 return &#123; ...state, users: state.users.filter(user =&gt; user.id !== action.id) &#125;; default: return state; &#125;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const nextId = useRef(4); // 추가 const &#123; users &#125; = state; const &#123; username, email &#125; = state.inputs; const onChange = useCallback(e =&gt; &#123; const &#123; name, value &#125; = e.target; dispatch(&#123; type: 'CHANGE_INPUT', name, value &#125;); &#125;, []); const onCreate = useCallback(() =&gt; &#123; dispatch(&#123; type: 'CREATE_USER', user: &#123; id: nextId.current, username, email &#125; &#125;); nextId.current += 1; &#125;, [username, email]); const onToggle = useCallback(id =&gt; &#123; // 추가 dispatch(&#123; type: 'TOGGLE_USER', id &#125;); &#125;, []); const onRemove = useCallback(id =&gt; &#123; // 추가 dispatch(&#123; type: 'REMOVE_USER', id &#125;); &#125;, []); return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onToggle=&#123;onToggle&#125; onRemove=&#123;onRemove&#125; /&gt; // 추가 &lt;div&gt;활성사용자 수 : 0&lt;/div&gt; &lt;/&gt; );&#125;export default App; 5. 활성 사용자 수 구현 ( App.js ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import React, &#123; useRef, useReducer, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;const initialState = &#123; inputs: &#123; username: '', email: '' &#125;, users: [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'CHANGE_INPUT': return &#123; ...state, inputs: &#123; ...state.inputs, [action.name]: action.value &#125; &#125;; case 'CREATE_USER': return &#123; inputs: initialState.inputs, users: state.users.concat(action.user) &#125;; case 'TOGGLE_USER': return &#123; ...state, users: state.users.map(user =&gt; user.id === action.id ? &#123; ...user, active: !user.active &#125; : user ) &#125;; case 'REMOVE_USER': return &#123; ...state, users: state.users.filter(user =&gt; user.id !== action.id) &#125;; default: return state; &#125;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); const nextId = useRef(4); const &#123; users &#125; = state; const &#123; username, email &#125; = state.inputs; const onChange = useCallback(e =&gt; &#123; const &#123; name, value &#125; = e.target; dispatch(&#123; type: 'CHANGE_INPUT', name, value &#125;); &#125;, []); const onCreate = useCallback(() =&gt; &#123; dispatch(&#123; type: 'CREATE_USER', user: &#123; id: nextId.current, username, email &#125; &#125;); nextId.current += 1; &#125;, [username, email]); const onToggle = useCallback(id =&gt; &#123; dispatch(&#123; type: 'TOGGLE_USER', id &#125;); &#125;, []); const onRemove = useCallback(id =&gt; &#123; dispatch(&#123; type: 'REMOVE_USER', id &#125;); &#125;, []); const count = useMemo(() =&gt; countActiveUsers(users), [users]); // 추가 return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onToggle=&#123;onToggle&#125; onRemove=&#123;onRemove&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; // 변경 &lt;/&gt; );&#125;export default App; 여기까지 완료 시 모든 기능들이 useReducer 를 사용하여 구현되었다. useReducer vs useState 어떨 때 useReducer 를 쓰고 어떨 때 useState 를 써야 하는가? 정해진 답은 없다. 어떤 것을 사용하든 상황에 따라 불편할 때 도 있고 편할 때도 있다. 예를 들어서 컴포넌트에서 관리하는 값이 딱 하나고, 그 값이 단순한 숫자, 문자열 또는 boolean 값이라면 확실히 useState 로 관리하는게 편할 것이다. 1const [value, setValue] = useState(true); 하지만, 만약에 컴포넌트에서 관리하는 값이 여러개가 되어서 상태의 구조가 복잡해진다면 useReducer로 관리하는 것이 편해질 수도 있다. 따라서 useState, useReducer 를 자주 사용해보고 맘에 드는 방식을 선택한다. setter(setState) 를 한 함수에서 여러번 사용해야 하는 일이 발생한다면 그 때부터 useReducer 를 쓸까? 에 대한 고민을 시작해보 것도 좋을 것이다. 123456// setter를 여러번 이용한 예제setUsers(users =&gt; users.concat(user));setInputs(&#123; username: '', email: ''&#125;); useReducer 를 썼을때 편해질 것 같으면 useReducer 를 쓰고, 딱히 그럴것같지 않으면 useState 를 유지하면 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React.memo 를 사용한 컴포넌트 리렌더링 방지","slug":"react-velo-17","date":"2020-01-22T01:19:45.000Z","updated":"2020-01-23T07:55:37.328Z","comments":true,"path":"2020/01/22/react-velo-17/","link":"","permalink":"https://hyeok999.github.io/2020/01/22/react-velo-17/","excerpt":"","text":"React with Velopert - 17 - React.memo 를 사용한 컴포넌트 리렌더링 방지 CreateUser.js UserList.js 함수형 업데이트 기본 파라미터 방식 함수형 업데이트 방식 App.js Chap 17. React.memo 를 사용한 컴포넌트 리렌더링 방지 컴포넌트의 props 가 바뀌지 않았다면, 리렌더링을 방지하여 컴포넌트의 리렌더링 성능 최적화를 해줄 수 있는 React.memo 라는 함수에 대해서 알아본다. React.memo를 사용하면 컴포넌트에서 리렌더링이 필요한 상황에서만 리렌더링을 하도록 설정해줄 수 있다. 사용법은 굉장히 쉽다. 그냥, 감싸주면 된다. CreateUser.js 1234567891011121314151617181920212223import React from 'react';const CreateUser = (&#123; username, email, onChange, onCreate &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;input name=\"username\" placeholder=\"계정명\" onChange=&#123;onChange&#125; value=&#123;username&#125; /&gt; &lt;input name=\"email\" placeholder=\"이메일\" onChange=&#123;onChange&#125; value=&#123;email&#125; /&gt; &lt;button onClick=&#123;onCreate&#125;&gt;등록&lt;/button&gt; &lt;/div&gt; );&#125;;export default React.memo(CreateUser); // 추가 UserList.js 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; useEffect &#125; from 'react';const User = React.memo(function User(&#123; user, onRemove, onToggle &#125;) &#123; // 추가 useEffect(() =&gt; &#123; console.log('user 값이 설정됨'); console.log(user); return () =&gt; &#123; console.log('user 가 바뀌기 전..'); console.log(user); &#125;; &#125;, [user]); return ( &lt;div&gt; &lt;b style=&#123;&#123; cursor: 'pointer', color: user.active ? 'green' : 'black' &#125;&#125; onClick = &#123;() =&gt; onToggle(user.id)&#125; &gt; &#123;user.username&#125; &lt;/b&gt; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; onRemove(user.id)&#125;&gt; 삭제 &lt;/button&gt; &lt;/div&gt; );&#125;);function UserList(&#123; users, onRemove, onToggle &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default React.Memo(UserList); // 추가 함수형 업데이트 여기까지 적용이 완료되면 input박스의 내용을 추가하거나 수정해도 UserList가 리렌더링 되지 않는다.(오직 Input박스만 리렌더링) 하지만, 추가적인 문제로는 User 중 하나라도 수정(user.active 변경)이 된다면 모든 User들이 리렌더링 되고 CreateUser도 리렌더링 된다는것이다. 왜 리렌더링이 될까? 그 이유는 아래처럼 useCallback을 사용할 때 2번째 파라미터로 넣어준 의존성 배열 deps 에 users 가 들어가 있기 때문이다. users 중 1개라도 변경이 된다면 onCreate, onToggle, onRemove 가 새로 만들어지므로 전부 리렌더링 되는 것이다. 1234567891011const onCreate = useCallback(() =&gt; &#123;...&#125;, [users, username, email]);const onRemove = useCallback(id =&gt; &#123; ...&#125;, [users]);const onToggle = useCallback(id =&gt; &#123; ...&#125;, [users]); 이 부분에서 사용할 수 있는 것이 바로 함수형 업데이트 이다. 예전(useState)를 잠깐 배웠을 때를 생각해보자. 기본 파라미터 방식 1234const [number, setNumber] = useState(0);const onIncrease = () =&gt; &#123; setNumber(number + 1); &#125;const onDecrease = () =&gt; &#123; setNumber(number - 1); &#125; 함수형 업데이트 방식 1234const [number, setNumber] = useState(0);const onIncrease = () =&gt; &#123; setNumber(prevNumber =&gt; prevNumber + 1); &#125;const onDecrease = () =&gt; &#123; setNumber(prevNumber =&gt; prevNumber - 1); &#125; 함수형 업데이트를 하게 되면, setUsers 에 등록하는 콜백함수의 파라미터에서 최신 users 를 참조 할 수 있기 때문에 deps 에 users 를 넣지 않아도 된다. ( onChange 의 경우엔 함수형 업데이트를 해도 영향은 가지 않는다 ). App.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import React, &#123; useRef, useState, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = useCallback(e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(inputs =&gt; (&#123; ...inputs, [name]: value &#125;)); &#125;, []); const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]); const nextId = useRef(4); const onCreate = useCallback(() =&gt; &#123; const user = &#123; id: nextId.current, username, email &#125;; setUsers(users =&gt; users.concat(user)); setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; &#125;, [username, email]); const onRemove = useCallback(id =&gt; &#123; // user.id 가 파라미터로 일치하지 않는 원소만 추출해서 새로운 배열을 만듬 // = user.id 가 id 인 것을 제거함 setUsers(users =&gt; users.filter(user =&gt; user.id !== id)); &#125;, []); const onToggle = useCallback(id =&gt; &#123; setUsers(users =&gt; users.map(user =&gt; user.id === id ? &#123; ...user, active: !user.active &#125; : user ) ); &#125;, []); const count = useMemo(() =&gt; countActiveUsers(users), [users]); return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App; 여기까지 완료하면, 해당 항목만 리렌더링 될 것이다. deps에 users를 넣었을 때는 users 값이 변경될 때 마다 함수가 재선언되어서 props가 변경되었다고 CreateUser 컴포넌트가 인지를 했기에 리렌더링이 되었었다. 하지만 함수형 업데이트를 사용할 경우 users의 최신값이 보존되기 때문에 deps엔 따로 안넣어도 되니 함수가 재선언되지 않고 CreateUser 컴포넌트가 props가 변경되었다고 인지를 못한다. UserList와 User 컴포넌트는 users가 변함을 인지하고 리렌더링 되는 것이다. 리액트 개발을 할 때, useCallback, useMemo, React.memo 는 컴포넌트의 성능을 실제로 개선할수있는 상황에서만 진행하자. 예를 들어서, User 컴포넌트에 b 와 button 에 onClick 으로 설정해준 함수들은, 해당 함수들을 useCallback 으로 재사용한다고 해서 리렌더링을 막을 수 있는것은 아니다. 추가적으로, 렌더링 최적화 하지 않을 컴포넌트에 React.memo 를 사용하는것은, 불필요한 props 비교만 하는 것이기 때문에 실제로 렌더링을 방지할수있는 상황이 있는 경우에만 사용하자. React.memo 에서 두번째 파라미터에 propsAreEqual 이라는 함수를 사용하여 특정 값들만 비교를 하는 것도 가능하다. 1234export default React.memo( UserList, (prevProps, nextProps) =&gt; prevProps.users === nextProps.users); 하지만, 이걸 잘못사용한다면 오히려 의도치 않은 버그들이 발생하기 쉽다. 예를 들어, 함수형 업데이트로 전환을 안했는데 이렇게 users 만 비교를 하게 된다면, onToggle 과 onRemove 에서 최신 users 배열을 참조하지 않으므로 심각한 오류가 발생 할 수 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"useCallback 을 사용하여 함수 재사용하기","slug":"react-velo-16","date":"2020-01-22T01:11:24.000Z","updated":"2020-01-23T07:54:44.064Z","comments":true,"path":"2020/01/22/react-velo-16/","link":"","permalink":"https://hyeok999.github.io/2020/01/22/react-velo-16/","excerpt":"","text":"React with Velopert - 16 - useCallback 을 사용하여 함수 재사용하기 useCallback 사용 규칙 주의 할 점 App.js Chap 16. useCallback 을 사용하여 함수 재사용하기useCallback 을 사용하여 함수 재사용하기 useMemo 는 특정 결과 값을 재사용 할 때 사용하는 반면, useCallback 은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다. useCallback 사용 규칙 useCallback은 결과 값이 아니라 함수를 반환한다는 것을 잊지말자. 첫번째 파라미터 - 어떻게 연산할지 정의하는 함수를 넣어준다. 두번째 파라미터 - deps 배열을 넣어주면 되는데, 이 배열 안에 넣은 내용이 바뀌면, 등록한 함수를 호출해서 값을 연산해주고, 만약에 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 된다. 주의 할 점함수 안에서 사용하는 상태 혹은 props 가 있다면 꼭, deps 배열안에 포함시켜야 된다는 것.만약에 deps 배열 안에 함수에서 사용하는 값을 넣지 않게 된다면, 함수 내에서 해당 값들을 참조할때 가장 최신 값을 참조 할 것이라고 보장 할 수 없다. props 로 받아온 함수가 있다면, 이 또한 deps 에 넣어야 한다. 12useCallback( fn , [deps] )useCallback( () =&gt; &#123;&#125;,[deps] ) useCallback은 사실 useMemo를 기반으로 만들어져서 useMemo를 다음과 같이 쓸 경우 useCallback과 동일한 역할을 한다. 123456const onToggle = useMemo( () =&gt; () =&gt; &#123; /* ... */ &#125;, [users]); 예전에 App.js에서 작성했던 onCreate, onRemove, onToggle 함수를 확인해보자. 1234567891011121314151617181920212223242526const onCreate = () =&gt; &#123; const user = &#123; id: nextId.current, username, email &#125;; setUsers(users.concat(user)); setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1;&#125;;const onRemove = id =&gt; &#123; setUsers(users.filter(user =&gt; user.id !== id));&#125;;const onToggle = id =&gt; &#123; setUsers( users.map(user =&gt; user.id === id ? &#123; ...user, active: !user.active &#125; : user ) );&#125;; 위 함수들은 컴포넌트가 리렌더링 될 때 마다 새로 만들어진다. 함수를 선언하는 것 자체는 사실 메모리도, CPU 도 리소스를 많이 차지 하는 작업은 아니기 때문에 함수를 새로 선언한다고 해서 그 자체 만으로 큰 부하가 생길일은 없지만, 한번 만든 함수를 필요할때만 새로 만들고 재사용하는 것은 중요하다. 그 이유는, 나중에 컴포넌트에서 props 가 바뀌지 않았으면 Virtual DOM 에 새로 렌더링하는 것 조차 하지 않고 컴포넌트의 결과물을 재사용 하는 최적화 작업을 할텐데, 이 작업을 하려면, 함수를 재사용하는것이 필수다. App.js useCallback 을 추가해보자 각각 onChange , onCreate, onRemove, onToggle 에 추가하면 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import React, &#123; useRef, useState, useMemo, useCallback &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = useCallback( // useCallback 추가 e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;, [inputs] ); const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]); const nextId = useRef(4); const onCreate = useCallback(() =&gt; &#123; // useCallback 추가 const user = &#123; id: nextId.current, username, email &#125;; setUsers(users.concat(user)); setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; &#125;, [users, username, email]); const onRemove = useCallback( // useCallback 추가 id =&gt; &#123; setUsers(users.filter(user =&gt; user.id !== id)); &#125;, [users] ); const onToggle = useCallback( // useCallback 추가 id =&gt; &#123; setUsers( users.map(user =&gt; user.id === id ? &#123; ...user, active: !user.active &#125; : user ) ); &#125;, [users] ); const count = useMemo(() =&gt; countActiveUsers(users), [users]); return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"useMemo 연산한 값 재사용하기","slug":"react-velo-15","date":"2020-01-20T14:51:57.000Z","updated":"2020-01-20T14:54:35.216Z","comments":true,"path":"2020/01/20/react-velo-15/","link":"","permalink":"https://hyeok999.github.io/2020/01/20/react-velo-15/","excerpt":"","text":"React with Velopert - 15 - useMemo 연산한 값 재사용하기 useMemo 사용 규칙 App.js useMemo 사용하기 App.js 전체 코드 Chap 15. useMemo 연산한 값 재사용하기useMemo 연산한 값 재사용하기 성능 최적화를 위하여 연산된 값을 useMemo라는 Hook 을 사용하여 재사용하는 방법을 알아보도록 하자. useMemo 연산한 값 재사용하기 이번에는 성능 최적화를 위하여 연산된 값을 useMemo라는 Hook 을 사용하여 재사용하는 방법을 알아보도록 하자. App 컴포넌트에서 다음과 같이 countActiveUsers 라는 함수를 만들어서, active 값이 true 인 사용자의 수를 세어서 화면에 렌더링 해보자. useMemo 사용 규칙 첫번째 파라미터 - 어떻게 연산할지 정의하는 함수를 넣어준다. 두번째 파라미터 - deps 배열을 넣어주면 되는데, 이 배열 안에 넣은 내용이 바뀌면, 등록한 함수를 호출해서 값을 연산해주고, 만약에 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 된다. 12useMemo( fn , [deps] )useMemo( () =&gt; &#123;&#125;,[deps] ) App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import React, &#123; useRef, useState &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; // 추가 console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125; function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;; const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]); const nextId = useRef(4); const onCreate = () =&gt; &#123; const user = &#123; id: nextId.current, username, email &#125;; setUsers(users.concat(user)); setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; &#125;; const onRemove = id =&gt; &#123; setUsers(users.filter(user =&gt; user.id !== id)); &#125;; const onToggle = id =&gt; &#123; setUsers( users.map(user =&gt; user.id === id ? &#123; ...user, active: !user.active &#125; : user ) ); &#125;; const count = countActiveUsers(users); // 추가 return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; // 추가 &lt;/&gt; );&#125;export default App; 위 코드의 문제점은, 활성 사용자 수를 세는건 users 에 변화가 있을때만 세야되는건데, input 값이 바뀔 때에도 컴포넌트가 리렌더링 되므로 불필요 할 때에도 호출하여서 자원이 낭비되고 있다. 왜 이런 현상이 벌어지는 걸까? 이유는 input 박스에 내용을 작성할 경우 input태그의 value값이 바뀌고 바뀐 값을 토대로 리액트는 컴포넌트의 변화에 의해 화면을 리렌더링하게 된다. 이러한 현상은 불필요하고 또 자원을 낭비하게 된다. 이러한 상황에는 useMemo 라는 \bHook 함수를 사용하면 성능을 최적화 할 수 있다. useMemo 사용하기 count 변수 할당 부분을 아래처럼 변경해보자. Memo 는 “memoized” 를 의미하는데, 이는, 이전에 계산 한 값을 재사용한다는 의미를 가지고 있다. 명심해야 할 것은 useMemo는 계산 한 값 이라는 것이다. 1const count = useMemo(() =&gt; countActiveUsers(users), [users]); App.js 전체 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import React, &#123; useRef, useState, useMemo &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function countActiveUsers(users) &#123; console.log('활성 사용자 수를 세는중...'); return users.filter(user =&gt; user.active).length;&#125;function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;; const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]); const nextId = useRef(4); const onCreate = () =&gt; &#123; const user = &#123; id: nextId.current, username, email &#125;; setUsers(users.concat(user)); setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; &#125;; const onRemove = id =&gt; &#123; setUsers(users.filter(user =&gt; user.id !== id)); &#125;; const onToggle = id =&gt; &#123; setUsers( users.map(user =&gt; user.id === id ? &#123; ...user, active: !user.active &#125; : user ) ); &#125;; const count = useMemo(() =&gt; countActiveUsers(users), [users]); // 변경 return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; &lt;div&gt;활성사용자 수 : &#123;count&#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 19","slug":"react-study-19","date":"2020-01-19T19:01:36.000Z","updated":"2020-01-19T19:04:05.369Z","comments":true,"path":"2020/01/20/react-study-19/","link":"","permalink":"https://hyeok999.github.io/2020/01/20/react-study-19/","excerpt":"","text":"React Study 19 Graphql 프로젝트 (인스타그램) 백엔드 초기설정하기 (백엔드) 프론트 설정 Graphql 프로젝트 (파일 업로드) 백엔드 서버 프론트 Apollo X GraphQL 초기설정 해주기 (프론트) 업로드 해주는 컴포넌트(FileUpload)를 작성한다. 뮤테이션 작성 드래그 부분 작성 쿼리 작성 드래그 혹은 파일이 백엔드 서버에 추가 시 리렌더링 해주기. 전체코드 App.js FileUpload.js 용어 - ( 러버덕 ) 파일 업로드 useMutation useQuery Graphql 프로젝트 (인스타그램)백엔드 초기설정하기 (백엔드) 몽고 DB 실행 https://github.com/levelasquez/instagram-clone-graphql 가서 클론 다운로드( 나는 zip으로 해서 폴더만 끌어옴 ) npm install package.json에 dependencies에서 “bcrypt”: “^1.0.3” 제거 npm i babel-node npm i esm npm install @babel/core @babel/register @babel/preset-env –save-dev 1234567891011121314151617// resolver/users 부분에서 bcrypt 부분 다 날림, password 재설정export default &#123; Query: &#123; allUsers: (parent, args, &#123; models &#125;) =&gt; models.User.find(), getUser: (parent, args, &#123; models &#125;) =&gt; models.User.findOne(args), &#125;, Mutation: &#123; createUser: async (parent, &#123; password, ...args &#125;, &#123; models &#125;) =&gt; &#123; try &#123; const user = await models.User.create(&#123; ...args, password &#125;); return user &amp;&amp; user._id; &#125; catch (error) &#123; return false; &#125; &#125;, &#125;,&#125;; npm start 프론트 설정 npm i .prettierrc 파일 추가 12345&#123; \"semi\": false, \"singleQuote\": true, \"trailingComma\": \"all\"&#125; npm start 훅기반으로 HOC를 만드는 것은 옛날 패턴이다. (안티패턴 - 권장하는 방식이 아님.) 123456789showLogin = event =&gt; &#123; event.preventDefault() this.setState(&#123; showLogin: true, showRegister: false, showLostPassword: false, &#125;)&#125; 이벤트 버블링 현상이 일어날수 있으니 event.preventDefault()를 작성해준다. Graphql 프로젝트 (파일 업로드) 서버 준비 되있음. 백엔드 서버 123456789const typeDefs = gql` type Query &#123; files: [String] &#125; type Mutation &#123; uploadFile(file: Upload!): Boolean &#125;`; 프론트Apollo X GraphQL 초기설정 해주기 (프론트) Apollo 클라이언트에서는 캐시를 만들 때 InMemoryChche를 사용 App.js 12345678910111213141516171819202122232425import React, &#123; useEffect &#125; from 'react';import './App.css';import &#123; ApolloProvider, useQuery &#125; from '@apollo/react-hooks';import ApolloClient from 'apollo-client';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';import &#123; createUploadLink &#125; from 'apollo-upload-client';import &#123; FileUpload &#125; from './Components/FileUpload';import gql from 'graphql-tag';const link = createUploadLink(&#123; uri: 'http://localhost:4000/graphql' &#125;);export const client = new ApolloClient(&#123; link, cache: new InMemoryCache(),&#125;);function App() &#123; return ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;FileUpload /&gt; &lt;/ApolloProvider&gt; );&#125;export &#123; App &#125;; 업로드 해주는 컴포넌트(FileUpload)를 작성한다. import 추가 123456// FileUpload.jsximport React from 'react'import gql from 'graphql-tag'import &#123; useMutation &#125; from '@apollo/react-hooks'// useDropzone : 드래그앤 드롭 해서 업로드 되는 모듈 import &#123; useDropzone &#125; from 'react-dropzone' 뮤테이션 작성 업로드 되는 요청은 쿼리가 아니라 뮤테이션이다. useMutation은 배열 구조 분해 방식 함수명를 여러번 선언했을 때, 함수명의 중복을 쉽게 피하도록 함수명을 사용자 임의로 지정하게 하기 위해 배열의 첫번째 영역은 함수 뮤테이션 작성할 때 함수명을 지정(백엔드에서 정의된 이름에서 카멜케이스로 변경하여 사용해주자) $가 붙은 것은 변수명이라는 뜻 123456// FileUpload.jsxconst uploadFileMutation = gql` mutation UploadFile($file : Upload!) &#123; uploadFile(file: $file) &#125;` 드래그 부분 작성 위에서 작성한 뮤테이션을 훅을 통해 불러온다. onDrop함수를 설정한다. 여기서 [file]은 파일을 드래그해서 올려놓았을 때, 가르키는 파일을 의미한다. // 뮤테이션이 여기서 실행된다. useDropzone({ onDrop }) → 객체로 함수를 랩핑해서 전달해야 한다. 123456789101112// FileUpload.jsxexport const Upload = () =&gt; &#123; const [uploadFile] = useMutation(uploadFileMutation) const onDrop = ([file]) =&gt; uploadFile(&#123;variables: &#123;file&#125;&#125;) const &#123; getRootProps, getInputProps, isDragActive &#125; = useDropzone(&#123; onDrop &#125;) return ( &lt;div &#123;...getRootProps&#125; &gt; &lt;/div&gt; )&#125; 드래그앤드롭이 인식이 되고 싶은 시작 지점의 태그에 {...getRootProps} 을 설정한다. 12345&lt;div &#123;...getRootProps&#125;&gt; &lt;input &#123;...getInputProps&#125; /&gt;&lt;/div&gt; input을 {...getInputProps}으로 오버라이드 한다. 12345678910&lt;div &#123;...getRootProps&#125;&gt; &lt;input &#123;...getInputProps&#125; /&gt; &#123; isDragActive ? &lt;p&gt;여기에 파일을 드래그 앤 드롭하세요.&lt;/p&gt; : &lt;p&gt;파일을 선택하세요.&lt;/p&gt; &#125;&lt;/div&gt; 만약 드래그가 안되는 브라우저일 경우, 파일을 선택하게 해야되기 때문에 isDragActive로 boolean값을 받아 비교한다. 쿼리 작성 다시 App.js로 돌아와서 쿼리를 작성한다. useQuery는 객체 구조 분해 방식 선언만으로 수행되기 때문에 별도의 함수가 필요 없음 123456789101112131415161718192021222324252627282930313233343536// App.js...function App() &#123; return ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;FileUpload /&gt; &lt;hr /&gt; &lt;Files /*추가*/ /&gt; &lt;/ApolloProvider&gt; );// 아래부터 전부 추가const GET_FILES = gql` &#123; files &#125;`;function Files() &#123; const &#123; data, loading &#125; = useQuery(GET_FILES); // useQuery는 객체, useMutation은 배열 useEffect(() =&gt; &#123; console.log('abc'); &#125;); if (loading) return &lt;p&gt;loading&lt;/p&gt;; return ( &lt;&gt; &#123;data.files.map((f, i) =&gt; ( &lt;p key=&#123;i&#125;&gt;&#123;f&#125;&lt;/p&gt; ))&#125; &lt;/&gt; );&#125;export &#123; App, GET_FILES &#125;; 드래그 혹은 파일이 백엔드 서버에 추가 시 리렌더링 해주기. 드래그 혹은 파일 추가 버튼을 이용하여 백엔드 서버에 파일이 추가 될 경우 화면 리렌더링 하는 작업을 한다. 순서를 보장받고 싶을 땐 async/await를 사용하자 배열구조분해 방식으로 받는 uploadFile과 같은 값은 항상 Promise이므로 async/await를 사용할 수 있는 것. useMutation 첫번째 쿼리는 뮤테이션 자체, 두번째는 옵션으로 refetchQueries라는 속성이 있는데 이 뮤테이션을 수행한 이후에 쿼리를 가져오게 해주는 역할을 함. 1234567891011121314151617181920212223242526272829303132333435// FileUpload.jsximport React, &#123; useCallback &#125; from 'react';import gql from 'graphql-tag';import &#123; useMutation &#125; from '@apollo/react-hooks';import &#123; useDropzone &#125; from 'react-dropzone';import &#123; GET_FILES &#125; from '../App'; // 추가const uploadFileMutation = gql` mutation UploadFile($file: Upload!) &#123; uploadFile(file: $file) &#125;`;export const FileUpload = () =&gt; &#123; const [uploadFile] = useMutation(uploadFileMutation, &#123; refetchQueries: [&#123; query: GET_FILES &#125;], // 2번째 파라미터 추가 // 업로드 뮤테이션을 수행한 이후에 쿼리를 가져오게 해주는 역할을 한다. &#125;); const onDrop = useCallback( async ([file]) =&gt; &#123; await uploadFile(&#123; variables: &#123; file &#125; &#125;); &#125;, [uploadFile], ); // 타입이 프로미스다. 따라서, async, await가 사용가능하다. const &#123; getRootProps, getInputProps, isDragActive &#125; = useDropzone(&#123; onDrop &#125;); return ( // &lt;div &#123;...this.state&#125;&gt;&lt;/div&gt; &lt;div &#123;...getRootProps()&#125;&gt; &lt;input &#123;...getInputProps()&#125; /&gt; &#123;isDragActive ? &lt;p&gt;여기에 파일을 드래그 앤 드롭하세요.&lt;/p&gt; : &lt;p&gt;파일을 선택하세요.&lt;/p&gt;&#125; &lt;/div&gt; );&#125;; 전체 코드 App.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; useEffect &#125; from 'react';import './App.css';import &#123; ApolloProvider, useQuery &#125; from '@apollo/react-hooks';import ApolloClient from 'apollo-client';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';import &#123; createUploadLink &#125; from 'apollo-upload-client';import &#123; FileUpload &#125; from './Components/FileUpload';import gql from 'graphql-tag';const link = createUploadLink(&#123; uri: 'http://localhost:4000/graphql' &#125;);export const client = new ApolloClient(&#123; link, cache: new InMemoryCache(),&#125;);function App() &#123; return ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;FileUpload /&gt; &lt;hr /&gt; &lt;Files /&gt; &lt;/ApolloProvider&gt; );&#125;const GET_FILES = gql` &#123; files &#125;`;function Files() &#123; const &#123; data, loading &#125; = useQuery(GET_FILES); // useQuery는 객체, useMutation은 배열 useEffect(() =&gt; &#123; console.log('abc'); &#125;); if (loading) return &lt;p&gt;loading&lt;/p&gt;; return ( &lt;&gt; &#123;data.files.map((f, i) =&gt; ( &lt;p key=&#123;i&#125;&gt;&#123;f&#125;&lt;/p&gt; ))&#125; &lt;/&gt; );&#125;export &#123; App, GET_FILES &#125;; FileUpload.js 123456789101112131415161718192021222324252627282930313233import React, &#123; useCallback &#125; from 'react';import gql from 'graphql-tag';import &#123; useMutation &#125; from '@apollo/react-hooks';// useDropzone : 드래그앤 드롭 해서 업로드 되는 모듈import &#123; useDropzone &#125; from 'react-dropzone';import &#123; GET_FILES &#125; from '../App';const uploadFileMutation = gql` mutation UploadFile($file: Upload!) &#123; uploadFile(file: $file) &#125;`;export const FileUpload = () =&gt; &#123; const [uploadFile] = useMutation(uploadFileMutation, &#123; refetchQueries: [&#123; query: GET_FILES &#125;], &#125;); const onDrop = useCallback( async ([file]) =&gt; &#123; await uploadFile(&#123; variables: &#123; file &#125; &#125;); &#125;, [uploadFile], ); // 타입이 프로미스다. const &#123; getRootProps, getInputProps, isDragActive &#125; = useDropzone(&#123; onDrop &#125;); return ( // &lt;div &#123;...this.state&#125;&gt;&lt;/div&gt; &lt;div &#123;...getRootProps()&#125;&gt; &lt;input &#123;...getInputProps()&#125; /&gt; &#123;isDragActive ? &lt;p&gt;여기에 파일을 드래그 앤 드롭하세요.&lt;/p&gt; : &lt;p&gt;파일을 선택하세요.&lt;/p&gt;&#125; &lt;/div&gt; );&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기","slug":"react-velo-14","date":"2020-01-18T14:38:43.000Z","updated":"2020-01-18T14:41:00.716Z","comments":true,"path":"2020/01/18/react-velo-14/","link":"","permalink":"https://hyeok999.github.io/2020/01/18/react-velo-14/","excerpt":"","text":"React with Velopert - 14 - useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기 useEffect 작업 설정 useEffect 를 사용 규칙 주로 사용되는 부분 마운트/언마운트 UserList.js deps 에 특정 값 넣기 deps 파라미터를 생략하기 Chap 14. useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기useEffect 작업 설정 useEffect 라는 Hook 을 사용하여 컴포넌트가 마운트 됐을 때 (처음 나타났을 때), 컴포넌트가 언마운트 됐을 때 (사라질 때), 컴포넌트를 업데이트 될 때 (특정 props가 바뀔 때) 특정 작업을 처리할 수 있다. useEffect 사용 규칙 첫번째 파라미터 - 함수 두번째 파라미터 - 의존값이 들어있는 배열 (deps) ( 만약에 deps 배열을 비우게 된다면, 컴포넌트가 처음 나타날때에만 useEffect 에 등록한 함수가 호출됨. ) useEffect 에서는 함수를 반환 할 수 있는데 이를 cleanup 함수라고 부른다.deps 가 비어있는 경우에는 컴포넌트가 사라질 때 cleanup 함수가 호출된다. 123456useEffect(() =&gt; &#123; effect // ComponentDidMount return () =&gt; &#123; // 리턴 명시하는 함수가 ComponentWillUnMount cleanup &#125;;&#125;, [deps]) // ComponentDidUpdate 할 조건, 빈배열[] 시 1번만 실행, 생략시 모든 조건(All true) 주로 사용되는 부분 effect : UI가 렌더링 된 이후에 일어날 일들을 정의한다.주로 props =&gt; state / REST API / D3 , Video.js / setInterval , setTimeout 등등 cleanup: 컴포넌트가 사라지면서 언마운트 되면서 해야할 일들을 정의한다. 주로 clearInterval, clearTimeout , 라이브러리 인스턴스 제거 등등 deps : deps 부분은 effect부분에서 조회나 사용하고 있는 상태가 존재한다면 이부분에 명시를 해주는 것이 규칙이다. 마운트/언마운트 UserList.js12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; useEffect &#125; from 'react';function User(&#123; user, onRemove, onToggle &#125;) &#123; useEffect(() =&gt; &#123; // 이부분 작성 console.log('컴포넌트가 화면에 나타남'); return () =&gt; &#123; console.log('컴포넌트가 화면에서 사라짐'); &#125;; &#125;, []); return ( &lt;div&gt; &lt;b style=&#123;&#123; cursor: 'pointer', color: user.active ? 'green' : 'black' &#125;&#125; onClick=&#123;() =&gt; onToggle(user.id)&#125; &gt; &#123;user.username&#125; &lt;/b&gt; &amp;nbsp; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; onRemove(user.id)&#125;&gt;삭제&lt;/button&gt; &lt;/div&gt; );&#125;function UserList(&#123; users, onRemove, onToggle &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default UserList; 주로, 마운트 시에 하는 작업들은 다음과 같은 사항들이 있다. props 로 받은 값을 컴포넌트의 로컬 상태로 설정 외부 API 요청 (REST API 등) 라이브러리 사용 (D3, Video.js 등…) setInterval 을 통한 반복작업 혹은 setTimeout 을 통한 작업 예약 그리고 언마운트 시에 하는 작업들은 다음과 같은 사항이 있다. setInterval, setTimeout 을 사용하여 등록한 작업들 clear 하기 (clearInterval, clearTimeout) 라이브러리 인스턴스 제거 deps 에 특정 값 넣기 이번에는 deps 에 특정 값을 넣어보도록 하자. deps 에 특정 값을 넣게 된다면, 컴포넌트가 처음 마운트 될 때에도 호출이 되고, 지정한 값이 바뀔 때에도 호출이 된다. 그리고, deps 안에 특정 값이 있다면 언마운트시에도 호출이되고, 값이 바뀌기 직전에도 호출이 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; useEffect &#125; from 'react';function User(&#123; user, onRemove, onToggle &#125;) &#123; useEffect(() =&gt; &#123; console.log('user 값이 설정됨'); console.log(user); return () =&gt; &#123; console.log('user 가 바뀌기 전..'); console.log(user); &#125;; &#125;, [user]); return ( &lt;div&gt; &lt;b style=&#123;&#123; cursor: 'pointer', color: user.active ? 'green' : 'black' &#125;&#125; onClick=&#123;() =&gt; onToggle(user.id)&#125; &gt; &#123;user.username&#125; &lt;/b&gt; &amp;nbsp; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; onRemove(user.id)&#125;&gt;삭제&lt;/button&gt; &lt;/div&gt; );&#125;function UserList(&#123; users, onRemove, onToggle &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default UserList; useEffect 안에서 사용하는 상태나, props 가 있다면, useEffect 의 deps 에 넣어주어야 한다. 약 useEffect 안에서 사용하는 상태나 props 를 deps 에 넣지 않게 된다면 useEffect 에 등록한 함수가 실행 될 때 최신 props / 상태를 가르키지 않게 된다. deps 파라미터를 생략하기 deps 파라미터를 생략한다면, 컴포넌트가 리렌더링 될 때마다 호출 된다. 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; useEffect &#125; from 'react';function User(&#123; user, onRemove, onToggle &#125;) &#123; useEffect(() =&gt; &#123; console.log(user); &#125;); return ( &lt;div&gt; &lt;b style=&#123;&#123; cursor: 'pointer', color: user.active ? 'green' : 'black' &#125;&#125; onClick=&#123;() =&gt; onToggle(user.id)&#125; &gt; &#123;user.username&#125; &lt;/b&gt; &amp;nbsp; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; onRemove(user.id)&#125;&gt;삭제&lt;/button&gt; &lt;/div&gt; );&#125;function UserList(&#123; users, onRemove, onToggle &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default UserList; 리액트 컴포넌트는 기본적으로 부모컴포넌트가 리렌더링되면 자식 컴포넌트 또한 리렌더링이 된다. ( 바뀐 내용이 없어도 ) 실제 DOM 에 변화가 반영되는 것은 바뀐 내용이 있는 컴포넌트에만 해당된다. 하지만, Virtual DOM 에는 모든걸 다 렌더링하고 있다는 것이다. 이는 불필요한 리소스를 게속적으로 사용하게 되는 것이므로 추후에 최적화를 하는것으로 이 부분을 메꿔야만 한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"배열에 항목 수정하기","slug":"react-velo-13","date":"2020-01-18T09:15:07.000Z","updated":"2020-01-18T14:40:36.624Z","comments":true,"path":"2020/01/18/react-velo-13/","link":"","permalink":"https://hyeok999.github.io/2020/01/18/react-velo-13/","excerpt":"","text":"React with Velopert - 13 - 배열에 항목 수정하기 예제 : User 컴포넌트에 계정명을 클릭했을 때 색상 바꾸기 App.js UserList.js Chap 13. 배열에 항목 수정하기배열에 항목 수정하기 예제 : User 컴포넌트에 계정명을 클릭했을 때 색상 바꾸기 App.jsonToggle 함수를 만들어서 props로 뿌려준다. 여기서, 선택된 요소의 id값을 통해 User를 비교해야 하므로 map함수를 이용한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import React, &#123; useRef, useState &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;; const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com', active: true &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com', active: false &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com', active: false &#125; ]); const nextId = useRef(4); const onCreate = () =&gt; &#123; const user = &#123; id: nextId.current, username, email &#125;; setUsers(users.concat(user)); setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; &#125;; const onRemove = id =&gt; &#123; setUsers(users.filter(user =&gt; user.id !== id)); &#125;; const onToggle = id =&gt; &#123; // 이부분 추가 setUsers( users.map(user =&gt; user.id === id ? &#123; ...user, active: !user.active &#125; : user ) ); &#125;; return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; // 이부분 추가 &lt;/&gt; );&#125;export default App; UserList.js 그 다음에는 UserList 컴포넌트에서 onToggle를 받아와서 User 에게 전달해주고, onRemove 를 구현했었던것처럼 onToggle 에 id 를 넣어서 호출해주자. 주의할 것은 태그내에 함수를 연결해줄때는 반드시 호출문이 아닌 함수 명만을 적어주어야한다는 것에 주의하자. 1234567891011121314151617181920212223242526272829303132333435import React from 'react';function User(&#123; user, onRemove, onToggle &#125;) &#123; return ( &lt;div&gt; &lt;b style=&#123;&#123; cursor: 'pointer', color: user.active ? 'green' : 'black' &#125;&#125; onClick=&#123;() =&gt; onToggle(user.id)&#125; &gt; &#123;user.username&#125; &lt;/b&gt; &amp;nbsp; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; onRemove(user.id)&#125;&gt;삭제&lt;/button&gt; &lt;/div&gt; );&#125;function UserList(&#123; users, onRemove, onToggle &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; onRemove=&#123;onRemove&#125; onToggle=&#123;onToggle&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 18","slug":"react-study-18","date":"2020-01-15T14:37:28.000Z","updated":"2020-01-15T14:39:44.569Z","comments":true,"path":"2020/01/15/react-study-18/","link":"","permalink":"https://hyeok999.github.io/2020/01/15/react-study-18/","excerpt":"","text":"React Study 18 GraphQL 미니 프로젝트 백엔드 Resolver (middle-ware) input 키워드 프론트 mutation 작성 (src/graphql/mutation.js) Query 작성 (src/graphql/queries.js) 데이터 요청 - 컴포넌트방식(클래스기반) ‘npm i react-apollo’ &lt; Query &gt; &lt; Mutatation &gt; 데이터 요청 - 훅방식 ‘npm i apollo-boost’ useQuery useMutation 비동기 방식을 처리하는 방법들 용어 - ( 러버덕 ) 프론트 백엔드 데이터 요청 - 컴포넌트방식 데이터 요청 - 훅방식 GraphQL 미니 프로젝트 프론트 개발 ← 쿼리, 뮤테이션 → Resovers ← 백엔드 개발자 → DB 프론트엔드는 최소 백엔드에 정의된 Types을 해석할 수 있는 역량이 필요하다. 즉, Types를 해석해서 Query 와 Mutation을 작성하는 능력이 필요함. 백엔드 Type은 객체 형식 { 필드 : 값 }로 이루어졌다. Schema는 타입들의 정의 와 백엔드 개발자가 만드는 resolver 정의를 포함하는 개념이다. resolver는 프론트가 보낸 요청을 처리하는 로직을 구현한 곳을 의미한다. Resolver (middle-ware)어떠한 프로그래밍 언에 대해 종속시키지 않기 위해서 Resolver라는 개념을 도입해 중간에 다리를 놓았음. resolver의 예 : getPost , createPost라는 요청이 들어왔을 때 처리 예시 12345678910// FRONT 에서 데이터 요청(쿼리,뮤테이션)을 했을 떄 데이터를 직접적으로 처리하는 구간export default &#123; Query: &#123; getPost: (parent, args, &#123; models &#125;) =&gt; models.Post.findOne(args) &#125;, Mutation: &#123; createPost: (parent, args, &#123; models, user &#125;) =&gt; models.Post.create(&#123; ...args.post, by: user &#125;) &#125;&#125;; 순서 : 프론트가 데이터 요청(쿼리, 뮤테이션) → Resolver(요청 해결) → DB → Resolver → 프론트 NOSQL은 DB에 데이터가 정의가 되어 있지 않더라도 마치 있는 것처럼 업데이트를 할 수 있다.(SQL은 안된다.) input 키워드 input 키워드는 MUTATION에서만 사용된다. (페이로드에 해당됨) 12345678910111213input iBy &#123; username: String! thumbnail: String&#125;input iPost &#123; desc: String photo: String&#125;type Mutation &#123; createPost(post: iPost): Post! # 위에서 정의한 input이 사용됨.&#125; 프론트mutation 작성 (src/graphql/mutation.js) 회원 가입을 위한 MUTATION (쓰기, 수정, 삭제) mutation의 이름(예제에서는 CreateUser)은 백엔드개발자가 어떤 mutation이 사용됬는지 로그확인용으로 사용되지 그 외의 사용용도는 없다. (이름이 없다면 익명함수의 느낌) 1234// 백엔드 파일의 타입상황type Mutation &#123;createUser(username: String!, password: String!, fullname: String!, email: String!):Boolean!&#125; 1234567891011121314151617181920// 프론트import gql from 'graphql-tag';export default &#123; creatUser: gql` mutation CreateUser( $username: String! $password: String! $fullname: String! $email: String! ) &#123; createUser( username: $username password: $password fullname: $fullname email: $email ) &#125; `,&#125;; 위 작성된 mutation은 JS에 function과 비교하면 이러한 느낌이다. (동일하진 않지만 이런 느낌이다.) 12345678910111213function CreateUser( $username: String!, $password: String!, $fullname: String!, $email: String! ) &#123; createUser( username: $username, password: $password, fullname: $fullname, email: $email )&#125; Query 작성 (src/graphql/queries.js) 모든 유저 조회 및 특정 유저 조회을 위한 QUERY (읽기) query의 이름(예제에서는 AllUser, GetUser)은 백엔드개발자가 어떤 query가 사용됬는지 로그확인용으로 사용되지 그 외의 사용도는 없다. (이름이 없다면 익명함수의 느낌) 1234567891011121314// 백앤드 쿼리 type User &#123; _id: ID! username: String! password: String! fullname: String! email: String! thumbnail: String &#125; type Query &#123; allUsers: [User]! getUser(_id: ID!): User! &#125; 123456789101112131415161718192021222324// 프론트import gql from 'graphql-tag';export default &#123; allUsers: gql` query AllUsers &#123; allUsers &#123; username fullname email thumbnail &#125; &#125; `, getUser: gql` query GetUser($_id: ID!)&#123; getUser(_id: $_id) &#123; username fullname email &#125; &#125; `,&#125;; 데이터 요청 - 컴포넌트방식(클래스기반) ‘npm i react-apollo’ 반드시 클래스 기반에서 사용해야한다. &lt; Query &gt;123456789101112131415161718192021222324252627282930import gql from \"graphql-tag\";import &#123; Query &#125; from \"react-apollo\";const GET_DOGS = gql` &#123; dogs &#123; id breed &#125; &#125;`;const Dogs = (&#123; onDogSelected &#125;) =&gt; ( &lt;Query query=&#123;GET_DOGS&#125;&gt; &#123;(&#123; loading, error, data &#125;) =&gt; &#123; if (loading) return \"Loading...\"; if (error) return `Error! $&#123;error.message&#125;`; return ( &lt;select name=\"dog\" onChange=&#123;onDogSelected&#125;&gt; &#123;data.dogs.map(dog =&gt; ( &lt;option key=&#123;dog.id&#125; value=&#123;dog.breed&#125;&gt; &#123;dog.breed&#125; &lt;/option&gt; ))&#125; &lt;/select&gt; ); &#125;&#125; &lt;/Query&gt;); &lt; Mutatation &gt;1234567891011121314151617181920212223242526272829303132333435363738import gql from \"graphql-tag\";import &#123; Mutation &#125; from \"react-apollo\";const ADD_TODO = gql` mutation AddTodo($type: String!) &#123; addTodo(type: $type) &#123; id type &#125; &#125;`;const AddTodo = () =&gt; &#123; let input; return ( &lt;Mutation mutation=&#123;ADD_TODO&#125;&gt; &#123;(addTodo, &#123; data &#125;) =&gt; ( &lt;div&gt; &lt;form onSubmit=&#123;e =&gt; &#123; e.preventDefault(); addTodo(&#123; variables: &#123; type: input.value &#125; &#125;); input.value = \"\"; &#125;&#125; &gt; &lt;input ref=&#123;node =&gt; &#123; input = node; &#125;&#125; /&gt; &lt;button type=\"submit\"&gt;Add Todo&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; )&#125; &lt;/Mutation&gt; );&#125;; 데이터 요청 - 훅방식 ‘npm i apollo-boost’ 반드시 함수 기반에서 사용해야한다. useQuery useQuery는 객체 구조 분해 방식. loading : true || false / error : obj useQuery는 선언만 해줘도 쿼리가 날라간다. loading을 안적어줄 시 undefined에러를 일으킨다. (loading 을 쓰거나, &amp;&amp;로 유효성검사를 해야한다. ) 12345678910111213141516171819import &#123; useQuery &#125; from '@apollo/react-hooks';import gql from 'graphql-tag';const GET_GREETING = gql` query getGreeting($language: String!) &#123; greeting(language: $language) &#123; message &#125; &#125;`;function Hello() &#123; const &#123; loading, error, data &#125; = useQuery(GET_GREETING, &#123; variables: &#123; language: 'english' &#125;, &#125;); if (loading) return &lt;p&gt;Loading ...&lt;/p&gt;; // if (!loading) &#123; &#123;data.greeting.message&#125; &#125; // 혹은 &amp;&amp;를 사용한다. return &lt;h1&gt;Hello &#123;data.greeting.message&#125;&lt;/h1&gt;;&#125; useMutation useMutation는 배열 구조 분해 방식. useMutation의 경우, 선언만할 경우 usequery처럼 요청을 보내지는 않는다. useMutation 의 첫번째 파라미터에 인자로 해당 graphql에서 정의한 변수를 객체 파라미터로 정의해주어야 요청을 보낸다. useMutation의 첫번째 파라미터에 정의한 함수는 Promise이다. 1234567891011121314151617181920212223242526272829303132333435import gql from 'graphql-tag';import &#123; useMutation &#125; from '@apollo/react-hooks';const ADD_TODO = gql` mutation AddTodo($type: String!) &#123; addTodo(type: $type) &#123; id type &#125; &#125;`;function AddTodo() &#123; let input; const [addTodo, &#123; data &#125;] = useMutation(ADD_TODO); return ( &lt;div&gt; &lt;form onSubmit=&#123;e =&gt; &#123; e.preventDefault(); addTodo(&#123; variables: &#123; type: input.value &#125; &#125;); input.value = ''; &#125;&#125; &gt; &lt;input ref=&#123;node =&gt; &#123; input = node; &#125;&#125; /&gt; &lt;button type=\"submit\"&gt;Add Todo&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125; 비동기 방식을 처리하는 방법들 폴링 방식 : setInterval 을 사용해서 비동기코드가 주기적으로 확인해서 완료가 되어있는지 아닌지 확인함. Event Emitter 방식 : 어떠한 작업에 대해서 이벤트를 정해두고 그 작업이 완료가 될 경우 그 이벤트가 완료가 되었다는 것을 전달한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 17","slug":"react-study-17","date":"2020-01-14T13:45:43.000Z","updated":"2020-01-14T13:48:01.746Z","comments":true,"path":"2020/01/14/react-study-17/","link":"","permalink":"https://hyeok999.github.io/2020/01/14/react-study-17/","excerpt":"","text":"React Study 17 React 순서 되짚어 보기 GraphQL 필드 필드 - 객체 참조 aliases Fragments QUERY 와 MUTATION 오브젝트 타입과 필드 리스트 내부 필수 리스트 외부 필수 스칼라 타입 enumeration types interfaces ApolloQL을 사용한 GraphQL 실습 GraphQL을 활용 할 수 있게 도와주는 다양한 라이브러리들 Apollo GraphQL 사용이유 Npm 설치 Apollo Boost QUERY, MUTATION 사용 용어 - ( 러버덕 ) Graph QL Apollo React 순서 되짚어 보기 상태를 업데이트할 경우, 리렌더링 -&gt; Hook함수를 다 돈 후에 리렌더링한다. 만약, 상태 업데이트 부분이 Hook함수에 포함되어있다면, 모든 Hook을 다 돈 후 리렌더링 -&gt; Hook함수를 돈다. 상태 업데이트 반영은 해당 사이클에 바로 반영되지는 않는다. 다음 사이클에 반영이 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React, &#123; useState, useEffect, useRef &#125; from 'react';// ver. 1function Game() &#123; console.log('1. load'); const [pick, setPick] = useState(''); const [myPick, setMyPick] = useState(''); const [winner, setWinner] = useState(''); const selRef = useRef(null); // ver. 2 const runGame = val =&gt; &#123; const items = ['가위', '바위', '보']; const ranIdx = Math.floor(Math.random() * items.length); setPick(items[ranIdx]); setMyPick(val); &#125;; useEffect(() =&gt; &#123; console.log('3. useEffect1') let _winner; if (pick === '가위') &#123; if (myPick === '가위') _winner = 'none'; if (myPick === '바위') _winner = 'you'; if (myPick === '보') _winner = 'com'; &#125; else if (pick === '바위') &#123; if (myPick === '가위') _winner = 'com'; if (myPick === '바위') _winner = 'none'; if (myPick === '보') _winner = 'you'; &#125; else &#123; if (myPick === '가위') _winner = 'you'; if (myPick === '바위') _winner = 'com'; if (myPick === '보') _winner = 'none'; &#125; setWinner(_winner); &#125;, [pick, myPick]); useEffect(() =&gt; &#123; console.log('4. useEffect2') console.log('winner is ' + winner); &#125;, [winner]); const handleSelChange = () =&gt; &#123; const val = selRef.current.value; runGame(val); console.log(val); &#125; // 1 2 3 4 1 2 return ( &lt;&gt; &#123;winner&#125; &#123;(() =&gt; console.log('2. render'))()&#125; &lt;select ref=&#123;selRef&#125; onChange=&#123;handleSelChange&#125;&gt; &lt;option value=\"가위\"&gt;가위&lt;/option&gt; &lt;option value=\"바위\"&gt;바위&lt;/option&gt; &lt;option value=\"보\"&gt;보&lt;/option&gt; &lt;/select&gt; &lt;/&gt; );&#125;export default Game; GraphQL 만들어진 이유. RESTful API 로는 다양한 기종에서 필요한 정보들을 일일히 구현하는 것이 힘들다. 예로, iOS 와 Android 에서 필요한 정보들이 조금씩 달랐고, 그 다른 부분마다 API 를 구현하는 것이 힘들다. 특정 필드에 대해서 정확히 요청하고 기대한 결과를 얻을 수 있다. 123456789// (백엔드에서 작성된 내용)type Query &#123; me : User&#125;type User &#123; id : ID name : String &#125; type : 변수, 쿼리명을 만들기 위한 키워드Query : 커스텀명ID, String은 기본으로 내장된 Scala Type이다. 필드GraphQL은 객체에 대한 특정 필드를 요청하는 것이 무척 간단하다.아주 간단한 쿼리를 실행하여 얻는 결과를 살펴 보자. 1234567891011121314&#123; hero &#123; name &#125;&#125;#################################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125; &#125;&#125; 쿼리와 결과가 정확히 동일한 형태인 것을 볼 수 있다. 이것이 GraphQL의 핵심이다.name 필드는 String 타입을 반환합니다. 여기서는 스타워즈의 영웅이름인 &quot;R2-D2&quot; 를 반환했다. 필드 - 객체 참조앞의 예제에서는 String 타입인 영웅의 이름만 요청했지만 필드는 객체를 참조할 수도 있다.이 경우 해당 객체에 대한 필드를 하위 선택할 수 있다. GraphQL 쿼리는 연관된 객체와 필드를 탐색 할 수 있으므로 클라이언트는 기존 REST 구조처럼 여러번 요청을 수행하는 대신 한번의 요청으로 많은 데이터를 가져올 수 있다. 추가로, #을 이용해 주석을 달 수도 있다. 12345678910111213141516171819202122232425262728&#123; hero &#123; name # 쿼리에 주석을 쓸 수도 있습니다! friends &#123; name &#125; &#125;&#125;############################################&#123; &quot;data&quot;: &#123; &quot;hero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot;, &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125;, &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125;, &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125; ] &#125; &#125;&#125; 위 예제에서, friends 필드는 배열을 반환한다. GraphQL 쿼리는 단일 아이템이나 배열에 대해 모두 동일해 보이지만 스키마를 기반으로 예상되는 결과를 알 수 있다. 인자객체와 필드를 탐색할 수 있는 것만으로도 GraphQL은 이미 데이터를 가져오는데 굉장히 유용한 언어가 된다. 하지만 필드에 인자를 전달하는 기능을 추가하면, 훨씬 다양한 일을 할 수 있다. 1234567891011121314151617181920212223242526272829303132&#123; human(id: &quot;1000&quot;) &#123; # 인자를 추가한 부분 name height friends&#123; name &#125; &#125;&#125;##########################################&#123; &quot;data&quot;: &#123; &quot;human&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot;, &quot;height&quot;: 1.72, &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Han Solo&quot; &#125;, &#123; &quot;name&quot;: &quot;Leia Organa&quot; &#125;, &#123; &quot;name&quot;: &quot;C-3PO&quot; &#125;, &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125; ] &#125; &#125;&#125; REST에서는 요청에 쿼리 파라미터와 URL 세그먼트같은 단일 인자들만 전달할 수 있다. 하지만 GraphQL에서는 모든 필드와 중첩된 객체가 인자를 가질 수 있으므로 GraphQL은 여러번의 API fetch를 완벽하게 대체할 수 있다. 필드에 인자를 전달하면, 모든 클라이언트에서 개별적으로 처리하는 대신 서버에서 데이터 변환을 한 번만 구현할 수도 있다. 123456789101112131415&#123; human(id: &quot;1000&quot;) &#123; name height(unit: FOOT) &#125;&#125;##################################################&#123; &quot;data&quot;: &#123; &quot;human&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot;, &quot; lheight&quot;: 5.6430448 &#125; &#125;&#125; 인자는 다양한 타입이 될 수 있습니다. 위 예제에서는 열거형(Enumeration) 타입을 사용했다. 이 타입은 다양한 옵션들 (이 경우에는 길이 단위 METER, FOOT) 중 하나를 나타낸다. GraphQL은 기본 타입과 함께 제공되지만, GraphQL 서버는 데이터를 직렬화 할 수 있는 한 직접 커스텀 타입을 선언할 수도 있다. aliases12345678910111213141516171819&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125;######################################&#123; &quot;data&quot;: &#123; &quot;empireHero&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125;, &quot;jediHero&quot;: &#123; &quot;name&quot;: &quot;R2-D2&quot; &#125; &#125;&#125; 위 예제에서 두 hero 필드는 서로 충돌하지만, 서로 다른 이름의 별칭을 지정할 수 있으므로 한 요청에서 두 결과를 모두 얻을 수 있다. Fragments중복된 필드들을 다음과 같이 이용하여 중복을 피할 수 있다. 프래그먼트 개념은 복잡한 응용 프로그램의 데이터 요구사항을 작은 단위로 분할하는데 사용된다. 청크가 다른 여러 UI 구성 요소를 하나의 초기 데이터 fetch로 통합해야하는 경우에 많이 사용된다. 12345678910111213141516&#123; leftComparison: hero(episode: EMPIRE) &#123; ...comparisonFields &#125; rightComparison: hero(episode: JEDI) &#123; ...comparisonFields &#125;&#125;fragment comparisonFields on Character &#123; name appearsIn friends &#123; name &#125;&#125; QUERY 와 MUTATION 일반적인 DB는 “QUERY” 문 - CRUD : CREATE, READ, UPDATE, DELETE GraphQL의 “QUERY” - READ (QUERY는 생략이 가능하다.) GraphQL의 “MUTATION” - CREATE, UPDATE, DELETE gql에서는 굳이 쿼리와 뮤테이션을 나누는데 내부적으로 들어가면 사실상 이 둘은 별 차이가 없다. 쿼리는 데이터를 읽는데(R) 사용하고, 뮤테이션은 데이터를 변조(CUD) 하는데 사용한다는 개념 적인 규약을 정해 놓은 것. @include(if: Boolean)인수가 true인 경우의 필드 만 포함. @skip(if: Boolean) 인수가 true인 경우의 필드를 건너 띔. 12345678query Hero($episode: Episode, $withFriends: Boolean!) &#123; hero(episode: $episode) &#123; name friends @include(if: $withFriends) &#123; name &#125; &#125;&#125; 1234&#123; \"episode\": \"JEDI\", \"withFriends\": false&#125; 오브젝트 타입과 필드12345// 백엔드type Character &#123; name: String! appearsIn: [Episode!]!&#125; 오브젝트 선언 : type 오브젝트 타입(커스텀명) : Character 필드 : name, appearsIn 스칼라 타입 : String, ID, Int 등 느낌표(!) : 필수 값을 의미(non-nullable) 대괄호([, ]) : 배열을 의미(array) 리스트 내부 필수myField1 : List안에 있는 데이터 만 가지고 검사를 한다. 즉, 리스트 중 1개만이라도 null일 경우 에러가 난다. 1myField1: [String!] 1234myField1: null // validmyField1: [] // validmyField1: ['a', 'b'] // validmyField1: ['a', null, 'b'] // error 리스트 외부 필수myField2: List 자체를 검사한다. 즉, 리스트 자체가 null이면 안된다. 리스트들 중 몇개가 null이어도 괜찮다. 1myField2: [String]! 1234myField2: null // errormyField2: [] // validmyField2: ['a', 'b'] // validmyField2: ['a', null, 'b'] // valid 스칼라 타입하위 요소 없이 단일 데이터 자체만 가지고 있는 경우. 배열은 하위 요소가 아니다. 객체 형식의 필드와 값을 가지고 있는 것을 하위 요소라고 함. 하위 필드 값을 가지고 있는 것들은 스칼라 타입이라고 부를 수 없음. enumeration types12345enum Episode &#123; NEWHOPE EMPIRE JEDI&#125; enum 제시 타입중 하나의 타입으로 정의하게 하는 것. (위 예제에서는 3개중 하나) interfaces공통으로 쓸 내용을 interface로 빼 두고, 상속을 시켜줄 수 있다. 단, Java처럼 interface 필드 내용을 그대로 가져와서 쓰는게 아니라 상속받는 타입에서도 interface의 필드 내용을 모두 적어줘야한다. 즉, GraphQL에서는 interface의 내용을 모두 사용하게끔 강요 하는 것이다. 일반적으로 필드 네임은 그대로 유지해야하고, 값은 바꿀수 있다. 123456interface Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]!&#125;: 12345678910111213141516type Human implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! starships: [Starship] totalCredits: Int&#125;type Droid implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String&#125; ApolloQL을 사용한 GraphQL 실습GraphQL을 활용 할 수 있게 도와주는 다양한 라이브러리들gql 자체는 쿼리 언어이다. 이것 만으로는 할 수 있는 것이 없다. gql을 실제 구체적으로 활용 할 수 있도록 도와주는 라이브러리들이 몇가지 존재 하는데, gql 자체는 개발 언어와 사용 네트워크에 완전히 독립적이다. 대표적인 gql 라이브러리인 relay는 GraphQL의 어머니인 Facebook이 만들었다. 하지만, relay는 스키마와 쿼리에 대한 제약이 너무 심한 나머지, 공식 라이브러리에도 불과하고 Apollo graphql 보다 많이 사용되지는 않는다. Apollo GraphQL 사용이유Apollo를 사용하는 가장 큰 이유는 GraphQL이 캐시를 별도로 처리를 못하기 때문이다. 캐쉬란? 데이터를 저장해놔서 빠르게 사용할 수 있도록 임의 보관하는 것. 예를들어, /user/details /user/articles 와 같이 REST API는 요청이 명시적으로 분리되어 있기에 캐쉬화를 할 수 있지만, /graphql 은 분리화가 안되어 있기 때문에 캐쉬화가 거의 불가능하다. (Apollo를 사용한다 해서 브라우저에서 캐시화하는 것이 아니다.) 즉, REST API 는 캐쉬에 대한 문제가 거의 없지만, GraphQL은 단일 주소 /graphql로 요청을 하기 때문에 브라우저 단에서 캐쉬화가 불가능하다. 캐쉬-인메모리 : 캐쉬데이터를 RAM에 저장해주는 것. 백엔드에서 DB 조회를 하는 행위는 1번만 이루어지게 하고, 그 후부터는 다른 사용자가 같은 조회를 할 경우 DB 접속 없이 RAM에서 데이터를 가져오게끔 하는 것. ( 캐쉬 데이터를 빠르게 접근하기 위해서 RAM에다 데이터를 저장한다. - 휘발성 데이터 ) Npm 설치1npm i apollo-client apollo-cache-inmemory apollo-link-http graphql graphql-tag react-apollo apollo-client : Apollo에서 제공해주는 GraphQL 클라이언트 관련 라이브러리. apollo-cache-inmemory apollo-link-http는 Apollo에서 제공하는 GraphQL 클라이언트 관련 라이브러리. graphql : Facebook에 정의한 GraphQL 스팩을 JavaScript 언어로 구현한 패키지 graphql-tag : GraphQL 쿼리를 파싱해주는 템플릿 리터럴 태그. react-apollo : React 앱에 Apollo Client를 연결(Integration)해주는 패키지 Apollo Boost위 NPM 설치 과정 중 apollo-client, chche-inmemory,apollo-link-http 를 포함하고 있는 아주 고마운 패키지. Apollo Boost : Graph QL 클라이언트를 가지기 위한 셋팅을 전부 해준다. 12345678910111213141516171819import React from 'react';import &#123; ApolloProvider &#125; from 'react-apollo';import &#123; ApolloClient &#125; from 'apollo-boost';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';const cache = new InMemoryCache()const GITHUB_BASE_URL = 'https://api.github.com/graphql'const client = new ApolloClient(&#123; uri: GITHUB_BASE_URL, request: operation =&gt; &#123; operation.setContexty(&#123; headers : &#123; authorization : `Bearer $&#123;process.env.REACT_APP_GITHUB_API_TOKEN&#125;` &#125; &#125;) &#125;, cache&#125;) QUERY, MUTATION 사용1npm i @apollo/react-hooks 아폴로에서 쿼리와 뮤테이션을 처리할 수 있도록 만든 모듈. 클래스 기반의 프로젝트일 경우 query 컴포넌트 형태로 쓰면 되고, 훅 기반일 경우 @apollo/react-hooks의 모듈을 사용한다. 쿼리와 뮤테이션 작성은 대문자로 한다. QUERY 123456789101112131415161718192021222324252627import gql from 'graphql-tag'const reposQuery = gql`query Myrepositories&#123; viewer &#123; repositories(first:5) &#123; edges &#123; node &#123; id name stargazers&#123; totalCount &#125; viewerHasStarred &#125; &#125; &#125; &#125;&#125;`const userQuery = gql` &#123; viewer &#123; name email &#125;&#125;`export &#123; reposQuery, userQuery &#125;; MUTATION 1234567891011121314151617181920212223242526import &#123; gql &#125; from 'graphql-tag'const ADD_STAR = gql`mutation AddStar($repoid:ID!)&#123; addStar(input:&#123;starrableId:$repoid&#125;)&#123; # 리턴할 값 명시 starrable&#123; stargazers&#123; totalCount &#125; viewerHasStarred &#125; &#125;&#125;`const REMOVE_STAR = gql`mutation RemoveStar($repoid:ID!)&#123; removeStar(input:&#123;starrableId:$repoid&#125;)&#123;] # 리턴할 값 명시 starrable&#123; stargazers&#123; totalCount &#125; viewerHasStarred &#125; &#125;&#125;`export &#123; ADD_STAR, REMOVE_STAR &#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 16","slug":"react-study-16","date":"2020-01-13T12:26:29.000Z","updated":"2020-01-13T12:28:24.579Z","comments":true,"path":"2020/01/13/react-study-16/","link":"","permalink":"https://hyeok999.github.io/2020/01/13/react-study-16/","excerpt":"","text":"React Study 16 가위 바위 보 미니 게임 만들기 Ver1. 기본 프로젝트 구성하기. 개요 : 가위 바위 보 게임, Rock Paper Scissors State 생성 및 이벤트 생성해주기. User가 선택한 수(가위, 바위, 보) 값 설정해주기. Computer에게 Random 값 설정해주기. 승리자 결정하기 ( useEffect ) Ver1. 전체코드 Ver2. 클릭버튼을 Select박스로 변경하기 useRef 사용 하기. Ver2. 전체코드 Ver3. useReducer 적용, 전적표 만들기 useReducer 추가 하기. reducer() 추가 하기. useEffect 내부에 dispatch 추가해주기. 전적표 화면 렌더링 및 초기화 버튼, 초기화 dispatch 추가하기. Ver3. 전체코드 Graph QL - Graph + Query + Language 디자인 vs DB Github api - GraphQL 실습 GraphiQL 다운로드 Endpoint 설정 HTTP Headers 설정 실습 기본 쿼리 보내기 중복된 요청 시 네이밍 하기. fragment 키워드를 이용하여 중복요소 합치기 QUERY , MUTATION 용어 - ( 러버덕 ) useEffect useReducer useRef GraphQL QUERY MUTATION 가위 바위 보 미니 게임 만들기개요 : 가위 바위 보 게임, Rock Paper Scissors 값 : [‘가위’, ‘바위’, ‘보’] 사용자가 입력한 값 컴퓨터가 랜덤으로 생성한 값 Ver1. 기본 프로젝트 구성하기.State 생성 및 이벤트 생성해주기. 12345678910111213141516import React, &#123; useEffect, useState, useRef &#125;from 'react'const App = (props) =&gt; &#123; const [pick, setPick] = useState(null); const [myPick, setMyPick] = useState(null); const [winner, setWinner] = useState(null); return ( &lt;&gt; &#123;winner&#125; &lt;button onClick=&#123;() =&gt; runGame('가위')&#125;&gt;가위&lt;/button&gt; &lt;button onClick=&#123;() =&gt; runGame('바위')&#125;&gt;바위&lt;/button&gt; &lt;button onClick=&#123;() =&gt; runGame('보')&#125;&gt;보&lt;/button&gt; &lt;/&gt; );&#125; myPick : Computer가 선택한 가위, 바위, 보myPick : User가 선택한 가위, 바위, 보winner : Computer 혹은 User 중 이긴 상태 ####User가 선택한 수(가위, 바위, 보) 값 설정해주기. 123const runGame = (value) =&gt; &#123; setMyPick(value);&#125; Computer에게 Random 값 설정해주기. 난수를 발생시키는 함수 : Math.random() - 수학적으로 안전한 랜덤값은 아니다.소수점 내림 : Math.floor() 위 2개의 함수를 이용해서 랜덤 정수를 만들어 낸다. 특정한 정수 범위 내에서 랜덤 값 만드는 방법 12// 최저값 + Math.floor(Math.random() + (최고값 - 최저값))0 + Math.floor(Math.random() * (Max - Min)) 절대 최대값을 넘을 수 없는 난수를 발생시키는 식으로 최저값~최고값 사이의 정수를 난수로 발생시켜 줌 버튼을 클릭할때마다 난수가 바뀌어야 함 1234567const runGame = (value) =&gt; &#123; const items = ['가위', '바위', '보']; const randomIndex = Math.floor(Math.random() * items.length); setPick(items[randomIndex]); setMyPick(value); // 여기서는 승패의 여부에 대한 로직을 구현할 수 없다.&#125; runGame 함수 내부에서 승패의 여부에 대한 로직을 구현할 수 없는 이유는 runGame함수 내부에서는 pick값을 바로 확인할 수 없기 때문이다. setPick 과 setMyPick이 비동기로 동작한다. 따라서, useEffect 에서 확인해야만 한다. - 렌더링 이후 동작하기 떄문 승리자 결정하기 ( useEffect ) 123456789101112131415161718192021222324useEffect(() =&gt; &#123; let _winner = ''; // 누가 이겼는지 표현하기 위한 값 : 'computer' , 'user' // pick : 컴퓨터, myPick : 사용자가 클릭한 value if (pick === '가위') &#123; if (myPick === '바위') _winner = 'user' if (myPick === '보') _winner = 'computer' if (myPick === '가위') _winner = 'none' &#125; else if(pick === '바위' ) &#123; if (myPick === '바위') _winner = 'none' if (myPick === '보') _winner = 'user' if (myPick === '가위') _winner = 'computer' &#125; else if(pick === '보' ) &#123; if (myPick === '바위') _winner = 'computer' if (myPick === '보') _winner = 'none' if (myPick === '가위') _winner = 'user' &#125; setWinner(_winner);&#125;, [pick, myPick])useEffect(() =&gt; &#123; console.log('컴퓨터, ', pick); console.log('사용자, ', myPick); console.log('우승자, ', winner);&#125;, [winner]) Ver1. 전체코드 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, &#123; useEffect, useState, useRef &#125;from 'react'const App = (props) =&gt; &#123; console.log('load'); const [pick, setPick] = useState(null); const [myPick, setMyPick] = useState(null); const [winner, setWinner] = useState(null); const runGame = (value) =&gt; &#123; const items = ['가위', '바위', '보']; const randomIndex = Math.floor(Math.random() * items.length); setPick(items[randomIndex]); setMyPick(value); // 여기서는 승패의 여부에 대한 로직을 구현할 수 없다. &#125; useEffect(() =&gt; &#123; let _winner = ''; // 누가 이겼는지 표현하기 위한 값 : 'computer' , 'user' // pick : 컴퓨터, myPick : 사용자가 클릭한 value if (pick === '가위') &#123; if (myPick === '바위') _winner = 'user' if (myPick === '보') _winner = 'computer' if (myPick === '가위') _winner = 'none' &#125; else if(pick === '바위' ) &#123; if (myPick === '바위') _winner = 'none' if (myPick === '보') _winner = 'user' if (myPick === '가위') _winner = 'computer' &#125; else if(pick === '보' ) &#123; if (myPick === '바위') _winner = 'computer' if (myPick === '보') _winner = 'none' if (myPick === '가위') _winner = 'user' &#125; setWinner(_winner); &#125;, [pick, myPick]) useEffect(() =&gt; &#123; console.log('컴퓨터, ', pick); console.log('사용자, ', myPick); console.log('우승자, ', winner); &#125;, [winner]) return ( &lt;&gt; &#123;winner&#125; &lt;button onClick=&#123;() =&gt; runGame('가위')&#125;&gt;가위&lt;/button&gt; &lt;button onClick=&#123;() =&gt; runGame('바위')&#125;&gt;바위&lt;/button&gt; &lt;button onClick=&#123;() =&gt; runGame('보')&#125;&gt;보&lt;/button&gt; &lt;/&gt; );&#125;export default App; Ver2. 클릭버튼을 Select박스로 변경하기useRef 사용 하기. 먼저 useRef를 사용하기 위해서 선언부터 해준다. (당연히 import도 추가해햐 한다.) 1const selectRef = useRef(null); 추가로 &lt;select&gt; 태그를 선택하기 위해서 ref={selectRef}로 선택해주고 onChange 이벤트를 걸어준다. handleSelectChange 함수에서는 현재 &lt;select&gt; 에서 선택된 value값을 토대로 runGame함수를 실행한다. 참고로 useRef는 createRef와 다르게 값이 변하더라도 리렌더링을 유발하지 않는다는 것을 기억하자. 12345678910111213141516const handleSelectChange = () =&gt; &#123; const value = selectRef.current.value; runGame(value); console.log(value); // useRef는 리렌더링을 유발하지 않는다.&#125;return ( &lt;&gt; &#123;winner&#125; &lt;select ref=&#123;selectRef&#125; onChange=&#123;handleSelectChange&#125;&gt; &lt;option value=\"가위\"&gt;가위&lt;/option&gt; &lt;option value=\"바위\"&gt;바위&lt;/option&gt; &lt;option value=\"보\"&gt;보&lt;/option&gt; &lt;/select&gt; &lt;/&gt;); 추가로, 변수에 ref를 바인딩 할때는 ref =&gt; input = ref처럼 화살표 함수를 사용했지만 useRef 사용 시에는 ref={selRef}와 같이 사용한다. 1234// 일반 변수ref=&#123;ref =&gt; input = ref&#125;// useRef 사용시ref=&#123;selRef&#125; Ver2. 전체코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React, &#123; useEffect, useState, useRef, useReducer &#125;from 'react'const App = (props) =&gt; &#123; console.log('load'); const [pick, setPick] = useState(null); const [myPick, setMyPick] = useState(null); const [winner, setWinner] = useState(null); const selectRef = useRef(null); const runGame = (value) =&gt; &#123; const items = ['가위', '바위', '보']; const randomIndex = Math.floor(Math.random() * items.length); setPick(items[randomIndex]); setMyPick(value); // 여기서는 승패의 여부에 대한 로직을 구현할 수 없다. &#125; useEffect(() =&gt; &#123; let _winner = ''; // 누가 이겼는지 표현하기 위한 값 : 'computer' , 'user' // pick : 컴퓨터, myPick : 사용자가 클릭한 value if (pick === '가위') &#123; if (myPick === '바위') _winner = 'user' if (myPick === '보') _winner = 'computer' if (myPick === '가위') _winner = 'none' &#125; else if(pick === '바위' ) &#123; if (myPick === '바위') _winner = 'none' if (myPick === '보') _winner = 'user' if (myPick === '가위') _winner = 'computer' &#125; else if(pick === '보' ) &#123; if (myPick === '바위') _winner = 'computer' if (myPick === '보') _winner = 'none' if (myPick === '가위') _winner = 'user' &#125; setWinner(_winner); // 기록을 해주는 로직을 추가한다. &#125;, [pick, myPick]) useEffect(() =&gt; &#123; console.log('컴퓨터, ', pick); console.log('사용자, ', myPick); console.log('우승자, ', winner); &#125;, [winner]) const handleSelectChange = () =&gt; &#123; const value = selectRef.current.value; runGame(value); console.log(value); // useRef는 리렌더링을 유발하지 않는다. &#125; return ( &lt;&gt; &#123;winner&#125; &lt;select ref=&#123;selectRef&#125; onChange=&#123;handleSelectChange&#125;&gt; &lt;option value=\"가위\"&gt;가위&lt;/option&gt; &lt;option value=\"바위\"&gt;바위&lt;/option&gt; &lt;option value=\"보\"&gt;보&lt;/option&gt; &lt;/select&gt; &lt;/&gt; );&#125;export default App; Ver3. useReducer 적용, 전적표 만들기useReducer 추가 하기. 먼저 useReducer를 사용하기 위해서 선언부터 해준다. (당연히 import도 추가해햐 한다.) useReducer를 통해 관리 되는 상태의 초기화는 빈배열로 한다. 1const [state, dispatch] = useReducer(reducer, []); reducer() 추가 하기. useReducer에서 사용할 리듀서를 추가한다. 리듀서에서는 객체의 상태를 덮어씌우는 형식으로 작동하기 때문에 기존의 값을 스프레드 불러와서 유지를 시켜줘야 하는 것에 꼭 주의하자. 참고로, Redux의 경우reducer action에서 대문자를 사용하지만 useReducer는 대/소문자 구별이 자유롭다. 12345678910111213141516171819202122232425262728293031323334const reducer = (state, action) =&gt; &#123; const data = state.history; switch (action.type) &#123; case 'ADD': return &#123; ...state, // 게임 기록 유지 history : data ? [ ...data, action.newGame ] // 초기 상태가 아닐 경우(기존 데이터를 갖고 있을 때) : [action.newGame] // 초기 상태인 경우(갖고 있는 데이터가 없을 때) &#125; case 'RESULT' : let _comWin, _userWin if(action.winner === 'computer') &#123; _comWin = state.comWin ? parseInt(state.comWin, 10) + 1 // 10진수 정수형태로 변환 : 1 &#125; if(action.winner === 'user') &#123; _userWin = state.userWin ? parseInt(state.userWin, 10) + 1 : 1 &#125; return &#123; ...state, comWin: _comWin || state.comWin, userWin: _userWin || state.userWin &#125; case 'RESET': return &#123;&#125;; &#125;&#125; useEffect 내부에 dispatch 추가해주기. dispatch 를 추가한다. 위치는 _winner가 선언된곤 제일 하단에 해주어야한다. 123456789101112131415161718192021222324useEffect(() =&gt; &#123; let _winner = ''; // 누가 이겼는지 표현하기 위한 값 : 'computer' , 'user' // pick : 컴퓨터, myPick : 사용자가 클릭한 value if (pick === '가위') &#123; if (myPick === '바위') _winner = 'user' if (myPick === '보') _winner = 'computer' if (myPick === '가위') _winner = 'none' &#125; else if(pick === '바위' ) &#123; if (myPick === '바위') _winner = 'none' if (myPick === '보') _winner = 'user' if (myPick === '가위') _winner = 'computer' &#125; else if(pick === '보' ) &#123; if (myPick === '바위') _winner = 'computer' if (myPick === '보') _winner = 'none' if (myPick === '가위') _winner = 'user' &#125; // 기록을 해주는 로직을 추가한다. if (_winner) &#123; setWinner(_winner); dispatch(&#123; type: 'ADD', newGame: `$&#123;_winner&#125;가 이겼습니다.(컴퓨터: $&#123;pick&#125; / 유저: $&#123;myPick&#125;)` &#125;) dispatch(&#123; type: 'RESULT', winner: _winner&#125;) &#125; &#125;, [pick, myPick]) 전적표 화면 렌더링 및 초기화 버튼, 초기화 dispatch 추가하기. 1234567891011121314151617181920 const &#123; history, comWin, userWin &#125; = state return ( &lt;&gt; 우승자 : &#123;winner&#125; &lt;br/&gt; 컴퓨터 : &#123;comWin || 0&#125; , 유저 : &#123;userWin || 0&#125; &lt;br/&gt; &lt;select ref=&#123;selectRef&#125; onChange=&#123;handleSelectChange&#125;&gt; &lt;option value=\"가위\"&gt;가위&lt;/option&gt; &lt;option value=\"바위\"&gt;바위&lt;/option&gt; &lt;option value=\"보\"&gt;보&lt;/option&gt; &lt;/select&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'RESET'&#125;)&#125;&gt;초기화&lt;/button&gt; &#123; history &amp;&amp; history.map((h, index) =&gt; &lt;h1 key=&#123;index&#125;&gt;&#123;h&#125;&lt;/h1&gt; ) //전적표 &#125; &lt;/&gt; );&#125; Ver3. 전체코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import React, &#123; useEffect, useState, useRef, useReducer &#125;from 'react'const reducer = (state, action) =&gt; &#123; const data = state.history; // eslint-disable-next-line default-case switch (action.type) &#123; case 'ADD': return &#123; ...state, // 게임 기록 유지 history : data ? [ ...data, action.newGame ] : [action.newGame] &#125; case 'RESULT' : let _comWin, _userWin if(action.winner === 'computer') &#123; _comWin = state.comWin ? parseInt(state.comWin, 10) + 1 : 1 &#125; if(action.winner === 'user') &#123; _userWin = state.userWin ? parseInt(state.userWin, 10) + 1 : 1 &#125; return &#123; ...state, comWin: _comWin || state.comWin, userWin: _userWin || state.userWin &#125; case 'RESET': return &#123;&#125;; &#125;&#125;const App = (props) =&gt; &#123; // 0 ~ 2 console.log('load'); const [pick, setPick] = useState(null); const [myPick, setMyPick] = useState(null); const [winner, setWinner] = useState(null); const selectRef = useRef(null); const [state, dispatch] = useReducer(reducer, []); const runGame = (value) =&gt; &#123; const items = ['가위', '바위', '보']; const randomIndex = Math.floor(Math.random() * items.length); setPick(items[randomIndex]); setMyPick(value); // 여기서는 승패의 여부에 대한 로직을 구현할 수 없다. &#125; useEffect(() =&gt; &#123; let _winner = ''; // 누가 이겼는지 표현하기 위한 값 : 'computer' , 'user' // pick : 컴퓨터, myPick : 사용자가 클릭한 value if (pick === '가위') &#123; if (myPick === '바위') _winner = 'user' if (myPick === '보') _winner = 'computer' if (myPick === '가위') _winner = 'none' &#125; else if(pick === '바위' ) &#123; if (myPick === '바위') _winner = 'none' if (myPick === '보') _winner = 'user' if (myPick === '가위') _winner = 'computer' &#125; else if(pick === '보' ) &#123; if (myPick === '바위') _winner = 'computer' if (myPick === '보') _winner = 'none' if (myPick === '가위') _winner = 'user' &#125; // 기록을 해주는 로직을 추가한다. if (_winner) &#123; setWinner(_winner); dispatch(&#123; type: 'ADD', newGame: `$&#123;_winner&#125;가 이겼습니다.(컴퓨터: $&#123;pick&#125; / 유저: $&#123;myPick&#125;)` &#125;) dispatch(&#123; type: 'RESULT', winner: _winner&#125;) &#125; &#125;, [pick, myPick]) useEffect(() =&gt; &#123; console.log('컴퓨터, ', pick); console.log('사용자, ', myPick); console.log('우승자, ', winner); &#125;, [winner]) const handleSelectChange = () =&gt; &#123; const value = selectRef.current.value; runGame(value); console.log(value); // useRef는 리렌더링을 유발하지 않는다. &#125; const &#123; history, comWin, userWin &#125; = state return ( &lt;&gt; 우승자 : &#123;winner&#125; &lt;br/&gt; 컴퓨터 : &#123;comWin || 0&#125; / 유저 : &#123;userWin || 0&#125; &lt;br/&gt; &lt;select ref=&#123;selectRef&#125; onChange=&#123;handleSelectChange&#125;&gt; &lt;option value=\"가위\"&gt;가위&lt;/option&gt; &lt;option value=\"바위\"&gt;바위&lt;/option&gt; &lt;option value=\"보\"&gt;보&lt;/option&gt; &lt;/select&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'RESET'&#125;)&#125;&gt;초기화&lt;/button&gt; &#123; history &amp;&amp; history.map((h, index) =&gt; &lt;h1 key=&#123;index&#125;&gt;&#123;h&#125;&lt;/h1&gt; ) &#125; &lt;/&gt; );&#125;export default App; Graph QL - Graph + Query + Language GraphQL은 페이스북에서 만든 쿼리 언어이다. 모든 데이터를 그래프처럼 연결을 하여 한번의 Query Language로 원하는 값을 도출하는 것. REST API의 단점 : 원하는 데이터가 서로 엮어져 있을 때 게속해서 GET, POST 등의 통신을 이용해 원하는 데이터를 얻을 때까지 타고 타고 들어가는 현상. GraphQL은 1번의 요청으로 REST API의 단점을 보완할 수 있다. 쿼리를 사용한다. DSL: Domain Specific Language 사용 - GraphQL 사용가능한 언어 123456789101112131415// gql의 요청문&#123; hero &#123; name &#125;&#125;// 응답 내용&#123; \"date\" : &#123; \"hero\" : &#123; \"name\" : \"R2-D2\" &#125; &#125;&#125; 디자인 vs DB REST API는 모든 로직에 대해서 각각의 다른 주소를 가지고 있기 때문에 그만큼 url을 만들고 사용해야 한다. XML은 JSON과 같은 데이터를 표현해줄 떄 사용한다. 다만 XML은 JSON이 표현하기 복잡한 데이터들을 표현해줄 떄 주로 이용한다. Microsoft의 pptx, xmlx 같은 것도 XML이고, 공공기관의 API들도 XML을 주로 이용한다. REST API의 단점 예시: 특정 유저가 작성한 모든 글을 가지고 오고 싶을 때. /users/1을 요청 할 경우, 여러가지 정보중 article에 대한 주소를 반환해준다. 그렇다면 또, /article 로 요청을 해서 /users/1에 대한 내용들을 가지고 와야한다. 즉, 일을 2번 해야되는데 GraphQL은 이러한 절차를 1번으로 줄여서 사용이 가능하다. 다시 얘기하면 받은 배열( { article: [1, 2, 3, 4, …] }에 대해 다시 아티클을 계속 요청해야 하므로 퍼포먼스가 저하된다는 것. Github api - GraphQL 실습 준비사항 GitHub Page 자기 프로필 settings Developer settings Personal access tokens repo, read:packages, user, workflow 체크(외 사용할 것 있다면 더 체크) Note 에 내용 적고 토큰생성 GraphiQL 다운로드 GraphiQL - 0.7.2.dmg 다운로드 하였음. Endpoint 설정 https://api.github.com/graphql Method는 POST로 한다. GraphQL은 쿼리로 오직 graphql 만 작성하는데, GET을 할 경우, 쿼리 스트링이 엄청나게 길어지기 때문에 이를 방지하기 위함이다. HTTP Headers 설정 Header name : Authorization Header value : Bearer 토큰값 ( Bearer은 Header에 붙여주는 규칙같은 것 ) 실습기본 쿼리 보내기 123456&#123; viewer &#123; name url &#125;&#125; 중복된 요청 시 네이밍 하기. 똑같은 요청을 여러번 보낼 때는 앞에 네이밍이 필요하다. (네이밍은 한개만 지어줘도 되나 둘 다 짓는 것을 권장) 1234567891011121314151617181920212223// 같은 요청을 두 번 보내면 에러 발생&#123; organization(login: \"reactjs\") &#123; name url &#125; organization(login: \"react\") &#123; name url &#125;&#125;// 네이밍 (한개만 네이밍 지어줘도 된다.)&#123; reactjs: organization(login: \"reactjs\") &#123; name url &#125; react: organization(login: \"react\") &#123; name url &#125;&#125; fragment 키워드를 이용하여 중복요소 합치기 12345678910111213&#123; reactjs: organization(login : \"reactjs\") &#123; ...sharedOrganizationFields &#125; organization(login : \"react\") &#123; ...sharedOrganizationFields &#125;&#125;fragment sharedOrganizationFields on Organization &#123; name url&#125; QUERY , MUTATION 일반 DB의 query : CRUD(CREATE READ UPDATE DELETE) GraphQL의 query : READ - 데이터 조회 기능 GraphQL의 mutation : CREATE UPDATE DELETE - 데이터 조회를 제외한 나머지 기능 쿼리문에 변수를 넣을 수 있으며 이로 인해 불필요한 중복을 줄일 수 있음 쿼리의 타입은 백엔드에서 알려줄 것 String 뒤 !가 반드시 오거나, 명시적으로 초기화 해주어야 한다. (예: String! 또는 String = “reactjs”) $는 변수를 생성하기 위한 키워드 1234567891011121314// 변수로 했을 경우, 타입은 무조건 있어야 한다.// !는 해당 데이터 타입을 강제로 고정 하는 것. // $는 변수를 생성하기 위한 키워드query ($organization: String!) &#123; organization(login : $organization) &#123; name url &#125;&#125;// QUERY VERIABLES&#123; \"organization\": \"reactjs\"&#125; QUERY VERIABLES를 작성하지 않고 기본으로 다음처럼 넘겨줄수 있다. 1234567// QUERY VERIABLES를 작성하지 않고 기본으로 다음처럼 넘겨줄수 있다.query ($organization: String = \"reactjs\") &#123; organization(login : $organization) &#123; name url &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"배열에 항목 제거하기","slug":"react-velo-12","date":"2020-01-11T14:11:07.000Z","updated":"2020-01-11T14:12:51.439Z","comments":true,"path":"2020/01/11/react-velo-12/","link":"","permalink":"https://hyeok999.github.io/2020/01/11/react-velo-12/","excerpt":"","text":"React with Velopert - 12 - 배열에 항목 제거하기 예제 : 배열 항목 삭제하기 삭제 버튼 렌더링 : UserList.js 삭제 함수 onRemove 구현 및 전달 : App.js Chap 12. 배열에 항목 제거하기배열에 항목 제거하기 UserList 에서 각 User 컴포넌트를 보여줄 때, 삭제 버튼을 렌더링해주자. 예제 : 배열 항목 삭제하기삭제 버튼 렌더링 : UserList.js 12345678910111213141516171819202122import React from 'react';function User(&#123; user, onRemove &#125;) &#123; return ( &lt;div&gt; &lt;b&gt;&#123;user.username&#125;&lt;/b&gt; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;button onClick=&#123;() =&gt; onRemove(user.id)&#125;&gt;삭제&lt;/button&gt; &lt;/div&gt; );&#125;function UserList(&#123; users, onRemove &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; onRemove=&#123;onRemove&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default UserList; User 컴포넌트의 삭제 버튼이 클릭 될 때는 user.id 값을 앞으로 props로 받아올 onRemove 함수의 파라미터로 넣어서 호출해야한다. 삭제 함수 onRemove 구현 및 전달 : App.js User 컴포넌트의 삭제 버튼이 클릭 될 때는 user.id 값을 앞으로 props 로 받아올 onRemove 함수의 파라미터로 넣어서 호출해야 한다. 여기서 onRemove “id 가 __인 객체를 삭제해라” 라는 역할을 가지고 있는데 onRemove 함수는 UserList 에서도 전달 받을것이며, 이를 그대로 User 컴포넌트에게 전달해줄것이다. 이제, onRemove 함수를 구현해자. 배열에 있는 항목을 제거할 때에는, 추가할 때 와 마찬가지로 불변성을 지켜가면서 업데이트를 해주어야 한다. 불변성을 지키면서 특정 원소를 배열에서 제거하기 위해서는 filter 배열 내장 함수를 사용한다. 이 함수는 배열에서 특정 조건이 만족하는 원소들만 추출하여 새로운 배열을 만들어준다. App 컴포넌트에서 onRemove 를 다음과 같이 구현후, UserList 에게 전달해 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; useRef, useState &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;; const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]); const nextId = useRef(4); const onCreate = () =&gt; &#123; const user = &#123; id: nextId.current, username, email &#125;; setUsers(users.concat(user)); setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; &#125;; const onRemove = id =&gt; &#123; // user.id 가 파라미터로 일치하지 않는 원소만 추출해서 새로운 배열을 만듬 // = user.id 가 id 인 것을 제거함 setUsers(users.filter(user =&gt; user.id !== id)); &#125;; return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; onRemove=&#123;onRemove&#125; /&gt; &lt;/&gt; );&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"배열에 항목 추가하기","slug":"react-velo-11","date":"2020-01-11T09:26:35.000Z","updated":"2020-01-11T14:09:11.913Z","comments":true,"path":"2020/01/11/react-velo-11/","link":"","permalink":"https://hyeok999.github.io/2020/01/11/react-velo-11/","excerpt":"","text":"React with Velopert - 11 - 배열에 항목 추가하기 예제 : 배열에 새로운 항목을 추가하기 새로운 컴포넌트 작성 : CreateUser.js 상태관리 추가 : App.js 1차 최종 코드 : App.js 배열 상태관리 추가 : App.js Spread 연산자 이용 최종 코드: App.js concat 함수 이용 최종 코드: App.js Chap 11. 배열에 항목 추가하기배열에 항목 추가하기 배열에 새로운 항목을 추가하는 방법에 대해서 알아보자. 우선 src폴더에 input 와 button 이 하나루 이루어진 컴포넌트, CreateUser.js 를 만들어보자. 예제 : 배열에 새로운 항목을 추가하기새로운 컴포넌트 작성 : CreateUser.js 1234567891011121314151617181920212223import React from 'react';function CreateUser(&#123; username, email, onChange, onCreate &#125;) &#123; return ( &lt;div&gt; &lt;input name=\"username\" placeholder=\"계정명\" onChange=&#123;onChange&#125; value=&#123;username&#125; /&gt; &lt;input name=\"email\" placeholder=\"이메일\" onChange=&#123;onChange&#125; value=&#123;email&#125; /&gt; &lt;button onClick=&#123;onCreate&#125;&gt;등록&lt;/button&gt; &lt;/div&gt; );&#125;export default CreateUser; 이번에는 상태 관리를 CreateUser 에서 하지 않고 부모 컴포넌트인 App에서 하게 하고, input 의 값 및 이벤트로 등록할 함수들을 props로 넘겨받아서 사용하도록 하자. 상태관리 추가 : App.js먼저 App.js에서 상태를 관리해주기 위해서 useState Hook을 사용하도록 한다. 1import React, &#123; useState ,useRef &#125; from 'react'; 추가로 function App() 내부에 CreateUser 컴포넌트에게 넘겨줄 상태 변수들을 정의하구 값을 할당한다. 1234567891011121314// 상태 설정const [inputs, setInputs] = useState(&#123; username: '', email: ''&#125;); const &#123; username, email &#125; = inputs; // 객체 비구조화(디스트럭처링) 할당const onChange = e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;);&#125;; 여기에 등록 버튼이 눌릴 경우 input 박스들을 비워주는 초기화 작업을 해주어야 하기 때문에 onCreate 내부에 상태를 관리함수를 추가한다. 123456789const onCreate = () =&gt; &#123; // 나중에 구현 할 배열에 항목 추가하는 로직 // ... setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; // current : 5&#125;; 1차 최종 소스 : App.js 마지막으로 return에 CreateUser 컴포넌트를 작성해주고 지금까지 작성한 상태와 함수들을 속성으로 전달한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, &#123; useState ,useRef &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;; const users = [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]; const nextId = useRef(4); // current : 4 const onCreate = () =&gt; &#123; // 나중에 구현 할 배열에 항목 추가하는 로직 // ... nextId.current += 1; // current : 5 &#125;; return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; /&gt;; &lt;/&gt; )&#125;export default App; 배열 상태관리 추가 : App.js 12345678910111213141516171819const users = [ // 이부분을 아래처럼 수정 하기 const [users, setUsers] = useState([ // useState로 관리시작 &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125;]); 배열의 변화를 주기 위해서 상태로 관리하기 시작한다. 배열에 변화를 줄 때에는 객체와 마찬가지로, 불변성을 지켜주어야 한다. 그렇기 때문에, 배열의 push, splice, sort 등의 함수를 사용하면 안된다. 만약에 사용해야 한다면, 기존의 배열을 한번 복사하고 나서 사용해야한다. 불변성을 지키면서 배열에 새 항목을 추가 할 때에는 spread 연산자를 사용하거나, concat 함수를 사용하면 된다. 1. Spread 연산자 이용 최종 코드: App.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; useState, useRef &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = e =&gt; &#123; const &#123;name, value&#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;; const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]); const nextId = useRef(4); // current : 4 const onCreate = () =&gt; &#123; const user = &#123; // 이부분 추가 id: nextId.current, username, email &#125;; setUsers([...users, user]); // spread를 이용하여 기존의 users 데이터와 함꼐 추가하고 있다. setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; // current : 5 &#125;; return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; /&gt; &lt;/&gt; )&#125;export default App; 2. concat 함수 이용 최종 코드: App.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React, &#123; useRef, useState &#125; from 'react';import UserList from './UserList';import CreateUser from './CreateUser';function App() &#123; const [inputs, setInputs] = useState(&#123; username: '', email: '' &#125;); const &#123; username, email &#125; = inputs; const onChange = e =&gt; &#123; const &#123; name, value &#125; = e.target; setInputs(&#123; ...inputs, [name]: value &#125;); &#125;; const [users, setUsers] = useState([ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]); const nextId = useRef(4); const onCreate = () =&gt; &#123; const user = &#123; // 이부분 추가 id: nextId.current, username, email &#125;; setUsers(users.concat(user)); // 기존의 users데이터에 함수를 덮붙이는 기능을 하는 concat함수를 이용했다. setInputs(&#123; username: '', email: '' &#125;); nextId.current += 1; &#125;; return ( &lt;&gt; &lt;CreateUser username=&#123;username&#125; email=&#123;email&#125; onChange=&#123;onChange&#125; onCreate=&#123;onCreate&#125; /&gt; &lt;UserList users=&#123;users&#125; /&gt; &lt;/&gt; );&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React Grid Mini Project","slug":"react-grid-mini-project","date":"2020-01-09T18:35:19.000Z","updated":"2020-03-09T09:04:22.561Z","comments":true,"path":"2020/01/10/react-grid-mini-project/","link":"","permalink":"https://hyeok999.github.io/2020/01/10/react-grid-mini-project/","excerpt":"","text":"React Grid Mini Project개요 커스텀 훅, useReducer, useCallback에 대한 학습을 위한 프로젝트를 구현해본다. 해당 프로젝트는 각각의 요소를 상태로서 관리를 하고 이전의 상태 , 현재의 상태, 미래의 상태를 각각 관리를 하는 방식으로 진행한다. 목차 화면 UI 보여주기 useState를 이용하여 set이벤트 구현(요소 클릭시 색깔 변화 확인) useHistory 커스텀 훅 만들어서 state와 set 연동하기 Clear구현하기 useReducer 적용하기 Undo, Redo 구현 전 초기 상태 셋팅 및 적용하기 Undo구현하기 Redo구현하기 canUndo, canRedo구현하기 useCallback으로 최적화하기 및 반복 렌더링 방지하기 느낀점 Git에서 소스보기 1. 화면 UI 보여주기 해당 프로젝트의 폴더 구조는 다음과 같다. 123src/styles.scsssrc/Main.jssrc/hooks/useHistory.js 먼저 UI를 구현하도록 한다.UI는 함수형 컴포넌트 형태로 구현을 하도록 한다.(클래스도 상관은 없다.) 123456789101112131415161718192021222324// src/Main.js : 상위 컴포넌트import React from 'react'import './styles.scss'const Main = (props) =&gt; &#123; return ( &lt;div className=\"container\"&gt; &lt;div className=\"controls\"&gt; &lt;button&gt; Undo &lt;/button&gt; &lt;button&gt; Redo &lt;/button&gt; &lt;button&gt;Clear&lt;/button&gt; &lt;/div&gt; &lt;div className=\"grid\"&gt; &#123;/* 1번. 선택 박스 요소 */&#125; &lt;/div&gt; &lt;/div&gt; );&#125;export default Main; 현재 만들고자 하는 UI의 박스 요소 개수는 총 625개다. 이것을 그리는 방법은 미리 배열에 저장해두고 map 함수를 이용하여 렌더링 하는 방식도 있지만, 즉시실행함수를 이용해서 즉석에서 바로 그리는것으로 하자. 따라서 반복문을 사용해야하는 데 여기서는 while문을 이용한다. 즉시 실행 함수에서 필요한 것은 요소를 그리기 위한 배열, 시작값, 끝값이 필요하고 while을 통해 시작값을 하나씩 올려가면서 끝값에 도달 할 때 까지 배열 push하고 while문이 끝낫을 때 해당 배열을 반환해주면서 화면에 렌더링 하도록 한다. {/* 1번. 선택 박스 요소 */} 부분에 해당 코드를 삽입하도록 하자. 123456789101112131415&lt;div className=\"grid\"&gt; &#123; ((blocks, i, len) =&gt; &#123; while(++i &lt;= len) &#123; blocks.push( &lt;div key = &#123;i&#125; className=&#123;'block'&#125; /&gt; ) &#125; return blocks; &#125;)([], 0, 625) &#125;&lt;/div&gt; 2. useState를 이용하여 set이벤트 구현(요소 클릭시 색깔 변화 확인) 상태를 관리하기 위해 useState Hook 을 사용하도록 한다. 직접적인 set Hook함수를 쓰는게 아니라 별도의 함수를 만들고 해당 함수 호출 시 set Hook을 하는 방식을 이용한다. set()함수의 인자로는 객체를 넣을건데 대충 다음과 같은 값으로 들어가야한다. { 선택한 요소박스의 숫자 : true || false } 참고로, undefined는 Boolean 비교 시 false이며 !undefined는true다. 클릭 시 className에 block active 라는 클래스가 추가되도록 구현하여야 한다. 주의사항, {&#39;block&#39; + (state[index] ? &#39; active&#39; : &#39;&#39;)} 에서 삼항연산자를 ()를 안치게 될 경우 렌더링이 안되는 것에 주의하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/Main.js : 상위 컴포넌트import React, &#123;useState&#125; from 'react'import './styles.scss'const Main = (props) =&gt; &#123;const [state, setState] = useState(&#123;&#125;) // 1번const set = (toggle) =&gt; &#123; // 2번 setState(toggle)&#125; return ( &lt;div className=\"container\"&gt; &lt;div className=\"controls\"&gt; &lt;button&gt; Undo &lt;/button&gt; &lt;button&gt; Redo &lt;/button&gt; &lt;button&gt;Clear&lt;/button&gt; &lt;/div&gt; &lt;div className=\"grid\"&gt; &#123; ((blocks, i, len) =&gt; &#123; while(++i &lt;= len) &#123; const index = i; blocks.push( &lt;div key = &#123;i&#125; className = &#123;'block' + (state[index] ? ' active' : '')&#125; // 3번 onClick = &#123;() =&gt; set(&#123;...state, [index] : !state[index] &#125;)&#125; // 2번 /&gt; ) &#125; return blocks; &#125;)([], 0, 625) &#125; &lt;/div&gt; &lt;/div&gt; );&#125;export default Main; 3. useHistory 커스텀 훅 만들어서 state와 set 연동하기 2번에서 만든 useState를 커스텀 훅으로 별도의 파일을 만들어 작성한다. (src/hooks/useHistory.js) 상위 컴포넌트(src/Main.js)에서는 커스텀 훅을 사용한다. 1234567891011121314// src/hooks/useHistory.js : 커스텀 훅import &#123;useState&#125; from 'react'const useHistory = (NowValue) =&gt; &#123; const [state, setState] = useState(&#123;&#125;) const set = (toggle) =&gt; &#123; setState(toggle) &#125; return &#123;state, set&#125; // 객체로 상태, 함수를 담아 뿌려준다.&#125;export default useHistory; 123456789101112131415161718192021222324252627282930313233343536373839404142// src/Main.js : 상위 컴포넌트import React from 'react'import useHistory from './hooks/useHistory' // 커스텀 훅 importimport './styles.scss'const Main = () =&gt; &#123; const &#123;state, set&#125; = useHistory(); // 커스텀 훅 사용하기. return ( &lt;div className=\"container\"&gt; &lt;div className=\"controls\"&gt; &lt;button&gt; Undo &lt;/button&gt; &lt;button&gt; Redo &lt;/button&gt; &lt;button&gt;Clear&lt;/button&gt; &lt;/div&gt; &lt;div className=\"grid\"&gt; &#123; ((blocks, i, len) =&gt; &#123; while(++i &lt;= len) &#123; const index = i; blocks.push( &lt;div key = &#123;i&#125; className = &#123;'block' + (state[index] ? ' active' : '')&#125; onClick = &#123;() =&gt; set(&#123;...state, [index] : !state[index] &#125;)&#125; /&gt; ) &#125; return blocks; &#125;)([], 0, 625) &#125; &lt;/div&gt; &lt;/div&gt; );&#125;export default Main; 4. Clear구현하기 커스텀 훅에 clean함수 구현 및 return에 포함시켜주기. clean을 누를 경우, 상태로 싹 비워줘야하기 때문에 일단 빈객체를 반환한다. 상위 컴포넌트에서 clean 함수 사용하기. 123456789101112131415161718// src/hooks/useHistory.js : 커스텀 훅import &#123;useState&#125; from 'react'const useHistory = (NowValue) =&gt; &#123; const [state, setState] = useState(&#123;&#125;) const set = (toggle) =&gt; &#123; setState(toggle) &#125; const clean = () =&gt; &#123; // 1번 setState(&#123;&#125;) &#125; return &#123;state, set, clean&#125; // 1번 - clean 추가&#125;export default useHistory; 123456789101112131415161718192021222324252627282930313233343536373839404142// src/Main.js : 상위 컴포넌트import React from 'react'import useHistory from './hooks/useHistory'import './styles.scss'const Main = () =&gt; &#123; const &#123;state, set, clean&#125; = useHistory(); // 2번 return ( &lt;div className=\"container\"&gt; &lt;div className=\"controls\"&gt; &lt;button&gt; Undo &lt;/button&gt; &lt;button&gt; Redo &lt;/button&gt; &lt;button onClick=&#123;() =&gt; clean()&#125;/*2번*/&gt;Clear&lt;/button &gt; &lt;/div&gt; &lt;div className=\"grid\"&gt; &#123; ((blocks, i, len) =&gt; &#123; while(++i &lt;= len) &#123; const index = i; blocks.push( &lt;div key = &#123;i&#125; className = &#123;'block' + (state[index] ? ' active' : '')&#125; onClick = &#123;() =&gt; set(&#123;...state, [index] : !state[index] &#125;)&#125; /&gt; ) &#125; return blocks; &#125;)([], 0, 625) &#125; &lt;/div&gt; &lt;/div&gt; );&#125;export default Main; 5. useReducer 적용하기 본격적으로 커스텀 훅에서 useState가 아닌 reducer를 구현한다. ( 구현 위치: src/hooks/useHistory.js ) 선언-예) const [상태변수명, dispatch] = useReducer(리듀서, 초기상태)로 선언한다. useReducer 는 다음과 같은 개념으로 구성되어 있다. 상태(state)를 어떻게 해야할 것인지 적어놓은 양식인 action action을 reducer에게 전달하는 dispatch , 예) dispatch({type: &#39;수행할 액션명(대문자)&#39;, 액션 }) action을 수행하는 reducer , 리듀서는 switch(action.type) 을 통해 어떻게 상태를 관리해야할지를 수행한다. 123456789101112131415161718192021222324252627// src/hooks/useHistory.js : 커스텀 훅import &#123;useReducer&#125; from 'react'const reducer = (state, action) =&gt; &#123; switch(action.type) &#123; case 'SET' : return action.toggle; case 'CLEAN' : return &#123;&#125;; &#125;&#125;const useHistory = (NowValue) =&gt; &#123; const [state, dispatch] = useReducer(reducer, &#123;&#125;) // 2번 const set = (toggle) =&gt; &#123; return dispatch(&#123;type: 'SET', toggle&#125;) &#125; const clean = () =&gt; &#123; return dispatch(&#123;type: 'CLEAN'&#125;) &#125; return &#123;state, set, clean&#125;&#125;export default useHistory; 6. Undo, Redo 구현 전 초기 상태 셋팅 및 적용하기. Undo와 Redo를 구현하기 앞서 초기 상태를 셋팅하도록 한다.Undo는 이전 상태로 되돌아가는 것이고, Redo는 현재에서 1번 앞선 상태(최신상태는 제외)로 되돌아가는 것이다.따라서, 과거-현재-미래 로 초기상태를 셋팅해보자. 초기상태는 과거, 현재, 미래로 구현한다. 과거와 미래는 지속적으로 상태를 기억해야하므로 배열로 만들고 배열에 추가하는 방식을 이용한다. set은 제일 최신 상태이므로 Redo가 필요 없기 때문에 빈배열을 준다. return은 present 만 한다. 123456789101112131415161718192021222324252627282930313233343536373839// src/hooks/useHistory.js : 커스텀 훅import &#123;useReducer&#125; from 'react'const initialState = &#123; // 1번 past : [], present : &#123;&#125;, future : []&#125;const reducer = (state, action) =&gt; &#123; const &#123;past, present, future&#125; = state; switch(action.type) &#123; case 'SET' : return &#123; past : [...past, present], // 2번, 과거 현재 상태를 배열로 추가하는 방식 이용. present : action.toggle, future : [] // 3번 &#125;; case 'CLEAN' : return initialState; &#125;&#125;const useHistory = (NowValue) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState) // 1번 초기상태 셋팅 const set = (toggle) =&gt; &#123; return dispatch(&#123;type: 'SET', toggle&#125;) &#125; const clean = () =&gt; &#123; return dispatch(&#123;type: 'CLEAN'&#125;) &#125; return &#123;state : state.present, set, clean&#125; // 4번&#125;export default useHistory; 7. Undo구현하기 과거의 상태로 돌아가는 Undo를 구현한다. 상위 컴포넌트에서 Hook을 통해 undo를 불러온다. (이벤트도 달아준다.) 커스텀 훅에서 undo에 대한 action, reducer, dispatch를 각각 구현해준다. reducer 반환하는 상태 현재, 과거, 미래를 다음과 같이 구성한다. 과거 : 현재 쌓아놓은 과거에서 마지막 배열을 제거한 후 할당한다. 현재 : 과거에 쌓여있는 데이터 중에 마지막 배열 보다 한칸 앞선 객체를 할당 한다. 미래 : 현재의 데이터를 배열 맨 앞에 할당한다.(Redo 사용 시 앞에서 부터 가져오기 위함.) 123456789101112131415// src/Main.js : 상위 컴포넌트import React from 'react'import useHistory from './hooks/useHistory'import './styles.scss'const Main = () =&gt; &#123; const &#123;state, set, clean, undo&#125; = useHistory(); // 1번 return ( &lt;div className=\"container\"&gt; &lt;div className=\"controls\"&gt; &lt;button onClick=&#123;() =&gt; undo() /* 1번 */&#125;&gt; Undo &lt;/button&gt; .... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// src/hooks/useHistory.js : 커스텀 훅import &#123;useReducer&#125; from 'react'const initialState = &#123; past : [], present : &#123;&#125;, future : []&#125;const reducer = (state, action) =&gt; &#123; const &#123;past, present, future&#125; = state; switch(action.type) &#123; case 'SET' : return &#123; past : [...past, present], present : action.toggle, future : [] &#125;; case 'UNDO' : // 2번 // 3번 const newPast = past.slice(0, -1); const beforePresent = past[past.length - 1]; return &#123; past : newPast, present : beforePresent, future : [present, ...future] &#125;; case 'CLEAN' : return initialState; &#125;&#125;const useHistory = (NowValue) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState) const set = (toggle) =&gt; &#123; return dispatch(&#123;type: 'SET', toggle&#125;) &#125; const clean = () =&gt; &#123; return dispatch(&#123;type: 'CLEAN'&#125;) &#125; const undo = () =&gt; &#123; // 2번 return dispatch(&#123;type: 'UNDO'&#125;) &#125; return &#123;state : state.present, set, clean, undo&#125; // 2번&#125;export default useHistory; 8. Redo구현하기 최신 상태로 되돌아가는 Redo를 구현한다. 상위 컴포넌트에서 Hook을 통해 Redo를 불러온다. (이벤트도 달아준다.) 커스텀 훅에서 Redo에 대한 action, reducer, dispatch를 각각 구현해준다. reducer 반환하는 상태 현재, 과거, 미래를 다음과 같이 구성한다. 과거 : 쌓아놓은 과거에서 추가로 현재 데이터를 배열에 추가한다. 현재 : 미래에 쌓여있는 데이터 중에 맨 처음 배열 리스트를 할당 한다. 미래 : 미래의 데이터에서 첫번째 배열 리스트를 제외한 나머지 배열리스트를 할당한다. 1234567891011121314151617181920// src/Main.js : 상위 컴포넌트import React from 'react'import useHistory from './hooks/useHistory'import './styles.scss'const Main = () =&gt; &#123; const &#123;state, set, clean, undo, redo&#125; = useHistory(); // 1번 return ( &lt;div className=\"container\"&gt; &lt;div className=\"controls\"&gt; &lt;button onClick=&#123;() =&gt; undo()&#125;&gt; Undo &lt;/button&gt; &lt;button onClick=&#123;() =&gt; redo()/* 1번 */&#125;&gt; Redo &lt;/button&gt; &lt;button onClick=&#123;() =&gt; clean()&#125;&gt;Clear&lt;/button&gt; &lt;/div&gt; ... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// src/hooks/useHistory.js : 커스텀 훅import &#123;useReducer&#125; from 'react'const initialState = &#123; past : [], present : &#123;&#125;, future : []&#125;const reducer = (state, action) =&gt; &#123; const &#123;past, present, future&#125; = state; switch(action.type) &#123; case 'SET' : return &#123; past : [...past, present], present : action.toggle, future : [] &#125;; case 'UNDO' : const newPast = past.slice(0, -1); const beforePresent = past[past.length - 1]; return &#123; past : newPast, present : beforePresent, future : [present, ...future] &#125;; case 'REDO' : // 2번 // 3번 const newFuture = future.slice(1); const nextPresent = future[0]; return &#123; past : [...past, present], present : nextPresent, future : newFuture &#125;; case 'CLEAN' : return initialState; &#125;&#125;const useHistory = (NowValue) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState) const set = (toggle) =&gt; &#123; return dispatch(&#123;type: 'SET', toggle&#125;) &#125; const clean = () =&gt; &#123; return dispatch(&#123;type: 'CLEAN'&#125;) &#125; const undo = () =&gt; &#123; return dispatch(&#123;type: 'UNDO'&#125;) &#125; const redo = () =&gt; &#123; return dispatch(&#123;type: 'REDO'&#125;) // 2번 &#125; return &#123;state : state.present, set, clean, undo, redo&#125; // 2번&#125;export default useHistory; 9. canUndo, canRedo구현하기 더 이상 과거 상태로 돌아가거나, 최신 상태로 돌아갈 필요가 없는 상황일 때 undo, redo 버튼을 막아버리는 canUndo와 canRedo를 구현해본다. 버튼의 클릭을 막아버리는 속성은 disabled를 이용한다. 해당 속성은 true와 false를 버튼의 클릭 유무를 결정내릴수 있게한다. 커스텀 훅에서 각각 state에서 past와 future의 길이가 0일 경우, true를 아닐 경우, false를 반환하는 형태로 구현한다. 123456789101112131415161718// src/Main.js : 상위 컴포넌트import React from 'react'import useHistory from './hooks/useHistory'import './styles.scss'const Main = () =&gt; &#123; const &#123;state, set, clean, undo, redo, canUndo, canRedo&#125; = useHistory(); // 1번 return ( &lt;div className=\"container\"&gt; &lt;div className=\"controls\"&gt; &lt;button onClick=&#123;() =&gt; undo()&#125; disabled=&#123;canUndo&#125; /* 1번 */&gt; Undo &lt;/button&gt; &lt;button onClick=&#123;() =&gt; redo()&#125; disabled=&#123;canRedo&#125; /* 1번 */&gt; Redo &lt;/button&gt; ... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// src/hooks/useHistory.js : 커스텀 훅import &#123;useReducer&#125; from 'react'const initialState = &#123; past : [], present : &#123;&#125;, future : []&#125;const reducer = (state, action) =&gt; &#123; const &#123;past, present, future&#125; = state; switch(action.type) &#123; case 'SET' : return &#123; past : [...past, present], present : action.toggle, future : [] &#125;; case 'UNDO' : const newPast = past.slice(0, -1); const beforePresent = past[past.length - 1]; return &#123; past : newPast, present : beforePresent, future : [present, ...future] &#125;; case 'REDO' : const newFuture = future.slice(1); const nextPresent = future[0]; return &#123; past : [...past, present], present : nextPresent, future : newFuture &#125;; case 'CLEAN' : return initialState; &#125;&#125;const useHistory = (NowValue) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState) const set = (toggle) =&gt; &#123; return dispatch(&#123;type: 'SET', toggle&#125;) &#125; const clean = () =&gt; &#123; return dispatch(&#123;type: 'CLEAN'&#125;) &#125; const undo = () =&gt; &#123; return dispatch(&#123;type: 'UNDO'&#125;) &#125; const redo = () =&gt; &#123; return dispatch(&#123;type: 'REDO'&#125;) &#125; const canUndo = state.past.length === 0; const canRedo = state.future.length === 0; return &#123;state : state.present, set, clean, undo, redo, canUndo, canRedo&#125;&#125;export default useHistory; 10. useCallback으로 최적화하기 및 반복 렌더링 방지하기 useCallback을 이용해서 최적화를 한다. useCallback(fn, [의존성배열]) undo와 redo의 경우 canUndo, canRedo 의 변화에 따라 사용할 수 있도록 useCallback에 추가한다. 반복 렌더링을 방지하기 위한 조건문을 reducer SET에 추가해준다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// src/hooks/useHistory.js : 커스텀 훅import &#123;useReducer, useCallback&#125; from 'react'const initialState = &#123; past : [], present : &#123;&#125;, future : []&#125;const reducer = (state, action) =&gt; &#123; const &#123;past, present, future&#125; = state; switch(action.type) &#123; case 'SET' : if (action.toggle === present) return state; // 3번 return &#123; past : [...past, present], present : action.toggle, future : [] &#125;; case 'UNDO' : const newPast = past.slice(0, -1); const beforePresent = past[past.length - 1]; return &#123; past : newPast, present : beforePresent, future : [present, ...future] &#125;; case 'REDO' : const newFuture = future.slice(1); const nextPresent = future[0]; return &#123; past : [...past, present], present : nextPresent, future : newFuture &#125;; case 'CLEAN' : return initialState; &#125;&#125;const useHistory = (NowValue) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState) const canUndo = state.past.length === 0; const canRedo = state.future.length === 0; const set = useCallback((toggle) =&gt; &#123; // 1번 return dispatch(&#123;type: 'SET', toggle&#125;) &#125;, [dispatch]); const clean = useCallback(() =&gt; &#123; // 1번 return dispatch(&#123;type: 'CLEAN'&#125;) &#125;, [dispatch]); const undo = useCallback(() =&gt; &#123; // 1번 if(!canUndo) dispatch(&#123;type: 'UNDO'&#125;) // 2번 &#125;, [canUndo, dispatch]); // 2번 const redo = useCallback(() =&gt; &#123; // 1번 if(!canRedo) dispatch(&#123;type: 'REDO'&#125;) // 2번 &#125;, [canRedo, dispatch]); // 2번 return &#123;state : state.present, set, clean, undo, redo, canUndo, canRedo&#125;&#125;export default useHistory; 11. 느낀점 우선, 커스텀 훅을 사용했을 경우 유지보수성면에서 좋아질 것이라고 생각했다. 지금은 하나의 파일에 작업을 해도 전혀 무리가 없지만, 협업이나 다른 사람에게 코드를 설명해주거나 할 때에는 커스텀 훅의 장점이 발휘될 것이라고 생각했다. 추가로 useReducer의 경우 사용 방법이 좀 까다롭고 복잡한 절차가 있었지만 사용하면 할수록 체계화된 느낌을 많이 받았고 상태가 어떤식으로 동작할 지 내부적인 선택으로 하는 것이기 때문에 가독성 면이나 유지보수면에서 큰 장점이라고 생각했다. 마지막으로, useCallbackd의 개념적인 면은 의존성 배열의 여부에 따라 이전의 상태를 기억하는 것으로 알고 있는데, 위 프로젝트에서는 의존성 배열이 모두 dispatch를 포함하고 있어서 아직까지는 왜 사용되었는지가 좀 의문이다. 추측상으로는 다른 상태가 추가되고 업데이트 될 경우, useCallback이 걸린 상태만 리렌더링을 방지하기 위함이라고 생각했다. 625개의 요소를 처음부터 다시 그려주는 것을 방지하는 것에 대해서 리소스적인 면은 큰 장점이라고 생각한다. Git에서 소스보기","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Hook","slug":"React-Hook","permalink":"https://hyeok999.github.io/tags/React-Hook/"},{"name":"Hook","slug":"Hook","permalink":"https://hyeok999.github.io/tags/Hook/"},{"name":"Custom Hook","slug":"Custom-Hook","permalink":"https://hyeok999.github.io/tags/Custom-Hook/"},{"name":"useCallback","slug":"useCallback","permalink":"https://hyeok999.github.io/tags/useCallback/"},{"name":"useReducer","slug":"useReducer","permalink":"https://hyeok999.github.io/tags/useReducer/"},{"name":"Functional Component","slug":"Functional-Component","permalink":"https://hyeok999.github.io/tags/Functional-Component/"}]},{"title":"React Todo List V2","slug":"react-todo-v2","date":"2020-01-08T18:31:09.000Z","updated":"2020-01-08T18:53:55.966Z","comments":true,"path":"2020/01/09/react-todo-v2/","link":"","permalink":"https://hyeok999.github.io/2020/01/09/react-todo-v2/","excerpt":"","text":"Todo Version 2기능 Todo 추가 Todo 삭제 Todo 체크 전체 Todos 완료 / 미완료 토글 체크된 Todos 삭제 체크된 Todos 카운팅 체크되지 않은 Todos 카운팅 탭에 따라 Todo 분류 (전체 Todo, 체크된 Todo, 체크되지 않은 Todo) Todo Version 2 구축하기 컴포넌트를 분류한다. 함수형 컴포넌트(Hook)으로 구축해본다. 컴포넌트 분류최상위 컴포넌트: MainView 하위 컴포넌트 : Input, Navigation, TodoList, Footer 마크업123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"js/app.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"footer\"&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 초기화 데이터12345let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ] CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; /* font-size: 16px; */ font-size: 0.9em; color: #58666e; background-color: #f0f3f4; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102,175,233,.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todo-list &#123;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .custom-checkbox custom-checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 custom-checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.custom-checkbox &#123; display: none;&#125;.custom-checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.custom-checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.custom-checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;.footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; Todo V2 전체 코드MainView.js최상위 컴포넌트 수정사항 : Navigation컴포넌트에서 상태를 받아가지고 오기 위해서 사용한 all을 상태 객체로 관리한다. 이렇게 한 이유는 굳이 DOM요소를 조작하지 않고 상태만으로 렌더링이 가능할 것이라고 판단하였기 때문이다. 따라서 기존의 주석 TODO: v1,2는 주석처리하고 주석 TODO: v3를 사용한다. 전반적으로 Todo Version 1과 비교했을 때 훨씬 더 자바스크립트의 모양새에 탈피한 느낌이며, 리액트의 특징 답게 UI를 신경쓰지 않고 상태만 관리를 해주면 되었기에 훨씬 더 간편하고 직관적이며 유지보수가 용이한 코드를 작성할 수 있었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React, &#123; useState, useEffect &#125; from 'react'import './MainView.css';import InputTodo from './components/Input';import Navigation from './components/Navigation';import TodoList from './components/TodoList';import Footer from './components/Footer';const MainView = () =&gt; &#123; const [todos, setTodos] = useState([]); //TODO: v1,v2 // const [navId, setNavId] = useState('all'); //TODO: v3 const [navLists, setNavLists] = useState([ &#123;id: 1, navId:'All', toggle: true&#125;, &#123;id: 2, navId:'Active', toggle: false&#125;, &#123;id: 3, navId:'Completed', toggle: false&#125; ]); useEffect(() =&gt; &#123; setTodos([ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ]) &#125;, []) const generatedId = () =&gt; &#123; return Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1; &#125; const addTodo = (key, target) =&gt; &#123; if(key !== 'Enter' || target.value.trim() === '') return; setTodos([ ...todos, &#123; id : generatedId(), content: target.value, completed: false &#125; ]) target.value = ''; &#125; const checkedTodo = (id) =&gt; &#123; setTodos(todos.map((todo) =&gt; (todo.id === id ? &#123;...todo, completed: !todo.completed&#125; : todo))) &#125; const removeTodo = (target, id) =&gt; &#123; if(!target.classList.contains('remove-todo')) return; setTodos(todos.filter((todo) =&gt; (todo.id !== id))) &#125; const allToggleTodo = (target) =&gt; &#123; setTodos(todos.map((todo) =&gt; (&#123;...todo, completed: target.checked&#125;))) &#125; const completedAllTodo = () =&gt; &#123; setTodos(todos.filter((&#123;completed&#125;) =&gt; (!completed))) &#125; //TODO: v1 // const changeNavigation = ($nav, target) =&gt; &#123; // if (target.classList.contains('nav')) return; // [...$nav.current.children].forEach(($navList) =&gt; &#123; // $navList.classList.toggle('active', $navList.id === target.id); // setNavId(target.id); // &#125;); // &#125; //TODO: v2 // const changeNavigation = ($nav, target) =&gt; &#123; // [...$nav.current.children].forEach(($navList) =&gt; &#123; // $navList.classList.toggle('active', $navList.id === target.id); // setNavId(target.id); // &#125;); // &#125; //TODO: v3 const changeNavigation = (id) =&gt; &#123; setNavLists(navLists.map((navList) =&gt; id === navList.id ? &#123;...navList, toggle:true&#125; : &#123;...navList, toggle:false&#125;)) &#125; //TODO: v1,v2 // const _todos = todos.filter((todo) =&gt; navId === 'all' ? todo : navId === 'active' ? !todo.completed : todo.completed) //TODO: v3 const _todos = todos.filter((todo) =&gt; navLists[0].toggle ? todo : navLists[1].toggle ? !todo.completed : todo.completed) const completedCount = _todos.filter((&#123;completed&#125;) =&gt; completed).length const activeCount = _todos.filter((&#123;completed&#125;) =&gt; !completed).length return ( &lt;div className=\"container\"&gt; &lt;h1 className=\"title\"&gt;Todos&lt;/h1&gt; &lt;div className=\"ver\"&gt;2.0&lt;/div&gt; &lt;InputTodo addTodo=&#123;addTodo&#125;/&gt; &lt;Navigation changeNavigation=&#123;changeNavigation&#125; navLists=&#123;navLists&#125;/&gt; &lt;TodoList todos=&#123;_todos&#125; checkedTodo=&#123;checkedTodo&#125; removeTodo=&#123;removeTodo&#125;/&gt; &lt;Footer allToggleTodo=&#123;allToggleTodo&#125; completedAllTodo=&#123;completedAllTodo&#125; completedCount=&#123;completedCount&#125; activeCount=&#123;activeCount&#125;/&gt; &lt;/div&gt; );&#125;export default MainView; components/Input/index.jsx하위 컴포넌트 input 태그를 별도로 분리하여 관리한다. 해당 태그에서 추가 이벤트가 일어나야 하므로 onKeyPress이벤트를 이용하였고 상위 컴포넌트로부터 내려받은 이벤트와 연결시켜주었다. 태그를 하나만 쓰면 되고 기존의 마크업을 변경시키지 않기 위해서 Fragments(&lt;&gt; &lt;/&gt;)을 이용하였다. 1234567891011import React from 'react'const InputTodo = (&#123;addTodo&#125;) =&gt; &#123; return ( &lt;&gt; &lt;input className=\"input-todo\" placeholder=\"What needs to be done?\" autoFocus onKeyPress=&#123;(&#123;key, target&#125;) =&gt; addTodo(key, target)&#125;/&gt; &lt;/&gt; );&#125;export default InputTodo; components/Navigation/index.jsx하위 컴포넌트 Navigation 을 분리하여 관리한다. 해당 태그에서 탭 변경 이벤트가 일어나야 하므로 onClick이벤트를 이용하였고 상위 컴포넌트로부터 내려받은 이벤트와 연결시켜주었다. 수정사항 : 기존에는 DOM을 조작하는 방식으로 이용을 하였으나 상위 컴포넌트에서 관리하는 상태를 이용하여 DOM을 조작하는 방식이 아닌 상태에 의존하여 DOM을 렌더링하는 방식으로 변경하였다. 123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useRef &#125; from 'react'const Navigation = (&#123;navLists, changeNavigation&#125;) =&gt; &#123; const nav = useRef(); console.log(navLists); return ( //TODO: v3 &lt;ul className=\"nav\" ref=&#123;nav&#125;&gt; &#123; navLists.map((navItem) =&gt; ( &lt;li key=&#123;navItem.id&#125; id=&#123;navItem.navId&#125; className=&#123;navItem.toggle ? 'active' : null&#125; onClick=&#123;() =&gt; changeNavigation(navItem.id)&#125; &gt; &#123;navItem.navId&#125; &lt;/li&gt; )) &#125; &lt;/ul&gt; //TODO: v1 // &lt;ul className=\"nav\" ref=&#123;nav&#125; onClick=&#123;(&#123;target&#125;) =&gt; changeNavigation(nav, target)&#125;&gt; // &lt;li id=\"all\" className=\"active\" &gt;All&lt;/li&gt; // &lt;li id=\"active\"&gt;Active&lt;/li&gt; // &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; // &lt;/ul&gt; //TODO: v2 // &lt;ul className=\"nav\" ref=&#123;nav&#125;&gt; // &lt;li id=\"all\" onClick=&#123;(&#123;target&#125;) =&gt; changeNavigation(nav, target)&#125; className=\"active\" &gt;All&lt;/li&gt; // &lt;li id=\"active\" onClick=&#123;(&#123;target&#125;) =&gt; changeNavigation(nav, target)&#125;&gt;Active&lt;/li&gt; // &lt;li id=\"completed\" onClick=&#123;(&#123;target&#125;) =&gt; changeNavigation(nav, target)&#125;&gt;Completed&lt;/li&gt; // &lt;/ul&gt; );&#125;export default Navigation; components/TodoList/index.jsx하위 컴포넌트 Todos List 를 별도로 분리하여 관리한다. 해당 태그에서는 실질적으로 Todo를 렌더링해야 한다. 중간의 input태그에서는 checked 속성이 이용되었는데 이 속성은 해당 태그 내의 속성 중 onChange 이벤트가 작성이 안되어 있으면 defaultChecked를 사용하라는 에러를 내뿜는다. 이점을 참고할 것. 삭제 버튼이 이쪽에 구현되야 하므로 &lt;i&gt;&lt;/i&gt;태그에 onClick 이벤트를 걸어주었다. 12345678910111213141516171819import React from 'react'const Todos = (&#123;todos, checkedTodo, removeTodo&#125;) =&gt; &#123; return ( &lt;ul className=\"todos\"&gt; &#123; todos.map((todo) =&gt; ( &lt;li id=&#123;todos.id&#125; className=\"todo-item\" key=&#123;todo.id&#125;&gt; &lt;input className=\"custom-checkbox\" type=\"checkbox\" id=&#123;`ck-$&#123;todo.id&#125;`&#125; onChange=&#123;() =&gt; checkedTodo(todo.id)&#125; checked=&#123;todo.completed&#125; /&gt; &lt;label htmlFor=&#123;`ck-$&#123;todo.id&#125;`&#125;&gt;&#123;todo.content&#125;&lt;/label&gt; &lt;i className=\"remove-todo far fa-times-circle\" onClick=&#123;(&#123;target&#125;) =&gt; removeTodo(target, todo.id)&#125;&gt;&lt;/i&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; );&#125;export default Todos; components/Footer/index.jsx하위 컴포넌트 Footer 를 별도로 분리하여 관리한다. Footer에서는 폴더를 쉽게 관리하기 위해서 내부적으로 2개의 하위 컴포넌트로 더 나누었다. CompleteAll ClearCompleted 1234567891011121314import React from 'react'import CompleteAll from './CompleteAll'import ClearCompleted from './ClearCompleted';const Footer = (&#123;allToggleTodo, completedAllTodo, completedCount, activeCount&#125;) =&gt; &#123; return ( &lt;div className=\"footer\"&gt; &lt;CompleteAll allToggleTodo=&#123;allToggleTodo&#125;&gt;&lt;/CompleteAll&gt; &lt;ClearCompleted completedAllTodo=&#123;completedAllTodo&#125; completedCount=&#123;completedCount&#125; activeCount=&#123;activeCount&#125;&gt;&lt;/ClearCompleted&gt; &lt;/div&gt; );&#125;export default Footer; components/Footer/ClearCompleted.jsxFooter의 하위 컴포넌트 완료된 할 일들을 목록에서 모두 제거해버리는 로직을 구현한다. 추가로, 현재 완료된 할 일 목록의 카운팅 수 와 완료되지 않은 할 일 목록의 카운팅 수를 화면에 렌더링한다. 123456789101112import React from 'react'const ClearCompleted = (&#123;completedAllTodo, completedCount, activeCount&#125;) =&gt; &#123; return ( &lt;div className=\"clear-completed\"&gt; &lt;button className=\"btn\" onClick=&#123;() =&gt; completedAllTodo()&#125; &gt;Clear completed (&lt;span className=\"completed-todos\"&gt;&#123;completedCount&#125;&lt;/span&gt;)&lt;/button&gt; &lt;strong className=\"active-todos\"&gt;&#123;activeCount&#125;&lt;/strong&gt; items left &lt;/div&gt; );&#125;export default ClearCompleted; components/Footer/CompleteAll.jsxFooter의 하위 컴포넌트 모든 목록에 대하여 클릭 시 모든 목록을 토글 시켜주는 기능을 구현한다. 따라서 버튼을 클릭해야 하므로 onClick으로 구현을 하며, 최상위 MainView - 상위 Footer - 현재 CompleteAll순으로 props를 통해 내려받는다. 123456789101112import React from 'react'const CompleteAll = (&#123;allToggleTodo&#125;) =&gt; &#123; return ( &lt;div className=\"complete-all\"&gt; &lt;input className=\"custom-checkbox\" type=\"checkbox\" id=\"ck-complete-all\" onClick=&#123;(&#123;target&#125;) =&gt; allToggleTodo(target)&#125; /&gt; &lt;label htmlFor=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; );&#125;export default CompleteAll; 소스 코드 보기","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Hook","slug":"Hook","permalink":"https://hyeok999.github.io/tags/Hook/"},{"name":"Functional Component","slug":"Functional-Component","permalink":"https://hyeok999.github.io/tags/Functional-Component/"},{"name":"Todo List","slug":"Todo-List","permalink":"https://hyeok999.github.io/tags/Todo-List/"}]},{"title":"React 스터디 15","slug":"react-study-15","date":"2020-01-08T14:39:17.000Z","updated":"2020-01-08T14:42:15.964Z","comments":true,"path":"2020/01/08/react-study-15/","link":"","permalink":"https://hyeok999.github.io/2020/01/08/react-study-15/","excerpt":"","text":"React Study 15 export 와 export default의 차이 React Hook 이어서 useCallback useMemo useEffect Hook 규칙 - 리액트 공식문서 참조 REACT-GRID-MINI 코딩 순서 코드 참고 용어 - ( 러버덕 ) useCallback useMemo useEffect Hook 규칙 useReducer export 와 export default의 차이 export default 함수명 로 작성시 다른 파일에서 해당 파일을 import 커스텀명 from &#39;파일주소&#39; 로 사용할 수 있다 export { 함수명 }로 작성시 다른 파일에서 해당 파일을 import { 함수명 } from &#39;파일주소&#39;로 사용해야 한다. React Hook 이어서useCallback 불필요한 렌더링 재발생 방지 useCallback은 함수 자체를 메모라이징 한다. (함수 표현식을 메모라이징) App.js 12345678910111213141516171819202122import React, &#123; useState, useEffect, useCallback &#125; from 'react';function Test(props) &#123; const [count, setCount] = useState(1); const countUp = (c) =&gt; &#123; setCount(c) &#125;; const seeResult = useCallback(() =&gt; &#123; console.log('count', count) &#125;, []) return ( &lt;div&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;seeResult&#125;&gt;확인&lt;/button&gt; &lt;button onClick=&#123;() =&gt; countUp(count + 1)&#125;&gt;증가&lt;/button&gt; &lt;/div&gt; );&#125;export default Test; useCallback의 의존성배열(2번쨰 파라미터)가 빈배열([])일 경우,1번만 함수 표현식을 기억해서 리턴을 한다.따라서 이후에 증가버튼을 아무리 누르고 확인버튼을 누를 경우, console 에는count 1만 찍히게 된다. useMemo 불필요한 렌더링 재발생 방지 useMemo은 함수를 호출해서 리턴한 값 자체를 메모라이징 한다. App.js 12345678910111213141516171819202122import React, &#123; useState, useMemo, useEffect, useCallback &#125; from 'react';import Sub from './Sub'function Test(props) &#123; const [count, setCount] = useState(1); const up = () =&gt; setCount(prev =&gt; prev+1) const memoizedSub = useMemo(() =&gt; &#123; return &lt;Sub/&gt; &#125;, []) return ( &lt;div&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;up&#125;&gt;증가&lt;/button&gt; &lt;Sub /&gt;&lt;br/&gt; &#123;memoizedSub&#125; &lt;/div&gt; );&#125;export default Test; Sub.js 12345678910import React, &#123; useEffect &#125; from 'react';let count = 1;export default function Sub() &#123; useEffect(() =&gt; &#123; count += 1; &#125;) return &lt;&gt;Sub : &#123;count&#125; &lt;/&gt;;&#125; memoizedSub에서는 useMemo(fn,[]) 를 통해서 결과 값을 맨처음(1번)만 메로라이징 하고 있다. 즉, &lt;Sub /&gt; 태그에서는 count값이 버튼을 누를수록 게속 올라가겠지만, {memoizedSub}는 메모라이징 된 &lt;Sub /&gt;를 반환하고 있기 때문에 값이 게속 1로 고정되어 있을 것이다. 추가로, 실행시 첫 렌더의 값은 1, 1, 1 일 것이다. 하지만, 증가를 누를 경우 2, 3, 1로 되어있다. 이 부분에 대해서는 첫 렌더링이 끝나고 Sub.js에서 useEffect가 호출된다. 문제는 useEffect에서는 상태를 업데이트 하는게 아니라 그저 그냥 변수를 업데이트 한 것이기 때문에 리렌더링이 이루어지지 않았다. 따라서 맨 처음 로드시 사실 count의 값은 1, 2, 1이 맞으나 2번째 2는 상태가 아닌 그냥 변수 이기 때문에 추가적인 화면에 렌더링이 안된것이다. useEffect 렌더링 이후 부터 실행된다. 기본적으로, componentDidMount, componentDidUpdate, componentWillUnMount 으로 합쳐놓은 꼴\\ 123456useEffect(() =&gt; &#123; effect // componentDidUpdate, 의존성 배열이 빈배열 시 componentDidMount return () =&gt; &#123; cleanup // componentWillUnMount &#125;;&#125;, [input]) // 의존성 배열([빈배열] : DidMount, 배열 미작성 시 모든 훅 업데이트에 작동) App.js 123456789101112131415161718import React, &#123; useState &#125; from 'react';import Sub from './Sub';function Test(props) &#123; const [ count, setCount ] = useState(1); const update = () =&gt; setCount(prev =&gt; prev + 1) return ( &lt;div&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;update&#125;&gt;Count Up&lt;/button&gt; &lt;Sub /&gt; &lt;/div&gt; )&#125;export default Test; Sub.js Sub는 아무 상관이 없음에도 업데이트가 되는 걸 확인할 수 있음. 12345678910import React, &#123; useEffect &#125; from 'react';let count = 1;export default function Sub () &#123; useEffect(() =&gt; &#123; count += 1 &#125;) return &lt;&gt;sub: &#123;count&#125;&lt;/&gt;&#125; Hook 규칙 - 리액트 공식문서 참조 1234567891011121314// useState 폴리필 (정확하지는 않는다.)function useState(initValue) &#123; let _val = initValue; function state() &#123; return _val; &#125; function setState(newVal) &#123; _val = newVal; &#125; return [state, setState];&#125;const [ count, setCount ] = useState(1); // 객체 구조분해 였다면 필드값이 일치해야만 사용 가능 순서가 중요하므로 if문이나 for문 등 조건문으로 감싸면 안된다. (오류 유발) 12345if (name !== '') &#123; useEffect(function persistForm() &#123; localStorage.setItem('formData', name); &#125;);&#125; Hook은 첫번째 렌더링에서 생성 및 선언하고 두번째 렌더링부터는 읽거나 추가 한다. 1234567891011121314151617// ------------// 첫 번째 렌더링// ------------useState('Mary') // 1. 'Mary'라는 name state 변수를 선언합니다.useEffect(persistForm) // 2. 폼 데이터를 저장하기 위한 effect를 추가합니다.useState('Poppins') // 3. 'Poppins'라는 surname state 변수를 선언합니다.useEffect(updateTitle) // 4. 제목을 업데이트하기 위한 effect를 추가합니다.// -------------// 두 번째 렌더링// -------------useState('Mary') // 1. name state 변수를 읽습니다.(인자는 무시됩니다)useEffect(persistForm) // 2. 폼 데이터를 저장하기 위한 effect가 대체됩니다.useState('Poppins') // 3. surname state 변수를 읽습니다.(인자는 무시됩니다)useEffect(updateTitle) // 4. 제목을 업데이트하기 위한 effect가 대체됩니다.// ... REACT-GRID-MINI useReducer(reducer, initialState) initialState는 초기 상태를 의미한다. reducer는 순수함수로 구성해야한다. 리듀서를 사용하는 이유 : 기존 상태와 새로운 Action이 주는 상태를 병합하여 새로운 상태를 리턴해주는 것이 목적 Redux 대신 사용. 12345678910const reducer = (state, action) =&gt; &#123; const &#123; past, present, future &#125; = state; switch (action.type) &#123; case 'UNDO': ...코드 case 'REDO': ...코드 case 'SET': ...코드 case 'CLEAR': ...코드 &#125;&#125;; initialState는 초기 상태를 정의 한 것, useHistory({})에서 보낸 초기값을 받기 위해 App.js에서 디스트럭처링으로 받고 있다. 1234567891011121314151617181920// 초기상태 정의const initialState = &#123; past: [], present: null, future: []&#125;;// export로 내보냄.export default function useHistory (initialPresent) &#123; const [state, dispatch] = useReducer(reducer, &#123; ...initialState, present: initialPresent &#125;)&#125;// App.jsfunction App() &#123; const &#123; state, set, undo, redo, clear, canUndo, canRedo &#125; = useHistory(&#123;&#125;); //초기화(디스트럭처링) ... 코드&#125; 코딩 순서 렌더링되는 요소 (return문 내부). 요소 완성을 위해서는 어떠한 요소들이 필요한지 파악한다. 따라서, useHistory(커스텀 훅)를 만들어야만 한다. export할 함수를 쓰고 시작 - 내부는 순차적으로 작성( dispatch를 해주는 것도 필요한 것들만 만들면 된다 ). 리듀서 함수 제작( 보통 함수 정의가 호출 보다 먼저 나와야하기 때문에 정의를 위에 작성 한다. - 개인적 의견 ). 코드 참고 state 불린값을 담기 위한 단일 객체인 set은 불린값 업데이트를 위한 함수. disabled는 클릭을 못하게 만드는 속성 : disabled={!canUndo}를 통해 조건을 주도록 함. useCallback을 쓰는 이유는 불필요하게 많이 렌더링되는걸 방지하기 위해 dispatch가 바뀌었을 경우에만 useCallback 함수를 실행하도록 만든 것. (해당 프로젝트는 요소를 625개를 렌더링하기 때문에 부하가 올 수 있다.) 의존성 배열에 dispatch는 불필요한 set, clear발생을 막기 위함. dispatch가 바뀌었다는 것은, Action이 전달하는 타입이 바뀌었다는 것을 의미한다. reducer는 순수함수여야 의미가 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 14","slug":"react-study-14","date":"2020-01-07T12:39:52.000Z","updated":"2020-01-07T12:41:58.240Z","comments":true,"path":"2020/01/07/react-study-14/","link":"","permalink":"https://hyeok999.github.io/2020/01/07/react-study-14/","excerpt":"","text":"React Study 14 로그인/로그아웃 프로젝트 이어서… 각 라우터 역할 JWT 디코드 API 만들기 커스텀 라우터 만들기 백엔드에서 쿠키 뿌려주기 React Hook API useLayoutEffect createRef 와 useRef createRef vs useRef의 차이점 useEffect의 의존성 배열 useRef 와 useEffect - lodash(isEqual) 기본 useRef 와 useEffect - lodash(isEqual) 커스텀 Hook 사용하기 useEffect 정리 createContext useContext 용어 - ( 러버덕 ) useEffect useLayoutEffect useRef lodash - isEqual createContext useContext 로그인/로그아웃 프로젝트 이어서…각 라우터 역할 signup : 전체적인 로그인 폼 핸들링 + 검증 : onSubmit 리액트의 폼 내장 속성으로 onSubmit &lt;form onSubmit={handleSubmit(onSubmit)}&gt; api에 패스워드1을 패스워드로 리네이밍(패스워드 칸이 두개 이므로 구분을 위해) success여부에 따라 오류 핸들링 signin 받아온 데이터를 객체구조 할당 토큰을 받아와서 사용할 데이터 형태로 수정 signout 커스텀 훅이 리턴하는 값은 토큰자체가 아니라 verify를 통해 decode된 객체가 리턴되기 때문에 사용하지 않을 것. Cookies.get을 통해 session을 가져온다. api에서 { headers }와 같이 객체 구조로 써서 값을 받아와야 한다. 로그아웃시 쿠키를 지우고 메인 페이지로 이동한다. 일반적으로 signin페이지로 접속했을 때는 디폴트 페이지로 리다이렉트 해줘야 한다. JWT 디코드 API 만들기 src/lib/hooks.js 12345678910111213141516171819import React, &#123; useState &#125; from 'react'import Cookies from 'js-cookie';import jwt from 'jsonwebtoken';// 쿠키에게 세션값을 가져와서 verify를 하여 오류가 없다면 json 객체를 있다면 false를 반환해주는 커스텀훅export const useAuthed = () =&gt; &#123; const [ authed ] = useState(() =&gt; &#123; try &#123; const session = Cookies.get('session'); const key = process.env.REACT_APP_JWT_KEY; const res = jwt.verify(session, key); return res; &#125; catch (error) &#123; return false; // 위변조가 되었음을 의미한다. &#125; &#125;); return authed;&#125; 커스텀 라우터 만들기 /signin 으로 바로 접속 시, 로그인이 이미 되어 있다면 바로 /user로 가고, 안되어 있다면 그대로 /signin으로 이동한다. /user 으로 바로 접속 시, 로그인이 이미 되어 있다면 바로 /user로 가고, 안되어 있다면 /signin으로 이동한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from 'react';import &#123; BrowserRouter as Router, Switch, Route, Redirect&#125; from 'react-router-dom';import SignIn from './components/SignIn';import SignUp from './components/SignUp';import SignOut from './components/SignOut';import User from './components/User';import Main from './components/Main';import &#123; useAuthed &#125; from './lib/hooks';function AuthedRoute (&#123;component: Component, ...rest&#125;) &#123; const isAuthed = useAuthed(); console.log(isAuthed); return ( &lt;Route &#123;...rest&#125; render = &#123;(props) =&gt; isAuthed !== false ? &lt;Component &#123;...props&#125; /&gt; : &lt;Redirect to=&#123;&#123;pathname:'/signin', state: &#123;from:props.location&#125;&#125;&#125;/&gt; &#125; /&gt; )&#125;function AuthedRedirect (&#123;component: Component, ...rest&#125;) &#123; const isAuthed = useAuthed(); console.log(isAuthed); return ( &lt;Route &#123;...rest&#125; render = &#123;(props) =&gt; isAuthed !== false ? &lt;Redirect to=&#123;&#123;pathname:'/user', state: &#123;from:props.location&#125;&#125;&#125;/&gt; : &lt;Component &#123;...props&#125; /&gt; &#125; /&gt; )&#125;function App() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;AuthedRedirect path='/signin' component=&#123; SignIn &#125;/&gt; &lt;Route path='/signup' component=&#123; SignUp &#125;/&gt; &lt;Route path='/signout' component=&#123; SignOut &#125;/&gt; &lt;AuthedRoute path='/user' component=&#123; User &#125;/&gt; &lt;Route path='/' component=&#123; Main &#125;/&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;export default App; 백엔드에서 쿠키 뿌려주기지금까지 한 방법들은 쿠키를 생성하는 방법은 백엔드에서 토큰을 뿌려주면 프론트에서 토큰을 받아서 쿠키를 동적으로 생성하는 방법을 이용하였다. 그런데, 일반적으로는 백엔드에서 쿠키를 생성해서 보내주기도 하기 떄문에 참고를 하면 좋을 것이다. React Hook APIuseLayoutEffect 이 함수의 시그니처는 useEffect와 동일하긴 한데, 모든 DOM 변경 후에 동기적으로 발생한다. 이것은 DOM에서 레이아웃을 읽고 동기적으로 리렌더링하는 경우에 사용하도록 한다. useLayoutEffect의 내부에 예정된 갱신은 브라우저가 화면을 그리기 이전 시점에 동기적으로 수행될 것이다. 화면 갱신 차단의 방지가 가능할 때 표준 useEffect를 먼저 사용 후 문제가 있을 경우 useLayoutEffect를 이용한다. 즉, useEffect는 비동기적으로 실행이되기 때문에 빈번하게 업데이트 될 경우, 요소들이 깜박이는 현상이 일어날 수 있다. 그런데, useLayoutEffect는 동기적으로 실행이되기 때문에 이러한 형상을 방지할 수 있다. *리액트에서 공식적으로 useEffect를 권한다. 따라서 문제가 있을 경우에만 useLayoutEffect를 이용하도록 한다. * 팁 - 공식문서 클래스 컴포넌트에서 코드를 변환하는 경우에 useLayoutEffect는 componentDidMount나 componentDidUpdate와 동일한 단계를 실행하게 된다는 것에 주의하기 바랍니다. 그렇기는 하지만, 먼저 useEffect를 사용해 보고 문제가 있다면 그다음으로 useLayoutEffect를 사용해 보기를 권합니다. 서버 렌더링을 사용하는 경우라면 자바스크립트가 모두 다운로드될 때까지는 useLayoutEffect와 useEffect 어느 것도 실행되지 않는다는 것을 명심해야 합니다. 이것이 서버에서 렌더링 되는 컴포넌트에서 useLayoutEffect가 사용되는 경우에 대해 React가 경고하는 이유입니다. 이를 수정하기 위해서는 (최초 렌더링 시에 필요하지 않다면) 로직을 useEffect로 이동한다거나 (useLayoutEffect가 수행될 때까지 HTML이 깨져 보이는 경우는) 클라이언트 렌더링이 완료될 때까지 컴포넌트 노출을 지연하도록 하세요. 서버에서 렌더링된 HTML에서 레이아웃 effect가 필요한 컴포넌트를 배제하고 싶다면, showChild &amp;&amp;를 사용하여 조건적으로 렌더링 하고 useEffect(() =&gt; { setShowChild(true); }, [])를 사용하여 노출을 지연시키세요. 이런 방법으로 자바스크립트 코드가 주입되기 전에 깨져 보일 수 있는 UI는 표현되지 않게 됩니다. 1234567891011121314151617181920import React, &#123; useState, useEffect, useLayoutEffect &#125; from 'react'const BlinkRender = () =&gt; &#123; const [value, setValue] = useState(0); // useEffect(() =&gt; &#123; // useEffect는 깜박거림을 유발할 수 있다. useLayoutEffect(() =&gt; &#123; if (value === 0) &#123; setValue(10 + Math.random() * 200); &#125; &#125;, [value]) return ( &lt;div onClick = &#123;() =&gt; setValue(0)&#125;&gt; value : &#123;value&#125; &lt;/div&gt; )&#125;export default BlinkRender; createRef 와 useRef useRef와 createRef 의 사용처current 라는 프로퍼티를 이용해 다음과 같은 행위를 할 수 있다. 값을 저장할 수 있다. React 기본 내장 함수, return되는 DOM 요소에 직접적인 접근, Focus를 맞추고 싶을 때 사용한다. createRef 1234567891011121314151617181920import React, &#123; createRef &#125; from 'react'const BlinkRender = () =&gt; &#123; const inputElement = createRef(); const focusInput = () =&gt; &#123; inputElement.current.focus(); &#125; return ( &lt;&gt; &lt;input ref=&#123;inputElement&#125; type=\"text\" /* createRef은 ref=&#123;(ref) =&gt; input = ref&#125;로 하면 안된다. */ /&gt; &lt;button onClick=&#123;focusInput&#125;&gt;Focus Input&lt;/button&gt; &lt;/&gt; )&#125;export default BlinkRender; useRef 123456789101112131415161718import React, &#123; useRef &#125; from 'react'const BlinkRender = () =&gt; &#123; const inputElement = useRef(); const focusInput = () =&gt; &#123; inputElement.current.focus(); &#125; return ( &lt;&gt; &lt;input ref=&#123;inputElement&#125; type=\"text\"/&gt; &lt;button onClick=&#123;focusInput&#125;&gt;Focus Input&lt;/button&gt; &lt;/&gt; )&#125;export default BlinkRender; createRef vs useRef의 차이점 123456789101112131415161718192021222324252627import React, &#123; useState, createRef, useRef &#125; from 'react'// useRef vs createRefconst BlinkRender = () =&gt; &#123; const [renderIndex, setRenderIndex] = useState(1); const refFromUseRef = useRef() const refFromCreateRef = createRef() if(!refFromUseRef.current) &#123; refFromUseRef.current = renderIndex &#125; // 최초 실행시만 할당된다. if(!refFromCreateRef.current) &#123; refFromCreateRef.current = renderIndex &#125; // 최초 실행시만 할당된다. return ( &lt;&gt; &lt;p&gt;Current render index: &#123;renderIndex&#125;&lt;/p&gt; &lt;p&gt;refFromUseRef: &lt;b&gt;&#123;refFromUseRef.current&#125;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;refFromCreateRef: &lt;b&gt;&#123;refFromCreateRef.current&#125;&lt;/b&gt;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setRenderIndex(prev =&gt; prev + 1)&#125;&gt;Re-Render&lt;/button&gt; &lt;/&gt; )&#125;export default BlinkRender; 위 코드를 통해서 useRef는 리렌더링을 하지 않는 걸 확인할 수 있다. (useRef의 프로퍼티 변경되고 있으나 UI를 업데이트 하지 않는 것, createRef는 리렌더링 되고 있다.) 본질적으로 useRef와 createRef는 .current 프로퍼티에 변경 가능한 값을 담고 있는 “상자”와 같다. 즉, 기본적으로 2개는 사용법이 같고 하는 행위도 거의 동일하다. 하지만, 가장 큰 차이점을 내포하고 있다. useRef는 내용이 변경될 때 그것을 알려주지는 않는다. 는 것을 유념하자. useRef의 .current 프로퍼티를 변형하는 것이 리렌더링을 발생시키지는 않는다. *즉, useRef는 프로퍼티가 변형이 되어도 리렌더링이 안되는 것이고, * createRef는 프로퍼티가 변형이 되면 리렌더링이 된다는 것이다. useRef는 컴포넌트를 가리키고, Hook State의 예전 값을 가져올 수 있도록 할 수 있다. 추가로) 동적으로 받아올때는 createRef를 사용하지 않으며 외부에서 변수를 두고 ref={ ref =&gt; input = ref} 동적으로 할당. useEffect의 의존성 배열 12345678910111213141516171819202122import React, &#123; useState, useEffect &#125; from 'react';export default function App () &#123; const [user, setUser] = useState(&#123;name: 'react', count: 1&#125;) useEffect(() =&gt; &#123; console.log('updated'); // shallow comparions 얕은 검사 &#125;, [user]) const randomUpdate = () =&gt; &#123; const count = Math.random() &gt;= 0.5 ? user.count : user.count + 1; // 2분의 1 업데이트 setUser(user =&gt; (&#123;...user, count&#125;)) &#125;; return ( &lt;&gt; &lt;p&gt;Count: &#123;user.count&#125;&lt;/p&gt; &lt;button onClick=&#123;randomUpdate&#125;&gt;Random up&lt;/button&gt; &lt;/&gt; )&#125; 위 코드의 문제는 userEffect의 의존성 배열이다. [user] 직접적인 숫자,문자열 과 같은 값을 비교하는게 아닌 객체나 함수는 reference만 비교하기 때문에 항상 새로운 것으로 알아들어 useEffect가 게속 호출된다. 해결방법은 2가지다. 의존성 배열이 [user]가 아닌, [user.count]로서 값을 비교하게 한다. useEffect에서 2번째 파라미터를 비우고, 모든 변화에 대해서 업데이트(내부적인 조건으로)를 실행한다. 이렇게 2번쨰 파라미터인 의존성 배열을 작성하지 않을 경우, 모든 변화를 감지하기 때문에 조건을 작성해야한다. 조건을 작성할 때 조심해야할 것이 객체나 함수같은 참조형인데 객체나 함수는 단순 비교(=)를 하게되면 겉치레만 비교를 하는 얕은 검사를 사용한다. 얕은 검사는 조건 상 무의미 하므로 깊은 복사로 바꿔줘야하는데 여기서 lodash의 isEqual을 사용한다. useRef 와 useEffect - lodash(isEqual) 기본 위에서 배웠던 useRef와 useEffect를 이용하여 만든 예제이다. 해당 예제는 버튼을 누를 경우, 버튼이 2분의 1(정확히는 아니지만) 확률로 1씩 증가 한다. 증가하게 된다면 콘솔창에 ‘updated’를 띄울 것이고, 증가하지 않는다면 ‘변경후’ 라는 문구만 뜨게 된다. 12345678910111213141516171819202122232425262728293031323334import React, &#123; useEffect, useState, useRef &#125; from 'react'import &#123; isEqual &#125; from 'lodash'const BlinkRender = () =&gt; &#123; const [user, setUser] = useState(&#123;name : 'react', count: 1&#125;) useEffect(() =&gt; &#123; const prevUser = prevUserRef.current if(!isEqual(prevUser, user))&#123; // 유저가 변경되지 않을 경우 // Deep comparison console.log('updated'); &#125; &#125;) // shallow comparison 얕은 검사 : 객체와 함수 검사시 레퍼런스만 비교한다. const prevUserRef = useRef(); useEffect(() =&gt; &#123; prevUserRef.current = user; console.log('변경후', prevUserRef.current); &#125;) // shallow comparions 얕은 검사 : 객체와 함수 검사시 레퍼런스만 비교한다. const randomUp = () =&gt; &#123; const count = Math.random() &gt;= 0.5 ? user.count : user.count + 1; setUser(user =&gt; (&#123;...user, count&#125;)) // 늘 새로운 객체, 늘 새로운 참조값 &#125; return ( &lt;&gt; &lt;p&gt;Count : &#123;user.count&#125;&lt;/p&gt; &lt;button onClick=&#123;randomUp&#125;&gt;Up&lt;/button&gt; &lt;/&gt; )&#125;export default BlinkRender; useRef는 이전값을 기억하는 용도로 사용되었다. useEffect는 비동기로 처리가 되기 때문에 처음 setUser를 통해 새로운 카운트가 업데이트가 되었을 경우, 2번이 실행된다. 2번에서는 lodash의 isEqual을 사용하였는데 isEqual은 객체를 비교하는게 아니라 객체 내부의 내용을 비교한다. 따라서 카운트 값이 올라가 있다면 prevUser의 count는 1(처음기준), user의 count는 2이므로 updated를 출력하고 3번이 실행된다. 3번에서는 prevUserRef에 user의 현재값을 할당한다. useRef 와 useEffect - lodash(isEqual) 커스텀 Hook 사용하기 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useEffect, useState, useRef &#125; from 'react'import &#123; isEqual &#125; from 'lodash'const usePrev = value =&gt; &#123; const ref = useRef() useEffect(() =&gt; &#123; ref.current = value &#125;) console.log(ref); return ref.current;&#125;const BlinkRender = () =&gt; &#123; const [user, setUser] = useState(&#123;name : 'react', count: 1&#125;) const prevUser = usePrev(user); // ref.current useEffect(() =&gt; &#123; if(!isEqual(prevUser, user))&#123; // 유저가 변경되지 않을 경우 console.log('updated'); &#125; &#125;) // shallow comparison 얕은 검사 : 객체와 함수 검사시 레퍼런스만 비교한다. const randomUp = () =&gt; &#123; const count = Math.random() &gt;= 0.5 ? user.count : user.count + 1; setUser(user =&gt; (&#123;...user, count&#125;)) // 늘 새로운 객체, 늘 새로운 참조값 &#125; return ( &lt;&gt; &lt;p&gt;Count : &#123;user.count&#125;&lt;/p&gt; &lt;button onClick=&#123;randomUp&#125;&gt;Up&lt;/button&gt; &lt;/&gt; )&#125;export default BlinkRender; useRef는 이전값을 기억하는 용도로 사용되었다. 커스텀 Hook을 사용할 경우, 1번이 실행된다면 user의 count값은 2로 올라가고 리렌더링이 된후 2번 -&gt; 3번이 실행된다. setUser함수 호출이 끝나게 되면 State를 통해 관리되던 user의 변경이 있었으므로 리렌더링을 다시 하게 되는데 2번이 실행된다. 여기서 2번을 실행할 때, useEffect만을 실행하는 것이므로 결국적으로 prevUser 에 반환을 하지 않게 된다. 단지 ref.current값만 올라가게 된다. (처음 기준 prevUser = undefined 그대로, ref.current = 1) 3번에서는 lodash의 isEqual을 사용하였는데 isEqual은 객체를 비교하는게 아니라 객체 내부의 내용을 비교한다. 따라서 카운트 값이 올라가 있다면 prevUser의 count는 undefined(처음기준), user의 count는 1이므로 updated를 출력하고 setUser 함수 호출이 끝나게 된다. 다시, 버튼을 눌러서 값이 올라갈 경우, 리렌더링을 하게 되면서 prevUser의 값이 1로 올라가게 된다. setUser함수 호출이 끝나게 되면 State를 통해 관리되던 user의 변경이 있었으므로 리렌더링을 다시 하게 되는데 2번이 실행된다. 여기서 2번을 실행할 때, useEffect만을 실행하는 것이므로 결국적으로 prevUser 에 반환을 하지 않게 된다. 단지 ref.current값만 올라가게 된다. (처음 기준 prevUser = undefined 그대로, ref.current = 1) useEffect 정리 비동기 함수다. Hook은 렌더링 될 때 마다 순서대로 호출되어서 실행한다. useEffect는 얕은 비교를 한다. 참조형 비교가 아닐 때는 user.count와 같이 값으로서 비교한다. 참조형(객체,함수) 비교를 해야 할 경우 깊은 복사형의 비교(lodash-isEqual)를 한다. lodash-isEqual은 객체 내부의 value만 비교하고 객체자체는 비교하지 않는다!(참조까지 비교하면 항상 false) useEffect는 순차적으로 실행이 되므로 순서에 주의한다. 순서대로 Hook이 작동해야 하므로 if문, for문 등 조건으로 감싸면 안된다.(에러유발 - 내부 사용은 가능하다.) createContext createContext는 Provider를 이용해서 하위 트리에 있는 컴포넌트가 연결 되어 있는 값을 읽을 수 있게 할 수 있다. createContext를 사용하면 중간에 있는 엘리먼트들에게 props를 넘겨주지 않아도 된다. createContext는 가장 가까이 있는 테마 Provider를 찾아 그 값을 사용한다는 것이다. Class.contextType은 React.createContext()로 생성한 Context 객체를 원하는 클래스의 contextType 프로퍼티로 지정할 수 있다. 그리고 this.context를 이용해 해당 Context의 가장 가까운 Provider를 찾아 그 값을 읽을 수 있게 된다. 123456789101112131415161718192021222324252627282930313233343536// context를 사용하면 모든 컴포넌트를 일일이 통하지 않고도// 원하는 값을 컴포넌트 트리 깊숙한 곳까지 보낼 수 있다.// light를 기본값으로 하는 테마 context를 만들어 보자.const ThemeContext = React.createContext('light');class App extends React.Component &#123; render() &#123; // Provider를 이용해 하위 트리에 테마 값을 보내주자. // 아무리 깊숙히 있어도, 모든 컴포넌트가 이 값을 읽을 수 있다. // 아래 예시에서는 dark를 현재 선택된 테마 값으로 보내고 있다. return ( &lt;ThemeContext.Provider value=\"dark\"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;// 이젠 중간에 있는 컴포넌트가 일일이 테마를 넘겨줄 필요가 없다.function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class ThemedButton extends React.Component &#123; // 현재 선택된 테마 값을 읽기 위해 contextType을 지정한다. // React는 가장 가까이 있는 테마 Provider를 찾아 그 값을 사용할 것 이다. // 이 예시에서 현재 선택된 테마는 dark. static contextType = ThemeContext; render() &#123; return &lt;Button theme=&#123;this.context&#125; /&gt;; &#125;&#125; useContext createContext로 생성하고 Provider를 사용하는 부분까지는 완전 동일하다. 차이점은 createContext는 가장 가까운 Provider를 찾아 연결하지만, useContext는 명시적으로 선택을 해줄 수 있다. 또한, contextType등의 복잡한 작업을 생략하고 단편적으로 useContext(콘텍스트)로 사용도 할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839const themes = &#123; light: &#123; foreground: \"#000000\", background: \"#eeeeee\" &#125;, dark: &#123; foreground: \"#ffffff\", background: \"#222222\" &#125;&#125;;const ThemeContext = React.createContext(themes.light); // 생성부문 동일function App() &#123; // Provider 동일 return ( &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton() &#123; const theme = useContext(ThemeContext); // 명시적으로 선택하였음 return ( &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt; I am styled by theme context! &lt;/button&gt; );&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React Todo List V1","slug":"react-todo-v1","date":"2020-01-07T08:34:12.000Z","updated":"2020-01-08T18:56:54.220Z","comments":true,"path":"2020/01/07/react-todo-v1/","link":"","permalink":"https://hyeok999.github.io/2020/01/07/react-todo-v1/","excerpt":"","text":"Todo Version 1기능 Todo 추가 Todo 삭제 Todo 체크 전체 Todos 완료 / 미완료 토글 체크된 Todos 삭제 체크된 Todos 카운팅 체크되지 않은 Todos 카운팅 탭에 따라 Todo 분류 (전체 Todo, 체크된 Todo, 체크되지 않은 Todo) Todo Version 1 구축하기 컴포넌트를 분류하지 않고, 하나의 파일에 클래스형 컴포넌트로 구축해본다. 마크업123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"js/app.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"footer\"&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 초기화 데이터12345let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ] CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; /* font-size: 16px; */ font-size: 0.9em; color: #58666e; background-color: #f0f3f4; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102,175,233,.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todo-list &#123;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .custom-checkbox custom-checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 custom-checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"custom-checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.custom-checkbox &#123; display: none;&#125;.custom-checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.custom-checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.custom-checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;.footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; Todo V1 전체 코드JavaScript로 구현한 것보다 확실히 Render를 별도로 구현하지 않아서 훨씬 더 간편하였다. 상태만 관리해주면 되었기 때문에 직접적인 UI를 고려하지 않아도 되는 편리함을 느꼈다. 반대로, render되는 시점에 대한 이해가 더 필요할 것으로 생각된다. 처음 구현시 화면 렌더링 순서에 대한 오해가 개발하는 데 있어서 오류를 발생시키는 원인이 되었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import React, &#123; createRef, Component &#125; from 'react'import './App.css';class App extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; todos : [], navId : 'all' &#125;; this.nav = createRef(); // this.cleanTodos = this.cleanTodos.bind(this); &#125; componentDidMount() &#123; let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ] this.setState(&#123; todos : [...this.state.todos, ...todos] &#125;) &#125; generateId() &#123; return Math.max(0, ...this.state.todos.map((todo) =&gt; todo.id)) + 1; &#125; addTodo(key, target) &#123; if (target.value.trim() === '' || key !== 'Enter') return; let todo = &#123; id: this.generateId() , content: target.value, completed: false&#125;; this.setState(() =&gt; (&#123; todos : [...this.state.todos, todo] &#125;)) target.value = ''; &#125; removeTodo(target, id) &#123; if(target.classList[0] !== 'remove-todo') return this.setState(&#123; todos : this.state.todos.filter((todo) =&gt; todo.id !== id) &#125;); &#125; checkTodo(target, id)&#123; if(target.classList[0] !== 'custom-checkbox') return; this.setState(&#123; todos : this.state.todos.map((todo) =&gt; (todo.id === id ? &#123; ...todo, completed: !todo.completed &#125; : todo)) &#125;) &#125; toggleTodos(target) &#123; this.setState(&#123; todos : this.state.todos.map((todo) =&gt; (&#123; ...todo, completed: target.checked&#125;)) &#125;) &#125; cleanTodos() &#123; this.setState(&#123; todos : this.state.todos.filter((todo) =&gt; (!todo.completed)) &#125;) &#125; changeNav(target) &#123; if (target.classList.contains('nav')) return; [...this.nav.current.children].forEach((navList) =&gt; &#123; navList.classList.toggle('active', navList.id === target.id); this.setState(&#123; navId : target.id &#125;) &#125;); &#125; render() &#123; console.log(this.state); const _todos = this.state.todos.filter((&#123; completed &#125;) =&gt; (this.state.navId === 'all' ? true : this.state.navId === 'active' ? !completed : completed)); const completedCount = _todos.filter((&#123; completed &#125;) =&gt; completed).length; const activeCount = _todos.filter((&#123; completed &#125;) =&gt; !completed).length; return ( &lt;div className=\"container\"&gt; &lt;h1 className=\"title\"&gt;Todos&lt;/h1&gt; &lt;div className=\"ver\"&gt;2.0&lt;/div&gt; &lt;input className=\"input-todo\" placeholder=\"What needs to be done?\" autoFocus onKeyPress=&#123;(&#123;key, target&#125;) =&gt; this.addTodo(key, target)&#125; /&gt; &lt;ul className=\"nav\" ref=&#123;this.nav&#125; onClick=&#123;(&#123;target&#125;) =&gt; this.changeNav(target)&#125;&gt; &lt;li id=\"all\" className=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul className=\"todos\"&gt; &#123; _todos.map((todo) =&gt; ( &lt;li id=&#123;todo.id&#125; className=\"todo-item\" key=&#123;todo.id&#125;&gt; &lt;input className=\"custom-checkbox\" type=\"checkbox\" onChange=&#123;(&#123;target&#125;) =&gt; this.checkTodo(target, todo.id)&#125; id=&#123;`ck-$&#123;todo.id&#125;`&#125; checked=&#123;todo.completed&#125; /&gt; &lt;label htmlFor=&#123;`ck-$&#123;todo.id&#125;`&#125;&gt;&#123;todo.content&#125;&lt;/label&gt; &lt;i className=\"remove-todo far fa-times-circle\" onClick=&#123;(&#123;target&#125;) =&gt; this.removeTodo(target, todo.id)&#125;&gt;&lt;/i&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;div className=\"footer\"&gt; &lt;div className=\"complete-all\"&gt; &lt;input className=\"custom-checkbox\" type=\"checkbox\" id=\"ck-complete-all\" onClick=&#123;(&#123;target&#125;) =&gt; this.toggleTodos(target)&#125;/&gt; &lt;label htmlFor=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div className=\"clear-completed\"&gt; &lt;button className=\"btn\" onClick=&#123;() =&gt; this.cleanTodos&#125;&gt;Clear completed (&lt;span className=\"completed-todos\"&gt;&#123;completedCount&#125;&lt;/span&gt;)&lt;/button&gt; &lt;strong className=\"active-todos\"&gt;&#123;activeCount&#125;&lt;/strong&gt; items left &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 소스 코드 보기","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"Todo List","slug":"Todo-List","permalink":"https://hyeok999.github.io/tags/Todo-List/"},{"name":"Class Component","slug":"Class-Component","permalink":"https://hyeok999.github.io/tags/Class-Component/"}]},{"title":"useRef 로 컴포넌트 안의 변수 만들기","slug":"react-velo-10","date":"2020-01-06T15:01:02.000Z","updated":"2020-01-06T15:02:59.513Z","comments":true,"path":"2020/01/07/react-velo-10/","link":"","permalink":"https://hyeok999.github.io/2020/01/07/react-velo-10/","excerpt":"","text":"React with Velopert - 10 - useRef 로 컴포넌트 안의 변수 만들기 예제 : useRef 를 사용하여 변수를 만들기 UserList.js App.js Chap 10. useRef 로 컴포넌트 안의 변수 만들기useRef 로 컴포넌트 안의 변수 만들기 컴포넌트에서 특정 DOM 을 선택해야 할 때, ref 를 사용해야 한다. 그리고, 함수형 컴포넌트에서 이를 설정 할 때 useRef 를 사용하여 설정해야 한다. 여기서 사용된 useRef Hook은 DOM을 선택하는 용도 외에도, 컴포넌트 안에서 조회 및 수정 할 수 있는 변수를 관리할 수 있다. useRef로 관리하는 변수는 값이 바뀐다고 해서 리렌더링 되지 않는다. 리액트 컴포넌트에서의 상태는 상태를 바꾸는 함수를 호출하고 나서 그 다음 렌더링 이후로 업데이트 된 상태를 조회 할 수 있는 반면에 useRef로 관리하고 있는 변수는 설정 후 바로 조회가 가능하다. 이 변수를 사용하여 다음과 같은 값을 관리 할 수 있다. setTimeout, setInterval 을 통해서 만들어진 id 외부 라이브러리를 사용하여 생성된 인스턴스 scroll 위치 우리는, App 컴포넌트에서 useRef 를 사용하여 변수를 관리해보자, 용도는 우리가 앞으로 배열에 새 항목을 추가할건데, 새 항목에서 사용 할 고유 id 를 관리하는 용도이다. useRef 를 사용하여 변수를 관리하기 전에 해야 할 작업이 있다. 지금은 우리가 UserList 컴포넌트 내부에서 배열을 직접 선언해서 사용을 하고 있는데, 이렇게 UserList 에서 선언해서 사용하는 대신에, 이 배열을 App 에서 선언하고 UserList 에게 props 로 전달 해주자. 예제 : useRef 를 사용하여 변수를 만들기UserList.js123456789101112131415161718192021import React from 'react';function User(&#123; user &#125;) &#123; return ( &lt;div&gt; &lt;b&gt;&#123;user.username&#125;&lt;/b&gt; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;/div&gt; );&#125;function UserList(&#123; users &#125;) &#123; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default UserList; App.js123456789101112131415161718192021222324252627282930313233import React, &#123; useRef &#125; from 'react';import UserList from './UserList';function App() &#123; const users = [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]; const nextId = useRef(4); // current : 4 const onCreate = () =&gt; &#123; // 나중에 구현 할 배열에 항목 추가하는 로직 // ... nextId.current += 1; // current : 5 &#125;; return &lt;UserList users=&#123;users&#125; /&gt;;&#125;export default App; 여기서 알수 있는 것 useRef() 를 사용 할 때 파라미터를 넣어주면, 이 값이 .current 값의 기본값이 된다. 수정 할때에는 .current 값을 수정하면 되고 조회 할 때에는 .current 를 조회하면 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"배열 렌더링하기","slug":"react-velo-09","date":"2020-01-06T11:27:56.000Z","updated":"2020-01-06T14:59:42.073Z","comments":true,"path":"2020/01/06/react-velo-09/","link":"","permalink":"https://hyeok999.github.io/2020/01/06/react-velo-09/","excerpt":"","text":"React with Velopert - 09 - 배열 렌더링하기 기본 배열 렌더링 UserList.js map 함수를 이용한 배열 렌더링 UserList.js key 추가하기 key의 존재유무에 따른 업데이트 방식 key가 없을 시 key가 존재할 시 Chap 9. 배열 렌더링하기배열 렌더링하기 다음과 같은 배열이 있다고 가정해보자. 1234567891011121314151617const users = [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125;]; 위 배열을 렌더링하려면 가장 단순한 것은 그대로 코드를 작성하는 것인데… UserList.js 123456789101112131415161718192021222324252627282930313233343536import React from 'react';function UserList() &#123; const users = [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]; return ( &lt;div&gt; &lt;div&gt; &lt;b&gt;&#123;users[0].username&#125;&lt;/b&gt; &lt;span&gt;(&#123;users[0].email&#125;)&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;b&gt;&#123;users[1].username&#125;&lt;/b&gt; &lt;span&gt;(&#123;users[1].email&#125;)&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;b&gt;&#123;users[2].username&#125;&lt;/b&gt; &lt;span&gt;(&#123;users[1].email&#125;)&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default UserList; 위와 같은 방법은 너무 중복된 코드가 많으므로 컴포넌트를 이용해 재사용 해보도록 하겠다. 기본 배열 렌더링 UserList.js123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';function User(&#123; user &#125;) &#123; return ( &lt;div&gt; &lt;b&gt;&#123;user.username&#125;&lt;/b&gt; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;/div&gt; );&#125;function UserList() &#123; const users = [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]; return ( &lt;div&gt; &lt;User user=&#123;users[0]&#125; /&gt; &lt;User user=&#123;users[1]&#125; /&gt; &lt;User user=&#123;users[2]&#125; /&gt; &lt;/div&gt; );&#125;export default UserList; 위와 같은 방식은 배열이 항상 고정적일 경우 나쁘지 않을 수도 있다. 하지만 배열이 수시로 늘어나고 적어짐에 따라 개발자는 배열이 늘어남과 동시에 수정할 곳이 늘어나는데 즉 유지보수성이 안 좋을 뿐더러 실수를 유발하는 원인이 될 수도 있고 실사용에서 이러한 실수는 치명적인 문제로 남을 수 있다. 따라서, 동적인 배열을 렌더링할 때는 다음 방법을 이용해보도록 한다. map 함수를 이용한 배열 렌더링 UserList.js동적인 배열을 렌더링하고자 할 때는 map()를 이용하도록 한다. 123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';function User(&#123; user &#125;) &#123; return ( &lt;div&gt; &lt;b&gt;&#123;user.username&#125;&lt;/b&gt; &lt;span&gt;(&#123;user.email&#125;)&lt;/span&gt; &lt;/div&gt; );&#125;function UserList() &#123; const users = [ &#123; id: 1, username: 'velopert', email: 'public.velopert@gmail.com' &#125;, &#123; id: 2, username: 'tester', email: 'tester@example.com' &#125;, &#123; id: 3, username: 'liz', email: 'liz@example.com' &#125; ]; return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; /&gt; ))&#125; &lt;/div&gt; );&#125;export default UserList; key 추가하기React에서 배열을 렌더링 할 때는 key라는 props를 상위 태그에 설정해주어야 한다. key를 설정 안해줄 경우 렌더링시 경고를 띄우기도 하고 실제로 정렬시 문제를 일으킬 수도 있기 때문에 설정 해주는 것이 중요하다. key 값은 각 원소들마다 가지고 있는 고유값으로 설정을 해야한다. 지금의 경우엔 id 가 고유 값으로 사용할 수 있는데 이를 위한 모듈도 존재한다.(uuid) 단, 자바스크립트가 지원하는 빌트인 함수인 렌더함수는 이용하면 안된다. 렌더함수는 고유값을 배포하는게 아니기 때문에 안전성면에서 약간 떨어지기 때문이다. 1234567return ( &lt;div&gt; &#123;users.map(user =&gt; ( &lt;User user=&#123;user&#125; key=&#123;user.id&#125; /&gt; ))&#125; &lt;/div&gt;); 만약에 배열을 렌더링 할 때 key 설정을 하지 않게된다면 기본적으로 배열의 index 값을 key 로 사용하게 되고, 콘솔창에 경고 메시지가 뜨게 된다. key의 존재유무에 따른 업데이트 방식 다음과 같은 배열이 있다고 가정하자. 123456const array = [ &#123; id: 0, text: 'a' &#125;, &#123; id: 1, text: 'b' &#125;, &#123; id: 2, text: 'c' &#125;, &#123; id: 3, text: 'd' &#125;,]; key가 없을 시 위 배열을 다음과 같이 렌더링한다고 가정해보자. key를 설정하지 않고 렌더링 한 것이다. 1array.map(item =&gt; &lt;div&gt;&#123;item.text&#125;&lt;/div&gt;); // key 미설정 위 배열의 b 와 c 사이에 z 를 삽입하게 된다면, 리렌더링을 하게 될 때 b 와 c 사이에 새 div 태그를 삽입을 하게 되는 것이 아니라, 기존의 c 가 z 로바뀌고, d 는 c 로 바뀌고, 맨 마지막에 d 가 새로 삽입된다. 그 다음에 a 를 제거하게 된다면, 기존의 a 가 b 로 바뀌고, b 는 z 로 바뀌고, z는 c로 바뀌고, c는 d 로바뀌고, 맨 마지막에 있는 d 가 제거된다. key가 존재할 시 만약 key를 다음과 같이 설정 해준다면 이 작업은 개선된다. 1array.map(item =&gt; &lt;div key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/div&gt;); // key 설정 배열이 업데이트 될 떄 key 가 없을 때 처럼 비효율적으로 업데이트 하는 것이 아니라, 수정되지 않는 기존의 값은 그대로 두고 원하는 곳에 내용을 삽입하거나 삭제한다. 때문에, 배열을 렌더링 할 때에는 고유한 key 값이 있는것이 중요하며, 만약에 배열안에 중복되는 key 가 있거나 key가 아예 존재하지 않을 때에는 렌더링시에 오류메시지가 콘솔에 나타나게 되며, 업데이트가 제대로 이루어지지 않게 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"useRef","slug":"react-velo-08","date":"2020-01-04T12:10:37.000Z","updated":"2020-01-04T12:12:36.334Z","comments":true,"path":"2020/01/04/react-velo-08/","link":"","permalink":"https://hyeok999.github.io/2020/01/04/react-velo-08/","excerpt":"","text":"React with Velopert - 08 - useRef 예제 : 초기화 버튼을 클릭했을 때 이름 input 에 포커스가 잡히도록 useRef 를 사용하여 기능을 구현 InputSample.js Chap 8. useRef 로 특정 DOM 선택하기useRef JavaScript 를 이용하여 특정 DOM을 선택하는 상황에서 우리는 getElementById, querySelector 같은 DOM Selector 함수를 사용해서 DOM을 선택하고는 했다. 엘리먼트의 크기 필요 스크롤바 위치 설정 포커스를 지정 Video.js, JWPlayer 같은 HTML Video 관련 라이브러리 D3, chart.js 같은 그래프 관련 라이브러리 등의 외부 라이브러리 etc… 위와 같은 여러가지 복잡한 상황 속에서는 리액트도 직접적으로 DOM을 선택해야만 한다. 여기서 리액트는 ref 를 사용한다. 함수형 컴포넌트에서 ref 를 사용 할 때에는 useRef 라는 Hook 함수를 이용한다. 클래스형 컴포넌트에서는 콜백함수, React.createRef 라는 함수를 이용한다. 예제 : 초기화 버튼을 클릭했을 때 이름 input 에 포커스가 잡히도록 useRef 를 사용하여 기능을 구현 전에 만든 InputSample.js 에서는 초기화 버튼을 누르면 포커스가 초기화 버튼에 그대로 남아있게 되었다. 이번에는 초기화 버튼을 클릭 시 input에 포커스가 잡히는 기능을 구현해본다. InputSample.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, &#123; useState, useRef &#125; from 'react';function InputSample() &#123; const [inputs, setInputs] = useState(&#123; name: '', nickname: '' &#125;); const nameInput = useRef(); const &#123; name, nickname &#125; = inputs; // 비구조화 할당을 통해 값 추출 const onChange = (e) =&gt; &#123; const &#123; value, name &#125; = e.target; // 우선 e.target 에서 name 과 value 를 추출 setInputs(&#123; ...inputs, // 기존의 input 객체를 복사한 뒤 [name]: value // name 키를 가진 값을 value 로 설정 &#125;); &#125;; const onReset = () =&gt; &#123; setInputs(&#123; name: '', nickname: '', &#125;); nameInput.current.focus(); &#125;; return ( &lt;div&gt; &lt;input name=\"name\" placeholder=\"이름\" onChange=&#123;onChange&#125; value=&#123;name&#125; ref=&#123;nameInput&#125; /&gt; &lt;input name=\"nickname\" placeholder=\"닉네임\" onChange=&#123;onChange&#125; value=&#123;nickname&#125; /&gt; &lt;button onClick=&#123;onReset&#125;&gt;초기화&lt;/button&gt; &lt;div&gt; &lt;b&gt;값: &lt;/b&gt; &#123;name&#125; (&#123;nickname&#125;) &lt;/div&gt; &lt;/div&gt; );&#125;export default InputSample; useRef() 를 사용하여 Ref 객체를 만들고, 이 객체를 선택하고 싶은 DOM 에 ref 값으로 설정해주어야 한다. 그러면, Ref 객체의 .current 값은 우리가 원하는 DOM 을 가르키게 된다. 위 예제에서는 onReset 함수에서 input 에 포커스를 하는 focus() DOM API 를 호출해주었다. 이제 input 에 포커스가 잘 잡힐 것 이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"여러개 input 상태 관리하기","slug":"react-velo-07","date":"2020-01-04T10:46:25.000Z","updated":"2020-01-04T12:08:46.975Z","comments":true,"path":"2020/01/04/react-velo-07/","link":"","permalink":"https://hyeok999.github.io/2020/01/04/react-velo-07/","excerpt":"","text":"React with Velopert - 07 - 여러개 input 상태 관리하기 예제 : 여러 input 박스 입력 및 초기화 버튼 만들기 (상태 관리하기) App.js InputSample.js 주의점-불변성 Chap 7. 여러개의 input 상태 관리하기여러개 input 상태 관리하기 input 상태가 다수 일 경우 관리를 하는 방법을 알아보자. 예제 : 여러 input 박스 입력 및 초기화 버튼 만들기 (상태 관리하기)App.js12345678910import React from 'react';import InputSample from './InputSample';function App() &#123; return ( &lt;InputSample /&gt; );&#125;export default App; InputSample.jsinput 의 개수가 여러개가 됐을때는, 단순히 useState 를 여러번 사용하고 onChange 도 여러개 만들어서 구현 할 수 있다. 하지만 그 방법은 가장 좋은 방법은 아니다. 더 좋은 방법은, input 에 name 을 설정하고 이벤트가 발생했을 때 이 값을 참조하는 것이다. 그리고, useState 에서는 문자열이 아니라 객체 형태의 상태를 관리해주어야 한다. 기존의 InputSample 컴포넌트를 다음과 같이 수정해보자. 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; useState &#125; from 'react';function InputSample() &#123; const [inputs, setInputs] = useState(&#123; name: '', nickname: '' &#125;); const &#123; name, nickname &#125; = inputs; // 비구조화 할당을 통해 값 추출 const onChange = (e) =&gt; &#123; const &#123; value, name &#125; = e.target; // 우선 e.target 에서 name 과 value 를 추출 setInputs(&#123; ...inputs, // 기존의 input 객체를 복사한 뒤 [name]: value // name 키를 가진 값을 value 로 설정 &#125;); &#125;; const onReset = () =&gt; &#123; setInputs(&#123; name: '', nickname: '', &#125;) &#125;; return ( &lt;div&gt; &lt;input name=\"name\" placeholder=\"이름\" onChange=&#123;onChange&#125; value=&#123;name&#125; /&gt; &lt;input name=\"nickname\" placeholder=\"닉네임\" onChange=&#123;onChange&#125; value=&#123;nickname&#125;/&gt; &lt;button onClick=&#123;onReset&#125;&gt;초기화&lt;/button&gt; &lt;div&gt; &lt;b&gt;값: &lt;/b&gt; &#123;name&#125; (&#123;nickname&#125;) &lt;/div&gt; &lt;/div&gt; );&#125;export default InputSample; 주의점-불변성 React에서 객체 상태를 수정할 때는 다음과 같이 직접적으로 값을 할당해서는 안된다. 1inputs[name] = value; inputs[name] = value 이런식으로 기존 상태를 직접 수정하게 되면, 값을 바꿔도 리렌더링이 되지 않는다. React에서는 객체 내용을 수정할 때, 반드시 객체로 반환해야한다. 여기서 주의점은 *객체로 반환시 기존의 객체에 덮어씌우는 꼴이기 때문에 전의 내용은 유지를 할 수가 없다. * 전의 내용을 유지하고 싶다면 반드시 Spread(…)문법이나 Object.assign 함수등을 이용해 복사해야만 한다. 1234setInputs(&#123; ...inputs, [name]: value&#125;); 이러한 작업들은 ‘불변성’을 지키기 위함인데 리액트가 컴포넌트에서 상태가 업데이트가 됬음을 감지하고 이에 따라 필요한 렌더링을 진행할 수 있다. 리액트에서는 불변성을 지켜주어야만 컴포넌트 업데이트 성능 최적화를 제대로 할 수 있다. 참고로, Redux에서도 위와 같은 이유로 반드시 새로운 객체를 반환해야만 한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 13","slug":"react-study-13","date":"2020-01-03T12:58:21.000Z","updated":"2020-01-03T13:00:22.803Z","comments":true,"path":"2020/01/03/react-study-13/","link":"","permalink":"https://hyeok999.github.io/2020/01/03/react-study-13/","excerpt":"","text":"React Study 13 JWT 기밀성, 무결성 이란? JWT 사용하기 JWT 생성 JWT 검증 (토큰 내부의 값을 확인할 수 잇다.) key 설정하기 JWT 디코드 그 외 추가 기술 : nonce 로그인 구현하기 user 커포넘트 만들기 api 추가하기 api 전체코드 쿠키 Set 설정 및 API 설정 쿠키 Get 설정 - 커스텀 Hook 커스텀 라우팅 용어 - ( 러버덕 ) JWT 기밀성 무결성 JWT 생성 JWT 검증 + key 설정 JWT 디코드 nonce JWT Bearer, Basic, jwt 라는 접두사로 시작하는 token이다. 헤드 부분에 접두사 형식으로 명시적으로 토큰 타입이 작성되는 경우도 있다. 백엔드는 클라이언트가 보낸 데이터의 원본을 절대 믿어서는 안된다. ( 위변조가 가능하기 때문 ) 따라서, 클라이언트가 보내는 데이터가 안정적 임을 확인하는 방법은 무엇인가? 데이터의 기밀성 , 무결성 을 보장하면 된다. 기밀성, 무결성 이란?기밀성 : 데이터 자체를 노출시키지 않는것이 목적 (암호화). 무결성 : 데이터가 그대로 변형되지 않고 전달되는 성질. JWT는 암호화(기밀성)가 목적이 아니라 데이터의 위변조를 판별하는 것 (즉, 무결성이 목적) 그 증거로 JWT.io 에 접속해보면 토큰을 아무런 제약없이 세부 내용을 확인 할 수 있다. 즉 토큰만 탈취를 한다면 손쉽게 세부내용을 볼 수 있다는 것이다. JWT 사용하기 JWT를 더 쉽게 사용하기 위한 npm 이 존재한다. 1npm install jsonwebtoken --save JWT 생성 백엔드에서 토큰을 만들어서 배포하는 경우가 대부분이다. 1234// import jwt from 'jsonwebtoken';var jwt = require('jsonwebtoken');var token = jwt.sign(&#123;foo:'bar'&#125;, 'keeey');var token2 = jwt.sign(&#123;foo:'bar'&#125;, 'keeey', &#123; expiresIn: 604800 &#125;); // 1 week 1번째 파라미터 : 임의의 위변조를 방지하고 싶은 JSON 객체를 정의 2번째 파라미터 : 키값 (노출되어서는 안된다.) 3번째 파라미터[옵션] : 해당 토큰이 존재할 수 있는 시간(만료시간)을 정의한다. 1초단위로 설정할 수 있다. JWT 검증 (토큰 내부의 값을 확인할 수 잇다.) 사실상 프론트 개발자가 가장 많이 사용되는 부분 1var decoded = jwt.verify(token, 'keeey'); 1번째 파라미터 : 임의의 위변조를 방지하고 싶은 JSON 객체를 정의. 2번쨰 파라미터 : 키값 (노출되어서는 안된다.) 여기서 2번째 파라미터인 key는 백엔드개발자가 프론트엔드 개발자에게 key값을 반드시 알려줘야한다. key 설정하기 key값은 프론트엔드에서는 .env파일로 저장을 한다. 1var decoded = jwt.verify(token, `process.env.REACT_APP_임의의_변수명` : ); .env파일 1process.env.REACT_APP_임의의_변수명=keeey key값의 유출은 결국 무결성을 보장할 수 없다는 의미를 말한다. 이외에도 key 값은 보통 AWS SSM 스토어를 통해 백엔드 개발자가 등록을 해두면, 동적으로 생성되는 코드들을 이용하거나 docker를 통해서 동적으로 배포하는 방법들이 있는데 이는 백엔드 개발자와 협업을 통해서 결정한다. JWT 디코드 1var decoded = jwt.decoded(token); 파라미터 : 토큰의 원본 토큰의 원본 값(JSON 객체)를 확인 할 수 있다. (단, 키값 없이 확인하는것이기 때문에 무결성을 보장할 수 없다.) JWT.io 에서 제공해주는 토큰을 확인하는 기능도 jwt.decoded 기능이다. 실상 검증보다는 많이 사용되지는 않는다. 그 외 추가 기술 : noncenonce : 기존값에 특수문자를 붙여서 사용한다. nonce는 패스워드가 정말 중요한 곳(보안성이 높아야만 하는 곳)에서 사용한다. 패스워드를 원본을 보내는것이 아니라 패스워드 사이에 임시의 특수문자들을 넣어준다. 사용자가 아이디랑 패스워드를 입력하고 로그인 버튼을 눌렀을 때 사용자가 입력한 값 외에 임의로 알수없는 값들이 추가되어서 그 값을 전송 시키는 방식이다. nonce는 수학적으로 증명된 라이브러리만 의미있으므로 반드시 라이브러리를 사용해야만 한다. 로그인 구현하기 로그인을 하려면 아이디와 패스워드가 필요하는데 프론트엔드가 백엔드에게 보내는 데이터에 대해 기밀성 혹은 무결성을 지켜줘야만 백엔드는 해당 데이터를 안심하고 사용할 수 있다. 왜냐하면 프론트엔드가 보내는 데이터의 신뢰를 보장해줄 장치가 필요하기 때문이다. 이는 서비스를 함에 있어 매우 중요하다. 우리는 그 신뢰를 JWT로 한다. 회원가입이 된 계정에게는 토큰이 발급되고 안된 계정에게는 토큰이 발급되지 않는다. 토큰의 생성 시점은 회원가입이 완료 되었을 때다. 문제는 회원가입 후 로그인을 하면서 생성된 토큰을 클라이언트가 가지고 있어야하는데 이부분을 쿠키로 해결한다. user 커포넘트 만들기 src/components/User/index.jsx 12345678910111213import React, &#123; useEffect &#125; from 'react'// import &#123; useAuthed &#125; from '../../lib/hooks'const User = (props) =&gt; &#123; return ( &lt;div&gt; 유저입니다. &lt;button onClick=&#123;() =&gt; &#123;props.history.push('/signout')&#125;&#125;&gt;로그아웃&lt;/button&gt; &lt;/div&gt; );&#125;export default User; api 추가하기 user API경우 헤더에 JWT 토큰을 넣어서 보내준다. 1const headers = &#123;'Authorization' : `JWT $&#123;session&#125;`&#125; api 전체코드src/lib/api.js 12345678910111213141516171819202122232425262728293031323334353637import axios from 'axios';export const signUp = async (&#123; username, password1 : password &#125;) =&gt; &#123; const &#123; data &#125; = await axios.post('http://localhost:3001/api/signup', &#123; username, password &#125;) console.log(data); return data;&#125;export const signIn = async (&#123; username, password &#125;) =&gt; &#123; const &#123; data &#125; = await axios.post('http://localhost:3001/api/signin', &#123; username, password &#125;) console.log(data); return data;&#125;export const signOut = async (session) =&gt; &#123; const headers = &#123; 'Authorization' : `JWT $&#123;session&#125;` &#125; const &#123; data &#125; = await axios.get('http://localhost:3001/api/signout', headers); console.log(data); return data;&#125;export const user = async (session) =&gt; &#123; const headers = &#123; 'Authorization' : `JWT $&#123;session&#125;` &#125; const &#123; data &#125; = await axios.get('http://localhost:3001/api/user', headers); console.log(data); return data;&#125; 쿠키 Set 설정 및 API 설정 먼저 로그인시 쿠키를 저장해야 되므로 쿠키를 설정해야 한다. npm 모듈에서 쿠키를 쉽게 사용할 수 있는 라이브러리를 이용을 한다. src/SignIn/index.jsx 1234567891011121314151617181920import React from 'react';import &#123; useForm &#125; from \"react-hook-form\";import &#123; signIn &#125; from '../../lib/api';import Cookies from 'js-cookie';const SignIn = (props) =&gt; &#123; const &#123; handleSubmit, register, errors &#125; = useForm(); const onSubmit = async values =&gt; &#123; const &#123; success , token &#125; = await signIn(values); if (success) &#123; // Cookies.set('session', token.split(' ')[1],&#123;expires:7&#125;); Cookies.set('session', token.split(' ')[1]); props.history.push('/user'); &#125; &#125;; return ( ... 쿠키는 Cookise.set(키, 값, [옵션-기한])으로 설정 가능하다. 1번째 파라미터 : name을 설정 해주어야 한다. 1번째 파라미터의 이름은 암묵적은 session이라고 정해주는 룰이 있다. 2번째 파라미터 : 1번쨰 파라미터와 쌍이 될 값을 적어주는데, JWT가 여기에 적힌다. 문제는 JWT의 접두사는 빼고 넣어야된다는 것이다. 3번째 파라미터 : 쿠키도 키한을 설정해줄 수 있다. 기한을 생략할 경우 session으로 들어가게 되는데 session은 브라우저가 닫힐 떄(탭말고 완전히 꺼질 때)까지의 기한을 의미한다. 쿠키 Get 설정 - 커스텀 Hook 쿠키에게 세션값을 가져와서 verify를 하여 오류가 없다면 json객체를 , 있다면 false를 반환해주는 커스텀훅을 작성해준다. verify는 npm 모듈을 이용하며, js-cookie로 구현한다. 커스텀 hook은 use키워드를 앞에 붙여주어야만 한다. 쿠키에서 초기 값을 가져와야 하므로 함수 표현식으로 초기화. lib/hooks.js 파일 생성 12345678910111213141516171819import React, &#123; useState &#125; from 'react'import Cookies from 'js-cookie';import jwt from 'jsonwebtoken';// 쿠키에게 세션값을 가져와서 verify를 하여 오류가 없다면 json 객체를 있다면 false를 반환해주는 커스텀훅export const useAuthed = () =&gt; &#123; const [ authed ] = useState(() =&gt; &#123; try &#123; const session = Cookies.get('session'); const key = process.env.REACT_APP_JWT_KEY; const res = jwt.verify(session, key); return res; &#125; catch (error) &#123; return false; // 위변조가 되었음을 의미한다. &#125; &#125;); return authed;&#125; .env파일 작성. README.md 파일과 같은 위치에 있어야 한다. 1REACT_APP_JWT_KEY=nodeauthsecret 커스텀 라우팅 라우터에서 검증을 하고 라우터에서 접근하는 즉시 인증을하여 통과시 로그인 아닐 시 로그아웃. src/components/Main.jsx 123456789101112131415161718192021222324function AuthedRoute (&#123;component: Component, authed, ...rest&#125;) &#123; return ( &lt;Route &#123;...rest&#125; render = &#123;(props) =&gt; authed !== false ? &lt;Component &#123;...props&#125; /&gt; : &lt;Redirect to=&#123;&#123;pathname:'/signin', state: &#123;from:props.location&#125;&#125;&#125;/&gt; &#125; /&gt; )&#125;function App() &#123; const isAuthed = useAuthed() return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path='/signin' component=&#123; Signin &#125; /&gt; &lt;Route path='/signup' component=&#123; Signup &#125;/&gt; &lt;AuthedRoute authed=&#123;isAuthed&#125; path='/user' component=&#123; User &#125;/&gt; &lt;Route path='/' component=&#123; Main &#125;/&gt; &lt;/Switch&gt; &lt;/Router&gt; );","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"input 상태 관리하기","slug":"react-velo-06","date":"2020-01-03T09:15:00.000Z","updated":"2020-01-03T12:58:54.959Z","comments":true,"path":"2020/01/03/react-velo-06/","link":"","permalink":"https://hyeok999.github.io/2020/01/03/react-velo-06/","excerpt":"","text":"React with Velopert - 06 - input 상태 관리하기 예제 : input 박스 입력 및 초기화 버튼 만들기 App.js InputSample.js Chap 6. input 상태 관리하기input 상태 관리하기 이번에는 리액트에서 사용자가 입력 할 수 있는 input 태그의 상태를 관리하는 방법을 알아보자. 예제 : input 박스 입력 및 초기화 버튼 만들기App.js12345678910import React from 'react';import InputSample from './InputSample';function App() &#123; return ( &lt;InputSample /&gt; );&#125;export default App; InputSample.jsuseState를 사용해서 버튼을 초기화하는 작업을 해보도록한다. input의 onChange 이벤트를 사용하도록한다. 이벤트에 등록하는 함수에서는 이벤트객체(e)를 파라미터로 받아와서 사용하는데 e.target은 이벤트가 발생한 DOM인 input DOM을 가르키게 된다. DOM의 value 값 즉, e.target.value를 조회하면 현재 input에 입력한 값이 무엇인지 확인할 수 있다. 12345678910111213141516171819202122232425import React, &#123; useState &#125; from 'react';function InputSample() &#123; const [text, setText] = useState(''); const onChange = (e) =&gt; &#123; setText(e.target.value); &#125;; const onReset = () =&gt; &#123; setText(''); &#125;; return ( &lt;div&gt; &lt;input onChange=&#123;onChange&#125; value=&#123;text&#125; /&gt; &lt;button onClick=&#123;onReset&#125;&gt;초기화&lt;/button&gt; &lt;div&gt; &lt;b&gt;값: &#123;text&#125;&lt;/b&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default InputSample; input 의 상태를 관리할 때에는 input 태그의 value 값도 설정해주는 것이 중요하다. 상태가 바뀌었을때 input 의 내용도 업데이트 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"useState를 통해 컴포넌트에서 바뀌는 값 관리하기","slug":"react-velo-05","date":"2020-01-02T13:46:31.000Z","updated":"2020-01-02T13:50:59.767Z","comments":true,"path":"2020/01/02/react-velo-05/","link":"","permalink":"https://hyeok999.github.io/2020/01/02/react-velo-05/","excerpt":"","text":"React with Velopert - 05 - useState 예제 : 버튼을 누르면 숫자가 바뀌는 Counter 컴포넌트 App.js Counter.js 이벤트 설정하기 동적인 값 끼얹기, useState 예제 : Counter.js에 Hook 사용해서 상태 관리해보기 정리 정리 - useReact 사용방법1 : 모듈 import 하기. 정리 - useReact 사용방법2 : 함수 호출하여 사용하기. 정리 - useReact 사용방법3 : 상태 변경 및 조회하기. 함수형 업데이트 Counter.js Chap 5. useState를 통해 컴포넌트에서 바뀌는 값 관리하기useState 리액트 16.8 이전 버전에서는 함수형 컴포넌트에서는 상태를 관리할 수 없었다. 하지만, 리액트 16.8 에서 Hooks 라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었다. 이번에는 useState 라는 함수를 사용해보게 되는데, 이게 바로 리액트의 Hooks 중 하나이다. 예제 : 버튼을 누르면 숫자가 바뀌는 Counter 컴포넌트App.js12345678910import React from 'react';import Counter from './Counter';function App() &#123; return ( &lt;Counter /&gt; );&#125;export default App; Counter.jsCounter에서 버튼이 클릭되는 이벤트가 발생 했을 때, 특정 함수가 호출되도록 설정을 해보자. 12345678910111213141516171819import React from 'react';function Counter() &#123; const onIncrease = () =&gt; &#123; console.log('+1') &#125; const onDecrease = () =&gt; &#123; console.log('-1'); &#125; return ( &lt;div&gt; &lt;h1&gt;0&lt;/h1&gt; &lt;button onClick=&#123;onIncrease&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onDecrease&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; );&#125;export default Counter; onIncrease 와 onDecrease라는 함수를 각각 만들고 이벤트를 설정 해주자. 이벤트 설정하기 리액트에서 엘리먼트에 이벤트를 설정해줄때에는 on이벤트이름={실행하고싶은함수} 형태로 설정해야 한다. 함수형태를 넣어주어야 하지, 함수를 다음과 같이 실행하면 안된다. 이유는 렌더링되는 시점에서 함수가 호출되버리기 때문이다. 이벤트를 설정할때에는 함수타입의 값을 넣어주어야 한다는 것, 주의하자. 1234567891011// 틀린방식&lt;button onClick=&#123;onIncrease()&#125;&gt;+1&lt;/button&gt;&lt;button onClick=&#123;onDecrease()&#125;&gt;-1&lt;/button&gt; // 올바른 방식1&lt;button onClick=&#123;onIncrease&#125;&gt;+1&lt;/button&gt;&lt;button onClick=&#123;onDecrease&#125;&gt;-1&lt;/button&gt;// 올바른 방식2 : 직접 Click 내부 화살표 함수로 구현해도 된다.&lt;button onClick=&#123;() =&gt; &#123;console.log('+1')&#125;&#125;&gt;+1&lt;/button&gt;&lt;button onClick=&#123;() =&gt; &#123;console.log('-1')&#125;&#125;&gt;-1&lt;/button&gt; 동적인 값 끼얹기, useState 컴포넌트에서 동적인 값을 상태(state)라고 칭한다. 리액트에는 useState라는 함수가 있는데 컴포넌트에서 상태를 관리할 수 있게하는 함수다. 리액트 훅 함수를 사용할 때 훅을 포함하는 함수명에 주의를 해야만한다. Hook 함수는 자신을 포함하고 있는 함수가 컴포넌트인지 판별하는 기준은 첫글자가 대문자로 시작하는지 안하는지의 차이다. 따라서 컴포넌트를 작성할 때는 반드시 대문자 네이밍인 파스칼케이스를 지키도록하자. 12345678910111213// 틀린 방법function counter() &#123; const [number, setNumber] = useState(0); return ...&#125;// 올바른 방법function Counter() &#123; const [number, setNumber] = useState(0); return ...&#125; 예제 : Counter.js에 Hook 사용해서 상태 관리해보기1234567891011121314151617181920212223import React, &#123; useState &#125; from 'react';function Counter() &#123; const [number, setNumber] = useState(0); const onIncrease = () =&gt; &#123; setNumber(number + 1); &#125; const onDecrease = () =&gt; &#123; setNumber(number - 1); &#125; return ( &lt;div&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrease&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onDecrease&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; );&#125;export default Counter; 위와 같이 작성했다면 숫자가 변경이 될 것이다. 정리 정리 - useReact 사용방법1 : 모듈 import 하기.사용하고자하는 파일에서 import 해준다. 1import React, &#123; useState &#125; from 'react'; 정리 - useReact 사용방법2 : 함수 호출하여 사용하기.useReact는 호출 시 배열을 반환하는 것을 이용하여 배열 비구조화 할당을 이용할 수 있다. 첫번째 요소는 현재상태, 2번째 요소는 Setter함수이다. 1234567// 기본적인 사용방법const numberState = useState(0);const number = numberState[0];const setNumber = numberState[1];// 배열 비구조화 할당을 이용하여 쉽게 이용하기.const [number, setNumber] = useState(0); 정리 - useReact 사용방법3 : 상태 변경 및 조회하기.1234567891011121314151617 // 상태 변경 하기 const onIncrease = () =&gt; &#123; setNumber(number + 1); &#125; const onDecrease = () =&gt; &#123; setNumber(number - 1); &#125; // 상태 조회하기return ( &lt;div&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrease&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onDecrease&#125;&gt;-1&lt;/button&gt; &lt;/div&gt;); 함수형 업데이트 Setter 함수를 사용 할 때, 업데이트 하고 싶은 새로운 값을 파라미터로 넣어주고 있다, 다른 방법으로는 기존 값을 어떻게 업데이트 할 지에 대한 함수를 등록하는 방식으로도 값을 업데이트 할 수 있다. Counter.js1234567891011121314151617181920212223import React, &#123; useState &#125; from 'react';function Counter() &#123; const [number, setNumber] = useState(0); const onIncrease = () =&gt; &#123; setNumber(prevNumber =&gt; prevNumber + 1); &#125; const onDecrease = () =&gt; &#123; setNumber(prevNumber =&gt; prevNumber - 1); &#125; return ( &lt;div&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrease&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onDecrease&#125;&gt;-1&lt;/button&gt; &lt;/div&gt; );&#125;export default Counter; onIncrease 와 onDecrease 에서 setNumber 를 사용 할 때 그 다음 상태를 파라미터로 넣어준것이 아니라, 값을 업데이트 하는 함수를 파라미터로 넣어주었다. 함수형 업데이트는 주로 나중에 컴포넌트를 최적화를 하게 될 때 사용하게 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"조건부 렌더링","slug":"react-velo-04","date":"2020-01-02T08:21:02.000Z","updated":"2020-01-02T13:44:53.933Z","comments":true,"path":"2020/01/02/react-velo-04/","link":"","permalink":"https://hyeok999.github.io/2020/01/02/react-velo-04/","excerpt":"","text":"React with Velopert - 04 - 조건부 렌더링 예제 App.js Hello.js React에서 연산자의 쓰임처 Hello.js props 값 설정을 생략하면 ={true} App.js Chap 4. 조건부 렌더링조건부 렌더링 조건을 이용하여 렌더링 결과를 결정할 수 있다. 예제App.js / Hello.js 2가지 파일이 있다. Hello 컴포넌트에서는 isSpecial 이 true 이냐 false 이냐에 따라서 컴포넌트의 좌측에 * 표시를 보여주는 예제를 작성하자. App.js123456789101112131415import React from 'react';import Hello from './Hello';import Wrapper from './Wrapper';function App() &#123; return ( &lt;Wrapper&gt; &lt;Hello name=\"react\" color=\"red\" isSpecial=&#123;true&#125;/&gt; &lt;Hello color=\"pink\" /&gt; &lt;/Wrapper&gt; )&#125; export default App; \u0010 Hello.js12345678910111213141516import React from 'react';function Hello(&#123; color, name, isSpecial &#125;) &#123; return ( &lt;div style=&#123;&#123; color &#125;&#125;&gt; &#123; isSpecial ? &lt;b&gt;*&lt;/b&gt; : null &#125; 안녕하세요 &#123;name&#125; &lt;/div&gt; );&#125;Hello.defaultProps = &#123; name: '이름없음'&#125;export default Hello; isSpecial 값이 true 라면 * 를, 그렇지 않다면 null 을 보여주도록 했다. 리액트의 JSX에서는 null , false, udefined 를 렌더링하게 될 경우 렌더링을 하지 않게된다. 주의할 점은 JS에서 0은 조건상 false로서 인식을 하지만, JSX에서는 0을 그대로 렌더링하는 것에 주의해야한다. React에서 연산자의 쓰임처해당 연산자들은 JS의 단축평가를 기준으로 한다. 삼항연산자 : 특정 조건에 따라 보여줘야 하는 내용이 다를 때 &amp;&amp;연산자 : 특정 조건이 true 이면 보여주고, false라면 숨길때 || 연산자 : 둘중 하나라도 보여줘야 할때 Hello.js12345678910111213141516import React from 'react';function Hello(&#123; color, name, isSpecial &#125;) &#123; return ( &lt;div style=&#123;&#123; color &#125;&#125;&gt; &#123;isSpecial &amp;&amp; &lt;b&gt;*&lt;/b&gt;&#125; 안녕하세요 &#123;name&#125; &lt;/div&gt; );&#125;Hello.defaultProps = &#123; name: '이름없음'&#125;export default Hello; props 값 설정을 생략하면 ={true}컴포넌트의 props 값을 설정하게 될 때 만약 props 이름만 작성하고 값 설정을 생략한다면, 이를 true 로 설정한 것으로 간주한다. 예를 들자면, App.js1234567891011121314import React from 'react';import Hello from './Hello';import Wrapper from './Wrapper';function App() &#123; return ( &lt;Wrapper&gt; &lt;Hello name=\"react\" color=\"red\" isSpecial /&gt; &lt;Hello color=\"pink\"/&gt; &lt;/Wrapper&gt; );&#125;export default App; 이렇게 isSpecial 이름만 넣어주면 isSpecial={true} 와 동일한 의미이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React로 사고하기","slug":"react-official-11","date":"2020-01-01T13:10:34.000Z","updated":"2020-01-01T13:12:34.219Z","comments":true,"path":"2020/01/01/react-official-11/","link":"","permalink":"https://hyeok999.github.io/2020/01/01/react-official-11/","excerpt":"","text":"React Official Document주요개념 : React로 사고하기 목업으로 시작하기 1단계 : UI를 컴포넌트 계층 구조로 분할하기 2단계 : React로 정적인 버전 만들기 3단계 : UI state에 대한 최소한의 (하지만 완전한) 표현 찾아내기 4단계: State가 어디에 있어야 할 지 찾기 5단계: 역방향 데이터 흐름 추가하기 마치며, React Official Document주요개념#11. React로 사고하기목업으로 시작하기JSON API와 목업을 디자이너로부터 받았다고 가정하자. JSON API는 아래와 같은 데이터를 반환한다. 12345678[ &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;]; 1단계 : UI를 컴포넌트 계층 구조로 분할하기 모든 컴포넌트의 주변에 박스를 쳐서 구역을 나누고 그 각각에 이름을 붙이도록 한다. 디자이너가 미리 정해두었을 수도 있으니 디자이너와 상의를 할수도 있다. 디자이너가 사용한 Photoshop 레이어 이름이 React 컴포넌트의 이름이 될 수도 있다. 여기서 다음과 같은 생각이 들 수도 있다. Q : 어떤 것이 컴포넌트가 되어야 할까? A : 함수, 객체를 만들 때처럼 만들면 된다. (단, 단일 책임 원칙을 지키도록한다.) 단일 책임 원칙은 하나의 컴포넌트는 한 가지 일만을 하는 것이 이상적이라는 원칙이다. 하나의 컴포넌트가 커지게 된다면 이는 보다 작은 하위 컴포넌트로 쪼개서 관리해야만 한다. 주로 JSON 데이터를 유저에게 보여주기 때문에, 데이터 모델이 적절하게 만들어졌다면, UI(컴포넌트 구조)가 잘 연결된 것이다. 이는 UI와 데이터 모델이 같은 인포메이션 아키텍처(information architecture)를 가지는 경향이 있기 때문이다. 각 컴포넌트가 데이터 모델의 한 조각을 나타내도록 분리하라. 다섯 개의 컴포넌트로 이루어진 앱을 한번 보자. 각각의 컴포넌트에 들어간 데이터는 Bold체 로 표기했다. FilterableProductTable(노란색): 예시 전체를 포괄한다. SearchBar(파란색): 모든 유저의 입력(user input) 을 받는다. ProductTable(연두색): 유저의 입력(user input)을 기반으로 데이터 콜렉션(data collection)을 필터링 해서 보여준다. ProductCategoryRow(하늘색): 각 카테고리(category)의 헤더를 보여준다. ProductRow(빨강색): 각각의 제품(product)에 해당하는 행을 보여준다. ProductTable(연두색)을 보면 “Name” 과 “Price” 레이블을 포함한 테이블 헤더만을 가진 컴포넌트는 없다. 이 같은 경우, 데이터를 위한 독립된 컴포넌트를 생성할지 생성하지 않을지는 개발자의 선택이다. 이 예시에서는 ProductTable(연두색)의 책임인 데이터 컬렉션(data collection)이 렌더링의 일부이기 때문에 ProductTable(연두색)을 남겨두었다. 그러나 이 헤더가 복잡해지면 (즉 정렬을 위한 기능을 추가하는 등) ProductTableHeader컴포넌트를 만드는 것이 더 합리적일 것이다. 이제 목업에서 컴포넌트를 확인하였으므로 이를 계층 구조로 나열해보자. 모형의 다른 컴포넌트 내부에 나타나는 컴포넌트는 계층 구조의 자식으로 나타낸다. FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow 2단계 : React로 정적인 버전 만들기. 데이터 모델을 렌더링하는 앱의 정적 버전을 만들기 위해 다른 컴포넌트를 재사용하는 컴포넌트를 만들고 props 를 이용해 데이터를 전달해준다. props는 부모가 자식에게 데이터를 넘겨줄 때 사용할 수 있는 방법이다. 정적 버전을 만들기 위해 state를 사용하는 것은 좋지 않다. state는 오직 상호작용을 위해, 즉 시간이 지남에 따라 데이터가 바뀌는 것에 사용한다. 우리는 앱의 정적 버전을 만들고 있기 때문에 지금은 필요하지 않는다. 앱을 만들 때 하향식(top-down)이나 상향식(bottom-up)으로 만들 수 있다. 다시 말해 계층 구조의 상층부에 있는 컴포넌트 (즉 FilterableProductTable부터 시작하는 것)부터 만들거나 하층부에 있는 컴포넌트 (ProductRow) 부터 만들 수도 있다. 간단한 예시에서는 보통 하향식으로 만드는 게 쉽지만 프로젝트가 커지면 상향식으로 만들고 테스트를 작성하면서 개발하기가 더 쉽다. 이 단계가 끝나면 데이터 렌더링을 위해 만들어진 재사용 가능한 컴포넌트들의 라이브러리를 가지게 된다. 현재는 앱의 정적 버전이기 때문에 컴포넌트는 render() 메서드만 가지고 있을 것이다. 계층구조의 최상단 컴포넌트 (FilterableProductTable)는 prop으로 데이터 모델을 받는다. 데이터 모델이 변경되면 ReactDOM.render()를 다시 호출하서 UI가 업데이트 된다. UI가 어떻게 업데이트되고 어디에서 변경해야하는지 알 수 있다. React의 단방향 데이터 흐름(one-way data flow) (또는 단방향 바인딩(one-way binding))는 모든 것을 모듈화 하고 빠르게 만들어준다. 3단계 : UI state에 대한 최소한의 (하지만 완전한) 표현 찾아내기. UI를 상호작용하게 만들려면 기반 데이터 모델을 변경할 수 있는 방법이 있어야 한다. 이를 React는 state를 통해 변경할 수 있다. 애플리케이션을 올바르게 만들기 위해서는 애플리케이션에서 필요로 하는 변경 가능한 state의 최소 집합을 생각해보아야 하는데 여기서 핵심은 중복배제원칙이다. 애플리케이션이 필요로 하는 가장 최소한의 state를 찾고 이를 통해 나머지 모든 것들이 필요에 따라 그때그때 계산되도록 만들자. 예를 들어 TODO 리스트를 만든다고 하면, TODO 아이템을 저장하는 배열만 유지하고 TODO 아이템의 개수를 표현하는 state를 별도로 만드는 것은 삼가하자. TODO 갯수를 렌더링해야한다면 TODO 아이템 배열의 길이를 가져오면 된다. 예시 애플리케이션 내 데이터들을 생각해보자. 제품의 원본 목록 유저가 입력한 검색어 체크박스의 값 필터링 된 제품들의 목록 이는 각 데이터에 대해 아래의 세 가지 질문을 통해 결정할 수 있다. 부모로부터 props를 통해 전달되는가? 그러면 확실히 state가 아니다. 시간이 지나도 변하지 않는가? 그러면 확실히 state가 아니다. 컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가? 그렇다면 state가 아니다. 제품의 원본 목록은 props를 통해 전달되므로 state가 아니다. : 검색어와 체크박스는 state로 볼 수 있는데 시간이 지남에 따라 변하기도 하면서 다른 것들로부터 계산될 수 없기 때문이다. 마지막으로 필터링된 목록은 state가 아니다. : 제품의 원본 목록과 검색어, 체크박스의 값을 조합해서 계산해낼 수 있기 때문이다. 결과적으로 애플리케이션은 다음과 같은 state를 가진다. 유저가 입력한 검색어 체크박스의 값 4단계: State가 어디에 있어야 할 지 찾기. 이제 앱에서 최소한으로 필요한 state가 뭔지 찾아냈다. 다음으로는 어떤 컴포넌트가 state를 변경하거나 소유할지 찾아야 한다. 중요 : React는 항상 컴포넌트 계층구조를 따라 아래로 내려가는 단방향 데이터 흐름을 따른다. 어떤 컴포넌트가 어떤 state를 가져야 하는 지 바로 결정하기 어려울 수 있다. 많은 초보자가 이 부분을 가장 어려워한다. . 애플리케이션이 가지는 각각의 state에 대해서 state를 기반으로 렌더링하는 모든 컴포넌트를 찾아라. 공통 소유 컴포넌트 (common owner component)를 찾아라. (계층 구조 내에서 특정 state가 있어야 하는 모든 컴포넌트들의 상위에 있는 하나의 컴포넌트). 공통 혹은 더 상위에 있는 컴포넌트가 state를 가져야 한다. state를 소유할 적절한 컴포넌트를 찾지 못하였다면, state를 소유하는 컴포넌트를 하나 만들어서 공통 오너 컴포넌트의 상위 계층에 추가하라. 이 전략을 애플리케이션에 적용해보자. ProductTable은 state에 의존한 상품 리스트의 필터링해야 하고 SearchBar는 검색어와 체크박스의 상태를 표시해주어야 한다. 공통 소유 컴포넌트는 FilterableProductTable 의미상으로도 FilterableProductTable이 검색어와 체크박스의 체크 여부를 가지는 것이 타당하다. state를 FilterableProductTable에 두기로 했다. 먼저 인스턴스 속성인 this.state = {filterText: &#39;&#39;, inStockOnly: false} 를 FilterableProductTable의 constructor에 추가하여 애플리케이션의 초기 상태를 반영하자. 그리고 나서 filterText와 inStockOnly를 ProductTable와 SearchBar에 prop으로 전달한다. 마지막으로 이 props를 사용하여 ProductTable의 행을 정렬하고 SearchBar의 폼 필드 값을 설정하자. 이제 애플리케이션의 동작을 볼 수 있다. filterText를 &quot;ball&quot;로 설정하고 앱을 새로고침 해보자. 데이터 테이블이 올바르게 업데이트 된 것을 볼 수 있다. 5단계: 역방향 데이터 흐름 추가하기. 지금까지 우리는 계층 구조 아래로 흐르는 props와 state의 함수로써 앱을 만들었다. 이제 다른 방향의 데이터 흐름을 만들어볼 시간이다. 계층 구조의 하단에 있는 폼 컴포넌트에서 FilterableProductTable의 state를 업데이트할 수 있어야 한다. React는 전통적인 양방향 데이터 바인딩(two-way data binding)과 비교하면 더 많은 타이핑을 필요로 하지만 데이터 흐름을 명시적으로 보이게 만들어서 프로그램이 어떻게 동작하는지 파악할 수 있게 도와준다. 현재 상태에서 input box를 체크하거나 키보드를 타이핑할 경우 React가 입력을 무시하는 것을 확인할 수 있다. 이는 input태그의 value속성이 항상 FilterableProductTable에서 전달된 state와 동일하도록 설정했기 때문이다. 우리가 원하는 것이 무엇인지를 한번 생각해자. 우리는 사용자가 폼을 변경할 때마다 사용자의 입력을 반영할 수 있도록 state를 업데이트하기를 원한다. 컴포넌트는 그 자신의 state만 변경할 수 있기 때문에 FilterableProductTable는 SearchBar에 콜백을 넘겨서 state가 업데이트되어야 할 때마다 호출되도록 할 것이다. 우리는 input에 onChange 이벤트를 사용해서 알림을 받을 수 있다. FilterableProductTable에서 전달된 콜백은 setState()를 호출하고 앱이 업데이트될 것이다. 마치며, 이 글을 통해 React를 가지고 애플리케이션과 컴포넌트를 만드는 데에 대한 사고방식을 얻어갈 수 있기를 바란다. 이전보다 더 많은 타이핑을 해야 할 수 있지만, 코드를 쓸 일보다 읽을 일이 더 많다는 사실을 기억하자. 모듈화되고 명시적인 코드는 읽을 때 조금 덜 어렵다. 큰 컴포넌트 라이브러리를 만들게 되면 이 명시성과 모듈성에 감사할 것이며 코드 재사용성을 통해 코드 라인이 줄어들기 시작할 것이다. 😃","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"합성(Composition) vs 상속(Inheritance)","slug":"react-official-10","date":"2020-01-01T06:00:20.000Z","updated":"2020-01-01T13:10:28.277Z","comments":true,"path":"2020/01/01/react-official-10/","link":"","permalink":"https://hyeok999.github.io/2020/01/01/react-official-10/","excerpt":"","text":"React Official Document주요개념 : 합성(Composition) vs 상속(Inheritance) 컴포넌트에서 다른 컴포넌트를 담기 특수화 React에서 상속은? React Official Document주요개념#10. 합성(Composition) vs 상속(Inheritance) React는 상속 대신 합성을 사용하여 컴포넌트 간에 코드를 재사용하는 것이 좋다. 이번 문서에서는 React를 처음 접한 개발자들이 종종 상속으로 인해 부딪히는 몇 가지 문제들과 합성을 통해 이러한 문제를 해결하는 방법을 살펴보자. 컴포넌트에서 다른 컴포넌트를 담기 어떤 컴포넌트들은 어떤 자식 엘리먼트가 들어올 지 미리 예상할 수 없는 경우가 있다. 범용적인 ‘박스’ 역할을 하는 Sidebar 혹은 Dialog와 같은 컴포넌트에서 특히 자주 볼 수 있다. 이러한 컴포넌트에서는 특수한 children prop을 사용하여 자식 엘리먼트를 출력에 그대로 전달하는 것이 좋다. 1234567function FancyBorder(props) &#123; return ( &lt;div className=&#123;'FancyBorder FancyBorder-' + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125; 이러한 방식으로 다른 컴포넌트에서 JSX를 중첩하여 임의의 자식을 전달할 수 있다. 123456789101112function WelcomeDialog() &#123; return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; Welcome &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; );&#125; WelcomDialog()컴포넌트 내의 &lt;FancyBorder&gt;JSX 태그 안에 있는 것들이 FancyBorder() 컴포넌트의 children prop으로 전달된다. FancyBorder는 {props.children}을 &lt;div&gt; 안에 렌더링하므로 전달된 엘리먼트들이 최종 출력된다. 흔하진 않지만 종종 컴포넌트에 여러 개의 “구멍”이 필요할 수도 있다. 이런 경우에는 children 대신 커스텀 속성으로 전달 할 수도 있다. 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className=\"SplitPane\"&gt; &lt;div className=\"SplitPane-left\"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=\"SplitPane-right\"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; &lt;Contacts /&gt;와 &lt;Chat /&gt;같은 React 엘리먼트는 단지 객체이기 때문에 다른 데이터처럼 prop으로 전달할 수 있다. 이러한 접근은 다른 라이브러리의 “슬롯 (slots)“과 비슷해보이지만 React에서 prop으로 전달할 수 있는 것에는 제한이 없다. 특수화 때로는 어떤 컴포넌트의 “특수한 경우”인 컴포넌트를 고려해야 하는 경우가 있다. 예를 들어, WelcomeDialog는 Dialog의 특수한 경우라고 할 수 있다. React에서는 이 역시 합성을 통해 해결할 수 있다. 더 “구체적인” 컴포넌트가 “일반적인” 컴포넌트를 렌더링하고 props를 통해 내용을 구성한다. 1234567891011121314151617181920function Dialog(props) &#123; return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; &#123;props.message&#125; &lt;/p&gt; &lt;/FancyBorder&gt; );&#125;function WelcomeDialog() &#123; return ( &lt;Dialog title=\"Welcome\" message=\"Thank you for visiting our spacecraft!\" /&gt; );&#125; 합성은 클래스로 정의된 컴포넌트에서도 동일하게 적용된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243function Dialog(props) &#123; return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; &#123;props.message&#125; &lt;/p&gt; &#123;props.children&#125; &lt;/FancyBorder&gt; );&#125;class SignUpDialog extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = &#123;login: ''&#125;; &#125; render() &#123; return ( &lt;Dialog title=\"Mars Exploration Program\" message=\"How should we refer to you?\"&gt; &lt;input value=&#123;this.state.login&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.handleSignUp&#125;&gt; Sign Me Up! &lt;/button&gt; &lt;/Dialog&gt; ); &#125; handleChange(e) &#123; this.setState(&#123;login: e.target.value&#125;); &#125; handleSignUp() &#123; alert(`Welcome aboard, $&#123;this.state.login&#125;!`); &#125;&#125; React에서 상속은? Facebook에서는 수천 개의 React 컴포넌트를 사용하지만, 컴포넌트를 상속 계층 구조로 작성을 권장할만한 사례를 아직 찾지 못했다. props와 합성은 명시적이고 안전한 방법으로 컴포넌트의 모양과 동작을 커스터마이징하는데 필요한 모든 유연성을 제공한다. 컴포넌트가 원시 타입의 값, React 엘리먼트 혹은 함수 등 어떠한 props도 받을 수 있다는 것을 기억하자 UI가 아닌 기능을 여러 컴포넌트에서 재사용하기를 원한다면, 별도의 JavaScript 모듈로 분리하는 것이 좋다. 컴포넌트에서 해당 함수, 객체, 클래스 등을 import 하여 사용할 수 있다. 상속받을 필요가 없다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"daily_algorithm63","slug":"daily-algorithm63","date":"2019-12-31T07:36:21.000Z","updated":"2019-12-31T07:38:36.088Z","comments":true,"path":"2019/12/31/daily-algorithm63/","link":"","permalink":"https://hyeok999.github.io/2019/12/31/daily-algorithm63/","excerpt":"","text":"큰 수 만들기문제 설명어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 number k return 1924 2 94 1231234 3 3234 4177252841 4 775841 해당 문제는 탐욕법을 이용해서 해결해야되는 문제인데 너무 어렵게 풀었다. 이 문제의 주요 풀이는 다음과 같다. 예를들어 (1231237 , 3) 이라고 가정했을 경우, 뒤에서부터 3번째 자리의 숫자(237)을 제외하고 찾아야한다. 이유는, 앞에서부터 찾는 숫자들 중 제일 큰것을 골라야 하기 때문이다. 그러니까 제일 마지막에 큰 숫자를 찾을 경우 7 - 3 인 4자리의 숫자를 만들어야하는데 그러지 못할 수도 있으니 나머지를 정해두고 찾는 방식이다. 따라서, 1231을 중 제일 큰것을 찾는다. 여기서는 3이 제일 크므로 3을 특정 변수에 추가 시켜준다. 여기서 3의 위치를 계산을 하고 3을 찾기 까지의 카운트나 위치주소 등을 계산해서 몇개를 제거했는지를 계산하다. 그 다음부터 1을 찾는데 현재 4자리중 3을 찾았으니 앞으로 3자리를 채워야하고 서브로 2자리는 남겨놓아야만 한다. 따라서 뒤부터 2번째 자리의 숫자(37)을 제외하고 찾는다. 그러면 12 중 큰 것을 찾으면 되므로 2를 변수에 추가한다. (현재 : 32) 제거 카운트가 입력한 카운트와 같거나 클 경우 나머지를 전부 답 변수에 추가핸준다. (정답 : 3237) 이러한 방식으로 문제를 해결해보도록 한다. 1회차처음 풀이 방법은 상당히 요란하다. 나는 주로 indexOf , slice, Math.max 를 이용한 방법을 했는데 해당 문제는 주어진 숫자 , 자리수를 계산해야되므로 큰 수를 찾을 때 앞에서 부터 찾는다. 제일 큰 숫자를 찾을 경우 제일 큰 숫자의 인덱스 + 1를 특정 변수에 저장을 하고 해당 변수부터 찾은 위치까지의 인덱스 을 k와 비교하면서 k보다 클 경우에 나머지 숫자들을 전부 추가하고 for문을 빠져나와 리턴한다. 1234567891011121314151617181920212223242526272829303132function solution(number, k) &#123; if(number.charAt(0) == '0') return \"0\" let num = number.split(''); let stCount = 0; let count = number.length - k; let aCount = 0; let subNum = []; let answer = ''; for (let i = 0; i &lt; count; i++) &#123; subNum = num.slice(stCount, -count + 1 + i); if (subNum.indexOf(`$&#123;Math.max(...subNum)&#125;`) === -1) &#123; subNum = num.slice(-stCount); answer += Math.max(...subNum); break; &#125; answer += Math.max(...subNum); stCount += subNum.indexOf(`$&#123;Math.max(...subNum)&#125;`) + 1; aCount += subNum.indexOf(`$&#123;Math.max(...subNum)&#125;`); if (aCount &gt;= k) &#123; subNum = `$&#123;num.slice(-count + 1 + i).join('')&#125;`; answer += subNum; break; &#125; &#125; return answer;&#125;console.log(solution(\"1924\", 2)) 해당 문제의 결과 : 10번, 12번 에러 테스트 케이스 전부 통과 10번 , 12번 실패 2회차1회차를 너무 요란하게 푼 것 같아서 조금 수정해보았다. 전반적인 풀이 방식은 같으나 뒤에서부터 slice를 계산하는게 아니라 앞에서 부터 더해주면서 계산을 하였고 나머지 카운트를 제거하면서 계산하여 나머지 카운트가 결국 0일 때 전부더 정답에 추가하는 방식을 하였다. 12345678910111213141516171819202122232425function solution(number, k) &#123; if (number.charAt(0) == '0') return '0'; const num = number.split(''); let answer = ''; let max = 0; let index = 0; let j = k + 1; let remainK = k; for (let i = 0; i &lt; number.length - k; i++) &#123; max = num.slice(index, j); console.log(max.sort()); answer += (max.sort())[max.length - 1]; index += max.join('').indexOf(Math.max(...max)) + 1; remainK -= max.join('').indexOf(Math.max(...max)); if (remainK &lt;= 0) &#123; answer += num.slice(index).join(''); break; &#125; j += 1; &#125; return answer;&#125;console.log(solution(\"1924\", 2)) 해당 문제의 결과 : 12번은 해결되었으나 10번이 게속 실패가 뜸. 테스트 케이스 전부 통과 10번 실패 3회차빌트인 메소드들에 의존성이 심한 것 같아서 이번에는 그냥 이중 for문 을 이용하였다. 풀이 방식은 전반적으로 같으나 Math.max 대신에 for문을 이용하여 가장 큰 크기의 숫자를 찾는 방식을 이용하였다. 123456789101112131415161718192021222324function solution(number, k) &#123; let answer = ''; let max = 0; let index = -1; for (let i = 0; i &lt; number.length - k; i++) &#123; max = 0; for (let j = index + 1; j &lt;= k + i; j++) &#123; if (max &lt; number[j]) &#123; index = j; max = number[j]; &#125; &#125; answer += max; &#125; return answer;&#125;console.log(solution('1924', 2));// console.log(solution(\"1231234\",3))// console.log(solution(\"4177252841\",4))// console.log(solution(\"4177252841\",1))// console.log(solution(\"321\",1)) 해당 문제의 결과 : 테스트 케이스 전부 통과 10번 시간초과 4회차 - 정답연속되는 실패로 지쳐서 다른 사람의 코드나 해결 방법들을 찾아보았는데 타 언어들은 스트링빌더를 이용해서 해결했지만, 자바스크립트는 스트링빌더가 따로 존재하지 않기 때문에 구현을 해주어야 했다. 스트링빌더는 제쳐두고 내부 for문을 굳이 다돌아야 할까? 라는 생각이 문뜩 들었는데 생각해보니 내부 for문에서 가장 큰수(9)를 찾을 경우 더 반복을 돌아봤자 의미가 없겠다는 생각이 들어 추가해보았는데 무사히 통과되었다. 12345678910111213141516171819202122232425function solution(number, k) &#123; let answer = ''; let max = 0; let index = -1; for (let i = 0; i &lt; number.length - k; i++) &#123; max = 0; for (let j = index + 1; j &lt;= k + i; j++) &#123; if (max &lt; number[j]) &#123; index = j; max = number[j]; if (max === '9') break; // 추가 &#125; &#125; answer += max; &#125; return answer;&#125;console.log(solution('1924', 2));// console.log(solution(\"1231234\",3))// console.log(solution(\"4177252841\",4))// console.log(solution(\"4177252841\",1))// console.log(solution(\"321\",1))","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"React 스터디 12","slug":"react-study-12","date":"2019-12-31T07:31:14.000Z","updated":"2019-12-31T07:32:52.765Z","comments":true,"path":"2019/12/31/react-study-12/","link":"","permalink":"https://hyeok999.github.io/2019/12/31/react-study-12/","excerpt":"","text":"React Study 12 예제 : 로그인 기능 만들기 새로운 프로젝트 생성 백엔드 추가 lib폴더 생성하고 Axios API 작성 해주기 SignUp 코드 작성 - input 유효성 검사하기 SignIn 코드 작성 - 쿠키 이용하기 쿠키 로컬스토리지 쿠키 vs 로컬스토리지 세션 토큰 기반 인증 방식 (JWT) 용어 - ( 러버덕 ) 쿠키 로컬스토리지 세션 JWT 쿠키 vs 로컬스토리지 예제 : 로그인 기능 만들기 1. 새로운 프로젝트 생성App.js에 리액트 라우터를 활용. 1npm i react-router-dom --save /signin - 회원 로그인 폼 : 이메일, 패스워드, 로그인버튼 /signup - 회원가입 폼 : 이메일, 패스워드, 가입버튼 /user - 빈페이지 작성 ( User ) / - 빈페이지 작성 ( Main ) App.js 1234567891011121314151617181920212223242526272829import React from 'react';import &#123; BrowserRouter as Router, Switch, Route&#125; from 'react-router-dom';import Signin from './components/SignIn';import Signup from './components/SignUp';import User from './components/User';import Main from './components/Main';import './App.css';function App() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path='/signin' component=&#123; Signin &#125; /&gt; &lt;Route path='/signup' component=&#123; Signup &#125;/&gt; &lt;Route path='/user' component=&#123; User &#125;/&gt; &lt;Route path='/' component=&#123; Main &#125;/&gt; &lt;/Switch&gt; &lt;/Router&gt; // &lt;/Provider&gt; );&#125;export default App; 2. 백엔드 추가백엔드는 보내준 압축 파일을 현재 진행중인 프로젝트 말고 다른 위치에서 압축을 풀고 해당 명령어를 입력해준다. 12npm inpm start 백엔드의 포트번호를 3001번대로 변경해준다. 검색 - 3000 : 1개뜸 12var port = normalizePort(process.env.PORT || '3001');app.set('port', port); 포스트맨(Post Man) 테스트하기포스트맨으로 데이터가 잘 흘러가는지 테스트를 해본다. 회원가입 부분에서 POST메소드를 통해 회원가입을 요청했을 때의 결과이다. 회원가입 후 로그인을 할 때 POST로 데이터를 보냈을 때의 결과이다. 여기서 데이터 조회를 해야할텐데 어째서 GET 이 아닌 POST 를 사용한 것은 우선 해당 프로젝트에서 데이터를 요청을 하는 방식은 &lt;form&gt;태그를 이용했다는 것이고 GET을 사용할 경우 ID, PASSWORD가 모두 URL로 노출되기 때문에 POST를 이용한다. 3. lib폴더 생성하고 Axios API 작성 해주기2번에서 했던 데이터들을 불러오기 위해서 2개의 API를 작성해준다. lib/api.js 12345678910111213141516171819import axios from 'axios';export const signUp = async (&#123; username, password1 : password &#125;) =&gt; &#123; const &#123; data &#125; = await axios.post('http://localhost:3001/api/signup', &#123; username, password &#125;) console.log(data); return data;&#125;export const signIn = async (&#123; username, password &#125;) =&gt; &#123; const &#123; data &#125; = await axios.post('http://localhost:3001/api/signin', &#123; username, password &#125;) console.log(data); return data;&#125; 4. SignUp 코드 작성 - input 유효성 검사하기우선, 회원가입 폼(/signup)에서는 ID와 PW를 2개받고 입력된 이메일과 비밀번호에 대해 유효검사를 해주어야한다. 직접적으로 작성해도 되지만 react에서는 hook을 포함한 유효검사 라이브러리를 제공한다. React-Hook-Form 1npm i react-hook-form --save 3번에서 진행한 api를 불러오고 async/await를 이용하여 POST를 요청하도록 하자. 성공적으로 요청이 돌아왔다면 ./signin으로 URL을 라우팅하도록 한다. components/SignUp/index.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React, &#123; useState &#125; from 'react';import &#123; useForm &#125; from \"react-hook-form\";import &#123; signUp &#125; from '../../lib/api';const SignUp = (props) =&gt; &#123; const &#123; handleSubmit, register, watch, errors &#125; = useForm(); const [ alreadyExist, setAlreadyExist ] = useState(false); const onSubmit = async values =&gt; &#123; const &#123; success , msg &#125; = await signUp(values); if (success) &#123; props.history.push('./signin'); &#125; else if ( msg === 'Username already exists.') &#123; setAlreadyExist(true); &#125; &#125;; return ( &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt; &lt;label htmlFor=\"email\"&gt; Email : &lt;input id=\"email\" name=\"username\" type=\"text\" ref=&#123;register(&#123; required: 'Required', pattern: &#123; value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,4&#125;$/i, message: \"invalid email address\" &#125; &#125;)&#125; /&gt; &#123;errors.email &amp;&amp; errors.email.message&#125; &lt;/label&gt; &lt;br/&gt; &lt;label htmlFor=\"pwd1\"&gt; Password : &lt;input id=\"pwd1\" name=\"password1\" type=\"password\" ref=&#123;register(&#123; required: 'Required' &#125;)&#125; /&gt; &lt;/label&gt; &lt;br/&gt; &lt;label htmlFor=\"pwd2\"&gt; Password 재확인 : &lt;input id=\"pwd2\" name=\"password2\" type=\"password\" ref=&#123;register(&#123; required: 'Required', validate: (value) =&gt; &#123; return value === watch('password1'); &#125; &#125;)&#125; /&gt; &lt;/label&gt; &lt;br/&gt; &#123; errors.password2 &amp;&amp; '비밀번호가 일치하지 않습니다.' &#125; &#123; alreadyExist &amp;&amp; '이미 존재하는 아이디 입니다.'&#125; &lt;br/&gt; &lt;button type=\"submit\"&gt;회원가입&lt;/button&gt; &lt;/form&gt; );&#125;export default SignUp; 5. SignIn 코드 작성 - 쿠키 이용하기로그인 시 로그인 지속시간 과 JWT 데이터를 임시로 저장하기 위한 저장소가 필요한데 그것을 클라이언트 브라우저의 쿠키에 저장하도록 한다. 쿠키는 그냥 사용할 경우 난잡하므로 특정 라이브러리를 이용하도록 하자. JS-Cookie 1npm i js-cookie --save 1Cookie.set('session',JWT토큰값) 추가로 4번에서 했던 유효성 검사를 여기서도 해줘야하기 때문에 react-hook-form을 여기서도 작성해준다. 그리고 3번에서 진행한 api를 불러오고 async/await를 이용하여 POST를 요청해 토큰(JWT)을 받아가지고 온다. 성공적으로 요청이 돌아왔다면 쿠키에 session이라는 키에 토큰을 값으로 하여 저장하고 / (Main.js)으로 URL을 라우팅하도록 한다. components/SignIn/index.jsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; useState &#125; from 'react';import &#123; useForm &#125; from \"react-hook-form\";import &#123; signIn &#125; from '../../lib/api';import Cookies from 'js-cookie';const SignIn = (props) =&gt; &#123; const &#123; handleSubmit, register, watch, errors &#125; = useForm(); const [ alreadyExist, setAlreadyExist ] = useState(false); const onSubmit = async values =&gt; &#123; const &#123; success , token &#125; = await signIn(values); if (success) &#123; Cookies.set('session', token.split(' ')[1]); props.history.push('/'); &#125; &#125;; return ( &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt; &lt;label htmlFor=\"email\"&gt; Email : &lt;input id=\"email\" name=\"username\" type=\"text\" ref=&#123;register(&#123; required: 'Required', pattern: &#123; value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,4&#125;$/i, message: \"invalid email address\" &#125; &#125;)&#125; /&gt; &#123;errors.email &amp;&amp; errors.email.message&#125; &lt;/label&gt; &lt;br/&gt; &lt;label htmlFor=\"pwd\"&gt; Password : &lt;input id=\"pwd\" name=\"password\" type=\"password\" ref=&#123;register(&#123; required: 'Required' &#125;)&#125; /&gt; &lt;/label&gt; &lt;br/&gt; &#123; alreadyExist &amp;&amp; '이미 존재하는 아이디 입니다.'&#125; &lt;br/&gt; &lt;button type=\"submit\"&gt;로그인&lt;/button&gt; &lt;/form&gt; );&#125;export default SignIn; 쿠키 쿠키 : 서버에 보내기 위한 데이터를 임시 저장하기 위한 클라이언트 브라우저 저장소. 쿠키를 사용하는 이유 : 서버에 전송할 데이터를 클라이언트에 저장하기 위해서 + JWT(JS WEB TOKEN) 저장하기 위해서. expires를 작성 안해줄 경우 즉시 삭제된다. (UTC 스트링) path를 설정하면 설정된 url에서만 쿠키를 접근하게 해준다. (쿠키를 사용하는 사이트에서만 읽고 쓸수 있다.) 쿠키 폴리필 1234567891011121314// 쿠키의 기본 표현식 (Document의 쿠키)document.cookie = \"key=value; expires=Thu, 01 JAN 1970 00:00:00 UTC; path=/;\";// 위 쿠키 기본 표현식을 함수로 표현해서 쉽게 사용할 때 만들어본 함수function setCookie(cname, cvalue, exdays) &#123; // Expiration days let d = new Date() d.setTime(d.getTime() + (exdays*60*60*24*1000)) const expires = \"expires\" + d.toUTCString() document.cookie = cname + \"=\" + cvalue + \";\" + expires + \"path=/\" //path는 특정한 페이지에서만 쿠키를 쓰고 싶을때 사용한다.&#125;setCookie(\"username\", \"react\", 1); // 하루 뒤에는 이 쿠키가 자동으로 삭제된다. - 이름 , 해당값, 만료기간 설정 브라우저 쿠키 메소드를 이용하는 것보다는 Node Package Manager를 ****통한 쿠키라이브러리를 쓰는것을 추천한다. JS-Cookie 로컬스토리지 로컬스토리지 : 쿠키로 쓸 데이터는 서버에 전송을 하겠다는 전제, 반대로 서버로 전송할 필요가 없는 데이터는 로컬 스토리지를 이용. 값으로 JSON 데이터를 넣을 때는 JSON.stringfy(넣을 값) 을 이용한다. 1234567891011//데이터 저장window.localStorage.setItem('test','123');//데이터 조회window.localStorage.getItem('test');//데이터 1개 삭제window.localStorage.removeItem('test');//데이터 전체 삭제window.localStorage.clear(); 로컬스토리지 vs 쿠키 쿠키는 초창기부터 만들어진 브라우저 저장소이기 때문에 사용방법이 난잡하다. (물론 쓰기 쉽게 개발된 라이브러리가 있다.) 로컬스토리지는 비교적으로 쉽게 사용할 수 있도록 정의가 되어있는 편인데, 복잡한 표현식을 가진 쿠키를 쓰는 이유는 오로지 서버에게 전송할 데이터를 클라이언트에게 저장하고 싶을 때 사용한다. 쿠키의 저장소는 4000kb(Chrome 기준)로 매우 작기 때문에 모든 데이터를 쿠키에 저장해서는 안된다. 반드시 서버와 주고받을 데이터만 저장한다. 로컬스토리지의 저장소는 10mb(Chrome 기준)이다. Redux를 통해 저장할 데이터는 비교적 용량이 큰 로컬스토리지에 저장하는 것이 좋다. json web token의 경우 쿠키에 넣는 것이 바람직하다. 세션 세션 : 서버에서 저장하고 있는 데이터(정보). 세션을 사용하는 이유 : 쿠키는 세션 저장소에 담긴 데이터를 얻기 위한 열쇠 정도로 생각하면 편하다. 쿠키를 통하여 세션의 정보를 열람할 수 있다. 토큰 기반 인증 방식 (JWT) 기존 서버의 인증 기반 방식은 서버에게 데이터를 몰아주는 식의 방식을 사용했다. 따라서 서버에게 자연스럽게 과부하가 걸리는등의 문제를 야기했는데 이를 토큰이라는 매개체를 통해서 해결한다. JWT는 세션/쿠키와 함께 모바일과 웹의 인증을 다루는 가장 많이 사용되는 표준 중 하나이다. WEB상에서 안정하게 사용할 수 있는 식별자이며 Json Web Token의 약자로 인증에 필요한 정보들을 암호화시킨 토큰을 뜻하는데 위의 세션/쿠키 방식과 유사하게 사용자는 Access Token(JWT 토큰)을 HTTP 헤더에 실어 서버로 보내게 된다. JWT는 다음과 같은 경우에 많이 사용된다. 회원 인증: JWT 를 사용하는 가장 흔한 시나리오 이다. 유저가 로그인을 하면, 서버는 유저의 정보에 기반한 토큰을 발급하여 유저에게 전달해줍니다. 그 후, 유저가 서버에 요청을 할 때 마다 JWT를 포함하여 전달한다. 서버가 클라이언트에게서 요청을 받을때 마다, 해당 토큰이 유효하고 인증됐는지 검증을 하고, 유저가 요청한 작업에 권한이 있는지 확인하여 작업을 처리한다.서버측에서는 유저의 세션을 유지 할 필요가 없다. 즉 유저가 로그인되어있는지 안되어있는지 신경 쓸 필요가 없고, 유저가 요청을 했을때 토큰만 확인하면 되니, 세션 관리가 필요 없어서 서버 자원을 많이 아낄 수 있다. 정보 교류: JWT는 두 개체 사이에서 안정성있게 정보를 교환하기에 좋은 방법이다. 그 이유는, 정보가 sign 이 되어있기 때문에 정보를 보낸이가 바뀌진 않았는지, 또 정보가 도중에 조작되지는 않았는지 검증할 수 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 11","slug":"react-study-11","date":"2019-12-29T16:39:39.000Z","updated":"2019-12-29T16:41:28.249Z","comments":true,"path":"2019/12/30/react-study-11/","link":"","permalink":"https://hyeok999.github.io/2019/12/30/react-study-11/","excerpt":"","text":"React Study 11 React Hook 무한 루프 : setCount를 바로 하지 않는 이유 Hook 상태 업데이트 해보기 Hook 상태 업데이트 : 기본 Hook 상태 업데이트 : 리듀서 React 최적화 (useMemo, useCallback) useMemo , React.memo useCallback useMemo vs useCallback useMemo 예제 Custom Hook 만들기 예제 로컬 스토리지 용어 - ( 러버덕 ) React Hook Hook 업데이트 방법 useMemo React.memo useCallback 로컬 스토리지 React Hook 함수 컴포넌트에서 클래스 없이 React 상태와 Props에 접근할 수 있는 함수 상태를 관리할 변수(명), 상태를 업데이트 해줄 함수로 이루어진 배열의 형태. 함수의 클로저 구현. Class 컴포넌트를 사용하게 될 경우 기본적인 코드베이스가 커지기 때문에 Hook은 코드 길이를 대폭 줄일수 있다. use키워드가 들어간 것은 React Hook임을 명시함. 무한 루프 : setCount를 바로 하지 않는 이유 1setCount(count + 1) return 외부에서 실행시 Too many re-renders. React limits the number of renders to prevent an infinite loop 오류가 발생한다. jsx내에서 setCount를 하게 되면 count + 1에서 1이 증가되고 return 실행 후 다시 setCount호출, 다시 호출호출… 무한 루프에 빠지게 됨 onClick 내부에서도 마찬가지로 아래와 같이 쓸 경우 오류 발생! 12&lt;button onClick=&#123;setCount(count + 1)&#125;&gt;+&lt;/button&gt;// 정답 :&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; Hook 상태 업데이트 해보기기본적인 Hook을 이용한 상태를 정의(선언)할떄는 useState를 사용해서 한다 ( = this.state) 1234567function ExampleWithManyStates() &#123; // 상태 변수를 여러 개 선언했습니다! const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); // ...&#125; 만약 이런 정의된 상태들을 업데이트 할 때 클래스 컴포넌트라면 this.setState로 작성하면 간편해진다. 클래스 컴포넌트의 this.setState는 기존 상태 유지 + 병합의 개념을 가지고 있다. 12345this.setState = (&#123; age : 42, fruit : 'banana', todos : [&#123; text: 'Learn Hooks' &#125;]&#125;) Hook 상태 업데이트 : 기본Hook을 사용할 떄는 선언된 상태들을 하나로 묶는 상위 상태가 필요하다. 1const [state, setState] = useState(&#123;&#125;) 여기서 문제는 React Hook은 상태 변화시 기존상태를 유지하지 않기 떄문에 유지하는 작업을 필요로한다. 12345678const [state, setState] = useState(&#123;&#125;)setState(prev =&gt; (&#123; ...prev, // prev가 기존 상태를 유지. age : 42, fruit : 'banana', todos : [&#123; text: 'Learn Hooks' &#125;]&#125;)) 이러한 과정은 ...prev를 게속 작성해주어야하기 때문에 불편한데, 이를 방지하기 위해서는 reducer를 이용하여 해결할 수 있다. Hook 상태 업데이트 : 리듀서react의 useReducer를 사용할 때도 역시 선언된 상태들을 하나로 묶는 상위 상태가 필요하다. 12import React, &#123; useReducer &#125; from 'react';const [state, setState] = useReducer(reducer, &#123;&#125;); 그리고 reducer 함수를 정의해주어야만 한다. 1234567891011121314const [state, setState] = useReducer(reducer, &#123;&#125;);const reducer = (prevState, newState) =&gt; (&#123; ...prevState, ...newState &#125;) // 리듀서 : 기존의 상태와 새로운 상태를 받고 코드대로 처리한다. // 해당 리듀서는 기존 상태와 새로운 상태를 병합해주는 역할 // const [state, setState] = useReducer(reducer, initState); setState(&#123; age : 42, fruit : 'banana', todos : [&#123; text: 'Learn Hooks' &#125;] &#125;); React 최적화 (useMemo, useCallback)123456789101112131415161718192021222324import React , &#123;useState, useEffect&#125; from 'react';import './App.css';const Button = (&#123;onClick, count&#125;) =&gt; &#123; console.log(count); return &lt;button count=&#123;count&#125; onClick =&#123;onClick&#125;&gt;버튼&lt;/button&gt;&#125;function App() &#123; const [count1, setCount1] = useState(0) // 클래스의 this.setState const [count2, setCount2] = useState(0) // 클래스의 this.setState const increment1 = () =&gt; setCount1(c =&gt; c + 1); // setCount1(count1 + 1); const increment2 = () =&gt; setCount2(c =&gt; c + 1); // setCount1(count2 + 1); return ( &lt;&gt; &lt;Button count=&#123;count1&#125; onClick=&#123;increment1&#125;&gt;&lt;/Button&gt; &lt;Button count=&#123;count2&#125; onClick=&#123;increment2&#125;&gt;&lt;/Button&gt; &lt;/&gt; );&#125;export default App; 위 과정에서 문제는 React Hook의 useState 를 통해서 2가지의 상태를 정의하였다. 문제는 1가지의 state 만 변경되어 Reack Hook이 전부 재렌더링 된다는 것이다. 즉 저기서 버튼 1개만 눌러도 2가지 &lt;Button&gt; 태그가 다시 렌더링 되는 불필요함을 겪는다. (물론 상태는 관리된다.-렌더링만 다시) useMemo , React.memo 리액트가 내부적으로 기존의 함수들을 메모하듯 메모해놓는 것. 위 문제를 해결하기 위해서는 useMemo 혹은 React.memo 를 사용한다. useMemo 와 React.memo는 내부에서 실행하는데 시간이 많이 걸리거나 렌더링 되었던 요소들 , 불필요한 재호출이 발생할 수 있는 함수를 첫번째 파라미터로 받고, 의존성 배열을 두번째 파라미터로 받아서 두번째 파라미터 요소들을 조건으로 하여 변경되었을 때 만 첫번째 파라미터 함수가 호출되도록 한다. 두가지 모듈의 기능은 컴포넌트를 받아와서 업데이트 된 요소만 반환 해 준다. 12useMemo(() =&gt; 함수명(),[변경될 조건 값]);React.memo(() =&gt; 함수명()); useMemo는 2번쨰 파라미터인 의존성 배열인 [변경될 조건 값] 전제로 변경을 하고, React.memo는 파라미터로 받은 함수 자체가 변경될 경우 변경을 한다. 함수의 실행 결과값을 반환해준다. 123const Button = React.memo((&#123;onClick, count&#125;) =&gt; &#123; return &lt;button count=&#123;count&#125; onClick = &#123;onClick&#125;&gt;버튼&lt;/button&gt;&#125;) 여기서 React.memo, useMemo 만 가지고서는 유지를 할 수 없기 때문에 추가적인 작업을 또 필요로 한다. useCallback문제는 2가지의 모듈을 사용하기 위해서는 useCallback()을 사용해야만 한다. 1useCallback(() =&gt; 함수명(), [의존성 배열 - 조건]); useCallback()의 2번쨰 파라미터는 의존성 배열(조건)인데 [] 을 빈배열로 둘 경우 1번만 실행해서 기억해서 가지고 있는다. useCallback()을 사용해야 하는 이유는 {} === {} 와 같은 문제인데 객체{} 혹은 함수function은 원시값이 아닌 참조값이기 때문에 고정이 아니다. 1234567// 변경 전const increment1 = () =&gt; setCount1(c =&gt; c + 1);const increment2 = () =&gt; setCount2(c =&gt; c + 1);// 변경 후const increment1 = useCallback(() =&gt; setCount1(c =&gt; c + 1), []);const increment2 = useCallback(() =&gt; setCount2(c =&gt; c + 1), []); 자 다시 확인해보면 위에서 작성한 React.memo 는 파라미터로 받은 함수가 하나라도 변경이 있을 때만 함수를 다시 실행시키는 것인데, useCallback()을 작성을 안해준다면 객체는 참조값이기 떄문에 한개만 클릭해도 객체 자체가 새롭게 메모리에 작성되기 때문에 둘다 새롭게 렌더링 되는 것이다. 즉, useCallback() -&gt; DeepCopy 하기 위함. (Object.assign, lodash의 deepClone 을 사용해도 된다.) useMemo vs useCallback 두 모듈 특정한 함수나 결과를 기억하고 싶을 떄 사용한다. useMemo : 값을 리턴 useCallback : 함수를 리턴 useMemo 예제React Hook의 단점은 한 가지 상태변수만 바뀌어도 전체가 다시 렌더링된다는 것이다. 아래 예제는 2개의 버튼이 있다. 단어 카운트 : 배열에 저장된 문자열 요소의 길이를 반환해주는 버튼 기본 카운트 : 단순 숫자만 늘려주는 버튼 학습을 위해 강제로 1번 버튼에 딜레이를 주었다. 평범하게 이해한다면 기본 카운트 버튼을 클릭하는것에는 딜레이가 전혀 없어야 한다. 하지만!! 딜레이가 존재한다는 것이다. 이것은 위에서 말한 React Hook에서 한가지 상태변수만 바뀌어도 전체가 다시 렌더링 되는 것 때문인데 이것을 방지 하기 위해서 useMemo를 사용한다. 123456789101112131415161718192021222324252627282930import React , &#123; useState, useMemo &#125; from 'react';export default function App() &#123; const [count, setCount] = useState(0); const [wordIndex, setWordIndex] = useState(0); const words = ['react', 'node.js', 'web']; const word = words[wordIndex]; const computeLetterCount = word =&gt; &#123; let i = 0; while(i &lt; 1000000000) i++ return word.length; &#125; // 강제 딜레이 발생 const letterCount = useMemo(() =&gt; computeLetterCount(word), [word]); return ( &lt;&gt; &#123;letterCount&#125; &lt;button onClick=&#123;() =&gt; &#123; const next = wordIndex + 1 === words.length ? 0 : wordIndex + 1; setWordIndex(next); &#125;&#125;&gt;단어 카운트&lt;/button&gt; &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;기본 카운트&lt;/button&gt; &lt;/&gt; )&#125; letterCount()에 useMemo를 사용하면 setCount가 발생할때는 딜레이가 발생하지 않도록 할 수 있음. Custom Hook 만들기 Custom Hook을 만드는데 특정한 규칙은 없지만 만들 함수명 앞에 use를 적어주는 것이 Hook이라고 알려주는 컨벤션이다. useEffect 는 ComponentDidMount, ComponentWillUnMount, ComponentDidUpdate를 합쳐놓은 개념이다. ComponentDidMount : 렌더링 이후에 실행된다. 주로 이벤트, setTimeout, setInterval, AJAX 처리등을 작성한다. ComponentWillUnMount : Router에 의해 URL 변경, 페이지이동, 탭닫음 등등을 할 때 메모리 누수를 방지하고자 선언된 상태, 이벤트들을 취소하기 위함으로 주로 사용된다. ComponentDidUpdate :렌더링 이후 정의해 놓은 상태가 변경될 때마다 실행한다. React Hook에서는 2번째 파라미터로 정의를 하는데 비워놓을 경우 모든 상태가 변경될 때마다 useEffect가 실행되고, 빈배열로 정의할 경우 렌더링 이후 1번만, 배열내에 특정 상태 변수를 작성하면 해당 변수에 대한 변경만 감지한다. 123456useEffect(() =&gt; &#123; effect // ComponentDidMount return () =&gt; &#123; // 리턴 명시하는 함수가 ComponentWillUnMount cleanup &#125;;&#125;, [input]) // ComponentDidUpdate 예제1234567891011121314151617181920212223242526272829303132333435363738394041424344import React, &#123;useEffect, useState&#125; from 'react'function useKeyPress(targetKey) &#123; const [keyPressed, setKeyPressed] = useState(false) // e.key vs key function downHandler(&#123; key &#125;) &#123; if (key === targetKey) &#123; setKeyPressed(true) &#125; &#125; const upHandler = (&#123;key&#125;) =&gt; &#123; if (key === targetKey) &#123; setKeyPressed(false) &#125; &#125; useEffect(() =&gt; &#123; // ComponentDidMount window.addEventListener('keydown', downHandler) window.addEventListener('keyup', upHandler) // ComponentWillUnMount : Router에 의해 URL 변경, 페이지이동, 탭닫음 등등 return () =&gt; &#123; window.removeEventListener('keydown', downHandler) window.removeEventListener('keyup', upHandler) &#125;; &#125;,[] /* ComponentDidUpdate */) return keyPressed;&#125;const CustomHook = (props) =&gt; &#123; const aPressed = useKeyPress('a'); const bPressed = useKeyPress('b'); return ( &lt;&gt; &#123;aPressed &amp;&amp; 'A is pressed'&#125; &#123;bPressed &amp;&amp; 'B is Pressed'&#125; &lt;/&gt; );&#125;export default CustomHook; 로컬 스토리지 브라우저를 닫거나, 웹페이지를 꺼도 데이터가 유지된다. 리덕스의 한계는 브라우저가 새로고침이 될 경우 모든 데이터가 날아가는데 리덕스와 로컬 스토리지를 연동하여 사용하면 이러한 단점을 보완할 수 있다. 주로 사용되는 함수 window.localStorage.getItem(key) : 로컬 스토리지에서 받아온 데이터는 JSON.parse로 풀어야 한다. window.localStorage.setItem(key, JSON.stringfy(변수명)) : JSON으로 형변환후 set 해야한다. 쿠키 vs 로컬스토리지 : 로컬스토리지는 그 컴퓨터에만 저장만 하고 서버에 전송하지는 않는다. 쿠키는 사용자의 동의를 받고 서버에 전송하기 까지 한다. ( 코드 작성 중 ) 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123;useEffect,useState&#125; from 'react'import &#123; cleanup &#125; from '@testing-library/react';// localStorage.setItem('data', JSON.stringfy(obj))function useLocalStorage(key, init) &#123; const [storedValue, setStoredValue] = useState(() =&gt; &#123; try &#123; const item = window.localStorage.getItem(key) window.localStorage.setItem(key, JSON.stringify(init)) return item ? JSON.parse(item) : init; &#125; catch (error) &#123; console.error(error); return init; &#125; &#125;) const setValue = value =&gt; &#123; try &#123; setStoredValue(value) window.localStorage.setItem(key, JSON.stringify(value)) &#125; catch (error) &#123; console.error(error); &#125; &#125; return [storedValue, setValue];&#125;const App = (props) =&gt; &#123; const [name, setName] = useLocalStorage('name', 'react'); // setName('web'); useEffect(() =&gt; &#123; setName('web'); &#125;) return ( &lt;&gt; &lt;/&gt; )&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"State 끌어올리기","slug":"react-official-09","date":"2019-12-28T13:02:11.000Z","updated":"2019-12-29T16:49:33.986Z","comments":true,"path":"2019/12/28/react-official-09/","link":"","permalink":"https://hyeok999.github.io/2019/12/28/react-official-09/","excerpt":"","text":"React Official Document주요개념 : State 끌어올리기 온도계산기 기본 컴포넌트 생성 두번째 Input 추가 하기 변환 함수 작성 State 끌어올리기 Calculator 변경사항 요약 Calculator 컴포넌트 수정하기 정리 교훈 React Official Document주요개념#9. State 끌어올리기온도 계산기기본 컴포넌트 생성 먼저 BoilingVerdict라는 이름의 컴포넌트부터 만들어보자. 이 컴포넌트는 섭씨 온도를 의미하는 celsius prop를 받아서 이 온도가 물이 끓기에 충분한지 여부를 출력한다. 123456function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125; Calculator라는 컴포넌트를 만들어보자. 컴포넌트는 온도를 입력할 수 있는 &lt;input&gt;을 렌더링하고 그 값을 this.state.temperature에 저장한다. ( 현재 입력값에 대한 BoilingVerdict 컴포넌트를 렌더링 한다. ) 123456789101112131415161718192021222324252627class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(temperature)&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 두번째 Input 추가하기 화씨 입력 컴포넌트도 추가한다. 또한 섭씨, 화씨 입력 컴포넌트간에 동기화 상태를 유지한다. Calculator에서 TemperatureInput 컴포넌트를 빼내는 작업부터 시작. ( &quot;c&quot; 또는 &quot;f&quot;의 값을 가질 수 있는 scale prop를 추가할 것. ) 12345678910111213141516171819202122232425262728const scaleNames = &#123; c: 'Celsius', f: 'Fahrenheit'&#125;;class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 이제 Calculator가 분리된 두 개의 온도 입력 필드를 렌더링하도록 변경할 수 있다. 12345678910class Calculator extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;TemperatureInput scale=\"c\" /&gt; &lt;TemperatureInput scale=\"f\" /&gt; &lt;/div&gt; ); &#125;&#125; 변환 함수 작성 변환 함수 작성해주기, 화씨 -&gt; 섭씨 toCelsius 섭씨 -&gt; 화씨 toFahrenheit 1234567function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125; 문자열 반환함수 작성해주기. 인자는 temperature 와 위에서 적은 toCelsius 와 toFahrenheit 중 하나를 받는다. 만약, temperature 가 잘못된 값으로 받을 경우, 빈문자열을 반환한다. 12345678910111213function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); // temperaturer 잘못된 값 처리 if (Number.isNaN(input)) &#123; return ''; &#125; // const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125; tryConvert(&#39;abc&#39;, toCelsius)는 빈 문자열을 반환하고 tryConvert(&#39;10.22&#39;, toFahrenheit)는 &#39;50.396&#39;을 반환한다. State 끌어올리기 &lt;TemperatureInput scale=&quot;c&quot; /&gt;,&lt;TemperatureInput scale=&quot;f&quot; /&gt; 컴포넌트가 각각의 입력값을 각자의 state에 독립적으로 저장하고 있다. 1234567891011121314class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; // ... 하지만, 두 입력값이 서로의 것과 동기화된 상태로 있는 것을 원하며, 섭씨 온도 입력값을 변경하면 화씨 온도 입력값 역시 변환된 온도를 반영해야 한다.(반대도 동일) React에서 state를 공유하는 일은 그 값을 필요로 하는 컴포넌트 간의 가장 가까운 공통 조상으로 state를 끌어올림으로써 이뤄낼 수 있다.( 혹은 Redux 를 이용 ) 이제 TemperatureInput이 개별적으로 가지고 있던 지역 state를 지우는 대신 Calculator로 그 값을 옮겨놓을 것이다. Calculator가 공유될 state를 소유하고 있으면 이 컴포넌트는 두 입력 필드의 현재 온도에 대한 “진리의 원천(source of truth)“이 된다. 이를 통해 두 입력 필드가 서로 간에 일관된 값을 유지하도록 만들 수 있다. 두 TemperatureInput 컴포넌트의 props가 같은 부모인 Calculator로부터 전달되기 때문에, 두 입력 필드는 항상 동기화된 상태를 유지할 수 있게 된다. 우선, TemperatureInput 컴포넌트에서 this.state.temperature를 this.props.temperature로 대체할 것입니다. 지금은 this.props.temperature가 이미 존재한다고 가정해보자. 나중에는 이 값을 Calculator로부터 건네야 한다. 1234render() &#123; // Before: const temperature = this.state.temperature; const temperature = this.props.temperature; // ... props는 읽기 전용이다. temperature가 지역 state였을 때는 그 값을 변경하기 위해서 그저 TemperatureInput의 this.setState()를 호출하는 걸로 충분했지만, 이제 temperature가 부모로부터 prop로 전달되기 때문에 TemperatureInput은 그 값을 제어할 능력이 없다. React에서는 보통 이 문제를 컴포넌트를 “제어” 가능하게 만드는 방식으로 해결한다. DOM &lt;input&gt;이 value와 onChange prop를 건네받는 것과 비슷한 방식이다. 사용자 정의된 TemperatureInput 역시 temperature와 onTemperatureChange props를 자신의 부모인 Calculator로부터 건네받을 수 있다. 이제 TemperatureInput에서 온도를 갱신하고 싶으면 this.props.onTemperatureChange를 호출하면 된다. 1234handleChange(e) &#123; // Before: this.setState(&#123;temperature: e.target.value&#125;); this.props.onTemperatureChange(e.target.value); // ... onTemperatureChange prop는 부모 컴포넌트인 Calculator로부터 temperature prop와 함께 제공될 것이다. 를 이용해 자신의 지역 state를 수정해서 변경사항을 처리하므로, 변경된 새 값을 전달받은 두 입력 필드는 모두 리렌더링된다. Calculator 변경사항 요약 Calculator의 변경사항을 들여다보기 전에 TemperatureInput 컴포넌트에 대한 변경사항부터 요약해보자. 이 컴포넌트의 지역 state를 제거했으며 this.state.temperature 대신에 this.props.temperature를 읽어오도록 변경했다. state를 변경하고 싶을 경우 this.setState() 대신에 Calculator로부터 건네받은 this.props.onTemperatureChange()를 호출하도록 만들었다. 12345678910111213141516171819202122class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.props.onTemperatureChange(e.target.value); &#125; render() &#123; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; Calculator 컴포넌트 수정하기 temperature와 scale의 현재 입력값을 이 컴포넌트의 지역 state에 저장한다. 이것은 우리가 입력 필드들로부터 “끌어올린” state이며 그들에 대한 “진리의 원천(source of truth)“으로 작용할 것이다. 또한 두 입력 필드를 렌더링하기 위해서 알아야 하는 모든 데이터를 최소한으로 표현한 것이기도 한다. 예를 들어서, 섭씨 입력 필드에 37을 입력하면 Calculator 컴포넌트의 state는 다음과 같을 것이다. 1234&#123; temperature: '37', scale: 'c'&#125; 이후에 화씨 입력 필드의 값을 212로 수정하면 Calculator의 state는 다음과 같은 모습일 것이다. 1234&#123; temperature: '212', scale: 'f'&#125; 두 입력 필드에 모두 값을 저장하는 일도 가능했지만 결국은 불필요한 작업이었던 것이다. 가장 최근에 변경된 입력값과 그 값이 나타내는 단위를 저장하는 것만으로도 충분하다. 그러고 나면 현재의 temperature와 scale에 기반해 다른 입력 필드의 값을 추론할 수 있다. 두 입력 필드의 값이 동일한 state로부터 계산되기 때문에 이 둘은 항상 동기화된 상태를 유지하게 된다. 1234567891011121314151617181920212223242526272829303132333435363738class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: '', scale: 'c'&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: 'c', temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: 'f', temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=\"c\" temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=\"f\" temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 이제 어떤 입력 필드를 수정하든 간에 Calculator의 this.state.temperature와 this.state.scale이 갱신됩니다. 입력 필드 중 하나는 있는 그대로의 값을 받으므로 사용자가 입력한 값이 보존되고, 다른 입력 필드의 값은 항상 다른 하나에 기반해 재계산됩니다. 정리 입력값을 변경할 때 일어나는 일들을 정리해보자. React는 DOM &lt;input&gt;의 onChange에 지정된 함수를 호출한다. 위 예시의 경우 TemperatureInput의 handleChange 메서드에 해당한다. TemperatureInput 컴포넌트의 handleChange 메서드는 새로 입력된 값과 함께 this.props.onTemperatureChange()를 호출한다. onTemperatureChange를 포함한 이 컴포넌트의 props는 부모 컴포넌트인 Calculator로부터 제공받은 것이다. 이전 렌더링 단계에서, Calculator는 섭씨 TemperatureInput의 onTemperatureChange를 Calculator의 handleCelsiusChange 메서드로, 화씨 TemperatureInput의 onTemperatureChange를 Calculator의 handleFahrenheitChange 메서드로 지정해놓았다. 따라서 우리가 둘 중에 어떤 입력 필드를 수정하느냐에 따라서 Calculator의 두 메서드 중 하나가 호출된다. 이들 메서드는 내부적으로 Calculator 컴포넌트가 새 입력값, 그리고 현재 수정한 입력 필드의 입력 단위와 함께 this.setState()를 호출하게 함으로써 React에게 자신을 다시 렌더링하도록 요청한다. React는 UI가 어떻게 보여야 하는지 알아내기 위해 Calculator 컴포넌트의 render 메서드를 호출한다. 두 입력 필드의 값은 현재 온도와 활성화된 단위를 기반으로 재계산된다. 온도의 변환이 이 단계에서 수행된다. React는 Calculator가 전달한 새 props와 함께 각 TemperatureInput 컴포넌트의 render 메서드를 호출한다. 그러면서 UI가 어떻게 보여야 할지를 파악한다. React는 BoilingVerdict 컴포넌트에게 섭씨온도를 props로 건네면서 그 컴포넌트의 render 메서드를 호출한다. React DOM은 물의 끓는 여부와 올바른 입력값을 일치시키는 작업과 함께 DOM을 갱신한다. 값을 변경한 입력 필드는 현재 입력값을 그대로 받고, 다른 입력 필드는 변환된 온도 값으로 갱신된다. 입력 필드의 값을 변경할 때마다 동일한 절차를 거치고 두 입력 필드는 동기화된 상태로 유지된다. 교훈 React 애플리케이션 안에서 변경이 일어나는 데이터에 대해서는 “진리의 원천(source of truth)“을 하나만 두어야 한다. 보통의 경우, state는 렌더링에 그 값을 필요로 하는 컴포넌트에 먼저 추가된다. 그러고 나서 다른 컴포넌트도 역시 그 값이 필요하게 되면 그 값을 그들의 가장 가까운 공통 조상으로 끌어올리면 된다. 다른 컴포넌트 간에 존재하는 state를 동기화시키려고 노력하는 대신 하향식 데이터 흐름에 기대는 걸 추천한다. state를 끌어올리는 작업은 양방향 바인딩 접근 방식보다 더 많은 “보일러 플레이트” 코드(일부분에 주석, 메모등을 적는 코드)를 유발하지만, 버그를 찾고 격리하기 더 쉽게 만든다는 장점이 있다. 어떤 state든 간에 특정 컴포넌트 안에서 존재하기 마련이고 그 컴포넌트가 자신의 state를 스스로 변경할 수 있으므로 버그가 존재할 수 있는 범위가 크게 줄어든다. 또한 사용자의 입력을 거부하거나 변형하는 자체 로직을 구현할 수도 있다. 어떤 값이 props 또는 state로부터 계산될 수 있다면, 아마도 그 값을 state에 두어서는 안 된다. 예를 들어 celsiusValue와 fahrenheitValue를 둘 다 저장하는 대신, 단지 최근에 변경된 temperature와 scale만 저장하면 된다. 다른 입력 필드의 값은 항상 그 값들에 기반해서 render() 메서드 안에서 계산될 수 있다. 이를 통해 사용자 입력값의 정밀도를 유지한 채 다른 필드의 입력값에 반올림을 지우거나 적용할 수 있게 된다. UI에서 무언가 잘못된 부분이 있을 경우, React Developer Tools를 이용하여 props를 검사하고 state를 갱신할 책임이 있는 컴포넌트를 찾을 때까지 트리를 따라 탐색해보자. 이렇게 함으로써 소스 코드에서 버그를 추적할 수 있다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"폼","slug":"react-official-08","date":"2019-12-27T14:32:11.000Z","updated":"2019-12-29T16:49:15.305Z","comments":true,"path":"2019/12/27/react-official-08/","link":"","permalink":"https://hyeok999.github.io/2019/12/27/react-official-08/","excerpt":"","text":"React Official Document주요개념 : 폼 HTML 에서의 Form React에서의 Form 제어 컴포넌트(Controlled Components) textarea 태그 select 태그 file input 태그 다중 입력 제어하기 제어되는 Input Null 값 React Official Document주요개념#8. 폼HTML 에서의 Form1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type=\"text\" name=\"name\" /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 위와 같이 HTML에서의 Form은 타 페이지로 이동을 한다. React에서도 위와같이 작성을 해도 문제는 없으나, 대부분 JavaScript 함수로 Form의 제출을 처리하고 사용자가 입력한 데이터에 접근하도록 하는 것이 편리하다. 이를 위한 표준 방식 기술을 ‘제어 컴포넌트(Controlled Components)’ 라고 한다. React에서의 Form제어 컴포넌트(Controlled Components) HTML에서 &lt;input&gt;, &lt;textarea&gt;, &lt;select&gt;와 같은 Form 요소는 일반적으로 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트 한다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state속성에 유지되며 setState() 함수를 통해 업데이트 된다. React의 state는 신뢰 가능한 단일 출처 (single source of truth)로 만들어 두 요소를 결합할 수 있다. 먼저 Form을 렌더링하는 React 컴포넌트에서 Form에 발생하는 사용자 입력값을 제어한다. 이런식으로 React에 의해 값이 제어되는 입력 Form 요소를 제어 컴포넌트라 칭한다. 이름을 기록하는 Form 제어 컴포넌트를 작성해보자 123456789101112131415161718192021222324252627282930class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 여기서 render()의 &lt;input&gt;태그의 value값은 항상 this.state.value가 되고 React state는 신뢰 가능한 단일 출처가 된다. React state를 업데이트하기 위해 모든 키 입력에서 handleChange가 동작하기 때문에 사용자가 입력할 때 보여지는 값이 업데이트된다. 제어 컴포넌트로 사용하면 모든 state 변화는 연관된 핸들러를 가진다. 이것을 통하여 입력 수정, 유효성 검사등이 간편해진다. 예, 입력받은 값을 전부 대문자로 변환하는 예제 123handleChange(event) &#123; this.setState(&#123;value: event.target.value.toUpperCase()&#125;);&#125; textarea 태그 HTML에서는 &lt;textarea&gt;는 텍스트를 자식요소로 정의한다. React에서 &lt;textarea&gt;에서 텍스트 대신 value 어트리뷰트를 대신 사용한다. (소스 량이 줄어듬) 123456789101112131415class EssayForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: 'Please write an essay about your favorite DOM element.' &#125;; &#125; render() &#123; return ( ... &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; ); &#125;&#125; select 태그 HTML에서 &lt;select&gt;은 드롭다운 목록을 만든다. 123456&lt;select&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option selected value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;&lt;/select&gt; 여기서 coconut 옵션이 초기값이 된다. React에서는 selected 속성 대신 최상단 select태그에 value 속성을 사용한다. 한 곳에서 업데이트만 하면 되기 떄문에 제어 컴포넌트에서 사용하기가 더 편리하기 떄문이다. 12345678910111213141516171819202122232425class FlavorForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: 'coconut'&#125;; this.handleChange = this.handleChange.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; render() &#123; return ( ... &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt; &lt;/select&gt; ... ); &#125;&#125; 추가로 select태그에 multiple 옵션을 허용한다면 value 속성에 배열을 전달할 수 도 있다. 1&lt;select multiple=&#123;true&#125; value=&#123;['B', 'C']&#125;&gt; file input 태그 HTML에서 &lt;input type=&quot;file&quot;&gt;는 사용자가 하나 이상의 파일을 자신의 장치 저장소에서 서버로 업로드하거나 File API를 통해 JavaScript로 조작할 수 있다. 1&lt;input type=\"file\" /&gt; 값이 읽기 전용이라서 React에서는 비제어 컴포넌트다. 다중 입력 제어하기 여러 input 엘리먼트를 제어해야할 때, 각 엘리먼트에 name 어트리뷰트를 추가하고 event.target.name 값을 통해 핸들러가 어떤 작업을 할 지 선택할 수 있게 해줄 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Reservation extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isGoing: true, numberOfGuests: 2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event) &#123; const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input name=\"isGoing\" type=\"checkbox\" checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; Number of guests: &lt;input name=\"numberOfGuests\" type=\"number\" value=&#123;this.state.numberOfGuests&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; name값이 무엇으로 바뀔지 모르기 때문에 [name]: value라고 작성했다. 제어되는 Input Null 값 제어 컴포넌트에 value prop을 지정하면 의도하지 않는 한 사용자가 변경할 수 없다. value를 설정했는데 여전히 수정할 수 있다면 실수로 value를 undefined나 null로 설정했을 수 있다. 예, 처음 입력은 잠겨있지만 잠시 후 입력이 가능해진다. 12345ReactDOM.render(&lt;input value=\"hi\" /&gt;, mountNode);setTimeout(function() &#123; ReactDOM.render(&lt;input value=&#123;null&#125; /&gt;, mountNode);&#125;, 1000); value는 초기값을 기억하기 때문이다. 따라서 React에서는 defaultValue를 이용한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"리스트와 Key","slug":"react-official-07","date":"2019-12-25T14:19:10.000Z","updated":"2019-12-29T16:49:08.865Z","comments":true,"path":"2019/12/25/react-official-07/","link":"","permalink":"https://hyeok999.github.io/2019/12/25/react-official-07/","excerpt":"","text":"React Official Document주요개념 : 리스트와 Key 자바스크립트에서 리스트 변환 리액트에서 여러개의 컴포넌트 렌더링 하기 기본 리스트 컴포넌트 Key Key로 컴포넌트 추출하기 Key는 주변 배열의 context에서만 의미를 지니고 있다. Key는 형제 사이에서만 고유한 값을 지녀야 한다. React에서 Key는 컴포넌트로 전달되지는 않는다. React Official Document주요개념#7. 리스트와 Key자바스크립트에서 리스트 변환아래는 map()함수를 이용하여 numbers 배열의 값을 두배로 만든 후 map()에서 반환하는 새 배열을 doubled 변수에 할당하고 로그를 확인하는 코드다. 123const numbers = [1, 2, 3, 4, 5];const doubled = numbers.map((number) =&gt; number * 2);console.log(doubled); 이 코드는 콘솔에 [2, 4, 6, 8, 10] 을 출력한다. React에서 배열을 요소(앨리먼트) 리스트로 만드는 방식은 위 방식과 거의 동일하다. 리액트에서 여러개의 컴포넌트 렌더링 하기 리액트는 요소들을 집합을 만들고 중괄호{}를 이용하여 JSX에 포함시킬 수 있다. 예) JS의 map() 함수를 이용해 numbers 배열을 반복 실행한다. 1234const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;); 각 항목에 대해서 &lt;li&gt; 요소들을 반환하고 배열의 결과를 새로운 변수에 저장한다. listItems 배열을 &lt;ul&gt;엘리먼트 안에 포함하고 DOM에 렌더링 한다. 1234ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('root')); &lt;li&gt;1&lt;/li&gt; ~ &lt;li&gt;5&lt;/li&gt; 의 요소가 &lt;ul&gt; 태그안에 들어가 있다. 기본 리스트 컴포넌트 일반적으로는 컴포넌트 내에서 리스트를 렌더링한다. 다음과 같이 배열자체를 할당 받고 리스트 전체를 렌더링한 값을 반환하는 컴퍼넌트를 작성할 수도 있다. 123456789101112131415function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 문제는 위와 같은 코드를 실행 시 리액트에서 Key에 대한 경고를 표시한다. key는 앨리먼트 리스트를 만들 때 포함시켜야 하는 특수한 문자열 속성이다. 따라서 numbers.map()안에서 리스트의 각 항목에 key를 할당하여 해당 경고를 해결한다. 1234567891011121314151617function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125; /* 이 부분 추가 */&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); Key 키는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 도와준다. Key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야만 한다. Key는 고유한 문자열이어야 하기 때문에 보통 데이터의 ID를 많이 이용한다. 그런데 만약 렌더링한 항목에 넣어줄 특정 값(ID)등이 떠오르지 않는다면 고차함수의 index를 사용할 수 도 있다. 123456const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 여기서 index는 가능한 사용하지 말아야 한다. 항목의 순서가 바뀔 경우 index는 state와 관련 문제를 일으킬 수도 있다. 따라서 이럴 경우, uuid라는 랜덤 문자열 값을 지정하는 노드 패키지 모듈(NPM)을 이용하도록 한다. Key로 컴포넌트 추출하기 Key는 주변 배열의 context에서만 의미를 지니고 있다. Key의 설정은 엘리먼트 리스트를 만들때 리스트 자체에게 주는 것이 아닌, 리스트를 불러오는 map()함수의 최상위 요소에 넣어주어야한다. 예를들면, ListItem 컴포넌트를 추출한 경우 ListItem 안에 있는 &lt;li&gt;엘리먼트가 아니라 배열의 &lt;ListItem/&gt;엘리먼트가 key를 가져야 한다. 123456789101112131415161718192021222324function ListItem(props) &#123; // X, 여기에는 key를 지정할 필요가 없다. return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // O, map 함수내부 안의 요소에 key를 지정해야 한다. &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); Key는 형제 사이에서만 고유한 값을 지녀야 한다. Key는 배열 안에서 형제 사이에서 고유해야 하고 전체 범위에서 고유할 필요는 없다. 두 개의 다른 배열을 만들 때 동일한 key를 사용할 수 있다. 123456789101112131415161718192021222324252627282930313233function Blog(props) &#123; const sidebar = ( &lt;ul&gt; &#123;props.posts.map((post) =&gt; &lt;li key=&#123;post.id&#125; /*같은 키를 쓰고 있다.*/&gt; &#123;post.title&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key=&#123;post.id&#125; /*같은 키를 쓰고 있다.*/&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;sidebar&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; );&#125;const posts = [ &#123;id: 1, title: 'Hello World', content: 'Welcome to learning React!'&#125;, &#123;id: 2, title: 'Installation', content: 'You can install React from npm.'&#125;];ReactDOM.render( &lt;Blog posts=&#123;posts&#125; /&gt;, document.getElementById('root')); React에서 Key는 컴포넌트로 전달되지는 않는다. Key는 연속적이 리스트 엘리먼트에 대한 힌트일 뿐이다. 컴포넌트에서 key와 동일한 값이 필요하면 다른 이름의 prop으로 명시적으로 전달한다. 123456const content = posts.map((post) =&gt; &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;); Post 컴포넌트에서는 props.id는 읽을 수 있지만, props.key는 읽을 수 없다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"daily_algorithm62","slug":"daily-algorithm62","date":"2019-12-24T11:26:38.000Z","updated":"2019-12-24T11:28:24.493Z","comments":true,"path":"2019/12/24/daily-algorithm62/","link":"","permalink":"https://hyeok999.github.io/2019/12/24/daily-algorithm62/","excerpt":"","text":"최대공약수와 최소공배수문제 설명두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다. 제한 사항 두 수는 1이상 1000000이하의 자연수입니다. 입출력 예 n m return 3 12 [3, 12] 2 5 [1, 10] 입출력 예 설명입출력 예 #1위의 설명과 같습니다. 입출력 예 #2자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다. 12345678910111213141516171819function GCD(a, b) &#123; while (b != 0) &#123; const r = a % b; a = b; b = r; &#125; return a;&#125;function LCM(a, b) &#123; return (a * b) / GCD(a, b);&#125; // 두수를 곱하고 최대공약수를 빼준다.function solution(n, m) &#123; const answer = [GCD(n, m), LCM(n, m)]; return answer;&#125;console.log(solution(12, 3));","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"조건부 렌더링","slug":"react-official-06","date":"2019-12-24T11:21:55.000Z","updated":"2019-12-29T16:49:02.505Z","comments":true,"path":"2019/12/24/react-official-06/","link":"","permalink":"https://hyeok999.github.io/2019/12/24/react-official-06/","excerpt":"","text":"React Official Document주요개념 : 조건부 렌더링 조건 연산자 이용 엘리먼트(요소)를 변수에 저장하기 인라인으로 IF를 표현하기 논리 &amp;&amp; 연산자로 if를 인라인으로 표현하기 삼항 연산자로 If-Else구문 인라인으로 표현하기 컴포넌트 렌더링 막기 setState 일괄처리 setState 일괄처리 해결 React Official Document주요개념#6. 조건부 렌더링React에서는 원하는 동작을 캡슐화하는 컴포넌트를 만들 수 있다. 이렇게 하면 애플리케이션의 상태에 따라서 컴포넌트 중 몇 개만을 렌더링 할 수 있다. 조건 연산자 이용if 나 삼항연산자를 이용해서 현재 상태를 나타내는 엘리먼트를 만드는 데에 사용할 수 있다. 예제) 아래 두 컴포넌트가 있다고 가정한다. 1234567function UserGreeting(props) &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;;&#125;function GuestGreeting(props) &#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;;&#125; 사용자의 로그인 상태에 맞게 위 두 컴포넌트 중 하나만 보여주도록 하는 Greering 컴포넌트를 생성 해보자. 12345678910111213function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125;ReactDOM.render( // Try changing to isLoggedIn=&#123;true&#125;: &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;, document.getElementById('root')); isLoggedIn의 값 에 따라서 다른 인사말을 렌더링 한다. 엘리먼트(요소)를 변수에 저장하기엘리먼트를 저장하기 위해 변수를 사용할 수 있다. 즉, 엘리먼트도 하나의 값으로 표현할수 있는 표현식이다. 출력의 다른 부분은 변하지 않은 채로 컴포넌트의 일부를 조건부로 렌더링 할 수 있다. 로그인 과 로그아웃 버튼을 나타내는 두 컴포넌트가 있다고 가정해 보자. 123456789101112131415function LoginButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Login &lt;/button&gt; );&#125;function LogoutButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Logout &lt;/button&gt; );&#125; 123456789101112131415161718192021222324252627282930313233343536373839class LoginControl extends React.Component &#123; constructor(props) &#123; super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = &#123;isLoggedIn: false&#125;; &#125; handleLoginClick() &#123; this.setState(&#123;isLoggedIn: true&#125;); &#125; handleLogoutClick() &#123; this.setState(&#123;isLoggedIn: false&#125;); &#125; render() &#123; const isLoggedIn = this.state.isLoggedIn; let button; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;LoginControl /&gt;, document.getElementById('root')); ​ this.state.isLoggedIn에 따라서 각 버튼을 보여주고 로그인 상태일 때는 로그아웃 버튼과 Greeting을 로그아웃 상태일때는 로그인 버튼과 Greeting을 보여주고 있다. 인라인으로 IF를 표현하기변수를 선언하고 if를 사용해서 조건부로 렌더링 하는 것은 좋은 방법이지만 더 짧은 구문을 사용하고 싶을 때가 있을 수 있다. 여러 조건을 JSX 안에서 인라인(inline)으로 처리할 방법 몇 가지를 알아 보자. 논리 &amp;&amp; 연산자로 if를 인라인으로 표현하기 JSX 안에는 중괄호를 이용해서 표현식을 포함 할 수 있다. 그 안에 JavaScript의 논리 연산자 &amp;&amp;를 사용하면 쉽게 엘리먼트를 조건으로 사용 할 수 있다. 12345678910111213141516171819function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; );&#125;const messages = ['React', 'Re: React', 'Re:Re: React'];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById('root')); 위 예제는 unreadMessages.length가 0 이상 일 때, &lt;h2&gt;You have {unreadMessages.length} unread messages.&lt;/h2&gt;를 보여주는 예제이다. (단축평가) 삼항 연산자로 If-Else구문 인라인으로 표현하기 엘리먼트를 조건부로 렌더링하는 다른 방법은 삼항 연산자인 condition ? true: false를 사용하는 것 이다. 12345678render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 123456789101112render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; &#123;isLoggedIn ? ( &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt; ) : ( &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt; )&#125; &lt;/div&gt; );&#125; 이렇게 JSX 내부에 인라인으로 조건들을 이용하여 표현할 수 있다. 너무 많은 조건으로 가독성이 많이 저하된다면 컴포넌트를 분리하여 해결할 수도 있으니 참고하자. 컴포넌트 렌더링 막기가끔 다른 컴포넌트에 의해 렌더링될 때 컴포넌트 자체를 숨기고 싶을 때가 있을 수 있다. 이때는 렌더링 결과를 출력하는 대신 null을 반환하면 해결할 수 있다. 아래의 예시에서는 &lt;WarningBanner /&gt;가 warn prop의 값에 의해서 렌더링된다. prop이 false라면 컴포넌트는 렌더링하지 않게 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className=\"warning\"&gt; Warning! &lt;/div&gt; );&#125;// 상위 컴포넌트class Page extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;showWarning: true&#125;; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState(state =&gt; (&#123; showWarning: !state.showWarning &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? 'Hide' : 'Show'&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Page /&gt;, document.getElementById('root')); 컴포넌트의 render 메서드로부터 null을 반환하는 것은 생명주기 메서드 호출에 영향을 주지 않는다. 그 예로 componentDidUpdate는 계속해서 호출되게 된다. setState 일괄처리 setState 는 비동기로 state를 업데이트 한다. setState(updater, [callback]) setState메소드는 즉시 실행되는 (동기적으로 실행되는) 것이 아니므로 setState를 통해 상태를 변경하더라도 해당 메소드가 실행된 직후에 변경된 상태가 적용되는 것이 아니다. setState를 호출한 직후에 this.state에 접근하는 것은 올바른 방법이 아니며 그렇게 접근 시 잘못된 상태를 만들 수도 있다. 아래 예제를 보자. 123456789state = &#123; count: 0&#125;updateCount = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1&#125;); this.setState(&#123; count: this.state.count + 1&#125;); this.setState(&#123; count: this.state.count + 1&#125;); this.setState(&#123; count: this.state.count + 1&#125;);&#125; 위 예제에서 최종 count의 값은 ‘4’라고 생각할 수 있지만, 여러 setState가 동일한 상태를 업데이트 하는 경우 setState에 대한 마지막 호출은 일괄 처리 중 이전 값을 무시하므로 count는 ‘1’이 된다. setState 일괄처리 해결 만약 이전의 상태에 더해서 상태를 변경해야 한다면 가장 좋은 방법 중 하나는 updater 함수를 사용하는 것 이다. updater함수를 setState 메소드의 첫번째 인자로 넘기는 방식으로 사용할 수 있다. setState(updater, [callback]) 123456updateCount = () =&gt; &#123; this.setState(prevstate =&gt; (&#123; count: prevstate.count + 1&#125;)); this.setState(prevstate =&gt; (&#123; count: prevstate.count + 1&#125;)); this.setState(prevstate =&gt; (&#123; count: prevstate.count + 1&#125;)); this.setState(prevstate =&gt; (&#123; count: prevstate.count + 1&#125;));&#125; 여기서 [callback]은 옵션 인자로서 setState의 실행이 완료된 후 실행되며 해당 callback이 실행된 후에 해당 컴포넌트의 재 렌더링이 이루어진다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"React 스터디 10","slug":"react-study-10","date":"2019-12-23T14:15:39.000Z","updated":"2019-12-23T14:17:55.014Z","comments":true,"path":"2019/12/23/react-study-10/","link":"","permalink":"https://hyeok999.github.io/2019/12/23/react-study-10/","excerpt":"","text":"React Study 10 객체의 접근 방법 YouTube 프로젝트 변경점 좋아요, 싫어요 기능 추가 댓글 추가 / 삭제 기능 추가 Stale closure problem 결과를 변경하기 위한 해결점 1 : 함수를 만들고 함수로 호출 결과를 변경하기 위한 해결점 2 : 즉시실행함수를 사용한다. React Hook useState useEffect 용어 - ( 러버덕 ) 객체의 접근 방법 React Hook useState useEffect Stale closure problem 객체의 접근 방법12345678910const state = &#123; id : 'abc', pwd : '1234' &#125;state.id; // abcstate['id'] // abccont pwd = 'pwd'state[pwd] // 1234state['pwd'] // 1234state.pwd //1234state.id === state[id]; // true YouTube 프로젝트 변경점좋아요, 싫어요 기능 추가Action 구성하기 액션의 내용은 현재 좋아요와 싫어요를 기본적으로 저장할 id와 좋아요인지 싫어요인지 구별하기 위한 toggle_like를 구별한다. 12345export const LIKE = 'LIKE';export function like(id, toggle_like) &#123; return (&#123;type:LIKE, id, toggle_like&#125;)&#125; Reducer 구성하기 Action 구성을 했다면 toggle_like를 구성해준다. toggle은 true인지 false인지만 구분하면 되므로 if ... else로 구분해준다. data &amp;&amp; data.likeCount 에서 &amp;&amp; 연산자의 의미는 첫번째, 자바스크립트에게 객체 내부로 접근하기 전에 상위 레벨부터 접근해야만 한다. 바로 data.likeCount로 접근했을 경우, data가 존재하지 않는다면, undefined.likeCount가 될 수도 있기 때문이다. 두번째, 해당 소스는 likeCount 와 disLikeCount로 총 2개가 나뉘어져 있다. 만약 2개중 한개라도 사용되었다면 이미 data는 존재하는 것이기 때문에 항상 참이게 된다. 그럴경우 초기화가 되어있지 않은 data.likeCount는 null 상태인데 여기서 +1을 아무리 해도 NULL이다. 따라서 2개의 비교가 필요하다. 12345678910111213141516171819202122232425262728case LIKE : if(action.toggle_like) &#123; return &#123; ...state, // 쿼리를 보존하기위해서 data: &#123; ...state.data, // 나중에 추가될 데이터를 보존하기위해서 [action.id]: &#123; ...data, // Comment의 데이터를 보존하기 위해서 나열해주엇음. likeCount: data &amp;&amp; data.likeCount ? data.likeCount + 1 : 1, &#125; &#125; &#125; &#125; else &#123; return &#123; ...state, // 쿼리를 보존하기위해서 data: &#123; ...state.data, // 나중에 추가될 데이터를 보존하기위해서 [action.id]: &#123; ...data, // Comment의 데이터를 보존하기 위해서 나열해주엇음. disLikeCount: data &amp;&amp; data.disLikeCount ? data.disLikeCount + -1 : -1, &#125; &#125; &#125; &#125;; VideoPlayer Redux 추가하기 VideoPlayer에 Redux를 추가한다. 123456789101112131415161718192021&lt;button onClick=&#123;() =&gt; props.like(_id, true)&#125;&gt;좋아요&lt;/button&gt;&#123; props.data[_id] &amp;&amp;props.data[_id].likeCount ? props.data[_id].likeCount : 0&#125;&lt;button onClick=&#123;() =&gt; props.like(_id, false)&#125;&gt;싫아요&lt;/button&gt;&#123; props.data[_id] &amp;&amp;props.data[_id].disLikeCount ? props.data[_id].disLikeCount : 0&#125;...&#125;;function mapStateToProps(state) &#123;...&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; like, &#125;, dispatch)&#125;export default connect(mapStateToProps,mapDispatchToProps)(VideoPlayer); 댓글 추가 / 삭제 기능 추가Action 구성하기 댓글 추가 및 삭제기능 전부 id객체 내부따라서 저장이 되야하므로 2개를 전부 받는다. 댓글 추가 기능은 텍스트 값을 입력 받아야하므로 val 를 인자로 받고 댓글 삭제 기능은 각 댓글마다 있는 commentId 를 가지고 삭제해야 한다. 12345678910export const COMMENT = 'COMMENT';export const DELETECOMMENT = 'DELETECOMMENT';export function comment(id, val) &#123; return (&#123;type:COMMENT, id, val&#125;)&#125;export function deleteComment(id, commentId) &#123; return (&#123;type:DELETECOMMENT, id, commentId&#125;)&#125; Reducer 구성하기 먼저 댓글 추가 기능을 작성하자. 댓글을 추가할 때 중복이 되어야 하므로 배열로 받는다. data 객체와 comments 배열이 둘다 존재 하지 않을 경우 배열 내부에 객체로 text(댓글 내용) 과 cid(댓글 아이디)를 추가한다. 여기서, cid(댓글 아이디)는 여러가지 방법이 있지만, 새로 추가된 댓글과 중복되어서는 안된다. 나는 여기서 1씩 늘어나는 방식을 사용한다. cid : Math.max(-1, ...data.comments.map((id) =&gt; id.cid)) + 1 는 댓글이 존재할 경우 해당 댓글아이디만을 map()함수를 이용해 뽑아낸뒤 Math.max를 이용해 최고값을 갱신하다. 그 후 1을 더해준다. 여기서 Math.max(-1)을 기본으로 두어 만약 댓글이 전부 삭제하고 다시 추가할 경우, 다시 0부터 시작하게끔 설정한다. 12345678910111213141516171819case COMMENT : return &#123; ...state, data : &#123; ...state.data, [action.id]: &#123; ...data, comments: data &amp;&amp; data.comments ? [ &#123; text: action.val, cid : Math.max(-1, ...data.comments.map((id) =&gt; id.cid)) + 1 &#125;, ...data.comments ] : [&#123; text: action.val, cid : 0 &#125;], &#125; &#125;&#125;; 삭제기능은 VideoPlayer 에서 선택한 비디오의 cid와 filter()를 돌리면서 뽑아내 cid 를 비교하여 삭제하는 방식을 사용한다. 1234567891011case DELETECOMMENT : return &#123; ...state, data : &#123; [action.id]: &#123; comments: data &amp;&amp; data.comments.filter((comment) =&gt; &#123; return comment.cid !== action.commentId &#125;) &#125; &#125; &#125;; VideoPlayer Redux 추가하기 props.data[_id] &amp;&amp; props.data[_id].comments &amp;&amp; props.data[_id].comments.map((comment) 의 의미는 자바스크립트에서는 객체에 접근하기 위해서는 상위부터 접근해야만 한다. props.data[_id].comments에 접근할 때, 만약 props.data[_id]가 없다면 javascript는 props.data[_id].comments가 undefined.comments로 인식을 하기 때문이다. 따라서 방어코드 최상위부터 접근을 해야하는데 해당 객체의 최상위는 props다. 그런데 props는 Router 컴포넌트를 통해 뿌려지기 때문에 절대 없을 수가 없으므로 검사를 할 필요가 없다. 따라서 다음 단계인 props.data[_id]부터 검사하기 시작한다. 삭제는 선택한 요소의 cid를 보내주어야 하므로 해당 객체를 선택할 당시의 comment.cid를 클릭의 인자값으로 넘겨준다. 1234567891011121314151617181920212223242526272829303132333435363738 const handleEnter = (k) =&gt; (e) =&gt; &#123; if(e.key === 'Enter') &#123; k(_id, e.target.value); &#125; &#125; return ( ... &lt;input type='text' onKeyPress=&#123;handleEnter(props.comment)&#125; /&gt; &lt;div&gt; &#123; props.data[_id] &amp;&amp; props.data[_id].comments &amp;&amp; props.data[_id].comments.map((comment) =&gt; &lt;h1 key=&#123;uuid.v4()&#125;&gt; &#123;comment.text&#125; &lt;button onClick=&#123;() =&gt; props.deleteComment(_id, comment.cid)&#125;&gt;삭제&lt;/button&gt; &lt;/h1&gt; ) &#125; &lt;/div&gt; &lt;/div&gt; );&#125;;function mapStateToProps(state) &#123;...&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; like, comment, deleteComment &#125;, dispatch)&#125;export default connect(mapStateToProps,mapDispatchToProps)(VideoPlayer); Stale closure problem12345678910111213141516function useState(init) &#123; let _val = init; function setState(newVal) &#123; _val = newVal &#125; return [_val, setState];&#125;const [query, setQuery] = useState('여행')console.log(query)setQuery('크리스마스')console.log(query) // 여행, 여행 값을 리턴할 경우, 상위 렉시컬환경의 값이 업데이트 되지않는다. 결과를 변경하기 위한 해결점 1 : 함수를 만들고 함수로 호출함수 내부에서만 작동하는 변수일 경우 앞에 _를 붙여주는 경우가 많다. 1234567891011121314151617181920function useState(init) &#123; let _val = init; function useState () &#123; return _val &#125; function setState(newVal) &#123; _val = newVal &#125; return [useState, setState];&#125;const [query, setQuery] = useState('여행')console.log(query())setQuery('크리스마스')console.log(query()) // 여행, 크리스마스 결과를 변경하기 위한 해결점 2 : 즉시실행함수를 사용한다. 외부에서 접근하지 못하도록 변수를 보호할 수 있다. 기존의 함수에서 변수 리턴 시 업데이트가 되지 않는 문제를 해결. 1234567891011121314151617const React = (function() &#123; let _val return &#123; render(Component) &#123; const Comp = Component() Comp.render() return Comp &#125;, useState(init) &#123; _val = _val || init function setState(newVal) &#123; _val = newVal &#125; return [_val, setState] &#125; &#125;&#125;)(); React Hook리액트에서는 Hook을 IIFE(즉시실행함수) 형태로 폴리필 해보자. 많은 함수가 있게지만 useState는 다음과 같이 작성한다. 리액트 훅은 무조건 최상위에서만 사용한다.(for문, if문 등의 중첩 내에서 리액트 훅 사용 X) 리액트 훅 내부에서 for, if문등의 사용은 가능하다. 12345678910111213141516171819202122232425262728293031const React = (function() &#123; let _val return &#123; render(Component) &#123; const Comp = Component() Comp.render() return Comp &#125;, useState(init) &#123; _val = _val || init function setState(newVal) &#123; _val = newVal &#125; return [_val, setState] &#125; &#125;&#125;)()const &#123; useState &#125; = Reactfunction Counter() &#123; const [count, setCount] = useState(0) return &#123; click : () =&gt; setCount(count + 1), render : () =&gt; console.log('render', &#123;count&#125;) &#125;&#125; // 개발자가 작성한 코드 : 리액트 훅let AppApp = React.render(Counter)App.click()App = React.render(Counter) useState12345678const &#123; useState &#125; = Reactfunction Counter() &#123; const [count, setCount] = useState(0) return &#123; click : () =&gt; setCount(count + 1), render : () =&gt; console.log('render', &#123;count&#125;) &#125;&#125; // 개발자가 작성한 코드 : 리액트 훅 리액트 훅에서는, this.setState를 사용하지 않는다. useState는 변수와 변수를 업데이트하기 위한 함수를 정의한다. useEffectcomponentDidMount, componentDidUpdate를 합쳐놓은 느낌. componentDidUpdate와 동일하게 는 모든 변화에 대해 업데이트 하기 때문에 모니터 조건이 필요하다. useEffect 역시 모니터 조건이 반드시 필요하다. (옵션) 조건식으로 쓸 변수들을 Array로 작성시킨다. 1234567891011useEffect(() =&gt; &#123; console.log(count);&#125;) // 기본 : 모든 업데이트에 대해 변화를 감지한다. ( 반드시 조건식을 작성해야만 한다. )useEffect(() =&gt; &#123; console.log(count);&#125;, [count]) // 조건쓸 변수를 배열에 작성 : [count] 요소의 변화가 있을 경우에만 감지.useEffect(() =&gt; &#123; console.log(count);&#125;, []) // 빈 배열 : 빈배열로 작성 시 단 한번만 실행된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 09","slug":"react-study-09","date":"2019-12-23T14:12:17.000Z","updated":"2019-12-23T14:14:11.480Z","comments":true,"path":"2019/12/23/react-study-09/","link":"","permalink":"https://hyeok999.github.io/2019/12/23/react-study-09/","excerpt":"","text":"React Study 09 여러 데이터를 담을 변수의 타입 결정 : 객체 선언 vs 배열 선언 defaultValue와 Value YouTube 프로젝트 변경점 &lt;SearchBar&gt; 태그 URL로 쿼리를 변경하는 방식으로 바꾸기. ComponentDidUpdate 설정 getYoutubeData 함수 → 클래스필드 변수로 변경 getYoutubeData 함수 변경( _getYoutubeData ) 및 복제하기 용어 - ( 러버덕 ) defaultValue Value ComponentDidUpdate 여러 데이터를 담을 변수의 타입 결정 : 객체 선언 vs 배열 선언사용. 데이터가 고유한 값이 많다면 객체 사용이 편리하다. 중복을 허용되는 데이터는 ‘배열’ -&gt; Array.find 로 찾아야한다. update 또한 추가로해야한다. 소스가 매우 길어진다. 중복을 방지하고 싶은 데이터는 ‘객체’ defaultValue와 Value YouTube 프로젝트 변경점&lt;SearchBar&gt; 태그 URL로 쿼리를 변경하는 방식으로 바꾸기. Redux Store에 쿼리를 저장하고 독립적으로 분리한 VideoPlayer 컴포넌트에게 쿼리를 넘겨주기 위해서. 123456/* &lt;SearchBar onSearchVideos=&#123;debounce(this.getYoutubeData, 500)&#125; /&gt; */&lt;SearchBar onSearchVideos=&#123;e =&gt; &#123; this.props.history.push(`/results?search_query=$&#123;e.target.value&#125;`) &#125;&#125; ComponentDidUpdate 설정리액트에서 지원하는 라이프사이클 중 하나로, 비동기 함수다. URL이 실시간으로 바뀌거나, Props, State값등이 하나라도 바뀔경우 ComponetDidUpdate함수를 호출한다. prevProps, prevState 는 각각 현재 바뀐값 직전의 값을 나타내고 있다. 이 함수는 &lt;SearchBar&gt;태그의 onChange떄문에 사용하는 것이기 때문에 해당 함수를 쓰지 않고 클릭이나 엔터만을 이용할 경우 ComponentDidUpdate를 정의해줄 필요가 없다. 12345678910111213// this에 props 값, this에 state 값이 하나라도 바뀔경우 실행된다. // prevProps가 변경되기 props 값 , prevState는 변경되기 이전 state 값 componentDidUpdate(prevProps, prevState) &#123; const &#123; props &#125; = this; // props는 최신값, 따라서 방어코드를 작성한다. if ( props.location ) &#123; const &#123; search_query &#125; = qs.parse(props.location.search) const &#123; search_query : prev &#125; = qs.parse(prevProps.location.search) if( search_query !== prev ) &#123; // 중요한 방어코드 this.getYoutubeData(search_query || '') // undefined가 나올경우 ''을 띄운다. &#125; &#125; &#125; search_query !== prev는 정말로 중요한 방어코드다. 해당 코드는 해당 함수가 실행되면서 변경된 많은 변경점 중에 오직 쿼리값만의 변경유무를 체크한다. 만약 변경 사항이 없다면 셀 수 없이 많은 코드가 실행되어 버리므로, 업데이트가 되어지는 변수에 대해서만 실행하고자 하는 로직을 명확하게 코딩해야 한다. ( 수많은 API를 요청해버리는 사태가 벌어질 수 있다. ) getYoutubeData 함수 → 클래스필드 변수로 변경 &lt;SearchBar&gt; 태그에서 getYoutubeData함수가 아닌 URL에 쿼리를 변경하는 방식으로 바꾸었기 때문. 변경전 123456789101112131415161718192021222324252627getYoutubeData(query)&#123; // async getYoutubeData(query) &#123; if (isChanged) &#123; this.setState(this.defaultState); &#125; try &#123; const &#123; nextPageToken &#125; = this.state; const params = &#123; key: process.env.REACT_APP_YOUTUBE_API_KEY, q: query, part: \"snippet\", maxResults: 10, pageToken: nextPageToken &#125;; const &#123; data &#125; = await axios.get( `https://www.googleapis.com/youtube/v3/search`, &#123; params &#125; ); this.setState(&#123; videos: [...this.state.videos, ...data.items], nextPageToken: data.nextPageToken &#125;); &#125; catch (e) &#123;&#125;&#125; 변경후 URL 형식으로 바뀌면서 URL 쿼리를 Redux Store에 추가해주어야만 하기 때문에 맨 아래에 this.props.updateQuery(query); 구문을 추가 해주었다. 또한 debounce함수를 이제는 &lt;SearchBar&gt; 태그에서 getYoutubeData함수에 걸어주는게 아니므로 클래스필드로 변경하고 함수에 debounce와 함수내부에 async키워드를 사용한다. 12345678910111213141516171819202122232425262728getYoutubeData = debounce(async (query) =&gt; &#123; if (this.props.query !== query) &#123; this.setState(this.defaultState); &#125; try &#123; const &#123; nextPageToken &#125; = this.state; const params = &#123; key: process.env.REACT_APP_YOUTUBE_API_KEY, q: query, part: \"snippet\", maxResults: 10, pageToken: nextPageToken &#125;; const &#123; data &#125; = await axios.get( `https://www.googleapis.com/youtube/v3/search`, &#123; params &#125; ); this.setState(&#123; videos: [...this.state.videos, ...data.items], nextPageToken: data.nextPageToken &#125;); &#125; catch (e) &#123;&#125; this.props.updateQuery(query); // 추가 &#125;, 550 ); ####getYoutubeData 함수 변경( _getYoutubeData ) 및 복제하기 위와 같이 작성될 경우 문제가 사용자가 입력하는 시간이 debounce함수로 인해 매우 지연되게 보인다는 것이다. 이는 사용자가 어플리케이션을 사용을 안하게되버리는 요인이 될 수 있기 때문에 고쳐준다. 고치는 방법은 함수를 2분할 하는 것이다. getYoutubeData -&gt; _getYoutubeData 로 변경하고 인자에 isChanged를 추가한다. 12345678910111213141516171819202122232425262728_getYoutubeData = debounce(async (query, isChanged) =&gt; &#123; if (isChanged) &#123; this.setState(this.defaultState); &#125; // 수정 try &#123; const &#123; nextPageToken &#125; = this.state; const params = &#123; key: process.env.REACT_APP_YOUTUBE_API_KEY, q: query, part: \"snippet\", maxResults: 10, pageToken: nextPageToken &#125;; const &#123; data &#125; = await axios.get( `https://www.googleapis.com/youtube/v3/search`, &#123; params &#125; ); this.setState(&#123; videos: [...this.state.videos, ...data.items], nextPageToken: data.nextPageToken &#125;); &#125; catch (e) &#123;&#125; //this.props.updateQuery(query); // 삭제 &#125;, 550 ); this.props.updateQuery(query);도 삭제한다. 추가 함수 추가로 _getYoutubeData함수를 호출하는 getYoutubeData함수를 추가해준다. 12345678getYoutubeData(query) &#123; let isChanged = false; if(this.props.query !== query) &#123; isChanged = true; this.props.updateQuery(query); &#125; this._getYoutubeData(query, isChanged); &#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"이벤트 처리하기","slug":"react-official-05","date":"2019-12-21T10:08:46.000Z","updated":"2019-12-29T16:48:51.952Z","comments":true,"path":"2019/12/21/react-official-05/","link":"","permalink":"https://hyeok999.github.io/2019/12/21/react-official-05/","excerpt":"","text":"React Official Document주요개념 : 이벤트 처리하기 React 이벤트 문법 기본동작 방지 ( preventDefault ) 이벤트 리스너 예제 : Toggle 컴포넌트 만들기 React this constructor 내부에서 this 바인딩 public class field 문법 콜백에 화살표 함수 사용 constructor 내부에서 this 바인딩 편리하게 사용하기 이벤트 핸들러에 인자 전달하기 React Official Document주요개념#5. 이벤트 처리하기 React 앨리먼트에서 이벤트를 처리하는 방식은 DOM 엘리먼트에서 이벤트를 처리하는 방식과 유사하다. 몇 가지 문법차이를 설명한다. React 이벤트 문법 React의 이벤트는 소문자 대신 대문자로 시작하는 카멜 케이스(camelCase)를 이용한다. (이벤트-카멜, 컴포넌트명-파스칼) JSX를 사용하여 문자열이 아닌 함수로 이벤트 핸들러를 전달한다. 123456789// JavaScript&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt;// React&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; 기본동작 방지 ( preventDefault ) React에서는 false를 반환해도 기본 동작을 방지할 수 없다. 반드시 preventDefault를 명시적으로 호출해야 한다. 123456789101112131415161718// 일반 HTML에서는 새 페이지를 여는 링크의 기본 동작을 방지하기 위해 다음과 같은 코드를 작성한다.&lt;a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\"&gt; Click me&lt;/a&gt;// React에서는 다음과 같이 작성function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log('The link was clicked.'); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; 이벤트 리스너 React를 사용할 때 DOM 엘리먼트가 생성된 후 리스너를 추가하기 위해 addEventListener를 호출할 필요가 없다. 단, 엘리먼트가 처음 렌더링될 때 리스너를 제공하면 된다. ES6 클래스를 사용하여 컴포넌트를 정의할 때, 일반적인 패턴은 이벤트 핸들러를 클래스의 메서드로 만드는 것이다. 예를 들어, 다음 Toggle 예제 컴포넌트는 사용자가 “ON”과 “OFF” 상태를 토글 할 수 있는 버튼을 렌더링한다. 예제 : Toggle 컴포넌트 만들기 12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 콜백에서 `this`가 작동하려면 아래와 같이 바인딩 해주어야 한다. this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(state =&gt; (&#123; isToggleOn: !state.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); React thisJSX 내부의 this는 JavaScript에서 클래스 머세더처럼 기본 바인딩이 되어 있지 않다. 따라서 이벤트 전달을 위해서는 this를 반드시 바인딩 해주어야만 한다. 위 토글 예제에서는 this.handleClick을 바인딩하지 않고 onClick을 사용한다면 undefinde를 표시한다. undefined 를 피하는 방법은 대표적으로 3가지가 존재한다. constructor 내부에서 this 바인딩 123456constructor(props) &#123; super(props); // 콜백에서 `this`가 작동하려면 아래와 같이 바인딩 해주어야 한다. this.handleClick = this.handleClick.bind(this);&#125; public class field 문법 123456class LoggingButton extends React.Component &#123; // 이 문법은 `this`가 handleClick 내에서 바인딩되도록 한다. // 주의: 이 문법은 *실험적인* 문법. handleClick = () =&gt; &#123; console.log('this is:', this); &#125; 콜백에 화살표 함수 사용 1234567891011121314class LoggingButton extends React.Component &#123; handleClick() &#123; console.log('this is:', this); &#125; render() &#123; // 이 문법은 `this`가 handleClick 내에서 바인딩되도록 한다. return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; 3가지다 전부 작동되는 문법이다. 3번째 문법( 콜백에 화살표 함수 사용 )의 경우에는 LoggingButton이 렌더링될 떄마다 다른 콜백이 생성된다는 것인데, 보통의 경우 문제가 없으나 콜백이 하위 컴포넌트에 props로 전달된다면 그 컴포넌트들은 추가로 다시 렌더링을 수행할 수도 있다. 이러한 문제를 피하고 싶다면 1번째(constructor 내부에서 this 바인딩) 와 2번째 (public class field 문법) 를 주로 이용한다. constructor 내부에서 this 바인딩 편리하게 사용하기 1234constructor(props) &#123; super(props) Object.getOwnPropertyNames(App.prototype).forEach(key =&gt; this[key] = this[key].bind(this))&#125; Object.getOwnPropertyNames(App.prototype).forEach(key =&gt; this[key] = this[key].bind(this)) Object.getOwnPropetyNames(App.prototype)은 App.prototype에 존재하는 모든 프로퍼티 명(key)을 모아서 하나의 배열을 반환한다. 1234567var a = &#123; a : 1, b : 2, c : 3, d : 4&#125;Object.getOwnPropertyNames(a); // ['a','b','c','d'] 그 후 해당 배열을 forEach 고차함수를 사용해 순회를 돌리고 각각의 키를 각각 바인드 시킨다. 위 코드를 통해서 명시적으로 다음처럼 하나하나 이벤트 바인딩을 하지 않아도 된다. 12345678// 개별적인 constructor 바인딩constructor(props) &#123; super(props) this.add = this.add.bind(this) this.minus = this.minus.bind(this) this.click = this.click.bind(this) this.gogo = this.gogo.bind(this)&#125; 12345// 위처럼 바인딩을 하나하나 해주지 않아도 된다.constructor(props) &#123; super(props) Object.getOwnPropertyNames(App.prototype).forEach(key =&gt; this[key] = this[key].bind(this))&#125; 이벤트 핸들러에 인자 전달하기 루프 내부에서는 이벤트 핸들러에 추가적인 매개변수를 전달하는 것이 일반적이다. 예를들면 id가 행의 ID일 경우 다음 코드가 모두 작동된다. 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 두 경우 모두 React 이벤트를 나타내는 e 인자가 ID 뒤에 두 번째 인자로 전달된다. 화살표 함수를 사용하면 명시적으로 인자를 전달해야 하지만 bind를 사용할 경우 추가 인자가 자동으로 전달된다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"daily_algorithm61","slug":"daily-algorithm61","date":"2019-12-21T10:05:19.000Z","updated":"2019-12-21T10:06:54.586Z","comments":true,"path":"2019/12/21/daily-algorithm61/","link":"","permalink":"https://hyeok999.github.io/2019/12/21/daily-algorithm61/","excerpt":"","text":"핸드폰 번호 가리기문제 설명프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다.전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요. 제한 조건 s는 길이 4 이상, 20이하인 문자열입니다. 입출력 예 phone_number return 01033334444 ***4444 027778888 *****8888 12345678910111213function solution(phone_number) &#123; let answer = ''; for (let i = 0; i &lt; phone_number.length - 4; i++) &#123; answer += '*'; &#125; for (let i = phone_number.length - 4; i &lt; phone_number.length; i++) &#123; answer += phone_number[i]; &#125; console.log(answer); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"State and Lifecycle","slug":"react-official-04","date":"2019-12-20T08:44:58.000Z","updated":"2019-12-29T16:48:40.626Z","comments":true,"path":"2019/12/20/react-official-04/","link":"","permalink":"https://hyeok999.github.io/2019/12/20/react-official-04/","excerpt":"","text":"React Official Document주요개념 : State and Lifecycle 함수에서 클래스로 변환하기 클래스에 지역 State 추가하기 생명주기 메서드를 클래스에 추가하기 componentDidMount() 메서드 구현 componentWillUnmount() 메서드 구현 tick() 함수 구현 호출 순서 요약 State 올바르게 사용하기 직접 State를 수정하지 않는다. State 업데이트는 비동기적 일 수도 있다. State 업데이트는 병합된다. 데이터는 아래로 흐른다. React Official Document주요개념#4. State and Lifecycle ‘#2 엘리먼트 렌더링’ 에서는 UI를 업데이트하는 한 가지 방법만 배웠으며, 렌더링 된 출력값을 변경하기 위해 ReactDOM.render()를 호출했다. 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); 이번에는 Clcok이라는 이름으로 컴포넌트를 만들어 사용하고 재사용,캡슐화를 해볼 것이다. 또한 이 컴포넌트는 매번 render를 해주는게 아니라 스스로 타이머를 설정하고 업데이트 하도록 한다. 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clcok date=&#123;new Date()&#125; /&gt;, document.getElementById('root') );&#125;setInterval(tick, 1000); 위 처럼 사용할 경우, 컴포넌트화는 한게 맞지만 결론적으로는 tick 함수가 1초마다 실행이 되어 render로 게속한는 것에는 변함이 없다. 따라서 Clock 컴포넌트가 타이머를 설정하고 매초 UI 업데이트하는 것이 Clock의 구현 세부사항이 되야만 한다. 이상적으로 한 번만 코드를 작성하고 Clock이 스스로 업데이트하도록 만들기 위해서 ‘state’를 추가해야만 한다. State는 props와 유사하지만, 비공개이고 컴포넌트에 의하여 완전히 제어된다. 함수에서 클래스로 변환하기 먼저 5단계로 Clock 과 같은 함수 컴포넌트를 클래스로 변환한다. React.Component를 확장하는 동일한 이름의 ES6 class를 생성. render()라고 불리는 빈 메서드를 추가. 함수의 내용을 render() 메서드 안으로 옮긴다. render() 내용 안에 있는 props를 this.props로 변경. 남아있는 빈 함수 선언을 삭제. 12345678910class Clock extends React.Component&#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; render 메서드는 업데이트가 발생할 때마다 호출되지만, 같은 DOM 노드로 &lt;Clock /&gt;을 렌더링하는 경우 Clock 클래스의 단일 인스턴스만 사용된다. 이것은 지역 state 와 생명주기 메서드와 같은 부가적인 기능을 사용할 수 있게 해준다. 클래스에 지역 State 추가하기 세 단계에 걸쳐서 date를 props에서 state로 이동해본다. render() 메서드 안에 있는 this.props.date를 this.state.date로 변경. constructor 함수를 추가하고 super 설정, 초기 this를 설정한다. &lt;Clcok /&gt;요소에서 date prop을 삭제한다. 12345678910111213141516171819202122class Clock extends React.Component&#123; &#123;/* 2번 */&#125; constructor(props) &#123; super(props); this.state = &#123;data: new Data()&#125;; &#125; &#123;/* 1번 */&#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clcok/&gt;, &#123;/* 3번 */&#125; document.getElementById('root')); 생명주기 메서드를 클래스에 추가하기 많은 컴포넌트가 있는 애플리케이션에서 컴포넌트가 삭제될 때 해당 컴포넌트가 사용 중이던 리소스를 확보하는 것이 중요하다. Clock 컴포넌트가 처음 DOM에 렌더링 될 때마다 타이머를 설정하려고 한다. 이것을 React에서는 ‘마운팅’ 이라 칭한다. 반대로 Clcok에 의해서 생성된 DOM이 삭제될 때마다 타이머를 해체해야 한다. 이것을 React에서는 ‘언마운팅’ 이라 칭한다. 이러한 시점을 정의해놓은 메서드들을 ‘생명주기 메서드’ 라고 부른다. 두 작업은 각각 componentDidMound() , componentWillUnmount() 메서드를 이용한다. 마지막으로 상태 변화를 반영하기 위한 tick()메서드를 구현한다. 123456789101112131415161718192021222324252627class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; &#123;/* 1. componentDidMount() 메서드 구현 */&#125; &#125; componentWillUnmount() &#123; &#123;/* 2. componentDidMount() 메서드 구현 */&#125; &#125; tick() &#123; &#123;/* 3. tick() 메서드 구현 */&#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; 1. componentDidMount() 메서드 구현 123456componentDidMount() this.timerID = setInterval( () =&gt; this.tick(), 1000 );&#125; componentDidMount() 메서드는render() 호출이 된 후에 실행된다. this (this.timerID)에서 어떻게 타이머 ID를 제대로 저장하는지 주의해야 한다. timer ID의 경우 데이터 흐름에는 포함되지 않지만 따로 setInterval을 통해 변화되는 값을 보관해야만 한다. 따라서 수동으로 부가적인 필드를 클래스에 추가한다. 2. componentWillUnmount() 메서드 구현 Clock 컴포넌트가 DOM으로부터 한 번이라도 삭제될 경우 타이머를 멈추기 위해 구현한다. 123componentWillUnmount() &#123; clearInterval(this.timerID);&#125; setInterval를 해제시킴. 3. tick() 함수 구현 Component가 매초 작동하도록 tick 메서드를 구현한다. 컴포넌트 지역 state를 업데이트하기 위해 this.setState()를 사용한다. 12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); 호출 순서 요약 &lt;Clock /&gt;가 ReactDOM.render()로 전달되었을 때 React는 Clock 컴포넌트의 constructor를 호출한다. Clock이 현재 시각을 표시해야 하기 때문에 현재 시각이 포함된 객체로 this.state를 초기화한다. React는 Clock 컴포넌트의 render() 메서드를 호출한다. 이를 통해 React는 화면에 표시되어야 할 내용을 알게 된다. 그 다음 React는 Clock의 렌더링 출력값을 일치시키기 위해 DOM을 업데이트한다. Clock 출력값이 DOM에 삽입되면, React는 componentDidMount() 생명주기 메서드를 호출한다. 그 안에서 Clock 컴포넌트는 매초 컴포넌트의 tick() 메서드를 호출하기 위한 타이머를 설정하도록 브라우저에 요청한다. 매초 브라우저가 tick() 메서드를 호출한다. 그 안에서 Clock 컴포넌트는 setState()에 현재 시각을 포함하는 객체를 호출하면서 UI 업데이트를 진행한다. setState() 호출 덕분에 React는 state가 변경된 것을 인지하고 화면에 표시될 내용을 알아내기 위해 render() 메서드를 다시 호출한다. 이 때 render() 메서드 안의 this.state.date가 달라지고 렌더링 출력값은 업데이트된 시각을 포함한다. React는 이에 따라 DOM을 업데이트한다. Clock 컴포넌트가 DOM으로부터 한 번이라도 삭제된 적이 있다면 React는 타이머를 멈추기 위해 componentWillUnmount() 생명주기 메서드를 호출한다. State 올바르게 사용하기setState()의 3가지 규칙 직접 State를 수정하지 않는다.state에 직접적으로 값을 줄 경우 컴포넌트를 다싯 렌더링 하지 않는다. setState()를 이용해야만 한다. 1234// Wrongthis.state.comment = 'Hello';// Correctthis.setState(&#123;comment: 'Hello'&#125;); this.state를 지정할 수 있는 유일한 공간은 바로 constructor이다. State 업데이트는 비동기적 일 수도 있다.React는 성능을 위해 여러 setState() 호출을 단일 업데이트로 한꺼번에 처리할 수 있다. this.props와 this.state가 비동기적으로 업데이트될 수 있기 때문에 다음 state를 계산할 때 해당 값에 의존해서는 안 된다. 예를 들어, 다음 코드는 카운터 업데이트에 실패할 수 있다. 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 이를 수정하기 위해 객체보다는 함수를 인자로 사용하는 다른 형태의 setState()를 사용한다. 그 함수는 이전 state를 첫 번째 인자로 받아들일 것이고, 업데이트가 적용된 시점의 props를 두 번째 인자로 받아들인다. 1234// Correctthis.setState((state, props) =&gt; (&#123; counter: state.counter + props.increment&#125;)); 위에서는 화살표 함수를 사용했지만, 일반적인 함수에서도 정상적으로 작동합니다. 123456// Correctthis.setState(function(state, props) &#123; return &#123; counter: state.counter + props.increment &#125;;&#125;); State 업데이트는 병합된다.setState()를 호출할 때 React는 제공한 객체를 현재 state로 병합한다. 예를 들어, state는 다양한 독립적인 변수를 포함할 수 있다. 1234567constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; 별도의 setState() 호출로 이러한 변수를 독립적으로 업데이트할 수 있다. 12345678910111213componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;);&#125; 병합은 얕게 이루어지기 때문에 this.setState({comments})는 this.state.posts에 영향을 주진 않지만 this.state.comments는 완전히 대체된다.( posts도 반대로 같다. ) 데이터는 아래로 흐른다. 부모 컴포넌트나 자식 컴포넌트 모두 특정 컴포넌트가 유상태인지 또는 무상태인지 알 수 없고, 그들이 함수나 클래스로 정의되었는지에 대해서 관심을 가질 필요가 없다. 이 때문에 state는 종종 지역 또는 캡슐화라고 불린다. state가 소유하고 설정한 컴포넌트 이외에는 어떠한 컴포넌트에도 접근할 수 없다. 컴포넌트는 자신의 state를 자식 컴포넌트에 props로 전달할 수 있다. 1&lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; 사용자 정의된 컴포넌트에도 적용 가능하다. 1&lt;FormattedDate date=&#123;this.state.date&#125; /&gt; FormattedDate 컴포넌트는 date를 자신의 props로 받을 것이고 이것이 Clock의 state로부터 왔는지, Clock의 props에서 왔는지, 수동으로 입력한 것인지 알지 못한다. 123function FormattedDate(props) &#123; return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;&#125; 일반적으로 이를 “하향식(top-down)” 또는 “단방향식” 데이터 흐름이라고 칭한다. 모든 state는 항상 특정한 컴포넌트가 소유하고 있으며 그 state로부터 파생된 UI 또는 데이터는 오직 트리구조에서 자신의 “아래”에 있는 컴포넌트에만 영향을 미친다. 트리구조가 props들의 폭포라고 상상하면 각 컴포넌트의 state는 임의의 점에서 만나지만 동시에 아래로 흐르는 부가적인 수원(water source)이라고 할 수 있다. 모든 컴포넌트가 완전히 독립적이라는 것을 보여주기 위해 App 렌더링하는 세 개의 &lt;Clock /&gt;을 만들었다. 1234567891011121314function App() &#123; return ( &lt;div&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 각 Clock은 자신만의 타이머를 설정하고 독립적으로 업데이트 한다. React 앱에서 컴포넌트가 유상태 또는 무상태에 대한 것은 시간이 지남에 따라 변경될 수 있는 구현 세부 사항으로 간주한다. 유상태 컴포넌트 안에서 무상태 컴포넌트를 사용할 수 있으며, 그 반대 경우도 마찬가지로 사용할 수 있다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"daily_algorithm60","slug":"daily-algorithm60","date":"2019-12-20T08:41:16.000Z","updated":"2019-12-20T08:43:41.224Z","comments":true,"path":"2019/12/20/daily-algorithm60/","link":"","permalink":"https://hyeok999.github.io/2019/12/20/daily-algorithm60/","excerpt":"","text":"하샤드 수문제 설명양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요. 제한 조건 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 arr return 10 true 12 true 11 false 13 false 입출력 예 설명입출력 예 #110의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다. 입출력 예 #212의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다. 입출력 예 #311의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다. 입출력 예 #413의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다. 12345678910function solution(n) &#123; const NUMBER = String(n); let result = 0; for (let i = 0; i &lt; NUMBER.length; i++) &#123; result += +NUMBER[i]; &#125; return NUMBER % result === 0;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"React 스터디 08","slug":"react-study-08","date":"2019-12-19T05:22:38.000Z","updated":"2019-12-19T10:37:57.055Z","comments":true,"path":"2019/12/19/react-study-08/","link":"","permalink":"https://hyeok999.github.io/2019/12/19/react-study-08/","excerpt":"","text":"React Study 08 React에서 input 태그 value 와 defaultvalue 차이 Redux 리덕스 사용 이유 카운터 실습 폴더 구조 Actions 설정 src/actions/index.js reducers 설정 카운터 리듀서 설정하기 src/reducers/counter.js reducers 합치기 src/reducers/index.js App.js 설정 Counter.js 컴포넌트 구현 function mapStateToProps(state) function mapDispatchToProps(dispatch) connect(mapStateToProps, mapDispatchToProps)(Counter) HOC 정리 실행 순서 Redux Dev Tools 용어 - ( 러버덕 ) Redux Actions Reducers Provider mapStateToProps(state) mapDispatchToProps(dispatch) HOC Redux Dev Tools React에서 input 태그 value 와 defaultvalue 차이기본 html에서 &lt;input id=&#39;test&#39; value=&#39;hello&#39;&gt; 라고 정의 했을 때, 여기에 ‘bye’라고 입력하여 value 값을 변경했다고 가정하자. 1234// input 값을 hello -&gt; bye 로 변환시var test = document.querySelector('#test');test.value // byetest.getAttribute('value'); // hello test.getAttribute(&#39;value&#39;);를 찍었을 경우 초기값 hello가 나오게 된다. 반면에 리액트에서는 다음과 같은 상태를 유지한다. value : 항상 최신의 값 defaultValue : 변경되기 전 최초의 값 Redux리덕스 사용 이유컴포넌트 간의 데이터 교환의 필요성이 생김. 따라서 리덕스라는 독립되어 있는 저장소(Redux)를 사용하기 위함. 리덕스는 순수함수를 지향하기 때문에 Reducer라는 함수를 통해 순수함수를 유지하고자 함. 스프레드 문법을 사용하여 기존의 상태를 유지한다. 카운터 실습폴더구조 Actions 설정 은행으로 가정했을 경우 입금명세표 등 할 일을 적어놓는 역할을 하는 Actions을 작성한다. App.js에서 실제로 사용하는 것은 리듀서가 아닌 리액트이다. src/actions/index.js1234567// 리듀서에서 사용하기 위함.export const ADD = 'ADD';// 함수자체는 Action Creator, 실제로 사용하는 건 reducer가 아니라 특정 컴포넌트다. (예제 : counter)export function add(val) &#123; return (&#123; type : ADD, val &#125;) // &#123; type ~~~~~~ &#125;가 Action.&#125; export const ADD = &#39;ADD&#39;;는 Reducer에서 사용하기 위함이다. 이와같이 따로 export를 해두고 정의를 해주는 이유는 유지보수를 편하게 하기 위함이다. 예를들어 ADD 가 변경될 경우 모든 곳에서 변경한다면 정말로 불편할 것이다. 따라서 action에서 정의만 바꿔주면 쉽게 유지보수할 수 있다. reducers 설정 은행으로 가정했을 경우 Actions(입금 명세표)를 받아 일을 처리할 은행직원인 Reducers를 작성한다. 카운터 리듀서 설정하기src/reducers/counter.js본격적으로 액션을 받아 데이터를 처리하는 카운팅 리듀서를 설정한다. 1234567891011121314151617import &#123; ADD &#125; from '../actions' // 액션을 받아옴.const INITIAL_STATE = &#123; count: 0, // 초기값&#125;export default function counter(state = INITIAL_STATE, action) &#123; switch(action.type) &#123; case ADD : return &#123; ...state, count: state.count + action.val &#125; default: return state; &#125;&#125; 특정 컴포넌트에서 dispatch 를 보내 받을 카운터 리듀서를 설정한다. reducers 합치기src/reducers/index.jsReducers를 통합적으로 사용하기 위해 하나의 리듀서로 묶어서 사용한다. 즉, 통합된 리듀서들을 export해주기 위함이다. Reducers마다 불러내는 것을 방지하기 위해서 사용한다. 123456789import &#123; combineReducers &#125; from 'redux'import counter from './counter'// import video from './video'// 리듀서가 통합된다.export default combineReducers(&#123; counter, // 리듀서명&#125;) combineReducers은 redux에서 제공된다. 리듀서들을 모아 하나의 리듀서로 통합시킨다. App.js 설정12345678910111213141516import React from 'react';import &#123; Provider &#125; from 'react-redux';import &#123; createStore &#125; from 'redux';import reducers from './reducers';import Counter from './Counter';function App() &#123; return ( &lt;Provider store=&#123;createStore(reducers, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__())&#125;&gt; &lt;Counter /&gt; &lt;/Provider&gt; );&#125;export default App; 우선 Redux를 사용하기 앞서 Redux를 사용하기 위해 명시를 해주어야 한다. import { Provider } from &#39;react-redux&#39;;import { createStore } from &#39;redux&#39;; Provider는 하위 컴포넌트에게 Redux의 단일 저장소 store와 dispatch를 사용할 수 있게 해주는 react-redux라이브러리의 모듈이다. 그리고 redux에서 제공하는 createStore함수를 통해 단일 저장소(Store)를 만들고 Store에 접근하기 위한 리듀서를 명시해준다. (은행으로 치면 통장개설) 1234createStore( 리듀서명, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()) 2번째 인자는 크롬 개발자도구의 Redux Dev Tools를 사용하기 위해 반드시 넣어줘야 한다. 리듀서 명은 위에서 설정한 합쳐놓은 리듀서를 import하면 된다. ( 다른 리듀서를 해도 되지만, 유지보수가 힘듬 ) 통합된 리듀서는 다음과 같이 import한다. import reducers from &#39;./reducers&#39;; reducers는 폴더명 이므로 자동으로 index.js를 가지고 온다. 마지막으로 실제로 구현할 Counter.js를 import하고 &lt;Provider&gt;태그 사이에 넣는다. Counter.js 컴포넌트 구현12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from 'react';import &#123; connect &#125; from 'react-redux';import &#123; bindActionCreators&#125; from 'redux';import &#123; add &#125; from './actions'const Counter = (props) =&gt; &#123; return ( &lt;div&gt; &#123;/* &lt;button onClick=&#123;() =&gt; props.dispatch.add(1)&#125;&gt; + &lt;/button&gt; */&#125; &#123;/* 위와 같이 적을 필요가 없다. 밑에서 함수로 props에게 전달해주었기 때문 */&#125; &lt;button onClick=&#123;() =&gt; props.add(1)&#125;&gt; + &lt;/button&gt; &#123; props.count &#125; &lt;button onClick=&#123;() =&gt; props.add(-1)&#125;&gt; - &lt;/button&gt; &lt;/div&gt; );&#125;// 리덕스에 접근하기 위해서 사용한다.// 리덕스 안에 있는 데이터를 Props로 맵핑해주는 함수.// state는 Provider가 내려줌.function mapStateToProps(state) &#123; return &#123; // state.리듀서명.해당변수 // state : 리덕스의 state , counter : 리듀서(은행직원 이름), count : 변수 count : state.counter.count // 여기서 선언한 count는 위에 있는 props.count와 동일해야한다. // 즉, countaa = state.counter.count = props.countaa &#125;&#125;// dispatch는 Provider가 내려줌.// 리덕스의 dispatch는 원래 액션이 리듀서에게// 전달하기 위해 store.dispatch(&#123;type: ~~~~&#125;)라고 적어야하는데// 이 과정이 불편하기 때문에// 리액트에서 편리하게 디스패치를 실행하는것처럼 보여주는 함수.function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; // bindActionCreators : 액션크리에이터를 여기에 나열해준다. // ++ actions의 add함수가 여기에 바인딩 되어야한다. add &#125;, dispatch)&#125;// 순서중요 connect(mapStateToProps, mapDispatchToProps)(상태 전달 컴포넌트)export default connect(mapStateToProps, mapDispatchToProps)(Counter); 리액트의 컴포넌트는 기본적으로 하위 컴포넌트들에게 props 외에는 다른 것을 전달해줄 수 없다. 따라서, 특정 방법을 이용해 상위 컴포넌트로부터 props 외의 데이터를 받아먄한다. App.js에서 설정했던 &lt;Provider&gt;는 하위 컴포넌트에게 dispatch 와 state(단일 - 복합리듀서)를 전달 해준다. 2개의 데이터를 전달 받아 사용하려면 아래처럼 2개의 함수를 정의하도록 하자. (커스텀이지만 기본적으로 이렇게 쓰인다.) function mapStateToProps(state)→ Provider, Redux의 스토어에 저장되어있는 상태들, 프로퍼티를 컴포넌트의 props로 전달해주기 위한 함수. 123456789function mapStateToProps(state) &#123; return &#123; // state.리듀서명.해당변수 // state : 리덕스의 state , counter : 리듀서(은행직원 이름), count : 변수 count : state.counter.count // 여기서 선언한 count는 위에 있는 props.count와 동일해야한다. // 즉, countaa 는 state.counter.count = props.countaa &#125;&#125; function mapDispatchToProps(dispatch)→ Provider, Redux에서 사용되는 Action(상태를 변화시키기 위한 명세-함수)를 컴포넌트의 props로 전달해주기 위한 함수 → 리액트에서 편리하게 dispatch 할 수 있도록 지원해주는 함수다. (원래는 store.dispatch~~) → bindActionCreators({ 액션크레이어터명 }, dispatch) 해당 액션크리에이터를 dispatch를 통해 리듀서에게 넘겨준다. 1234567// 리덕스의 dispatch는 원래 액션이 리듀서에게 전달하기 위해 store.dispatch(&#123;type: ~~~~&#125;)라고 적어야하는데 이 과정이 불편하기 때문에 리액트에서 편리하게 디스패치를 실행하는것처럼 보여주는 함수.function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; // bindActionCreators : 액션 크리에이터를 여기에 나열해준다. // ++ actions의 add함수가 여기에 바인딩 되어야한다. add &#125;, dispatch)&#125; // dispatch는 Provider가 내려주었다. connect(mapStateToProps, mapDispatchToProps)(Counter)위 2개의 함수 를 connect()에 인자로 차례대로 정의하면 props에 state 와 dispatch로 내린 함수(add)를 가질수 있게 된다. 즉, connect함수 최초 실행 시 두 인자를 통해 리턴된 결과물로 Counter를 실행시켜 최종값을 리턴한다. 12// 순서중요 connect(mapStateToProps, mapDispatchToProps)(상태 전달 컴포넌트)export default connect(mapStateToProps, mapDispatchToProps)(Counter); 위와 같이 작성이 완료되고 npm start 를 해보면 작동이 될 것이다. HOC위 connect() 함수가 어색하게 느껴질 수 있다. 이는 HOC에 대한 이해가 필요하다. 이러한 느낌이다. 1234567891011// HOCconst getDiscount = rate =&gt; price =&gt; (1 - rate) * price;getDiscount(0.1)(1000);const getDistcount = function (rate) &#123; return function (price) &#123; return (1 - rate) * price &#125;&#125;// 첫 리턴은 rate를 받아 price =&gt; (1 - 0.1) * price을 실행한다.// 2번째 리턴에서 price에 1000 이므로 리턴되는 값은 (1 - 0.1) * 1000 정리&lt;Provider store=&#39;store={createStore(reducers)&#39;&gt;하는 역할 Redux의 단일 저장소(store)를 정의한다. (은행 통장을 개설한다.) 하위 컴포넌트에게 dispatch , state(reducers에서 combineReducers로 합쳐진 단일 state)를 뿌려준다. function mapDispatchToProps(dispatch) 리덕스의 dispatch는 원래 액션이 리듀서에게 전달하기 위해서는 store.dispatch({type: ~~~~})라고 적어야하는데 이 과정이 불편하기 때문에 리액트에서 편리하게 디스패치를 실행하는것처럼 보여주는 함수. bindActionCreators() 와 같이 사용되며 액션크리에이터를 이 함수 내부에 작성한다. connect() 의 2번쨰 인자로 사용한다. props에서 bindActionCreators() 에 적혀진 함수를 사용하게 해준다. function mapStateToProps(state) Redux저장소에 저장된 값을 반환하여 props에서 사용하게끔 도와주는 함수. connect() 의 1번쨰 인자로 사용한다. 복합 리듀서에서 정의한 리듀서의 내부에서 사용되는 값을 명시해주면 된다. count : state.counter.count state : 리덕스의 state , counter : 리듀서(은행직원 이름), count : 변수 실행 순서 Provider는 createStore(reducers) 함수를 통해 리덕스 내부에 스토어를 생성한다. ( 은행에서 은행원(reducers)을 통해 통장(store)을 만드는 것처럼 ) Provider는 하위 컴포넌트에게 state와 dispatch를 전달해준다. Counter.js컴포넌트에서 props만 받을 수 있다. 단, 아직 state와 dispatch를 받은건 아니다. state(리덕스에 있는 상태)와 dispatch는 connect(mapStateToProps, mapDispatchToProps)(Counter); 를 이용하여 Counter컴포넌트의 props로 넘겨준다. (state와 dispatch가 필요 없는 경우 빈 함수를 리턴해주면 된다. ) Couter가 렌더링되면 Redux 저장소에 저장된 변수에 접근이 가능하게 되었으므로 + 혹은 - 버튼을 누를경우 dispatch 를 통해 Redux 저장소에 저장된 변수에 값이 변화되고 화면에 출력된다. Redux Dev Tools 구글 크롬에서 리덕스를 디버깅에 필요한 툴 ( 구글 크롬 확장 프로그램 설치 ) Redux Dev Tools 제작 GitHub 매우 직관적이라 사용하기 편리하다. 또한 특정 시간대로 이동하여 데이터의 변화를 확인할 수 있다. 사용하려면 아래와 같이 , creatStore() 의 2번째 인자로 명시를 해주어야한다. 이 툴을 이용하여 리덕스는 데이터에 대하여 언제나 UNDO, REDO가 가능하다. 1&lt;Provider store=&#123;createStore(reducers, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__())&#125;&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm59","slug":"daily-algorithm59","date":"2019-12-19T05:19:21.000Z","updated":"2019-12-19T05:21:25.056Z","comments":true,"path":"2019/12/19/daily-algorithm59/","link":"","permalink":"https://hyeok999.github.io/2019/12/19/daily-algorithm59/","excerpt":"","text":"탑문제 설명수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다. 송신 탑(높이) 수신 탑(높이) 5(4) 4(7) 4(7) 2(9) 3(5) 2(9) 2(9) - 1(6) - 맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요. 제한 사항 heights는 길이 2 이상 100 이하인 정수 배열입니다. 모든 탑의 높이는 1 이상 100 이하입니다. 신호를 수신하는 탑이 없으면 0으로 표시합니다. 입출력 예 heights return [6,9,5,7,4] [0,0,2,2,4] [3,9,9,3,5,7,2] [0,0,0,3,3,3,6] [1,5,3,6,7,6,5] [0,0,2,0,0,5,6] 입출력 예 설명입출력 예 #1앞서 설명한 예와 같습니다. 입출력 예 #2 [1,2,3] 번째 탑이 쏜 신호는 아무도 수신하지 않습니다.[4,5,6] 번째 탑이 쏜 신호는 3번째 탑이 수신합니다.[7] 번째 탑이 쏜 신호는 6번째 탑이 수신합니다. 입출력 예 #3 [1,2,4,5] 번째 탑이 쏜 신호는 아무도 수신하지 않습니다.[3] 번째 탑이 쏜 신호는 2번째 탑이 수신합니다.[6] 번째 탑이 쏜 신호는 5번째 탑이 수신합니다.[7] 번째 탑이 쏜 신호는 6번째 탑이 수신합니다. 1234567891011121314151617181920212223242526function solution(heights) &#123; const answer = [0]; const arr = [heights[0]]; let full = 0; let count = 0; for (let i = 1; i &lt; heights.length; i++) &#123; arr.push(heights[i]); count = 0; for (let j = 0; j &lt; arr.length; j++) &#123; if (arr[j] &gt; heights[i]) &#123; full = j + 1; count++; &#125; &#125; if (count == 0) &#123; answer.push(0); &#125; else &#123; answer.push(full); &#125; &#125; return answer;&#125;solution([3, 9, 9, 3, 5, 7, 2]);","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm58","slug":"daily-algorithm58","date":"2019-12-18T14:38:34.000Z","updated":"2019-12-18T14:46:53.598Z","comments":true,"path":"2019/12/18/daily-algorithm58/","link":"","permalink":"https://hyeok999.github.io/2019/12/18/daily-algorithm58/","excerpt":"","text":"짝수와 홀수문제 설명정수 num이 짝수일 경우 Even을 반환하고 홀수인 경우 Odd를 반환하는 함수, solution을 완성해주세요. 제한 조건 num은 int 범위의 정수입니다. 0은 짝수입니다. 입출력 예 num return 3 Odd 4 Even 123function solution(num) &#123; return num % 2 ? 'Odd' : 'Even';&#125; 평균 구하기문제 설명정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요. 제한사항 arr은 길이 1 이상, 100 이하인 배열입니다. arr의 원소는 -10,000 이상 10,000 이하인 정수입니다. 입출력 예 arr return [1,2,3,4] 2.5 [5,5] 5 12345function solution(arr) &#123; return (arr.reduce((sum,cur) =&gt; &#123; return sum + cur &#125;)/arr.length);&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"props를 통해 컴포넌트에게 값 전달하기","slug":"react-velo-03","date":"2019-12-17T13:56:43.000Z","updated":"2019-12-29T16:57:12.151Z","comments":true,"path":"2019/12/17/react-velo-03/","link":"","permalink":"https://hyeok999.github.io/2019/12/17/react-velo-03/","excerpt":"","text":"React with Velopert - 03 - props 를 통해 컴포넌트에게 값 전달하기 props 란 ? props의 기본 사용법 여러개의 props, 비구조화 할당(디스트럭처링) defaultProps 로 기본값 설정 props.children 조건부 렌더링 예제 : 특정 props의 값이 true 또는 false 에 따라서 컴포넌트의 좌측에 *표시하기. props 값 설정을 생략하면 ={true} Chap 3. props , 조건부 렌더링props 를 통해 컴포넌트에게 값 전달하기 props 란 ? properties의 줄임말 어떠한 값을 컴포넌트에게 전달할 때 사용. props의 기본 사용법 name 속성 값 전달하기. App 컴포넌트 ⇢ Hello 컴포넌트 src &gt; App.js 12345678910import React from 'react';import Hello from './Hello';function App() &#123; return ( &lt;Hello name=\"react\" /&gt; );&#125;export default App; src &gt; Hello.js 1234567import React from 'react';function Hello(props) &#123; return &lt;div&gt;안녕하세요 &#123;props.name&#125;&lt;/div&gt;&#125;export default Hello; 컴포넌트에게 전달되는 props 는 파라미터를 통하여 조회 할 수 있다. props 는 객체 형태로 전달되며, 만약 name 값을 조회하고 싶다면 props.name 을 조회하면 된다. 여러개의 props, 비구조화 할당(디스트럭처링) App 컴포넌트 ⇢ Hello 컴포넌트 src &gt; App.js 12345678910import React from 'react';import Hello from './Hello';function App() &#123; return ( &lt;Hello name=\"react\" color=\"red\"/&gt; );&#125;export default App; src &gt; Hello.js 12345678910import React from 'react';function Hello(&#123;color, name&#125;) &#123; &#123;/* 기본 return &lt;div style=&#123;&#123; color: props.color &#125;&#125;&gt;안녕하세요 &#123;props.name&#125;&lt;/div&gt; */&#125; return &lt;div style=&#123;&#123; color &#125;&#125;&gt;안녕하세요 &#123;name&#125;&lt;/div&gt; &#123;/* 비구조화 할당 디스트럭처링 */&#125;&#125;export default Hello; defaultProps 로 기본값 설정 App 컴포넌트 ⇢ Hello 컴포넌트 src &gt; App.js 12345678910111213import React from 'react';import Hello from './Hello';function App() &#123; return ( &lt;&gt; &lt;Hello name=\"react\" color=\"red\"/&gt; &lt;Hello color=\"pink\"/&gt; &lt;/&gt; );&#125;export default App; src &gt; Hello.js 1234567891011import React from 'react';function Hello(&#123; color, name &#125;) &#123; return &lt;div style=&#123;&#123; color &#125;&#125;&gt;안녕하세요 &#123;name&#125;&lt;/div&gt;&#125;Hello.defaultProps = &#123; name: '이름없음'&#125;export default Hello; props.children 컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 땐, props.children 을 조회하면 된다. 먼저 아래와 같이 작성했을 경우 Hello Component가 보이지 않는다. App 컴포넌트 ⇢ Hello 컴포넌트 src &gt; Wrapper.js 1234567891011121314import React from 'react';function Wrapper(&#123; children &#125;) &#123; const style = &#123; border: '2px solid black', padding: '16px', &#125;; return ( &lt;div style=&#123;style&#125;&gt; &lt;/div&gt; )&#125;export default Wrapper; src &gt; App.js 1234567891011121314import React from 'react';import Hello from './Hello';import Wrapper from './Wrapper';function App() &#123; return ( &lt;Wrapper&gt; &lt;Hello name=\"react\" color=\"red\"/&gt; &lt;Hello color=\"pink\"/&gt; &lt;/Wrapper&gt; );&#125;export default App; 내부의 내용이 보여지게 하기 위해서는 Wrapper 에서 props.children 을 렌더링 해야만 한다. src &gt; Wrapper.js 123456789101112131415import React from 'react';function Wrapper(&#123; children &#125;) &#123; const style = &#123; border: '2px solid black', padding: '16px', &#125;; return ( &lt;div style=&#123;style&#125;&gt; &#123;children&#125; &lt;/div&gt; )&#125;export default Wrapper; src &gt; App.js 1234567891011121314import React from 'react';import Hello from './Hello';import Wrapper from './Wrapper';function App() &#123; return ( &lt;Wrapper&gt; &lt;Hello name=\"react\" color=\"red\"/&gt; &lt;Hello color=\"pink\"/&gt; &lt;/Wrapper&gt; );&#125;export default App; 조건부 렌더링 특정 조건에 따라 다른 결과물을 렌더링 하는 것. 예제 : 특정 props의 값이 true 또는 false 에 따라서 컴포넌트의 좌측에 *표시하기.src &gt; App.js 123456789101112131415import React from 'react';import Hello from './Hello';import Wrapper from './Wrapper';function App() &#123; return ( &lt;Wrapper&gt; &lt;Hello name=\"react\" color=\"red\" isSpecial=&#123;true&#125;/&gt; &lt;Hello color=\"pink\" /&gt; &lt;/Wrapper&gt; )&#125;export default App; src &gt; Hello.js Hello 컴포넌트에서는 isSpecial 이 true 이냐 false 이냐에 따라서 컴포넌트의 좌측에 * 표시한다. 참고로 JSX 에서 null, false, undefined 를 렌더링하게 된다면 아무것도 나타나지 않게 된다. 12345678910import React from 'react';function Hello(&#123; color, name, isSpecial &#125;) &#123; return ( &lt;div style=&#123;&#123; color &#125;&#125;&gt; &#123; isSpecial ? &lt;b&gt;*&lt;/b&gt; : null &#125; 안녕하세요 &#123;name&#125; &lt;/div&gt; );&#125; 보통 삼항연산자를 사용한 조건부 렌더링을 주로 특정 조건에 따라 보여줘야 하는 내용이 다를 때 사용 아래처럼 &amp;&amp;를 사용한 단축평가를 활용 할 수 도 있다. 1234&lt;div style=&#123;&#123; color &#125;&#125;&gt; &#123;isSpecial &amp;&amp; &lt;b&gt;*&lt;/b&gt;&#125; 안녕하세요 &#123;name&#125;&lt;/div&gt; props 값 설정을 생략하면 ={true} 컴포넌트의 props 값을 설정하게 될 때 만약 props 이름만 작성하고 값 설정을 생략한다면, 이를 true 로 설정한 것으로 간주한다. src &gt; App.js 1234567891011121314import React from 'react';import Hello from './Hello';import Wrapper from './Wrapper';function App() &#123; return ( &lt;Wrapper&gt; &lt;Hello name=\"react\" color=\"red\" isSpecial /&gt; &lt;Hello color=\"pink\"/&gt; &lt;/Wrapper&gt; );&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm57","slug":"daily-algorithm57","date":"2019-12-17T13:56:30.000Z","updated":"2019-12-17T14:01:33.063Z","comments":true,"path":"2019/12/17/daily-algorithm57/","link":"","permalink":"https://hyeok999.github.io/2019/12/17/daily-algorithm57/","excerpt":"","text":"폰켓몬문제 설명당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다. 입출력 예 nums result [3,1,2,3] 2 [3,3,3,2,2,4] 3 [3,3,3,2,2,2] 2 입출력 예 설명입출력 예 #1문제의 예시와 같습니다. 입출력 예 #26마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다. 입출력 예 #36마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 3번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다. 123456789function solution(nums) &#123; const answer = nums.sort(); const len = Math.floor(nums.length / 2); let count = 0; answer.forEach((item, index) =&gt; (item !== answer[index - 1] ? count++ : ' ')); return count &gt;= len ? len : count;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"React 스터디 07","slug":"react-study-07","date":"2019-12-16T14:45:51.000Z","updated":"2019-12-16T14:46:55.183Z","comments":true,"path":"2019/12/16/react-study-07/","link":"","permalink":"https://hyeok999.github.io/2019/12/16/react-study-07/","excerpt":"","text":"React Study 07 한글 단어 처리 Router props.location Redux Redux의 사용이유 Redux를 배우는 시기 Redux 주요 개념 3가지 Redux 원칙 Action { type : 타입명, 변수명 : 변수값 } Reducers ACTION을 REDUCER에게 전달해주는 행위 : 디스패치( DISPATCH ) Store Redux Data Flow Redux 쉽게 이해해보기 Redux 셋팅 하기 용어 - ( 러버덕 ) props.location Redux Reducer Action Store 한글 단어 처리한글은 encodeURIComponent로 변환되어 해석한다. 1encodeURIComponent('사과') Router라우터는 Route를 모아놓은 최상위 집합이다. Route는 path를 통해 실제 경로를 지정한다. Switch를 통해 default루트 혹은 어떤 경로도 해당 되지 못할경우 404페이지를 쉽게 설정할 수 있다. props.locationYoutube 프로젝트를 보면 다음과 같은 코드가 있다. props.location은 상위 Router를 통해서 내려온 프로퍼티다. (history, location, match등이 내려온다.) location 객체는 URL상의 ? 뒤에 나오는 쿼리의 내용을 저장하는데, if (props.location)을 해준 이유는 해당 함수가 비동기로 돌기 떄문에, props.location이 정의가 되지 않을 시점에 props.location.search를 찾는다면 undefind를 유도한다. 따라서 이를 해결하기 위해 방어코드로 설정 해놓는다. 1234567891011componentDidMount() &#123; const &#123; props &#125; = this if (props.location) &#123; // 방어코드. lacation이 주입되기까지 기다린다. const &#123; search_query &#125; = qs.parse(props.location.search) // this.setState(&#123; // query : search_query // &#125;) this.getYoutubeData(search_query || '여행') // if (search_query) this.getYoutubeData(search_query) &#125;&#125; ReduxJS의 상태 관리 라이브러리. React 혹은 Vue와 같은 라이브러리 에서 많이 사용된다. 만약 순수 React소스로도 어플리케이션의 사용 문제가 없다면 Redux는 사용 고려 대상이 아니다. 왜냐하면 Redux 설정하는 것 자체는 복잡하고 많은 규칙과 쳬계를 개발자에게 강요하기 때문이다. Redux는 모든 상태는 예측 가능해야한다는 모티브를 지니고있다. Redux의 사용이유React에서 Redux를 사용하는 가장 큰 이유는 독립적인 여러 컴포넌트들이 다 같이 사용할 유일한 단일 저장소를 필요로 하기 때문이다. Router 를 사용하지 않는다면 최상위 컴포넌트에서 props로 전부 뿌리를 내려주면 되지만 Router를 사용하면서 URL 별로 관리를 시작한다면 컴포넌트들은 점점 독립적으로 자리를 잡게 된다. 서로 독립된 컴포넌트들끼리 데이터를 주고 받으면서 상태를 유지하기 위해서 단일 저장소를 필요로 하게 되는데 그것이 Redux를 사용해야만 하는 가장 큰 이유이다. Youtube-Mini-Clone 프로젝트에서 특정 비디오를 검색하고 나오는 리스트들 중 하나를 클릭하였을 경우, 해당 리스트의 플레이어에서 Nav-SearchBar는 공백으로 초기화 되어있다. ( 상태가 유지가 되지 않았다는 것을 의미 ) 또한 브라우저의 뒤로가기를 누를 경우, 역시 상태가 유지가 되지 않았으므로 아까와 같은 리스트들을 보여주지 않고 그저 공백 화면 만 보여줄 것이다. Redux를 배우는 시기 데이터 흐름이 복잡해질 경우 같으 데이터를 여러곳에 중복 사용 많은 요청 컴포넌트 간 통신 비계층적 데이터 Redux 주요 개념 3가지Action : ‘어떠한 데이터 변경작업을 해주세요’ 라는 것을 명시하는 곳. 데이터 요청을 하기 위한 데이터 객체 Reducers : 요청한 Action을 처리하여 새로운 상태를 리턴 해준다. HOF들처럼 특정 배열로 처리를하여 새로운 배열을 반환하는 느낌. Store : Redux에서 사용되는 유일한 단일 저장소. Redux 원칙 One immutable store : 기존의 상태에 직접적인 수정을 해서는 안된다. ( 예: a++ ) → 스프레드 등등 Actions trigger changes : 변화를 야기시킨다. Reducers update state : Reducers는 상태를 업데이트한다. Action { type : 타입명, 변수명 : 변수값 }type : 요청할 액션에 대한 설명 - 변수 (임의로 지정 가능하다.) Redux는 우리가 작업한 코드가 순수함수라는 보장이 없기 때문에, 이러한 문제를 원천적으로 막고자 ACTION -&gt; REDUCER -&gt; STORE 라는 순서를 지키라고 강요한다. Reducers상태는 읽기 전용 이다. Reducers는 순수 함수를 지향한다. 기존의 상태를 변경하지 않고 새로운 상태를 return 한다. 1234567891011export default function counter(state = INITIAL_STATE, action) &#123; switch(action.type) &#123; case ADD : return &#123; ...state, count: state.count + action.val &#125; default: return state; &#125;&#125; 작업한 코드가 순수함수라는 보장이 없기 때문에 순수함수를 만들라는 강요, 이 강요는 리덕스 시스템을 유지하는데 굉장히 중요하다. 언제나 예측 가능한 상태를 만들기 위한 원천적으로 제한(Action, Reducers) 을 두고 있다. ACTION을 REDUCER에게 전달해주는 행위 : 디스패치( DISPATCH )상태를 바꾸고싶다면 상태 자체(객체 자체)를 바꾸어야만한다. 이럴 경우, 바뀐 데이터에 대해 예측이 가능해진다. Store앱의 전체 상태 트리를 가지고 있다. 상태를 변경하는 유일한 방법은 액션을 보내는 것 뿐이다. 스토어는 클래스가 아니며, 몇가지 메서드가 속해있는 객체이고, createStore를 통해 생성할 수 있다. Store 메서드 getState() dispatch(action) subscribe(listener) replaceReducer(nextReducer) Redux는 모든 상태는 예측 가능해야만 하는 것을 강조한다. 곧 순수함수를 사용하라는 이야기다. 잘못된 상태변경. role은 더 이상 숫수함수가 아니다. 1234567state = &#123; name : 'KIM', role : 'developer'&#125;state.role = 'admin';return state; 리덕스에서 제안하는 상태변경. 객체 자체를 리턴한다. 123456789state = &#123; name : 'KIM', role : 'developer'&#125;return state = &#123; name : 'KIM', role = 'admin';&#125; Redux Data Flow상태 변화는 오직 Reducer만 가능하다. State -&gt; UI -&gt; ACTION -&gt; REDUX -&gt; STORE -&gt; State Redux 쉽게 이해해보기실제 우리가 생활에서 사용하는 은행(인터넷뱅킹X, 전자거래X, 반드시 은행 창구를 직접 이용해야만 한다.)이 있다고 가정하자. Redux는 은행이다. React.state는 지갑이다. 우린 지갑을 마음대로 사용할 수 있고, 돈만 들어 있다면 어떠한 절차없이 바로 사용하는 것이 가능하다. 은행 역시 우리 마음대로 사용할 수는 있지만, 절차와 체계 그리고 시스템을 지니고 있다. 은행에 가서 통장에서 돈을 얼마나 꺼낼것인지 출금 명세표를 작성하고 은행직원에게 전달하면 은행직원이 처리를 하고 돈을 준다. 여기서 Redux의 Store는 은행 통장 이다. (통장은 무조건 1개이다. 유일성 강조) 출금 명세표, 입금 명세표 등등의 은행에서 하고자 하는 업무를 작성해서 은행원에게 줘야하는데 Redux의 Action이 명세표들이다. Redux의 Reducer은 은행원이다. 명세표를 받아 처리를 하기 때문이다. 따라서 명세표를 은행원에게 주는 행위는 Redux의 Dispatch다. 자 이제, 통장을 보자 은행업무를 보고나면 통장에 입금 혹은 출금 등등을 했다면 통장에 기록이 남을텐데 통장기록은 한줄 한줄 쌓여간다. 기록을 지우고 다시 쓴 것이 아닌 한줄 한줄 쌓아서 적어놓은 것인데 이것은 Redux로 치면 순수함수와 불변성을 대변한다. 다시 정리하면, 은행(Redux)에 가서 100원을 입금 해달라는 명세표(Action)을 작성해서 은행원(Reducer)에게 준다.(주는 행위 : Dispatch) 은행원(Reducer)은 요청받은 명세표(Action)을 처리해서 통장(Store)에 기록한다. 통장(Store)에는 총 300원이 있는데 기록이 300원으로 있는게 아닌, 100원, 200원, 방금 넣은 300원으로 차례차례 기록 되어 있다.( 순수함수, 불변성 ) Redux 셋팅 하기 123npx create-react-app redux-studyVSCode로 해당 폴더 오픈 12npm i redux --savenpm i react-redux --save react-redux는 react에 redux를 적용하기 위해서 설치한다. 폴더 2개 생성src 하위 src/actionssrc/reducersstore는 redux에 포함되어 있기 때문에 만들 필욘 없다. import 추가src/App.js 12import &#123; Provider &#125; from 'react-redux';import &#123; createStore &#125; from 'redux'; createStore = store를 만든다. (은행 통장을 개설한다.) Provider는 하위 컴포넌트에게 store를 접근할 방법을 제공해준다. store를 사용하고자 하는 최상위 컴포넌트에게 다음 코드를 추가한다. Provider 랩핑src/App.js 최상위 컴포넌트에서 Provider를 랩핑시켜준다. 1234567function App() &#123; return ( &lt;Provider store=&#123;createStore(reducers)&#125;&gt; ... &lt;/Provider&gt; );&#125; store를 만들 때는 createStore함수를 통해야 하고 reducers를 걸쳐야만 한다. 은행 통장을 만들 때는, 은행원(reducers)을 걸쳐야 하는 것과 같다. reducers 파일 생성src/reducers/counter.js src/reducers/index.js App.js reducers importsrc/App.js 1import reducers from './reducers' actions 파일 생성 및 정의src/actions/index.js 12345export const ADD = 'ADD';export function add(val) &#123; return (&#123; type : ADD, val &#125;)&#125; Action : { type : ADD, val } type : 수행하고자 하는 변수명 , val : 실제 데이터 명, 값 Dispatch : return ({ type : ADD, val }) reducers 정의src/reducers/counter.js 위에 정의한 actions를 import하고 초기 상태를 정의해준다. 12345import &#123; ADD &#125; from '../actions'const INITIAL_STATE = &#123; count: 0 &#125; reducer를 정의한다. 1234567891011export default function counter(state = INITIAL_STATE, action) &#123; switch(action.type) &#123; case ADD : return &#123; ...state, count: state.count + action.val &#125; default: return state; &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm56","slug":"daily-algorithm56","date":"2019-12-16T14:41:30.000Z","updated":"2019-12-16T14:43:11.173Z","comments":true,"path":"2019/12/16/daily-algorithm56/","link":"","permalink":"https://hyeok999.github.io/2019/12/16/daily-algorithm56/","excerpt":"","text":"행렬의 덧셈문제 설명행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요. 제한 조건 행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다. 입출력 예 arr1 arr2 return [[1,2],[2,3]] [[3,4],[5,6]] [[4,6],[7,9]] [[1],[2]] [[3],[4]] [[4],[6]] 12345678910function solution(arr1, arr2) &#123; for(let i = 0; i &lt; arr1.length; i++ ) &#123; for(let j = 0; j &lt; arr1[0].length; j++) &#123; arr1[i][j] = arr1[i][j] + arr2[i][j]; &#125; &#125; return arr1;&#125; 재풀이12345function solution(arr1, arr2) &#123; const answer = arr1.map((arr1Cha,i) =&gt; arr1Cha.map((orginalArr, j) =&gt; orginalArr + arr2[i][j])); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"Components and Props","slug":"react-official-03","date":"2019-12-14T10:45:25.000Z","updated":"2019-12-29T16:48:31.512Z","comments":true,"path":"2019/12/14/react-official-03/","link":"","permalink":"https://hyeok999.github.io/2019/12/14/react-official-03/","excerpt":"","text":"React Official Document주요개념 : Components and Props 함수 컴포넌트와 클래스 컴포넌트 컴포넌트 렌더링 주의: 컴포넌트의 이름은 항상 대문자로 시작 컴포넌트를 이용한 렌더링 예시 컴포넌트 합성(구성) 컴포넌트 추출(분리) props는 읽기 전용 React Official Document주요개념#3. Components and Props컴포넌트를 통해 UI를 재사용 가능한 개별적인 여러 조각으로 나뉠 수 있다. 개념적으로 컴포넌트는 JavaScript 함수와 유사하다. “props”라고 하는 임의의 값을 받은 후, 화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환한다. 함수 컴포넌트와 클래스 컴포넌트JavaScript 함수 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 데이터를 가진 하나의 “props” 객체 인자를 받은 후 React 엘리먼트를 반환하므로 유효한 React 컴포넌트다. ES6 Class 12345class Welcom extends React.Component&#123; render() &#123; &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 컴포넌트 렌더링우선 함수 Component로 진행한다. 이전까지는 React 요소들을 DOM태그로 그렸었다. 1const element = &lt;div &gt;&lt;/div&gt;; 그런데 사용자 정의 컴포넌트로도 React 요소들을 나타낼 수 있다. 1const element = &lt;Welcome name=\"HYEOK\" /&gt;; React가 사용자 정의 컴포넌트로 작성한 요소를 발견하면 JSX 어트리뷰트를 해당 컴포넌트에 단일 객체로 전달한다. 여기서의 단일 객체가 ‘props’ 다. 주의: 컴포넌트의 이름은 항상 대문자로 시작React는 소문자로 시작하는 컴포넌트를 DOM 태그로 처리합니다. 예를들어 &lt;div&gt;&lt;/div&gt;는 HTML의 div 태그를 나타낸다. 하지만, &lt;Welcome /&gt;은 컴포넌트로 취급되며 컴포넌트는 스코프내에 존재해야한다. 컴포넌트를 이용한 렌더링 예시123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=\"HYEOK\" /&gt;;ReactDOM.render( element, document.getElementById('root')); 여기서 Welcom(props) 의 props는 { name : ‘HYEOK’ } 을 의미한다. 이 예시에서는 다음과 같이 실행된다. &lt;Welcome name=&quot;HYEOK&quot; /&gt; 엘리먼트로 ReactDOM.render()를 호출. React는 {name: &#39;HYEOK&#39;}를 props로 하여 Welcome 컴포넌트를 호출. Welcome 컴포넌트는 결과적으로 &lt;h1&gt;Hello, HYEOK&lt;/h1&gt; 엘리먼트를 반환. React DOM은 &lt;h1&gt;Hello, HYEOK&lt;/h1&gt; 엘리먼트와 일치하도록 DOM을 효율적으로 업데이트. 컴포넌트 합성(구성)컴포넌트는 다른 컴포넌트를 내부에 참조시킬 수 있다. React 앱에서는 UI적인 모든 것(버튼, 폼, 다이얼로그 등등)들을 컴포넌트로 표현할 수 있다. 12345678910111213141516171819function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;// Welcome을 여러번 렌더링 하는 App 컴포넌트function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 일반적으로 새로 만든 React 앱은 최상위에 단일 App 컴포넌트를 가지고 있다. 하지만 기존 앱에 React를 통합하는 경우에는 작은 단위 부터 시작해서 View 계층의 상단계로 올라가며 점진적으로 작업해야 한다. 컴포넌트 추출(분리)123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;div className=\"UserInfo\"&gt; &lt;img className=\"Avatar\" src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 이 컴포넌트는 구성요소들이 모두 중첩 구조로 이루어져 있어서 변경하기 어려울 수 있으며, 각 구성요소를 개별적으로 재사용하기도 힘들다. 이 컴포넌트는 author(객체), text(문자열) 및 date(날짜)를 props로 받은 후 소셜 미디어 웹 사이트의 코멘트를 나타낸다. 여기서 이 컴포넌트에서 몇 가지 컴포넌트로 분리를 해보자. 12345678function ImgAvatar(props) &#123; return ( &lt;img className=\"Avatar\" src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; );&#125; props의 이름은 사용될 context가 아닌 컴포넌트 자체의 관점에서 짓는 것을 권장한다. src = { props.author.avatarUrl } 을 src = { props.user.avatarUrl } 로 변경한 이유. author 보다는 user가 더 일반적이고 ImgAvatar 컴포넌트는 Comment 내에서 렌더링 된다는 것을 알 필요가 없기 때문. 12345678910111213141516171819function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;div className=\"UserInfo\"&gt; &#123;/* 이 부분에 컴포넌트를 삽입 */&#125; &lt;Avatar user=&#123;props.author&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 다음에는 &lt;div className=&quot;UserInfo&quot;&gt;~~&lt;/div&gt;를 통째로 분리해서 컴포넌트화 하도록 한다. 이미 Avatar 컴포넌트가 있기 때문에 Avatar 컴포넌트를 이용해서 만들도록 한다. 12345678910function UserInfo(props) &#123; return ( &lt;div className=\"UserInfo\"&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.user.name&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 이렇게 까지 컴포넌트화가 완료되었다고 코드는 다음처럼 짧아진다. 1234567891011121314&#123;/* 최종 소스 */&#125;function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;UserInfo user=&#123;props.author&#125; /&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 컴포넌트를 분리하는 작업은 쓸모없다고 느껴질 수 도 있다. 하지만 재사용 가능한 컴포넌트를 여러개 분리해놓는 것은 큰 앱을 만들때 큰 이점을 발휘한다. 특히 여러번 사용되는 UI(버튼, 패널, 아바타)에서는 미리 만들어 놓는 것이 좋을 수도 있다. props는 읽기 전용함수 컴포넌트나 클래스 컴포넌트 모두 컴포넌트의 자체 props를 수정해서는 안된다. 123function sum(a, b) &#123; return a + b;&#125; 이런 함수들은 순수 함수라고 호칭한다. 입력값을 바꾸려 하지 않고 항상 동일한 입력값에 대해 동일한 결과를 반환하기 때문. 반면에 다음 함수는 자신의 입력값을 변경하기 때문에 순수 함수가 아니다. 123function withdraw(account, amount) &#123; account.total -= amount;&#125; React는 매우 유연하지만 한 가지 엄격한 규칙이 있다. 모든 React 컴포넌트는 자신의 props를 다룰 때 반드시 순수 함수처럼 동작해야 합니다. 물론 애플리케이션 UI는 동적이며 시간에 따라 변한다. 해당 부분은 “state”라는 새로운 개념으로 대체한다. React 컴포넌트는 state를 통해 위 규칙을 위반하지 않고 사용자 액션, 네트워크 응답 및 다른 요소에 대한 응답으로 시간에 따라 자신의 출력값을 변경할 수 있다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"daily_algorithm55","slug":"daily-algorithm55","date":"2019-12-14T06:31:05.000Z","updated":"2019-12-14T06:37:44.336Z","comments":true,"path":"2019/12/14/daily-algorithm55/","link":"","permalink":"https://hyeok999.github.io/2019/12/14/daily-algorithm55/","excerpt":"","text":"비밀지도 [ 2018 KAKAO ]문제 설명네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(“ ) 또는벽(#”) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다. 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라. 입력 형식입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다. 1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식원래의 비밀지도를 해독하여 &#39;#&#39;, 공백으로 구성된 문자열 배열로 출력하라. 입출력 예제 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [&quot;#####&quot;,&quot;# # #&quot;, &quot;### #&quot;, &quot;# ##&quot;, &quot;#####&quot;] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [&quot;######&quot;, &quot;### #&quot;, &quot;## ##&quot;, &quot; #### &quot;, &quot; #####&quot;, &quot;### # &quot;] 1234567891011121314151617181920212223242526function transMap(n, num) &#123; let res = 0; let arr = ''; for (let i = 0; i &lt; n; i++) &#123; res = num % 2; num = Math.floor((num /= 2)); if (res) arr += '#'; else arr += ' '; &#125; return arr.split('').reverse().join('');&#125;function solution(n, arr1, arr2) &#123; const completedMap = []; let answer = ''; for (let i = 0; i &lt; n; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; answer += transMap(n, arr1[i])[j] === '#' || transMap(n, arr2[i])[j] === '#' ? '#' : ' '; &#125; completedMap.push(answer); answer = ''; &#125; return completedMap;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"유튜브 미니 클론 (No Route)","slug":"react-youtube-clone-noRoute","date":"2019-12-13T14:40:42.000Z","updated":"2020-03-09T09:13:27.583Z","comments":true,"path":"2019/12/13/react-youtube-clone-noRoute/","link":"","permalink":"https://hyeok999.github.io/2019/12/13/react-youtube-clone-noRoute/","excerpt":"","text":"Youtube Mini Clone React목차 Youtube Mini Clone 생성하기 기본 틀 짜기 유튜브 데이터 받아올 준비하기 유튜브 데이터 받아오기 Header 작성 ( 큰 틀 = 로고부분) Header 작성 ( 검색바 ) 입력 값 기본 정해두기 데이터 초기화 값 셋팅 Main 작성 ( VideoList + VideoPlayer ) 무한 스크롤 1. Youtube Mini Clone 생성하기1-1. 프로젝트를 시작할 폴더에 들어가서 리액트 프로젝트를 생성한다.1npx create-react-app youtube-practice 1-2. VSCode로 해당 프로젝트 폴더를 따로 오픈한다.1cd youtube-practice 1-3. 생성 당시 폴더 구조 2. 기본 틀 짜기처음 프로젝트 생성시 적혀진 내용들을 수정하고서 프로젝트를 시작하도록 한다. 2-1. src/App.css내용 모두 지우고 아래 코드를 삽입한다. 1234.main-content &#123; width: 1600px; margin: 25px auto;&#125; 2-2. src/App.js내용 모두 지우고 아래 코드를 삽입한다. 1234567891011121314151617181920import React from 'react';import './App.css';class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125; &#125; render() &#123; return ( &lt;div className = 'App'&gt; &lt;/div&gt; ) &#125;&#125;export default App; 2-3. src/index.cssCSS를 초기화를 미리 해두도록 한다. (reset.css 적용) 나중에 시멘틱을 위해서 a11y-hidden도 정의한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869* &#123; box-sizing: border-box;&#125;html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header, hgroup,menu, nav, output, ruby, section, summary,time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section &#123; display: block;&#125;body &#123; margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; line-height: 1;&#125;ol, ul &#123; list-style: none;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: ''; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;code &#123; font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;&#125;/*숨긴 콘텐츠*/.a11y-hidden, legend&#123; position: absolute; width: 1px; height: 1px; margin: -1px; overflow: hidden; /* 넘치는 부분을 감쳐준다 */ clip: rect(0,0,0,0); /* 선행조건 : position:absolute 해당 화면을 잘라내서 보여줌 */ white-space: nowrap; /* 줄바꿈을 하지않음. */ opacity: 0; /* 투명도 */&#125; 3. 유튜브 데이터 받아올 준비하기유튜브 API로부터 데이터를 받아올 준비를 한다. 3-1. 전역 URL 변수 생성 유튜브의 기본 URL은 다음과 같다. https://www.googleapis.com/youtube/v3/search import 코드 아래 작성해준다. 1const URL = 'https://www.googleapis.com/youtube/v3/search'; 3-2. state 변경 값 설정변경 될 수 있는 값들을 this.state에 미리 설정해준다. 12345this.state = &#123; videoDatas : [], nextPageToken : '', query : ''&#125; videoDatas : 유튜브 API를 통해 받아올 데이터를 담을 배열. nextPageToken : 유튜브 API에서 보여지는 데이터는 5개씩으로 처리가 되어있다. query : 입력한 값이 같은 지 다른 지에 따라 불러와야할 데이터가 다르므로 설정해둔다. 4. 유튜브 데이터 받아오기본격적으로 유튜브 API를 만들도록 한다. 4-1. axios 설치 및 적용먼저 데이터를 받아오기 위해 axios와 async / await를 이용한다. 패키지를 다운 받을 필요가 없는 fetch를 쓰지 않은 이유는 fetch는 다음과 같은 문제를 내포하기 때문이다. 크로스 브라우징 이슈 쿠키를 포함하려면 특정 npm을 랩핑해줘야 한다. status가 response 체크를 받아야만 한다. 따라서 axios를 먼저 npm install 한다. 1npm i axios --save 패키지 다운이 완료되었다면 import 를 해준다. 1import axios from 'axios'; 4-2. 유튜브 데이터 불러오는 메소드 정의하기로드 메소드는 class 내부 constructor 와 render 사이에 작성한다. 입력 받은 query로 데이터를 불러온다. 해당 메소드는 async/await를 사용한다. 먼저, 입력 값이 없을 경우 해당 메소드에 접근하지 못하도록 설정해야만 한다. 123async getYoutube(query) &#123; if (!query) return; &#125; axios는 첫번쨰 인자로 URL, 두번째 인자로 params 객체를 받는다. URL은 3-1. 전역 URL 변수 생성에서 만든 것을 활용한다. params는 key, q, pageToken, part를 정의해준다. 각각 API 키, 쿼리, 페이지 토큰 , 데이터 부분을 의미한다. 1234567891011121314151617const params = &#123; key : '유튜브 API키는 별도로 구하셔야 합니다.', q : query, pageToken : this.state.nextPageToken, part : 'snippet'&#125;try &#123; const &#123; data &#125; = await axios.get( URL, &#123; params &#125; ); this.setState(&#123; videoDatas : [...this.state.videoDatas, ...data.items], query : query, nextPageToken : data.nextPageToken &#125;,() =&gt; console.log(data))&#125; catch (error) &#123; console.error('에러',error);&#125; axios.get을 통해 받아온 데이터는 data 객체 안에 담겨져 있다. ( 그래서 디스트럭처링 해준다. ) setState를 할 때, videoDatas 에 주는 데이터들을 [...this.state.videoDatas, ...data.items] 로 적은 이유는 어떠한 이유로 다음 페이지의 데이터들을 불러올 떄, 데이터를 추가로 더 해주기 위함이다. 위와 같이 코드를 작성하게 된다면 새로운 입력값이든, 추가로 입력한 값이든 모두 수용할 수 있다. qeury는 입력한 데이터를 그대로 받는다. nextPageToken 또한 get으로 받은 데이터에서 찾아서 값을 할당한다. 5. Header 작성 ( 큰 틀 = 로고부분)유튜브 API를 활용해 유튜브 데이터를 들고오는 Search Bar를 작성한다. 최상위 컴포넌트 내의 하위 컴포넌트들은 함수형 컴포넌트로 작성한다. 5-1. Nav 컴포넌트 생성src에 Nav 폴더 생성 한 후 각각 images 폴더, Nav.css, Nav.jsx 파일을 생성한다. images 폴더에 유튜뷰 로고 이미지를 넣는다. ( 이미지는 인터넷에서 별도로 구한다. ) Nav.jsx에 아래 코드를 작성한다. ( src/Nav/Nav.jsx ) 1234567891011121314151617import React from 'react';import './Nav.css';import YoutubeLogo from './images/YouTube.png'const Nav = (props) =&gt; &#123; return ( &lt;header class='Nav'&gt; &lt;h1 className='a11y-hidden'&gt; 유튜브 &lt;/h1&gt; &lt;a href='#'&gt; &lt;img className='header-logo' src=&#123;YoutubeLogo&#125; alt=\"유튜브\"/&gt; &lt;/a&gt; &#123;props.children&#125; &lt;/header&gt; );&#125;export default Nav; props.children은 추후 해당 컴포넌트에 &lt;SearchBar onSearchVideo={this.getYoutube}&gt;&lt;/SearchBar&gt;을 불러들이기 위함이다. 5-2. Nav 컴포넌트 CSS 적용123456789101112131415161718192021222324252627282930.Nav &#123; background-color: rgb(48, 48, 48); position: relative; display: flex; align-items: center; justify-content: space-between;&#125;.Nav::before &#123; content: ''; min-width: 286px;&#125;.Nav::after &#123; content: ''; min-width: 284px;&#125;.Nav a&#123; position: absolute; height: auto; height: 50%; left : 30px; top : 50%; transform: translateY(-50%);&#125;.header-logo&#123; height: 100%;&#125; 5-3. src/App.js에서 Nav컴포넌트를 로드 한 후 커스텀 태그를 작성한다.App.js 최상단에 import 한다. 1import Nav from './components/Nav/Nav'; class 최하단에 있는 render 메소드에 다음과 같이 작성한다. 123456789render() &#123; return ( &lt;div className = 'App'&gt; &lt;Nav&gt; &lt;SearchBar onSearchVideo=&#123;this.getYoutube&#125;&gt;&lt;/SearchBar&gt; &lt;/Nav&gt; &lt;/div&gt; )&#125; 추후에 만들 검색바를 통해서 입력을 받고 실시간으로 데이터를 불러와야 하므로 &lt;SearchBar onSearchVideo={this.getYoutube}&gt;&lt;/SearchBar&gt;도 함께 작성한다. 5-3. getYoutube 바인드getYoutube 함수가 this를 제대로 적용시키기 위해서 bind작업을 한다. 코드는 class 내부 constructor 안 제일 아래에 작성한다. 12345678910constructor(props) &#123; super(props); this.state = &#123; videoDatas : [], query : '', nextPageToken : '' &#125; this.getYoutube = this.getYoutube.bind(this);&#125; 6. Header 작성 ( 검색바 )6-1. SearchBar 컴포넌트 생성src에 SearchBar 폴더 생성 한 후 각각 images 폴더, SearchBar.css, SearchBar.jsx 파일을 생성한다. images 폴더에 돋보기 모양 이미지를 넣는다. ( 이미지는 인터넷에서 별도로 구한다. ) SearchBar.jsx에 아래 코드를 작성한다. ( src/SearchBar/SearchBar.jsx ) 12345678910111213141516171819202122232425262728293031import React from 'react';import './SearchBar.css';import loupe from './images/loupe.png'const keyHandler = (search) =&gt; (e) =&gt; &#123; if(e.key === 'Enter') &#123; search(e.target.value); &#125;&#125;const SearchBar = (props) =&gt; &#123; let input = ''; return ( &lt;div className='search-wrapper'&gt; &lt;input ref = &#123;(ref) =&gt; input = ref&#125; // 2-1번 className='search-bar' type='search' placeholder=\"검색어를 입력하세요\" autoFocus onKeyPress = &#123;keyHandler(props.onSearchVideo)&#125; // 1번 /&gt; &lt;button className='btn-search' onClick=&#123;() =&gt; props.onSearchVideo(input)&#125; /*2-2번*/&gt; &lt;img className='search-icon' src=&#123;loupe&#125; alt=\"검색\" /&gt; &lt;/button&gt; &lt;/div&gt; );&#125;export default SearchBar; 1번 : &lt;input /&gt;의 onKeyPress는 어떤 키과 눌렸는지에 대해서 반응하도록 하는 이벤트 핸들러이다. 따라서 해당 이벤트를 처리하기 위해서 HOC(High Order Component)를 이용해서 콜백으로 뿌려준다. 2-1번 : 엔터 입력 말고도 버튼으로 클릭해서 입력도 구현을 해야만한다. 문제는 인풋 내부의 e.target.value를 통해 실시간 입력값을 들고올수 없단는 것이다. 따라서 해당 코드(ref , 리액트에서만 사용)를 이용하여 입력값을 전달받은 후 미리 정의해놓은 변수에 할당한다. 2-2번 : 할당받은 값을 토대로 이벤트를 호출한다. 6-2. SearchBar 컴포넌트 CSS 적용1234567891011121314151617181920212223242526272829303132333435.search-wrapper &#123; padding: 32px 0; white-space: nowrap;&#125;.search-bar&#123; width: 450px; height: 36px; padding: 0 auto; border: 1px solid #828282; vertical-align: middle; display: inline-block; border-radius: 3px 0px 0px 3px; line-height: 1.5; font-size: 15px; outline: none; padding-left: 15px; text-decoration: none;&#125;.btn-search&#123; height: 36px; border-radius: 0px 3px 3px 0px; border: 1px solid #828282; background: #fff; margin-left: -2px; font-size: 0; vertical-align: middle; display: inline-block;&#125;.search-icon&#123; width: 20px; height: 20px;&#125; 7. 입력 값 기본 정해두기처음에 입력이 안되었어도 미리 특정 검색어로 초기화를 해두도록 하자. class 내부 render위 componentWillMount()메소드를 정의하고 작성한다. 해당 함수는 순서를 보장 하기 위해서 async / await를 이용한다. 123async componentWillMount() &#123; return await this.setState(this.getYoutube('여행'));&#125; 8. 데이터 초기화 값 셋팅1videoDatas : [...this.state.videoDatas, ...data.items] 위 코드로 입력 값이 바뀔 경우에 데이터를 초기화 한 후 데이터가 쌓이도록 설정해두었다. 따라서 데이터 초기화 값을 미리 셋팅하도록 하자. 8-1. 초기화 변수 선언class 내부 constructor 메소드 최하단에 작성한다. 1234567891011constructor(props) &#123; super(props); this.state = &#123; videoDatas : [], query : '', nextPageToken : '' &#125; this.defaultState = this.state; // 초기화 default 작성 this.getYoutube = this.getYoutube.bind(this);&#125; 8-2. 초기화 로직 작성기존의 쿼리와 입력받은 쿼리가 다를 경우 초기화 한 후 입력받은 쿼리를 적용시켜야 한다. 따라서 초기화를 하는 로직을 구성한다. 위치는 getYoutube 메소드 내부 if문 다음에 작성한다. 123456789async getYoutube(query) &#123; if (!query) return; // 여기 작성 if (this.state.query !== query) &#123; this.setState(this.defaultState); &#125; ...&#125; 9. Main 작성 ( VideoList + VideoPlayer )VideoList를 작성하기에 앞서 현재 우리는 Router 설정을 안해주었다. 한가지의 URL 안에서 모든 것을 보여주어야 하기 떄문에 어떤 컴포넌트를 렌더링 할 것 인지 선택을 해야한다. 따라서 VideoPlayer를 보여주기 위해서는 videoId가 있어야한다. 비디오 리스트에서 특정 비디오가 선택됬다면 해당 비디오의 videoId를 저장하고 선택이 되지 않았다면 기본적으로 null값 혹은 빈문자열을 지니도록 한다. constructor 에서 videoId 프로퍼티를 추가하도록 하자. 12345678constructor(props) &#123; super(props); this.state = &#123; videoDatas : [], query : '', nextPageToken : '', videoId: '' // 추가 &#125; 9-1 VideoList 컴포넌트 구성하기먼저 VideoList 컴포넌트를 구성하다. 폴더구조는 다음과 같다. component/VideoList/VideoList.jsx 123456789101112import React from 'react'import VideoListItems from './VideoListItems'const VideoList = (props) =&gt; &#123; return ( &lt;ul&gt; &lt;VideoListItems &#123;...props&#125;&gt;&lt;/VideoListItems&gt; &lt;/ul&gt; );&#125;export default VideoList; list별로 다른 리스트 썸네일과 제목을 보여주어야만 한다. 따라서 따로 하위 컴포넌트를 추가로 작성해준다. component/VideoList/VideoListItems.jsx 12345678910111213141516171819202122import React from 'react'import uuid from 'uuid'import './VideoList.css'const VideoListItems = (props) =&gt; &#123; const videos = props.videoDatas.map(video =&gt; &#123; return &lt;li className='video-list' key=&#123;uuid.v4()&#125; &gt; &lt;figure&gt; &lt;img src=&#123;video.snippet.thumbnails.high.url&#125; alt=\"영상이미지\"/&gt; &lt;figcaption&gt;&#123;video.snippet.title&#125;&lt;/figcaption&gt; &lt;/figure&gt; &lt;/li&gt; &#125;) return ( &lt;&gt; &#123;videos&#125; &lt;/&gt; );&#125;export default VideoListItems; 여기서 uuid는 key를 고유한 랜덤키를 배포해주기 위한 npm 모듈이다. 다음으로 설치하고 작성한다. 1npm i uuid --save css를 구성한다. component/VideoList/VideoList.css 123456789101112131415.video-list &#123; margin : 30px 0;&#125;.video-list figure&#123; display: flex; align-items: center;&#125;.video-list figcaption&#123; width: 800px; height: 300px; margin-bottom: 20px; font-size: 20px;&#125; 9-2 VideoPlayer 컴포넌트 구성하기폴더구조는 다음과 같다. 먼저 css를 추가하도록 하자. component/VideoPlayer/VideoPlayer.css 123456789.video-player-wrap&#123; margin : 0 auto; text-align: center;&#125;.video-player&#123; width: 960px; height: 640px;&#125; component/VideoPlayer/VideoPlayer.jsx 12345678910111213import React from 'react'import './VideoPlayer.css'const VideoPlayer = (props) =&gt; &#123; const url = `https://youtube.com/embed/$&#123;props.videoId&#125;`; return ( &lt;div className=\"video-player-wrap\"&gt; &lt;iframe src=&#123;url&#125; title=&#123;props.videoId&#125; className=\"video-player\" /&gt; &lt;/div&gt; );&#125;export default VideoPlayer 9-3. App.js에 두 컴포넌트 작성App.js render 부분에 &lt;main&gt; 태그를 추가하고 videoId에 따라 어떤 컴포넌트를 렌더 할지 정한다. 12345678910111213141516171819render() &#123; const &#123; videoId &#125; = this.state return ( &lt;div className = 'App'&gt; &lt;Nav&gt; &lt;SearchBar onSearchVideo=&#123;debounce(this.getYoutube, 500)&#125;&gt;&lt;/SearchBar&gt; &lt;/Nav&gt; &lt;main&gt; &#123; videoId ? &lt;VideoPlayer videoId = &#123; videoId &#125;&gt;&lt;/VideoPlayer&gt; : &lt;VideoList &#123;...this.state&#125; /&gt; &#125; &lt;/main&gt; &lt;/div&gt; ) &#125; 각 컴포넌트에서 필요한 값들을 props로 내려주기 위해 태그 옆에 정의를 해두었다. 9-4. 비디오 플레이어 표시하기VideoList에서 Click 이벤트를 일으켜서 videoId를 바꿔 Player를 표시하는 작업을 하도록하자. 먼저 App.js 에 videId를 바꿀 함수를 정의하고 &lt;VideoList&gt;에 props로 뿌려 click이벤트로 사용하도록 하자. render() 함수 바로 위에 작성한다. 123setVideoId(id) &#123; this.setState(&#123; videoId : id &#125;)&#125; render() 함수의 &lt;VideoList&gt; 애도 해당 함수를 호출시킬 속성을 작성한다. 1234&lt;VideoList &#123;...this.state&#125; onSetVideoId = &#123;this.setVideoId&#125; // 추가/&gt; constructor 내부에서 bind를 해준다. 1234constructor(props) &#123; ... this.setVideoId = this.setVideoId.bind(this);&#125; VideoListItems.jsx 컴포넌트 파일에 접근하여 li부분에 onClick 이벤트를 추가한다. 1234567891011121314151617181920import React from 'react'import uuid from 'uuid'const VideoListItems = (props) =&gt; &#123; const videos = props.videoDatas.map(video =&gt; &#123; // li 부분 수정 return &lt;li key=&#123;uuid.v4()&#125; onClick=&#123;() =&gt; props.onSetVideoId(video.id.videoId)&#125; &gt; &lt;figure&gt; &lt;img src=&#123;video.snippet.thumbnails.default.url&#125; alt=\"영상이미지\"/&gt; &lt;figcaption&gt;&#123;video.snippet.title&#125;&lt;/figcaption&gt; &lt;/figure&gt; &lt;/li&gt; &#125;) return ( &lt;&gt; &#123;videos&#125; &lt;/&gt; );&#125;export default VideoListItems; 10. 무한스크롤이제 무한 스크롤을 작성한다. 우선 무한스크롤을 사용할 수 있도록 npm 을 설치하고, gif파일을 가지고 오도록하자(gif는 스피너 이미지. 구글로 구할것) 1npm i react-infinite-scroller --save import 를 추가한다. App.js 12import InfiniteScroll from 'react-infinite-scroller';import spinner from './components/images/spinner.gif' App.js 의 &lt;main&gt;부분을 다음과 같이 수정한다. 123456789101112131415161718192021&lt;main&gt; &#123; videoId ? &lt;VideoPlayer videoId = &#123; videoId &#125;&gt;&lt;/VideoPlayer&gt; : &lt;InfiniteScroll loadMore = &#123;() =&gt; this.getYoutube(this.state.query)&#125; hasMore = &#123;!!this.state.nextPageToken&#125; loader = &#123; &lt;div key=&#123;uuid.v4()&#125;&gt; &lt;img src=&#123;spinner&#125; alt=\"로딩 중\"&gt;&lt;/img&gt; &lt;/div&gt; &#125; &gt; &lt;VideoList &#123;...this.state&#125; onSetVideoId = &#123;this.setVideoId&#125; /&gt; &lt;/InfiniteScroll&gt; &#125;&lt;/main&gt; loadMore : 스크롤이 끝까지 발생 시 어떤 일을 할 것인가를 정의한다. hasMore : 스크롤이 끝까지 발생 시 어떤 일을 일으키는 조건을 정의 loader: loadMore이 일어나는 동안 수행할 일을 정의한다. 여기까지 하면 문제없이 잘 될 것이다. 다음에는 Router 기능을 추가하도록 하겠다. 현재 git .ignore로 설정을 해두어서 해당 프로젝트는 따로 관리를 해두지 않았다. 단, 좀더 확장되고 정확한 소스는 아래 링크에서 확인이 가능하다. Youtube Mini Clone","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"React 스터디 06","slug":"react-study-06","date":"2019-12-13T12:43:45.000Z","updated":"2019-12-13T12:46:32.217Z","comments":true,"path":"2019/12/13/react-study-06/","link":"","permalink":"https://hyeok999.github.io/2019/12/13/react-study-06/","excerpt":"","text":"React Study 06 환경변수 정의하기 .evn 파일 생성 .gitignore에 .env 추가 번외 : .env 파일을 만들지 않고 npm start 할 때마다 키값 넘겨주기(권장하진 않음) Router 파라미터를 넘기는 방법 2가지 쿼리 스트링 REST API Switch 해결방법 1 : exact 해결방법 2 : 중요도가 높은 라우팅을 먼저 선언해준다. 실습 라우팅해보기 쿼리 스트링 사용하기 REST API 사용하기 REST API 와 쿼리스트링 둘 다 사용하기 URL(주소가) 바뀐 것처럼 보여주기. 리액트 DOM을 렌더링 해주기 위해서 react-router-dom을 설치한다. react-router-dom을 import 한다. URL history 추가하기 Call Stack 초과를 막는 법 -&gt; 모든 것을 비동기 코드로 돌린다. setTimeout을 이용한다. 용어 - ( 러버덕 ) 환경변수 정의하는 법 쿼리스트링 REST API history 작성 Call Stack 초과시 해결 요령 환경변수 정의 하기 환경 변수는 process.env 라는 예약어를 통해서 만든다. Node.js에서는 process.env까지 예약어고, React에서는 process.env.REACT_APP_ 까지 예약어이다. 그 후부터는 임의로 네이밍할 수 있는 변수. 변수는 최대한 자세하게 그리고 전부 대문자로 작성한다. 1234const params = &#123; key: process.env.REACT_APP_YOUTUBE_API_KEY ...&#125; process.env는 리액트가 실행될때 가지고 오기 때문에 .env 설정이 끝나면 재 실행해야한다. .evn 파일 생성.gitignore 와 같은 위치 .env 파일을 생성한다. 그리고 다음과 같이 작성한다. 1REACT_APP_YOUTUBE_API_KEY=키 값 작성 값을 작성할 때 규칙 &#39;&#39;의 형태로 문자열로 작성하면 안된다. ;을 적으면 안된다. 다음 환경 변수를 작성하고 싶다면 엔터를 쳐서 다음 라인으로 넘어간다. 주석은 //로 시작한다. (예 : // 주석입니다. ) .gitignore에 .env 추가1234567# misc.env // 여기 추가.DS_Store.env.local // 개발자가 보는 환경.env.development.local // 개발자가 보는 환경.env.test.local // 아래는 테스팅 환경.env.production.local // 실제 배포 환경 번외 : .env 파일을 만들지 않고 npm start 할 때마다 키값 넘겨주기(권장하진 않음)맥 , 리눅스 (유닉스 기반 OS) 1REACT_APP_KEY= 키내용 npm start 윈도우 1($env:REACT_APP_key = &quot;키내용&quot;) -and (npm start) Router라우터는 다음과 같은 이유로 사용한다. URL이 바뀌지 않아 특정 페이지를 공유할 수 없다. 새로고침하면 상태를 유지하지 못해 처음 화면으로 돌아간다. 각각의 페이지에 고유한 데이터를 넣을 수 있다. URL 주소를 컴포넌트 단위로 분리시키고 주소에 해당되는 컴포넌트를 뿌려준다. 1npm i react-router-dom --save App.js 12345import &#123; BrowserRouter as Router, Switch, Route&#125; from 'react-router-dom' 123456789101112const App = () =&gt; &#123; return ( &lt;Router&gt; &lt;Switch&gt; &#123;/* 쿼리스트링 */&#125; &lt;Route path='/watch'&gt;&lt;/Route&gt; &#123;/* REST API 전달 */&#125; &lt;Route path='/watch/:id' component=&#123;VideoPlayer&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; )&#125; &lt;Router&gt; : Route 를 하기위한 모든 컴포넌트들을 모아놓은 집합 태그. &lt;Switch&gt;&lt;/Switch&gt; 자바스크립트의 조건 switch와 같다. (path가 조건이다. 조건에 해당되면 자동으로 break) &lt;Route path=&#39;/watch&#39;&gt;&lt;/Route&gt; : 실질적으로 Component를 지정해주는 태그. path가 비교조건 파라미터를 넘기는 방법 2가지쿼리 스트링Query String 이란 ? 예시 : https://www.youtube.com/watch?v=hHW1oY26kxQ https://www.youtube.com/watch는 유튜브측에서 정의한 주소. 즉, 고정된 것. ?뒤 부터는 변수명=변수값이다. 이어줄때는 &amp;를 사용한다. ?뒤부터 나오는 값들을 queryString이라 한다. 변수 &amp;를 통해서 데이터를 연달아 보내는 것이 가능하다. 사용자에게 쿼리를 설정하는 것이기 떄문에 라우팅 설정을 줄일 수 있다. 1234// 쿼리 스트링 전달https://www.youtube.com/watch?v=hHW1oY26kxQ// 여러개 전달https://www.youtube.com/watch?v=hHW1oY26kxQ&amp;custume=data&amp;key=keykey REST API오직 1개의 데이터를 보낼 수 있다. 여러개를 연달아 보낼 수 없다. REST API의 경우 엄격하게 규칙을 지정하고 있다. 하나하나 라우팅 설정을 모두 해야한다. 12// 일반적인 REST API 규격 정의https://www.youtube.com/watch/hHW1oY26kxQ SwitchSwitch에서 라우팅의 path가 일치한다면 바로 실행하고 끝낸다. path가 https://www.youtube.com/watch?id=hHW1oY26kxQ 라고 가정하자. 그리고 Switch가 이렇게 정의가 되어있다. 123456&lt;Router&gt; &lt;Switch&gt; &lt;Route path='/watch' component=&#123;VideoPlayer&#125; /&gt; &lt;Route path='/watch/:id' component=&#123;VideoPlayer&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt; 문제는 이렇게 될 경우 전체 path를 비교하는 데 부분으로 일치한다면 바로 실행하고 끝내버린다. 즉, 1번째 &lt;Route path=&#39;/watch&#39; component={VideoPlayer} /&gt; 의 path=&#39;/watch&#39; 는 일치한다. 뒷부분은 무시하고 이 부분이 일치를 하기 때문에 바로 실행해버린다. 따라서 2번째 &lt;Route path=&#39;/watch/:id&#39; component={VideoPlayer} /&gt;는 절대로 실행할 수 없게된다. 해결방법 1 : exactpath 앞에 exact를 명시 해준다면 전체 다 비교를 한다. 단, exact는 100%일치해야되기 때문에 값이 변하는 변수를 사용할 수 없다. id값이 게속 고정된다면 문제가 없지만 id값이 변한다면 &lt;Route path=&#39;/watch/:id&#39; component={VideoPlayer} /&gt;는 사용할 수 없다. 1234&lt;Switch&gt; &lt;Route exact path='/watch' component=&#123;VideoPlayer&#125; /&gt; &lt;Route path='/watch/:id' component=&#123;VideoPlayer&#125; /&gt;&lt;/Switch&gt; 해결방법 2 : 중요도가 높은 라우팅을 먼저 선언해준다.1234&lt;Switch&gt; &lt;Route path='/watch/:id' component=&#123;VideoPlayer&#125; /&gt; &lt;Route path='/watch' component=&#123;VideoPlayer&#125; /&gt;&lt;/Switch&gt; 실습 라우팅해보기전제 : 특정 버튼이나 링크를 클릭해서 URL 주소가 바뀌었다고 가정하자. (실제로는 바뀌지 않고 변경된 것처럼 보이는 것.) 라우트 지정해주고, &lt;Route&gt; 에 component에 적어주기. App.js 12345678910111213141516171819import React from 'react';import &#123; BrowserRouter as Router, Switch, Route&#125; from 'react-router-dom'import VideoPlayer from './VideoPlayer';const App = () =&gt; &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path='/watch/:id' component=&#123;VideoPlayer&#125; /&gt; &lt;Route path='/watch' component=&#123;VideoPlayer&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; )&#125; 쿼리 스트링 사용하기 npm 설치 1npm i query-string --save 사용하고자 하는 .jsx 컴포넌트 파일에 접근한다. VideoPlayer.jsx 쿼리스트링을 import 한다. 1import qs from 'query-string' 쿼리 스트링 사용하기 1qs.parse(props.location.search) props.location.search는 URL의 QueryString(? 뒤 내용) 들을 객체로 변환해준다. 예를들어, https://www.youtube.com/watch?id=hHW1oY26kxQ?custom=aaaa 라는 URL이라 가정하면 qs.parse(props.location.search)로 객체화 되면 1234&#123; id : hHW1oY26kxQ, custom : aaaa&#125; 이렇게 된다. 이것을 상수로 받아준다. 12345678910const VideoDetail = props =&gt; &#123; // Query String const &#123;v&#125; = qs.parse(props.location.search) return ( &lt;div className=\"video-detail\"&gt; &lt;/div&gt; );&#125;;export default VideoDetail; REST API 사용하기사용하고자 하는 .jsx 컴포넌트 파일에 접근한다. VideoPlayer.jsx 1234567891011const VideoDetail = props =&gt; &#123; // REST API const &#123; id &#125; = props.match.params.id; // const id = props.match.params.id; return ( &lt;div className=\"video-detail\"&gt; &lt;/div&gt; );&#125;;export default VideoDetail; 1const id = props.match.params.id; props.match.params 뒤부터 적은 프로퍼티는 라우트에서 적은 값들을 적어준다. path=&#39;/watch/:id&#39;== props.match.params.id REST API 와 쿼리스트링 둘 다 사용하기 VideoPlayer.jsx 1234567891011121314151617181920212223import React from \"react\";import \"./VideoPlayer.css\";import qs from 'query-string'const VideoDetail = props =&gt; &#123; // REST API const &#123; id &#125; = props.match.params.id; // const id = props.match.params.id; // Query String const &#123;v&#125; = qs.parse(props.location.search) const _id = id || v; if (!_id) return null; const url = `https://youtube.com/embed/$&#123;_id&#125;`; return ( &lt;div className=\"video-detail\"&gt; &lt;iframe src=&#123;url&#125; title=&#123;videoId&#125; className=\"video-player\" /&gt; &lt;/div&gt; );&#125;;export default VideoDetail; REST로 받은 id 와 쿼리스트링으로 받은 v 모두 사용해서 넘겨준다. 1const url = `https://youtube.com/embed/$&#123;id || v&#125;`; URL(주소가) 바뀐 것처럼 보여주기.URL이 바뀌는 것처럼 보여지나 브라우저 히스토리만 추가를 해서 실제로 바뀌지는 않는다. 또한 히스토리를 추가해주면 브라우저의 뒤로가기 버튼도 사용이 가능해진다. 1. 리액트 DOM을 렌더링 해주기 위해서 react-router-dom을 설치한다.1npm i react-router-dom --save 2. react-router-dom을 import 한다.Main.js 12345import &#123; withRouter &#125;from \"react-router-dom\";/* 소스 - 기존의 App.js 소스들 카피/페이스트*/export default withRouter(App); 3. URL history 추가하기SPA에서는 새로고침/페이지 이동은 금지시 한다. 따라서 history키워드를 통해서 URL에 쿼리나 REST API 값 전달이 가능하다. 이제는 this.setState가 아니라 this.props.history.push 키워드를 통해 url을 변경한다. 1this.props.history.push(`/watch?v=$&#123;selectedVideo&#125;`) SPA는 위와같이 url을 변경하여도 새로고침이 발생하지 않는다. 여기서 single page는 주소가 single이 아니라 페이지가 single - 페이지 이동이 없는 것. 리액트 라우터의 히스토리 푸시는 주소창에 주소만 바꿔줄뿐 페이지의 이동은 없기 때문에 console.log도 그대로 남고 모든 상태가 그대로 남음. &lt;a href=&quot;http://&quot;&gt; 하이퍼링크는 클릭하면 새 탭을 여는 역할 - 완전한 초기상태로 새로운 브라우저 탭을 만드는 것과 같다. 12345// 진짜 주소 이동window.location.href// 주소를 추가 - 페이지변경Xthis.props.history.push Call Stack 초과를 막는 법 -&gt; 모든 것을 비동기 코드로 돌린다.setTimeout을 이용한다.콜스택 초과 오류날 때 setTimeout을 이용하면 대부분 해결된다. 1setTimeout(() =&gt; this.props.history.push(`/results?search_query=$&#123;query&#125;`), 0)","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm54","slug":"daily-algorithm54","date":"2019-12-13T11:48:56.000Z","updated":"2019-12-13T11:51:53.367Z","comments":true,"path":"2019/12/13/daily-algorithm54/","link":"","permalink":"https://hyeok999.github.io/2019/12/13/daily-algorithm54/","excerpt":"","text":"이상한 문자열 만들기문제 설명문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요. 제한 사항 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다. 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다. 입출력 예 s return try hello world TrY HeLlO WoRlD 입출력 예 설명try hello world는 세 단어 try, hello, world로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 TrY, HeLlO, WoRlD입니다. 따라서 TrY HeLlO WoRlD 를 리턴합니다. 1234567891011121314151617function solution(s) &#123; var answer = ''; var str = s.split(' '); for(let i = 0; i &lt; str.length; i++)&#123; for(let j = 0; j &lt; str[i].length; j++)&#123; if(!(j % 2)) &#123; answer += str[i][j].toUpperCase(); &#125; else &#123; answer += str[i][j].toLowerCase(); &#125; &#125; if(i != str.length - 1 ) answer += ' '; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"React 스터디 05","slug":"react-study-05","date":"2019-12-12T13:45:03.000Z","updated":"2019-12-12T13:52:08.798Z","comments":true,"path":"2019/12/12/react-study-05/","link":"","permalink":"https://hyeok999.github.io/2019/12/12/react-study-05/","excerpt":"","text":"React Study 05 this.setState의 2가지 작용 의미있는 업데이트를 연속적으로 불러들일 때 같은 코드가 반복 될 때 Style Component import 변수명 from ~~폴더명 = 해당 폴더 index.js 로드 SearchBar 동영상 선택 판단하기 InfiniteScroll 용어 - ( 러버덕 ) this.setState SearchBar InfiniteScroll debounce this.setState의 2가지 작용1. 의미있는 업데이트를 연속적으로 불러들일 때1234567891011121314151617181920212223242526this.state = &#123; count: 0&#125;// 쓰지 말아야할 코드 : count가 4가 출력될것으로 예상하나 몇이 출력될지는 예상할 수 없다.updateCount = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1&#125;); this.setState(&#123; count: this.state.count + 1&#125;); this.setState(&#123; count: this.state.count + 1&#125;); this.setState(&#123; count: this.state.count + 1&#125;);&#125;// Promiseasync updateCount = () =&gt; &#123; await new Promise(resolve =&gt; this.setState(&#123; count : this.state.count + 1&#125;, resolve)); await new Promise(resolve =&gt; this.setState(&#123; count : this.state.count + 1&#125;, resolve)); await new Promise(resolve =&gt; this.setState(&#123; count : this.state.count + 1&#125;, resolve));&#125;// 콜백함수, 함수형 updateCount = () =&gt; &#123; this.setState((prevState) =&gt; &#123; count : prevState.count + 1 &#125;; this.setState((prevState) =&gt; &#123; count : prevState.count + 1 &#125;; this.setState((prevState) =&gt; &#123; count : prevState.count + 1 &#125;;&#125; 위와 같이 State를 업데이트 할 때는 콜백으로 던져주거나 혹은 Promise를 사용하여 순서를 보장시켜야만 한다. ( 프로미스 사용 추천 ) this.setState는 비동기 함수이므로 순서를 보장하지 못한다. 따라서 언제 count값이 올라갈지 예측 못하기 떄문에 위와 같은 코드를 적을 땐 반드시 Promise와 await를 이용하거나 함수형으로 setState값을 지정해주어야한다. 2. 같은 코드가 반복 될 때1234567updateCount = () =&gt; &#123; this.setState(&#123;quantity: 2&#125;); this.setState(&#123;quantity: 2&#125;); this.setState(&#123;quantity: 2&#125;); this.setState(&#123;quantity: 2&#125;); this.setState(&#123;quantity: 2&#125;);&#125; 위 처럼 의미없는 코드가 연속적으로 반복될 경우, React는 코드를 하나로 일괄 처리 한다. Style ComponentStyle Component : CSS를 javascript 처럼 코딩할 수 있게 하는 것. css 코드 안에서 js코드를 직접적으로 사용이 가능하다. import 변수명 from ~~폴더명 = 해당 폴더 index.js 로드import 시 폴더 명으로 끝날 경우 index.js를 디폴트로 찾는다는 것을 의미한다. 이것을 응용할 경우 하나의 index.js를 선언해주고 그 index.js에서 각각의 이미지들을 로드해온다면 다음과 같이 응용해서 사용할 수 있다. images/index.js 1234module.exports = &#123; spinner : require('./spinner.gif'); spinner2 : require('./spinner2.gif');&#125; App.js - import 123import &#123;spinner, spinner2&#125; from './components/images';// import spinner from './components/images/index.js';// import spinner2 from './components/images/index.js'; SearchBar 자동 검색 ( 검색 아이콘 버튼 이 없다. ) 키보드 엔터 시 검색 검색 아이콘 버튼 클릭 시 검색 1번과 2번을 혼합해서 쓰거나 2번과 3번을 혼합해서 쓰거나 한다. 1번 2번 3번을 전부 사용하는 것은 추천하지 않는다. 1. 자동 검색lodash의 { debounce } 를 이용한다. debounce는 최초 입력이 되었을 경우 지정해준 시간동안 입력했던 모든 입력을 무시하고 시간이 끝날 마지막에 입력된 값만을 입력으로 취급받는다. debounce의 권장 지연시간은 0.5 초(500ms) 이다. debounce를 사용하는 가장 큰 목적은 불필요한 네트워크 요청을 막을 수 있다는 것이다. 스크롤과 같은 곳에 많이 쓰인다. 1&lt;SearchBar onSearchVideos=&#123;debounce(this.getYoutubeData, 500)&#125;/&gt; SearchBar의 input 123456&lt;input type=\"text\" onChange=&#123;e =&gt; props.setInput(e.target.value)&#125; className=\"search-bar\" placeholder=\"검색어를 입력하세요\"/&gt; 위 onChange 이벤트 프로퍼티는 요소의 값이 변경될 때마다 이벤트를 일으키는데 여기에 데이터를 불러오는 함수를 연결할 경우 무언가 입력될 떄마다 해당 함수가 실행되면서 불필요한 요청을 지속적으로 일으킬 것이다. 이를 방지하고자 debounce를 사용한다. 2. 키보드 엔터 시 검색따로 해당 이벤트를 받아 사용하는 HOC를 작성하거나 직접적으로 인라인에 작성하는 방법이 있다. 12345678910111213141516const handleEnter = search =&gt; e =&gt; &#123; if (e.key === 'Enter') &#123; serach(e.target.value); &#125;&#125;&lt;input type=\"text\" onChange=&#123;e =&gt; props.setInput(e.target.value)&#125; // 인라인 방법들 주석 // onKeyPress=&#123;e =&gt; e.key === 'Enter' ? props.onSearchVideos(e.target.value) : () =&gt; &#123;&#125;&#125; // onKeyPress=&#123;e =&gt; if(e.key === 'Enter') &#123; props.onSearchVideos(e.target.value); &#125;&#125; onKeyPress=&#123;handleEnter(props.onSearchVideos)&#125; // HOC className=\"search-bar\" placeholder=\"검색어를 입력하세요\"/&gt; 3. 검색 아이콘 버튼 클릭 시 검색ref는 해당하는 리액트 컴포넌트를 DOM 객체처럼 직접 접근하는 지정된 키워드(예약어). 즉, DOM 요소에 직접적으로 접근해서 자신의 요소에 있는 프로퍼티들을 참조한다. 1ref = &#123;refs =&gt; (input = refs)&#125; ref의 직접적인 값은 undefined를 받지만 ref의 화살표로 던지는 인자 값(변수)인 refs에는 DOM 요소에 직접적으로 접근해서 자신의 요소에 있는 프로퍼티들을 참조한다. 여기서 refs는 self라고도 불리우며 ref를 포함하고 있는 요소 자체를 가르킨다. 123456789101112131415let input;return ( &lt;div className=\"search-wrapper\"&gt; &lt;input ref = &#123;ref =&gt; input = ref&#125; type=\"search\" className=\"search-bar\" placeholder=\"검색어를 입력하세요\" /&gt; &lt;button className=\"btn-search\" onClick=&#123;() =&gt; props.onSearchVideos(input.value)&#125;&gt; &lt;img className='search-icon' src=&#123;searchIcon&#125; alt=\"검색\"/&gt; &lt;/button&gt; &lt;/div&gt;) 만약 ref에 해당되는 console.log을 찍어보고 싶다면 다음과 같이 소스를 짜도록한다. 123456&lt;input ref = &#123;ref =&gt; &#123; console.log(ref) return input = ref &#125;&#125;/&gt; &amp;&amp; 는 항상 boolean 값을 반환하고 || 는 true인 값을 반환한다.( boolean값을 반환하는게 아니다. ) 사용자가 검색을 수행한다.(getYoutubeData를 통해 쿼리를 입력한다) 얻어온 값을 videoList 필요한데이터 -&gt; this.state -&gt; {…this.state}로 전부 넘긴다. -&gt; video가 선택이 되었을 때 사용할 state를 동적으로 추가가 가능하지만 기본 권장사항은 초기화를 해놓는 것이다. 실제 렌더링 되는 코드는 가능한 짧게 구상하는것이 좋다. 동영상 선택 판단하기라우팅 : url을 만들어서 페이지를 나누는 것. 현재 리액트 라우팅없이 작업을 하고 있기 때문에 하나의 페이지에서 UI를 뿌려주려면 조건부 렌더링을 해야만한다. 따라서 분기점을 나누어야하므로 사용자가 비디오를 클릭한 여부에 따라 나누도록 하겠다. selectedVideo가 가리키는 것은 선택된 비디오의 아이디 이다. 사용자가 동영상을 클릭했다면 selectedVideo는 특정 값(vedioId)을 가르키고 있을 것이다. 따라서, selectVideo 가 null 이라면, 비디오 리스트를 보여준다. VideoList selectVideo가 특정 값을 가지고 있다면 영상이 선택된 것이므로 해당 영상을 재생하는 VideoPlayer -&gt; iframe을 보여준다. 12345678910111213141516render () &#123; const &#123; selectedVideo &#125; = this.state; return ( &lt;div className=\"App\"&gt; &lt;Nav&gt; &lt;SearchBar onSearchVideos=&#123;debounce(this.getYoutubeData, 500)&#125;/&gt; &lt;/Nav&gt; &#123; selectedVideo ? &lt;VideoPlayer videoId = &#123; selectedVideo &#125; /&gt; : &lt;VideoList &#123;...this.state&#125; onVideoSelect = &#123;selectedVideo =&gt; this.setState(&#123; selectedVideo &#125;)&#125; /&gt; &#125; InfiniteScroll123456789101112131415&lt;InfiniteScroll loadMore = &#123;() =&gt; this.getYoutubeData(this.state.query)&#125; hasMore = &#123;!!this.state.nextPageToken&#125; loader = &#123; &lt;div key=&#123;uuid.v4()&#125; className=\"loader\"&gt; &lt;img src=&#123;spinner&#125; alt=\"loading\" /&gt; &lt;/div&gt; &#125;&gt; &#123;/* 무한로딩으로 렌더링될 모든 컴포넌트 */&#125; &lt;VideoList &#123;...this.state&#125; // onVideoSelect = &#123;selectedVideo =&gt; this.setState(&#123; selectedVideo &#125; onVideoSelect = &#123; this.setVideo &#125; /&gt;&lt;/InfiniteScroll&gt; loadMore : 사용자가 스크롤 바가 끝에 도달했을 떄 실행할 함수를 받는다.(반드시 화살표로 함수를 받아야한다.) hasMore : 더 페이지를 로드할것이 있는지 판단한다.( boolean 타입 ) loader : loadMore이 실행되고 데이터를 가지고 오는 동안 일어날 일을 정리한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"엘리먼트(요소) 렌더링","slug":"react-official-02","date":"2019-12-12T13:44:55.000Z","updated":"2019-12-29T16:48:23.132Z","comments":true,"path":"2019/12/12/react-official-02/","link":"","permalink":"https://hyeok999.github.io/2019/12/12/react-official-02/","excerpt":"","text":"React Official Document주요개념 : 엘리먼트(요소) 렌더링 React 엘리먼트(요소)란? DOM에 요소 렌더링하기 렌더링 된 요소 업데이트하기 React는 변경된 부분만 업데이트 한다. React Official Document주요개념#2. 엘리먼트(요소) 렌더링React 엘리먼트(요소)란? 1const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; 위와 같은 객체를 React Element(하위 요소)라 한다. React Element(요소)는 컴포넌트의 구성 요소 이며, React 앱의 가장 작은 단위이다. React는 React 요소를 읽은 후 DOM을 구성하고 최신으로 유지하는 데 React 요소를 사용한다. 일반 DOM 요소와 달리 React 요소는 일반 객체이며 React DOM은 React 요소와 일치하도록 DOM을 업데이트 한다. DOM에 요소 렌더링하기HTML 파일에 div 태그가 있다고 가정해보자. 1&lt;div id=\"root\"&gt;&lt;/div&gt; 위 태그의 하위로 들어가는 모든 요소는 React DOM에 의해 관리되므로 위의 태그를 &quot;root&quot; DOM 노드 라고 부른다. React로 구현된 애플리케이션은 일반적으로 하나의 루트 DOM 노드가 있다. React를 기존 앱에 통합하려는 경우 원하는 만큼 많은 수의 독립된 루트 DOM 노드를 만들 수 있다. React 요소를 루트 DOM 노드에 렌더링하려면 둘 다 ReactDOM.render()로 전달하면 된다. 123const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById('root'));// ReactDOM.render(리액트 요소, 삽입할 DOM 노드 요소를 선택하는 이벤트 객체 함수 호출); 렌더링 된 요소 업데이트하기React 요소는 불변객체다. 요소를 생성한 이후에는 해당 요소의 자식이나 속성을 변경할 수 없다. 요소는 영화에서 하나의 프레임과 같이 특정 시점의 UI를 보여준다. 지금까지 내용을 바탕으로 하면 UI를 업데이트하는 유일한 방법은 새로운 요소를 생성하고 이를 바뀔때마다 ReactDOM.render()로 전달하는 것 뿐이다. 123456789101112function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById('root'));&#125;setInterval(tick, 1000);// 1초마다 새로운 시간을 반환한다. 주의 : 실제로 대부분의 React 앱은 ReactDOM.render()를 한 번만 호출한다. 위는 단지 예시일 뿐 이다. React는 변경된 부분만 업데이트 한다.React DOM은 해당 요소와 그 하위 요소를 이전의 요소와 비교하고 DOM을 원하는 상태로 만드는데 필요한 경우에만 DOM을 업데이트한다. 위 그림을 보면 처음에만 전체가 렌더링 된 후 그 뒤 부터는 해당 텍스트부분만 지속적으로 바뀌는 것을 확인할 수 있다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"daily_algorithm53","slug":"daily-algorithm53","date":"2019-12-12T13:44:36.000Z","updated":"2019-12-12T13:48:39.729Z","comments":true,"path":"2019/12/12/daily-algorithm53/","link":"","permalink":"https://hyeok999.github.io/2019/12/12/daily-algorithm53/","excerpt":"","text":"직사각형 별찍기문제 설명이 문제에는 표준 입력으로 두 개의 정수 n과 m이 주어집니다.별(*) 문자를 이용해 가로의 길이가 n, 세로의 길이가 m인 직사각형 형태를 출력해보세요. 제한 조건 n과 m은 각각 1000 이하인 자연수입니다. 예시입력 15 3 출력 123*************** 12345678910111213process.stdin.setEncoding('utf8');process.stdin.on('data', data =&gt; &#123; const n = data.split(\" \"); const row = '*'.repeat(Number(n[0])); let answer = ''; for(let i = 0; i &lt; Number(n[1]); i++)&#123; answer += row; answer += '\\n'; &#125; console.log(answer);&#125;); 자연수 뒤집어 배열로 만들기문제 설명자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다. 제한 조건 n은 10,000,000,000이하인 자연수입니다. 입출력 예 n return 12345 [5,4,3,2,1] 123function solution(n) &#123; return String(n).split('').reverse().map((item) =&gt; +item);&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm52","slug":"daily-algorithm52","date":"2019-12-11T10:45:50.000Z","updated":"2019-12-11T10:47:48.396Z","comments":true,"path":"2019/12/11/daily-algorithm52/","link":"","permalink":"https://hyeok999.github.io/2019/12/11/daily-algorithm52/","excerpt":"","text":"제일 작은 수 제거하기문제 설명정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다. 제한 조건 arr은 길이 1 이상인 배열입니다. 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다. 입출력 예 arr return [4,3,2,1] [4,3,2] [10] [-1] 12345function solution(arr) &#123; return arr.length == 1 ? [-1] : arr.splice(arr.indexOf(Math.min(...arr),1)&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"React 스터디 04","slug":"react-study-04","date":"2019-12-10T11:29:39.000Z","updated":"2019-12-10T11:31:29.111Z","comments":true,"path":"2019/12/10/react-study-04/","link":"","permalink":"https://hyeok999.github.io/2019/12/10/react-study-04/","excerpt":"","text":"React Study 04 비동기 처리 fetch 단점 +then 대신 async/await +try - catch 비동기 코드 내 순회 YouTube Mini Clone 인수 기본값 설정하기. Axios , params 별도로 설정하기. debounce 함수 함수 컴포넌트 vs 클래스 컴포넌트 모든 상태를 하위 컴포넌트에게 전달하는법 HOC ( High Order Component ) InfiniteScroll uuid defaultState 백업 Update 이벤트 용어 - ( 러버덕 ) fetch 단점 try / catch 인수 기본값 성저하기 Axios, params 별도 설정 debounce 함수 HOC debounce , infiniteScroll, uuid Update 이벤트 비동기 처리 fetch 단점 크로스 브라우징 이슈 쿠키를 포함하려면 특정 npm을 랩핑해줘야 한다. status가 response 체크를 받아야만 한다. fetch에 대한 별도의 핸들링 모듈을 전부 설치를 해주어야한다. 어느 회사에 가느냐에 따라 사용하는 ajax가 다를 테지만 왠만하면 axios를 사용하는 것이 좋다. + then 대신 async/awaitPromise 에서 then 을 게속 나열하는 것보다는 async / await를 사용하도록 한다. then을 지속적으로 나열하다보면 반복 순회( for )를 하기가 힘들어지며 가독성이 매우 심하게 떨어지기 때문이다. + try - catchasync / await 에서 에러처리를 할때는 try - catch를 사용한다. try - catch는 에러처리 뿐만 아니라 다음 순서를 보장해줄 수 있기 때문에 반드시 사용하는것을 권장한다. 또한, try - catch 구문은 비동기 코드 별로 분리해서 설정해준다. 1234567891011121314 try &#123; const &#123; data &#125; = await axios.get('api주소',&#123; params &#125; ) this.setState(&#123;list : data.items &#125;); &#125; catch (error) &#123; console.error(error); &#125;// 위 try - catch 문이 에러를 일으켜도 지금 try - catch 문은 실행을 한다. try &#123; const &#123; data &#125; = await axios.get('api주소',&#123; params &#125; ) this.setState(&#123;list : data.items &#125;); &#125; catch (error) &#123; console.error(error); &#125; 비동기 코드 내 순회프로미스 체이닝 및 비동기 처리에는 forEach를 돌려서는 안된다. 실행순서를 보장받을 수 없다. 123456789101112const after1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1),1000))const after2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2),2000))const after3 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3),3000))const main = () =&gt; &#123; const tasks = [after3, after2, after1]; // 잘못된 예제 tasks.forEach(async task =&gt; console.log(await (task)))&#125;main() 예상과 달리(after3, 2, 1순서로 진행) 결과값은 1 2 3이 나온다. 비동기 처리된 배열을 forEach로 순회할 경우 순서가 보장되지 않는다. 만약 비동기 코드 내에서 for 순회를 하고 싶다면 for of를 사용한다. 실행순서는 보장받을 수 없다. 1234567891011121314const after1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1),1000))const after2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2),2000))const after3 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3),3000))const main = async () =&gt; &#123; const tasks = [after3, after2, after1]; // 올바른 예제 for (const t of tasks) &#123; console.log(await (t)) &#125;&#125;main(); 비동기에서 순회가 필요할 경우 for…of를 사용해야 한다. state를 초기화를 안하면 setState를 사용할 수 없다. state를 초기화하고 아무것도 정의를 안해도 setState에 적용된 내용을 삽입하고 state에 데이터가 있다면 setState를 통해 업데이트 된다. (UPSERT) YouTube Mini CloneUPSERT : Insert + Update를 혼합한 용어. 데이터가 없으면 생성, 있으면 업데이트 한다는 의미를 지닌다. try / catch를 사용하지 않을 경우 오류 핸들링이 되지 않기 때문에 다음 코드가 실행되지 않는다. try / catch 사용시 에러를 잡고 나서도 다음 코드 실행이 보장된다. 만약, 반드시 실행되어야 하는 중요한 비동기 작업이라면 각각 try / catch로 구분해서 관리하는 것이 좋다. 인수 기본값 설정하기.123async getYoutubeData(query='여행') &#123; ...&#125; Axios , params 별도로 설정하기.123456789101112131415async getYoutubeData(query='여행') &#123; const params = &#123; key : '', q : query, part : 'snippet', maxResults: 10, pageToken: nextPageToken &#125; try &#123; const &#123; data &#125; = await axios.get('https://www.googleapis.com/youtube/v3/search', &#123; params &#125;) this.setState(&#123;list : data.items &#125;); &#125; catch (error) &#123; console.error(error); &#125; &#125; 그대로 url을 전부 적게 될 경우 너무 길어지기 때문에 가장 기본 링크를 가져오고 params 객체를 별도로 선언한다. (가독성 ⇪) debounce 함수lodash가 관리하고 있는 메소드. 다음으로 설치하고 import 하여 사용할 수 있다. 123npm i lodash --save // bashimport &#123; debounce &#125; from 'lodash'; // 코드 내 삽입&lt;SearchBar onSearchVideos=&#123;debounce(this.getYoutubeData, 500) /&gt; // 사용 예 debounce 이벤트가 발생한 뒤부터 특정 시간 동안 기다린 이후에 이벤트가 발생한다. 최소 500(ms 단위)은 해야 효과를 볼 수 있다. 1debounce(this.getYoutubeData, 500); 1인자 : debounce를 걸 함수 2인자 : debounce 딜레이 지연시간 ms 함수 컴포넌트 vs 클래스 컴포넌트클래스 컴포넌트는 유상태인 컴포넌트에서 사용하는 것이 좋다.(state를 관리하는 컴포넌트) 함수 컴포넌트는 무상태인 컴포넌트에서 사용한다. ( 유상태인 컴포넌트에게 props로 상태를 전달받아 이용한다. ) 일반적으로 최상위 컴포넌트는 state를 관리하고 있으며 하위 컴포넌트는 state가 없고, props로 전달받아 사용하는 것이 좋다. 모든 상태를 하위 컴포넌트에게 전달하는법{...this.state} 를 이용한다. 1&lt;SearchBar &#123;...this.state&#125; /&gt; // 예 HOC ( High Order Component )함수 내에서 인수로 들어온 함수를 이용하는 것. 12345const handleEnter = search =&gt; e =&gt; &#123; if(e.key === 'enter') &#123; search(e.target.value) &#125;&#125; 위 HOC를 풀면 아래처럼 된다. 1234567function a(search) &#123; function b(e) &#123; if(e.key === 'enter') &#123; search(e.target.value) &#125; &#125;&#125; InfiniteScroll1npm i react-infinite-scroller --save loadMore : 실제로 데이터를 불러오는 함수 ( 무조건 화살표 함수 ) hasMore : 기준점 (다음 페이지의 토큰이 있을 경우 등등) loader : 로딩중 보여줄 스피너등으로 표시함 uuid1npm i uuid --save 고유한 랜덤 키 값을 생성하고자 할 때 사용한다. 123import uuid from 'uuid'; &lt;div key=&#123;uuid.v4()&#125; /&gt; // 코드 사용 defaultState 백업검색어가 바뀌었을 때 화면이 바뀌는데, 기존상태로 돌아갈 경우 모든 속성을 초기화하는 것보다 초기 상태의 State로 바꾸는게 편리하다.하위 컴포넌트들은 상태를 갖고 있지 않고(가능하면 상태가 없는걸로 만듦) Props로 전달받아 사용한다.또한, 가능하면 jsx코드 내에서는 리턴에서만 UI 보여주는게 좋다. Update 이벤트 3가지 방법으로 업데이트를 받을 것 : 즉시 업데이트, 엔터키 입력시 업데이트, 버튼 눌렀을 때 업데이트 onChange는 e를 받고 onKeyPress는 e를 받지 않았음 왜일까? 결과적으론 같은데 다른 방법 두 가지를 나타낸 것 1234567&lt;input type=\"search\" onChange=&#123;e =&gt; props.onSearchVideos(e.target.value)&#125; onKeyPress=&#123;handleEvent(props.onSearchVideos)&#125; className=\"input-search\" placeholder=\"검색어를 입력해주세요\" /&gt; onKeyPress가 반환하는 것은 두번째 매개변수로 전달된 함수 전체. 즉 props.onSearchVideos(e.target.value) 12345const handleEvent = search =&gt; e =&gt; &#123; if (e.key === 'Enter') &#123; search(e.target.value) &#125; &#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm51","slug":"daily-algorithm51","date":"2019-12-10T11:24:51.000Z","updated":"2019-12-10T11:27:45.182Z","comments":true,"path":"2019/12/10/daily-algorithm51/","link":"","permalink":"https://hyeok999.github.io/2019/12/10/daily-algorithm51/","excerpt":"","text":"문제 설명다트 게임카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~ 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다.갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다. 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다. 옵션으로 스타상(*) , 아차상(#)이 존재하며 스타상(*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다. 스타상(*)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(*)의 점수만 2배가 된다. (예제 4번 참고) 스타상(*)의 효과는 다른 스타상(*)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고) 스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고) Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다. 스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다. 0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라. 입력 형식점수|보너스|[옵션]으로 이루어진 문자열 3세트.예) 1S2D*3T 점수는 0에서 10 사이의 정수이다. 보너스는 S, D, T 중 하나이다. 옵선은 *이나 # 중 하나이며, 없을 수도 있다. 출력 형식3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다.예) 37 입출력 예제 예제 dartResult answer 설명 1 1S2D*3T 37 11 * 2 + 22 * 2 + 33 2 1D2S#10S 9 12 + 21 * (-1) + 101 3 1D2S0T 3 12 + 21 + 03 4 1S*2T*3S 23 11 * 2 * 2 + 23 * 2 + 31 5 1D#2S*3S 5 12 * (-1) * 2 + 21 * 2 + 31 6 1T2D3D# -4 13 + 22 + 32 * (-1) 7 1D2S3T* 59 12 + 21 * 2 + 33 * 2 1234567891011121314151617181920212223242526272829303132333435function solution(dartResult) &#123; const arr = dartResult.split(''); const starCount = dartResult.match(/[*]/g); let result = 0; let num = 0; let grade = 0; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === 'S' || arr[i] === 'D' || arr[i] === 'T') &#123; grade = +arr[i - 2] === 1 ? 10 : +(arr[i - 1]); num = grade * (arr[i] === 'S' ? 1 : arr[i] === 'D' ? grade : grade * grade); if (arr[i + 1] === '*') &#123; result *= 2; result += num * 2; &#125; else if (arr[i + 1] === '#') &#123; result += num * -1; &#125; else &#123; result += num; &#125; &#125; &#125; // 마지막에 *이 있다면 처음 던진 점수를 빼준다. if (arr[arr.length - 1] === '*') &#123; for (let i = 0; i &lt; 3; i++) &#123; if (arr[i] === 'S' || arr[i] === 'D' || arr[i] === 'T') &#123; grade = arr[i - 2] === 1 ? 10 : +(arr[i - 1]); result -= Math.pow(grade * (arr[i] === 'S' ? 1 : arr[i] === 'D' ? grade : grade * grade), starCount.length); break; &#125; &#125; &#125; return result;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"JSX 소개","slug":"react-official-01","date":"2019-12-09T14:40:19.000Z","updated":"2019-12-29T16:48:13.832Z","comments":true,"path":"2019/12/09/react-official-01/","link":"","permalink":"https://hyeok999.github.io/2019/12/09/react-official-01/","excerpt":"","text":"React Official Document주요개념 : JSX 소개 JSX 란? JSX를 표현식에 포함하기 변수 함수 호출 JSX도 표현식 JSX 속성 정의 경고 JSX 하위 요소 정의 JSX XSS 공격 방지 JSX는 객체를 표현한다. React element(요소) React Official Document주요개념#1. JSX 소개 JSX 란 ?1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 위 소스를 JSX라 하며 JavaScript를 확장한 문법이다. JavaScript의 모든 기능이 포함되어 있다. JSX는 React “엘리먼트(element)” 를 생성한다. JSX를 사용하려면 React 모듈을 import 해야한다. 1import React from 'react'; React에서는 이벤트 처리, 상태(state) 변화, 데이터가 준비되는 방식 등의 렌더링 로직이 본질적으로 다른 UI로직과 연결된다는 점을 받아들인다. 그리고 위와 같은 처리를 해주기 위해서 마크업(HTML) 과 JS코드를 분리하지않고, 둘 다 하나로 포함시켜서 사용하는 것을 ‘컴포넌트’ 라 칭하며 컴포넌트를 분리하여 관리한다. 여기서 컴포넌트를 작성할 때 마크업(HTML) 과 JS코드를 합친 코드를 JSX라 한다. React에서 JSX의 사용이 필수는 아니다.(React.createElement 로 구성해도 된다.) 하지만, 가독성, 유지보수 측면에서 JSX가 훨씬 유리하고 React가 에러 및 경고 메시지를 표시하게 해준다. JSX를 표현식에 포함하기JSX의 중괄호 안에는 유효한 모든 JavaScript 표현식을 넣을 수 있다. 변수1234567const name = 'Josh Perez';const element = &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;ReactDOM.render( element, document.getElementById('root')); 함수 호출12345678910111213141516171819function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); JSX 사용시 세미콜론 자동 삽입 기능을 방지하기 위해 () 소괄호로 감싸주는 것을 권장한다. JSX도 표현식Babel 컴파일이 끝나면 JSX는 정규 JavaScript 함수로 호출이 된다. 즉, JSX는 JavaScript 객체로 인식된다. JSX는 제어문, 반복문 등 안에 사용될 수 있으며, 변수에 할당하고, 인자로 받아들이고, 함수로부터 반환을 할 수 있다. 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; JSX 속성 정의속성에 따옴표를 이용해 문자열 리터럴을 정의할 수 있다. tabIndex=”0” 1const element = &lt;div tabIndex=\"0\"&gt;&lt;/div&gt;; 중괄호를 사용하여 어트리뷰트에 JavaScript 표현식을 삽입할 수도 있다. src={user.avatarUrl} 1const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;; 단, 자바스크립트 표현식을 감싼 중괄호를 큰 따옴표로 감싸면 안된다. 1const element = &lt;img src=\"&#123;user.avatarUrl&#125;\"&gt;&lt;/img&gt;; 경고 JSX는 HTML보다는 JavaScript에 가깝기 때문에, React DOM은 HTML 어트리뷰트 이름 대신 camelCase 프로퍼티 명명 규칙을 사용한다. 예를 들어, JSX에서 class는 className가 되고 tabindex는 tabIndex가 된다. JSX 하위 요소 정의만약, 태그 안에 텍스트 혹은 하위 요소가 존재하지 않는다면 XML 처럼 /&gt;로 닫을 수 있다. 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; JSX 태그는 하위 요소를 포함할 수 있다. 123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); JSX XSS 공격 방지 XSS 란? 크로스 사이트 스크립트 공격 의 약자로, 웹사이트에 스크립트 코드를 삽입하는 공격 기법을 의미. DOM 트리에 접근, 쿠키와 세션 정보를 탈취해 사용자 인증을 수행 할 수 있다. 이러한 XSS를 막을 수 있는 여러가지 방법들이 존재하는데 그 중 innerHTML 속성이 아닌 textContent 속성을 이용하여 이스케이프 처리된 텍스트 코드로 공격을 방지가 가능하다. 이스케이프로 처리된 텍스트란 다음을 의미한다. 문자 이스케이프 코드 &amp; &amp;amp ‘ &amp;#x27 “ &amp;quot &lt; &amp;lt &gt; &amp;gt / &amp;#x2F 즉 코드로써 작성될 수 있는 기호들을 이스케이프 처리한 텍스트로 작성하는 것이 XSS공격을 막는 방법이다. 본론으로 돌아가서 JSX는 XSS 공격을 방지 할 수 있다. 123const title = response.potentiallyMaliciousInput;// 이것은 안전하다.const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; 기본적으로 React DOM은 JSX에 삽입된 모든 값을 렌더링하기 전에 이스케이프 하므로, 애플리케이션에서 명시적으로 작성되지 않은 내용은 주입되지 않는다. 모든 항목은 렌더링 되기 전에 문자열로 변환된다. JSX는 객체를 표현한다. React element(요소)Babel을 통해 JSX는 React.createElement() 호출로 컴파일한다. 다음 두 예시는 동일하다. 12345const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;); 12345const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); React.createElement()는 버그가 없는 코드를 작성하는 데 도움이 되도록 몇 가지 검사를 수행하며, 기본적으로 다음과 같은 객체를 생성한다. 12345678// 주의: 다음 구조는 단순화되어있다const element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world!' &#125;&#125;; 위와 같은 객체를 React element(요소)라 한다. React는 React 요소를 읽은 후 DOM을 구성하고 최신으로 유지하는 데 React 요소를 사용한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"React","slug":"Develop/React","permalink":"https://hyeok999.github.io/categories/Develop/React/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"},{"name":"React Official Document","slug":"React-Official-Document","permalink":"https://hyeok999.github.io/tags/React-Official-Document/"}]},{"title":"JSX","slug":"react-velo-02","date":"2019-12-09T14:38:19.000Z","updated":"2019-12-29T16:57:01.741Z","comments":true,"path":"2019/12/09/react-velo-02/","link":"","permalink":"https://hyeok999.github.io/2019/12/09/react-velo-02/","excerpt":"","text":"React with Velopert - 02 - JSX JSX 란? JSX를 사용하는 이유 JSX 작성 주의점 null, false, undefined 를 렌더링하게 된다면 아무것도 나타나지 않게 된다. class 가 아니라 className 으로 정의해야한다. &lt;img&gt; 안에 무조건 alt 속성을 작성해야한다. 변수를 값으로 대입할 수 있다. 모든 태그는 반드시 닫혀야 한다. 2개 이상의 태그는 모두 하나의 태그 내부로 감싸야만 한다. style 작성 Chap 2. JSXJSX JSX 란 ? Javascript Extention의 약자이다. 리액트 컴포넌트 파일에서 XML 형태로 코드를 작성하면 babel 이 JSX 를 JavaScript 로 변환을 해준다. 예를들면, JSX로 다음과 같은 코드가 있다가 가정한다. 12345678910111213141516 &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/header&gt;&lt;/div&gt; 위 코드가 실행될 때 transpiler인 Babel이 JS의 파서가 읽을 수 있게끔 변형 시켜준다. 변형 시켜주면 다음과 같은 코드가 된다. 12345678910111213141516\"use strict\";React.createElement(\"div\", &#123; className: \"App\"&#125;, React.createElement(\"header\", &#123; className: \"App-header\"&#125;, React.createElement(\"img\", &#123; src: logo, className: \"App-logo\", alt: \"logo\"&#125;), React.createElement(\"p\", null, \"Edit \", React.createElement(\"code\", null, \"src/App.js\"), \" and save to reload.\"), React.createElement(\"a\", &#123; className: \"App-link\", href: \"https://reactjs.org\", target: \"_blank\", rel: \"noopener noreferrer\"&#125;, \"Learn React\"))); JSX를 사용하는 이유Virtual DOM은 JS 객체고 객체 안에서 태그, 속성, 자식노드들을 정의를 해주어야 한다. 그러한 정의를 우리는 React.createElement()함수를 통해 작성을 할 수 있는데, React.createElement(&quot;div&quot;,{ ... }, ...);형태로 코드를 게속 작성한다면 아마도 React를 사용하지 않을 것이다. 이유는 가독성면, 유지보수면 등등 사용하기가 너무나 불편한다. 반면에 우리가 익숙한 HTML 코드를 js 위에서 사용하는 것은 크게 불편하지 않기 때문에 JSX를 사용한다. JSX 작성 주의점 JSX 에서 값으로 null, false, undefined 를 렌더링하게 된다면 아무것도 나타나지 않게 된다. class 가 아니라 className 으로 정의해야한다. html 시 1&lt;div class=\"App\"&gt; jsx 시 1&lt;div className=\"App\"&gt; &lt;img&gt; 안에 무조건 alt 속성을 작성해야한다. 1&lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; *변수를 값으로 대입할 수 있다. * 123456function App() &#123; const logo = \"http://localhost:3000/static/media/logo.25bf045c.svg\" return ( &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; );&#125; 모든 태그는 반드시 닫혀야 한다. 12345678910111213import React from 'react';import Hello from './Hello';function App() &#123; return ( &lt;div&gt; &lt;Hello /&gt; &lt;div&gt; &#123;/* 에러 */&#125; &lt;/div&gt; );&#125; export default App; 2개 이상의 태그는 모두 하나의 태그 내부로 감싸야만 한다. 123456789101112131415161718import React from 'react';import Hello from './Hello';function App() &#123; return ( &#123;/* 이런식으로 작성하면 안된다. &lt;Hello /&gt; &lt;div&gt;안녕히계세요&lt;/div&gt; */&#125; &lt;div&gt; &lt;Hello /&gt; &lt;div&gt;안녕히계세요&lt;/div&gt; &lt;/div&gt; );&#125;export default App; ➤ 만약 특정 태그를 이용해 불필요한 태그를 남용하기 싫다면 리액트 Fragment를 이용한다. 1234567891011import React from 'react';import Hello from './Hello';function App() &#123; return ( &lt;&gt; &#123;/* 리액트 Fragment */&#125; &lt;Hello /&gt; &lt;div&gt;안녕히계세요&lt;/div&gt; &lt;/&gt; );&#125; style 작성 ➤ 인라인 스타일은 객체 형태로 작성 ➤ background-color 처럼 - 로 구분되어 있는 이름들은 backgroundColor 처럼 camelCase 형태로 네이밍 1234567891011121314151617181920import React from 'react';import Hello from './Hello';function App() &#123; const name = 'react'; const style = &#123; backgroundColor: 'black', color: 'aqua', fontSize: 24, // 기본 단위 px padding: '1rem' // 다른 단위 사용 시 문자열로 설정 &#125; return ( &lt;&gt; &lt;/Hello&gt; &lt;div style=&#123;style&#125;&gt;&#123;name&#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm50","slug":"daily-algorithm50","date":"2019-12-09T14:38:10.000Z","updated":"2019-12-09T14:42:21.162Z","comments":true,"path":"2019/12/09/daily-algorithm50/","link":"","permalink":"https://hyeok999.github.io/2019/12/09/daily-algorithm50/","excerpt":"","text":"문제 출처 : 프로그래머스 자릿수 더하기 문제 설명자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요.예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다. 제한사항 N의 범위 : 100,000,000 이하의 자연수 입출력 예 N answer 123 6 987 24 입출력 예 설명입출력 예 #1문제의 예시와 같습니다. 입출력 예 #29 + 8 + 7 = 24이므로 24를 return 하면 됩니다. 1234function solution(n)&#123; return [...`$&#123;n&#125;`].reduce((pre, cur) =&gt; pre + +cur, 0);&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"React 스터디 03","slug":"react-study-03","date":"2019-12-07T14:38:19.000Z","updated":"2019-12-09T14:45:16.900Z","comments":true,"path":"2019/12/07/react-study-03/","link":"","permalink":"https://hyeok999.github.io/2019/12/07/react-study-03/","excerpt":"","text":"React Study 03 import Component Transfile React에서는 데이터가 항상 불변성을 유지해야한다. ReatDOM.render() Hot Module Replacement (HMR) JSX로 데이터를 받아오기 React key 단방향 데이터 흐름 setState setState에서 콘솔확인하기 Component API 카운터 만들어보기 YOUTUBE Api 불러오기 axios 를 이용하여 데이터 Get 용어 - ( 러버덕 ) import Component Transfile setState Component API 불변성 import다른 파일, 다른 모듈에서 정의된 기능을 사용하기 위해서 사용한다. js파일은 확장자를 생략가능 하다. 그외의 확장자는 전부 확장자를 적어주어야한다. 12import App from './App';import './index.css'; Componentextends를 사용해서 컴포넌트를 상속받는다. 컴포넌트를 상속받는 이유? react.Component에 있는 render함수를 상속받아 쓰기 위해서. Transfile특정 언어를 다른언어로 변경시킴. JSX 를 바벨이 브라우저가 해석할 수 있도록 자바스크립트로 트랜스파일 해준다. React에서는 데이터가 항상 불변성을 유지해야한다.모든 것은 단방향으로 주기 위함이다. 상태 변화는 setState를 통해서만 가능해야한다. ReatDOM.render()1234ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); document에 있는 id가 root인 요소 내부를 &lt;App /&gt; 커스텀 태그로 대체한다. Hot Module Replacement (HMR) Hot Module Replacement (HMR)은 응용프로그램 실행 중에 추가 또는 제거된 모듈들을 페이지 리로드 없이 교체하는 기능. ReatDom.render() 아래에 작성한다. 개발 환경에서 사용하는 기능이다. HMR 기능을 사용하면 웹페이지를 새로고침하지 않고 업데이트된 요소만 업데이트 - 개발 환경에서만 사용 가능 123if (module.hot) &#123; module.hot.accept();&#125; JSX로 데이터를 받아오기123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; Component &#125; from 'react';import './App.css';const list = [ &#123; title: 'React', url: 'https://reactjs.org/', author: 'Jordan Walke', num_comments: 3, points: 4, objectID: 0,&#125;, &#123; title: 'Redux', url: 'https://redux.js.org/', author: 'Dan Abramov, Andrew Clark', num_comments: 2, points: 5, objectID: 1,&#125;, ];class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &#123;list.map(function(item) &#123; return ( &lt;div&gt; &lt;span&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; ); &#125;&#125; React key 정렬기준을 정의하기 위해서 key를 사용한다. src/App.js 12345678910111213&#123; list.map(function(item) &#123; return ( &lt;div key=&#123;item.objectID&#125;&gt; &lt;span&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;&#123;item.author&#125;&lt;/span&gt; &lt;span&gt;&#123;item.num_comments&#125;&lt;/span&gt; &lt;span&gt;&#123;item.points&#125;&lt;/span&gt; &lt;/div&gt; );&#125;)&#125; 순회(반복문)를 도는 JS함수(대표 : Map) 로 return 할 때 최상위에 반드시 key값을 정의해야만한다. key 값을 기준으로 새로 업데이트가 된다. key 는 예측할 수 있는 고유값이어야만 한다. (중복된값이 오면 안된다.) - 고유값을 랜덤으로 지정해주고 싶을때는 uuid라는 npm을 사용한다. key 에 절대로 index값을 넣어선 안된다. key는 정렬을 위해서 주로 사용한다. 단방향 데이터 흐름내가 마음대로 데이터에 직접적으로 접근하는게 아닌 setState를 통해서만 접근한다. 데이터(상태)에 대한 변경은 setState를 통해서만 한다. 1234onDismiss(id) &#123; const isNotId = item =&gt; item.objectID !== id; const updatedList = this.state.list.filter(isNotId); this.setState(&#123; list: updatedList &#125;);&#125; setStatesetState를 정의할때는 반드시 최소 비어있는 state가 필요하다. state를 변경하기 위해 사용한다. 1234constructor(props) &#123; super(props) this.state = &#123;&#125;&#125; 이렇게 3줄만 적을 경우, 다음처럼 줄일수 있다. 1state = &#123;&#125; 123const isSearched = searchTerm =&gt; item =&gt; item.title.toLowerCase().includes(searchTerm.toLowerCase());list.filter(item =&gt; item.title.toLowerCase().includes(searchTerm.toLowerCase());) setState 에서 콘솔 확인하기1234// setState에서 콘솔찍으려면 화살표 함수를 이용해야한다. 비동기 때문임. 순서보장.this.setState(&#123; counter: 1 &#125;, () =&gt;&#123; console.log(this.state.counter)&#125;) 상태에 대한 요소의 변경이 전혀없는 정적인 페이지를 만들경우 Function Stateless Components 상태에 대한 요소가 변화가 있는 동적인 페이지를 만들경우 ES6 Class Components Component API Constructor() getDerivedStateFromProps() render() : UI를 화면에 출력하라. componentDidMount() : render함수 이후에 실행 shouldComponentUpdate(nextProps, nextState) : 내가 지정한 props만 업데이트해라.(최적화) getSnapshotBeforUpdate componentDidUpdate() : component가 업데이트 되었을 경우에 실행. componentWillUnmount() : 다른 페이지로 이동하거나 하는 초기화 작업이 필요할 경우. 카운터 만들어보기App.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from 'react';import './App.css';class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; counter: 0, className: 'App-header-2' &#125; // this.adds = this.add.bind(this) // this.minus = this.minus.bind(this) Object.getOwnPropertyNames(App.prototype).forEach(key =&gt; this[key] = this[key].bind(this)) &#125; // render 이후에 실행됨. componentDidMount() &#123; //: this.state.counter = 1 이렇게사용하면 절대 안된다. 값을 바꾸고싶으면 setState이용 (아래 에졔) setInterval(() =&gt; this.setState(&#123; counter : this.state.counter + 1 &#125;),1000) // setState에서 콘솔찍어보고 싶으면 이렇게 해야된다. // this.setState(&#123; counter: 1 &#125;, () =&gt;&#123; // console.log(this.state.counter) // &#125;) &#125; add() &#123; console.log('answer : ' + this); this.setState(&#123;counter: this.state.counter + 100&#125;) &#125; minus() &#123; this.setState(&#123;counter: this.state.counter - 100&#125;) &#125; // calc(val) &#123; // this.setState(&#123;counter: this.state.counter + val&#125;) // &#125; render()&#123; return ( &lt;div className=\"App\"&gt; &lt;button onClick=&#123;this.adds&#125;&gt;+&lt;/button&gt;&#123;this.state.counter&#125;&lt;button onClick=&#123;this.minus.bind(this)&#125;&gt;-&lt;/button&gt; &#123;/* &lt;button onClick=&#123;() =&gt; this.calc(100)&#125;&gt;+&lt;/button&gt;&#123;this.state.counter&#125;&lt;button onClick=&#123;() =&gt; this.calc(-100)&#125;&gt;-&lt;/button&gt; */&#125; &lt;/div&gt; ); &#125;&#125;export default App; YOUTUBE Api 불러오기axios 를 이용하여 데이터 Get1npm i axios --save App.js ( 입력 받는 것은 주석처리해놓음 , 키 별도로 입력해야함.) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React from 'react';import './App.css';import Axios from 'axios';class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; list : [], subList : [], &#125; this.sort = this.sort.bind(this); // Object.getOwnPropertyNames(App.prototype).forEach(key =&gt; this[key] = this[key].bind(this)) &#125; async getYoutubeData(query) &#123; try &#123; const &#123; data &#125; = await Axios.get(`API 키`) this.setState(&#123;list : data.items &#125;); &#125; catch (error) &#123; console.error(error); &#125; &#125; // async getYoutubes(target, keyCode) &#123; // if(keyCode !== 13 || target.value.trim() === '') return; // try &#123; // const &#123; data &#125; = await Axios.get(`https://www.googleapis.com/youtube/v3/search?key=AIzaSyC1Y_pxHo33uSJV-HmXtP_jBhKNhbwnxug&amp;q=$&#123;target.value.trim()&#125;&amp;part=snippet`) // this.setState(&#123; subList : data.items &#125;); // &#125; catch (error) &#123; // console.error(error); // &#125; // &#125; sort()&#123; this.setState( &#123;subList : this.state.subList.reverse()&#125;) &#125; componentDidMount() &#123; this.getYoutubeData('롤드컵'); &#125; render () &#123; return ( &lt;div&gt; &#123;/* &lt;button onClick=&#123;() =&gt; this.getYoutubeData('여행')&#125;&gt; 렌더링 &lt;/button&gt; */&#125; &lt;div&gt; &#123;this.state.list.map(item =&gt; &#123; console.log(item.id.videoId); return &lt;div key=&#123;item.id.videoId&#125;&gt;&#123;item.snippet.title&#125;&lt;/div&gt;; &#125;)&#125; &lt;/div&gt; &#123;/* &lt;div&gt; &lt;input type=\"text\" onKeyDown=&#123;(&#123;target, keyCode&#125;) =&gt; this.getYoutubes(target, keyCode)&#125;&gt;&lt;/input&gt; &lt;/div&gt; &lt;div&gt; &#123;this.state.subList.map(item =&gt; &#123; console.log(item.id.videoId) return &lt;div key=&#123;item.id.videoId&#125;&gt;&#123;item.snippet.title&#125;&lt;/div&gt; &#125;)&#125; &lt;/div&gt; */&#125; &lt;button onClick=&#123;this.sort&#125;&gt;sort&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm49","slug":"daily-algorithm49","date":"2019-12-07T07:31:26.000Z","updated":"2019-12-07T07:33:53.361Z","comments":true,"path":"2019/12/07/daily-algorithm49/","link":"","permalink":"https://hyeok999.github.io/2019/12/07/daily-algorithm49/","excerpt":"","text":"문제 출처 : 프로그래머스 문자열을 정수로 바꾸기문제 설명문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요. 제한 조건 s의 길이는 1 이상 5이하입니다. s의 맨앞에는 부호(+, -)가 올 수 있습니다. s는 부호와 숫자로만 이루어져있습니다. s는 0으로 시작하지 않습니다. 입출력 예예를들어 str이 1234이면 1234를 반환하고, -1234이면 -1234를 반환하면 됩니다.str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다. 123function solution(s) &#123; return +s;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm48","slug":"daily-algorithm48","date":"2019-12-07T07:31:22.000Z","updated":"2019-12-07T07:33:36.503Z","comments":true,"path":"2019/12/07/daily-algorithm48/","link":"","permalink":"https://hyeok999.github.io/2019/12/07/daily-algorithm48/","excerpt":"","text":"문제 출처 : 프로그래머스 시저 암호문제 설명어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 AB는 1만큼 밀면 BC가 되고, 3만큼 밀면 DE가 됩니다. z는 1만큼 밀면 a가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요. 제한 조건 공백은 아무리 밀어도 공백입니다. s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다. s의 길이는 8000이하입니다. n은 1 이상, 25이하인 자연수입니다. 입출력 예 s n result AB 1 BC z 1 a a B z 4 e F d 12345678910111213141516function solution(s, n) &#123; const answer = s.split(''); let result = ''; answer.forEach((word) =&gt; &#123; let wordNum = word.charCodeAt() + n; if (word === ' ') result += String.fromCharCode(word.charCodeAt()); // O else if (wordNum &gt; 122) result += String.fromCharCode(word.charCodeAt() + n - 26); else if (word.charCodeAt() &gt; 64 &amp;&amp; word.charCodeAt() &lt; 91) &#123; if (wordNum &gt; 90) result += String.fromCharCode(word.charCodeAt() + n - 26); else result += String.fromCharCode(word.charCodeAt() + n); &#125; else result += String.fromCharCode(word.charCodeAt() + n); &#125;); return result;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"리액트 맛보기 (Virtual DOM)","slug":"react-velo-01","date":"2019-12-05T16:18:21.000Z","updated":"2019-12-29T16:56:49.736Z","comments":true,"path":"2019/12/06/react-velo-01/","link":"","permalink":"https://hyeok999.github.io/2019/12/06/react-velo-01/","excerpt":"","text":"React with Velopert - 01 - 리액트가 만들어진 이유 리액트의 탄생 Virtual DOM React 렌더링 과정 Component ​ React 시작하기 Component 만들어보기 Chap 1. 리액트 맛보기리액트가 만들어진 이유 React는 UI를 어떻게 업데이트 할 지가 아닌 어떻게 보여줄지를 집중해야 한다. Javscript를 사용하여 HTML의 요소들을 제어할 경우, DOM을 변형시키기 getElementById, querySelector 와 같은 DOM Selector API를 사용해왔다. 여기서 문제는 프로젝트 혹은 어플리케이션의 규모가 점점 증가할 수록 이벤트 처리에 대한 복잡성이 증가하고 유지보수가 어려워진다. 리액트의 탄생위와 같은 문제를 해결하기 위해 Angular JS, Backbone 등의 프레임워크가 출시가 되었다.이 프레임워크들은 대부분 JS의 특정 값이 바뀜 ➤ 특정 DOM의 속성이 바뀌도록 연결 ➤ 업데이트 방식으로 문제를 해결했다. 리액트는 위와 같이 문제를 해결하지 않고, 업데이트에 신경을 아예 쓰지 않도록했다. 해결방식은 다음과 같다. JS의 특정 값이 바뀜 ➤ 특정 DOM을 바뀐대로 다시 그린다 ➤ 업데이트 Virtual DOM 가상으로 존재하는 DOM 으로서 그냥 JavaScript 객체이기 때문에 작동 성능이 실제로 브라우저에서 DOM 을 보여주는 것 보다 속도가 훨씬 빠르다. React가 가상 DOM을 이용하는 이유는 다른 프레임워크처럼 속성을 연결하여 업데이트하는 방식이 아닌 아예 해당 요소를 새로 그리게 되는데 그럴 경우 어플리케이션의 속도가 크게 저하되기 때문이다. React 렌더링 과정 React에서는 상태가 업데이트 되면 메모리에 있는 Virtual DOM에 렌더링한다. 실제 브라우저에서 보여지고 있는 DOM을 비교한다. 비교한 차이점을 실제 DOM에 반영한다. (Patch) Component UI의 조각 React에서 다양한 기능을 제공한다. 1const Hello = &lt;div&gt;Hello&lt;/div&gt; React 시작하기1$ npx create-react-app begin-react Component 만들어보기React를 사용하기 위해서 React를 불러온다. 1import React from 'react'; 임의의로 선언하는 모든 컴포넌트(커스텀 컴포넌트)의 명칭의 시작은 무조건 대문자로 시작한다. react 프로젝트 폴더 &gt; src &gt; hello.js 생성 12345678import React from 'react';// Hello 컴포넌트function Hello() &#123; return &lt;div&gt;안녕하세요&lt;/div&gt;&#125; export default Hello; Hello 라는 컴포넌트를 만들었음. react 프로젝트 폴더 &gt; src &gt; App.js Hello 컴포넌트 불러와서 사용 해보기. 12345678910111213import React from 'react';import Hello from './Hello';function App() &#123; return ( &lt;div&gt; &lt;Hello /&gt; &#123; /* 컴포넌트는 재사용이 가능하다. */ &#125; &lt;Hello /&gt; &lt;Hello /&gt; &lt;/div&gt; );&#125; react 프로젝트 폴더 &gt; src &gt; index.js 123456789101112import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import * as serviceWorker from './serviceWorker';ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: https://bit.ly/CRA-PWAserviceWorker.unregister(); ReactDOM.render 의 역할은 브라우저에 있는 실제 DOM 내부에 리액트 컴포넌트를 렌더링하겠다는 것을 의미 react 프로젝트 폴더 &gt; public &gt; index.html 내부에 다음과 같은 &lt;div&gt; 태그가 있다. 1&lt;div id=\"root\"&gt;&lt;/div&gt; 결국, 리액트 컴포넌트가 렌더링 될 때에는, 렌더링된 결과물이 위 div 내부에 렌더링되는 것.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React-Preview","slug":"TIL/React-Preview","permalink":"https://hyeok999.github.io/categories/TIL/React-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"daily_algorithm47","slug":"daily-algorithm47","date":"2019-12-05T15:55:33.000Z","updated":"2019-12-05T15:57:58.664Z","comments":true,"path":"2019/12/06/daily-algorithm47/","link":"","permalink":"https://hyeok999.github.io/2019/12/06/daily-algorithm47/","excerpt":"","text":"문제 출처 : 프로그래머스 문자열 다루기 기본문제 설명문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 a234이면 False를 리턴하고 1234라면 True를 리턴하면 됩니다. 제한 사항 s는 길이 1 이상, 길이 8 이하인 문자열입니다. 입출력 예 s return a234 false 1234 true 123function solution(s) &#123; return (s.length == 4 || s.length == 6) ? /^\\d+$/.test(s) : false;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm46","slug":"daily-algorithm46","date":"2019-12-04T16:33:15.000Z","updated":"2019-12-05T15:57:52.231Z","comments":true,"path":"2019/12/05/daily-algorithm46/","link":"","permalink":"https://hyeok999.github.io/2019/12/05/daily-algorithm46/","excerpt":"","text":"문제 출처 : 프로그래머스 정수 내림차순으로 배치하기문제 설명 함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다. 제한 조건 n은 1이상 8000000000 이하인 자연수입니다. 입출력 예 n return 118372 123function solution(n) &#123; return +(String(n).split('').sort((a,b) =&gt; b-a).join(''));&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"React 스터디 02","slug":"react-study-02","date":"2019-12-04T16:27:32.000Z","updated":"2019-12-09T14:45:07.290Z","comments":true,"path":"2019/12/05/react-study-02/","link":"","permalink":"https://hyeok999.github.io/2019/12/05/react-study-02/","excerpt":"","text":"React Study 02 JSX 란? JSX를 사용하는 이유 JSX 내부 작성 주의점 Virtual DOM Virtual DOM(가상 돔)의 사용이유 Virtual DOM(가상 돔)의 장점 &amp; 단점 VirtualDOM이 받는 파라미터 세가지 (type, props, …child) ReactDOM.render() 함수 React 상태 업데이트 순서 import React 와 import ReactDOM 자세하게 알아보기. props 작성 규칙 Component Component를 정의하는 방법 2가지 Component 주의 사항 및 주요 코드 상태 변화 상태변화 사용 2가지 방법 초시계 만들어보기 Mounting : Component 가 생성되고 DOM에 inject 되는 것. 용어 - ( 러버덕 ) JSX Virtual DOM Component Component 주의사항 Reach 상태 변화 props 작성 규칙 JSX 란 ? Javascript xml의 약자이다. 리액트 컴포넌트 파일에서 XML 형태로 코드를 작성하면 babel 이 JSX 를 JavaScript 로 변환을 해준다. 예를들면, JSX로 다음과 같은 코드가 있다가 가정한다. 12345678910111213141516 &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/header&gt;&lt;/div&gt; 위 코드가 실행될 때 transpiler인 Babel이 JS의 파서가 읽을 수 있게끔 변형 시켜준다. 변형 시켜주면 다음과 같은 코드가 된다. 12345678910111213141516\"use strict\";React.createElement(\"div\", &#123; className: \"App\"&#125;, React.createElement(\"header\", &#123; className: \"App-header\"&#125;, React.createElement(\"img\", &#123; src: logo, className: \"App-logo\", alt: \"logo\"&#125;), React.createElement(\"p\", null, \"Edit \", React.createElement(\"code\", null, \"src/App.js\"), \" and save to reload.\"), React.createElement(\"a\", &#123; className: \"App-link\", href: \"https://reactjs.org\", target: \"_blank\", rel: \"noopener noreferrer\"&#125;, \"Learn React\"))); JSX를 사용하는 이유React.createElement(&quot;div&quot;,{ ... }, ...);형태로 코드를 게속 작성한다면 아마도 React를 사용하지 않을 것이다. 이유는 가독성면, 유지보수면 등등 사용하기가 너무나 불편한다. 반면에 우리가 익숙한 HTML 코드를 js 위에서 사용하는 것은 크게 불편하지 않기 때문에 JSX를 사용한다. JSX 내부 작성 주의점 class 가 아니라 className 으로 정의해야한다. html 시 1&lt;div class=\"App\"&gt; jsx 시 1&lt;div className=\"App\"&gt; &lt;img&gt; 안에 무조건 alt 속성을 작성해야한다. 1&lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; 변수를 값으로 대입할 수 있다. 123logo = \"http://localhost:3000/static/media/logo.25bf045c.svg\"// jsx 태그&lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; Virtual DOMReact는 라이브러리다. 특정 DOM요소에 대해서 리액트 라이브러리를 적용하는 것이다. 여기서 말하는 리액트 라이브러리는 Virtual DOM(가상 돔)을 이용한 리액트를 말하는데, 리액트는 실제 DOM이 아닌 Virtual DOM(가상 돔)을 이용한다. Virtual DOM(가상 돔)의 사용이유Vanilla JS 를 이용해 개발을 진행하다보면 게속적으로 DOM요소에 접근하기 위한 변수를 생성 하고 동적인 UI를 처리하기 위해서 이벤트 처리나 인터렉션이 지속적으로 늘어나고 유지보수가 점점 힘들어지게 된다. 이러한 이유로, React는 특정 DOM요소에 대한 동적인 업데이트의 처리를 규칙으로 정하는게 아니라, 동적으로 바뀔때마다 지우고 새로 그려내자는 식으로 하게된다. 여기서 문제는, 매번 새로 그린다면 속도 저하라는 문제가 생기는데 여기서 해결책으로 Virtual DOM(가상 돔)을 이용하게 된 것 이다. Virtual DOM(가상 돔)의 장점 &amp; 단점Virtual DOM의 장점 : 브라우저에 실제로 보여지는 DOM 이 아니라 그냥 메모리에 가상으로 존재하는 DOM 으로서 그냥 JavaScript 객체이기 때문에 작동 성능이 실제로 브라우저에서 DOM 을 보여주는 것 보다 속도가 훨씬 빠르다. Virtual DOM의 단점(React의 단점) : 라이브러리를 만드는데 반드시 실제 DOM 요소 1가지(이상)를 필요로 한다. VirtualDOM이 받는 파라미터 세가지 (type, props, …child) type : 어떠한 종료의 Virtual DOM인가 (태그인가) props : 해당 DOM에 어트리뷰트가 무엇인가 (속성) …child : 해당 Virtual DOM에 자식 요소가 무엇인가 ? ( REST파라미터로 배열로 받는다. ) ReactDOM.render() 함수12ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));ReactDOM.render( 가상 DOM, 실제 DOM); React 상태 업데이트 순서 React는 상태가 업데이트 되면, 업데이트가 필요한 곳의 UI 를 Virtual DOM 을 통해서 렌더링한다. React가 제공하는 비교 알고리즘을 통하여 실제 브라우저에 보여지고 있는 DOM 과 Virtual DOM을 비교 한 후, 차이가 있는 곳을 감지하여 이를 실제 DOM 에 패치킨다. import React 와 import ReactDOM 자세하게 알아보기.App.js ▾ 12import React from 'react';import ReactDOM from 'react-dom'; 위 두 코드를 대체하는 코드 ▾ 12345678910111213141516171819202122// 주석이 아니라 리액트 함수 말고 내가만든 커스텀 함수를 쓰겠다는 뜻/** @jsx customDOM */function customDOM (...props) &#123; return props &#125; const App = &lt;div className=\"App\"&gt; // 1번 &lt;header className=\"App-header\"&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; export default App 1번 const App 안에 html으로 보이는 태그들은 실제 html 태그가 아닌 가상 DOM 요소이다. props 작성 규칙카멜 케이스를 사용한다. 예) className, onClick, onLoad…. Component UI를 재사용 가능한 개별적인 부분들로 분리한다. 유지보수, 가독성이 좋다. Component는 데이터가 들어있는 props를 받고, React Element들을 return 한다. Component를 정의하는 방법 2가지 함수로 정의 123function Welcom(props) &#123; return &lt;h1&gt; Hello, &#123;props.name&#125; &lt;/h1&gt;&#125; ES6 class로 정의 123456789101112131415class Welcome extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; counter: 0, className: 'App-header' &#125; this.add = this.add.bind(this) this.minus = this.minus.bind(this) &#125; render() &#123; return &lt;h1&gt; Hello, &#123;this.props.name&#125; &lt;/h1&gt; &#125;&#125; Component 주의 사항 및 주요 코드 중복된 코드를 반복하지 않고 컴포넌트를 작성한다. 임의의로 선언하는 모든 컴포넌트(커스텀 컴포넌트)의 명칭의 시작은 무조건 대문자로 시작한다. 1234567891011121314151617181920212223// 대문자const Header = props =&gt; &lt;header&gt;&#123;props.children&#125;&lt;/header&gt;function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;Header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/Header&gt; &lt;/div&gt; );&#125; header ➤ type className ➤ props prop은 property의 줄임말, 변수 선언문 뒤에 나오는 모든 속성 태그들 children ➤ 헤더 태그 사이의 (하위)자식 요소들 props.children으로 모두 들어감 상태 변화가 없는 컴포넌트 : Stateless Component 상태 변화가 있는 컴포넌트 : State Component 상태 변화 setState( )함수를 이용한다. setState()는 비동기 함수로, state가 반영된 상태에서 무언가를 하고 싶을 때 2번째 인수를 콜백함수로 전달한다. 상태변화 사용 2가지 방법 React element에 이벤트를 닫아 함수를 연결할 때, 파라미터를 전달하는 경우 화살표함수를 사용해야 한다. 1&lt;button onClick = &#123; () =&gt; this.calc(100)&#125;&gt; + &lt;/button&gt; 파라미터를 전달하지 않은 경우에는 this를 바인딩 해줘야 한다. 123456789101112131415161718192021222324class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; counter: 0, className: 'App-header' &#125; this.add = this.add.bind(this) this.minus = this.minus.bind(this) &#125; // render 이후에 실행됨. componentDidMount() &#123; setInterval(() =&gt; this.setState(&#123; counter : this.state.counter + 1 &#125;),1000) &#125; add() &#123; console.log(this); this.setState(&#123;counter: this.state.counter + 100&#125;) &#125; minus() &#123; this.setState(&#123;counter: this.state.counter - 100&#125;) &#125; 1234567render()&#123; return ( &lt;div className=\"App\"&gt; &lt;button onClick=&#123;this.add&#125;&gt;+&lt;/button&gt; &lt;/div&gt; );&#125; 초시계 만들어보기 setState(중요한 메소드)를 써서 데이터의 상태 변화를 사용할 수 있다. 주의사항 : this.state.counter = 1 이런식으로 직접적으로 state를 바꿔서는 절대 안된다. 123456componentDidMount() &#123; setInterval(() =&gt; this.setState(&#123; counter: ++this.state.counter // 절대로 이런식으로 사용해선 안된다. counter: this.state.counter + 1 // 이렇게 사용해야 함 &#125;))&#125; React에서는 상태 변화를 직접적으로 변경 해서는 안된다. ( 오직 setState만 사용하여야 함 ) setState는 비동기함수. 콜백함수를 전달받을 수 있다. 정의하지 않았는데 자동으로 뜨는것들은 전부 오버라이드 하는 것. ➤ 예) componentDidMount( React.Component ) 같은 것. 함수에 setState를 사용하기 위해서는 바인드로 this를 넘겨줘야 함. ➤ constructor에서 this.add = thid.add.bind(this) ➤ 화살표 함수로 이벤트를 넘기면 바인딩이 필요 없음 - this에 대한 바인딩 필요없이 함수를 무조건 호출하고 리턴하는 것. 12345678910add (val) &#123; this.setState(&#123; counter: this.state.counter + val &#125;)&#125;&lt;button onClick=&#123;() =&gt; this.add(100)&#125;&gt;+&lt;/button&gt; // componentDidMount 에 작성add () &#123; this.setState(&#123; counter: this.state.counter + 100 &#125;)&#125;&lt;button onClick=&#123;this.add&#125;&gt;+&lt;/button&gt; // componentDidMount 에 작성this.add = this.add.bind(this) // class App 에 작성 특정한 인자 값을 넘길때만 화살표 함수를 사용하는 것이 좋고, 아래쪽처럼 바인딩 하는것이 좋은 방법(메모리상의 이유). this라는 건 결국 객체. 바인딩해야할 함수가 수백 수천개일 경우에는? Object.keys() 를 이용한다. 1234567const obj = &#123; name: 'dahee', email: 'a@a.a'&#125;console.log(Object.keys(obj))// [ 'name', 'email' ] 위를 이용하여 만든 바인드 코드 12345678this.add = this.add.bind(this) // 일일이 사용해서 불편하다.// Objectt.key를 이용해 간편히 이용한다.Object.keys(this).forEach(key =&gt; &#123; if (typeof this[key] === 'function') &#123; this[key] = this[key].bind(this) &#125;&#125;) Mounting : Component 가 생성되고 DOM에 inject 되는 것. constructor() static getDerivedStateFromProps() render() componentDidMount() 마운팅 할 때 위 순서대로 메소드들이 실행된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"타다 사이트 클론하기 (모바일 구현완료)","slug":"tada-web","date":"2019-12-03T16:02:06.000Z","updated":"2020-03-06T17:40:10.102Z","comments":true,"path":"2019/12/04/tada-web/","link":"","permalink":"https://hyeok999.github.io/2019/12/04/tada-web/","excerpt":"","text":"본 게시물은 상업적인 목적은 전혀 없으며, 학습하기 위해 사용하였습니다. 타다 클론 (모바일 구현 완료)Tada : 타다 사이트 클론하기. (개인 프로젝트) 1. 주제Tada : 타다 사이트 클론. 2. 주제 선정 이유 HTML 와 CSS 학습을 위해서 반응형으로 구성된 웹페이지를 구현해볼 필요성이 있다고 느낌. 실제 구현되고 서비스 중인 반응형 페이지를 직간접적으로 구현하여 학습을 함. 3. 프로젝트 요구 사항 W3C에서 제공한 MarkUp Validation Service 에서 이상이 없을 것. 최대한 시멘틱 하게 작성할 것. html , css 적인 요소를 구현하는 JS를 최대한 사용하지 말 것. 반응형으로 구현할 것 (모바일 , PC) 4. 구현 기술 HTML CSS 5. 프로젝트 구현 영상 ( 모바일 버전 ) 6. 추가사항PC버전은 차후에 개발 예정 View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"project","slug":"project","permalink":"https://hyeok999.github.io/tags/project/"},{"name":"Web clone","slug":"Web-clone","permalink":"https://hyeok999.github.io/tags/Web-clone/"}]},{"title":"daily_algorithm45","slug":"daily-algorithm45","date":"2019-12-03T15:52:32.000Z","updated":"2019-12-03T15:59:14.506Z","comments":true,"path":"2019/12/04/daily-algorithm45/","link":"","permalink":"https://hyeok999.github.io/2019/12/04/daily-algorithm45/","excerpt":"","text":"문제 출처 : 프로그래머스 [2020카카오공채] 문자열 압축문제 설명데이터 처리 전문가가 되고 싶은 어피치는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.간단한 예로 aabbaccc의 경우 2a2ba3c(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, abcabcdede와 같은 문자열은 전혀 압축되지 않습니다. 어피치는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, abcabcdede와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 abcabc2de가 되지만, 3개 단위로 자른다면 2abcdede가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s result &quot;aabbaccc&quot; 7 &quot;ababcdcdababcdcd&quot; 9 &quot;abcabcdede&quot; 8 &quot;abcabcabcabcdededededede&quot; 14 &quot;xababcdcdababcdcd&quot; 17 입출력 예에 대한 설명입출력 예 #1 문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #2 문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #3 문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #4 문자열을 2개 단위로 자르면 abcabcabcabc6de 가 됩니다.문자열을 3개 단위로 자르면 4abcdededededede 가 됩니다.문자열을 4개 단위로 자르면 abcabcabcabc3dede 가 됩니다.문자열을 6개 단위로 자를 경우 2abcabc2dedede가 되며, 이때의 길이가 14로 가장 짧습니다. 입출력 예 #5 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function solution(s) &#123; let count = 0; let temp = ''; let answer = []; if (s.length === 1) return 1; while (true) &#123; if (count &gt;= Math.floor(s.length / 2)) break; count++; let array = strToArr(s, count); let coin = 1; for (let i = 0; i &lt; array.length - 1; i++) &#123; if (array[i] === array[i + 1]) &#123; coin++; &#125; else &#123; if (coin === 1) temp += array[i]; else temp += coin + array[i]; coin = 1; &#125; &#125; if (coin === 1) temp += array[array.length - 1]; else temp += coin + array[array.length - 1]; answer.push(temp.length); temp = ''; &#125; // 함수 function strToArr(str, counts) &#123; let arr = str; let subArr = []; while (true) &#123; subArr.push(arr.substring(0, counts)); arr = arr.slice(-(arr.length) + counts); if (arr.length &lt;= counts || arr === '') &#123; subArr.push(arr); break; &#125; &#125; return subArr; &#125; // 함수 끝 return Math.min(...answer);&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"Debugger for Chrome Setting","slug":"ChromeDebuggerSetting","date":"2019-12-02T16:55:18.000Z","updated":"2019-12-02T16:58:06.977Z","comments":true,"path":"2019/12/03/ChromeDebuggerSetting/","link":"","permalink":"https://hyeok999.github.io/2019/12/03/ChromeDebuggerSetting/","excerpt":"","text":"Google Debugger 설정하기1. EXTENSIONS 에서 Debugger for Chrome 설치 2. 구성 설정 : url 수정 ( react는 3000번 사용 ) 디버거 실행하기 실행 후 화면 중단점 설정1. 중단점을 선택한다. 위에 있는 버튼으로 추가 조작을 한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"https://hyeok999.github.io/categories/Develop/Tips/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"Chrome","slug":"Chrome","permalink":"https://hyeok999.github.io/tags/Chrome/"},{"name":"Browser","slug":"Browser","permalink":"https://hyeok999.github.io/tags/Browser/"},{"name":"VScode","slug":"VScode","permalink":"https://hyeok999.github.io/tags/VScode/"},{"name":"VisualStudio Code","slug":"VisualStudio-Code","permalink":"https://hyeok999.github.io/tags/VisualStudio-Code/"}]},{"title":"React 스터디 01","slug":"react-study-01","date":"2019-12-02T16:46:23.000Z","updated":"2019-12-04T16:19:18.056Z","comments":true,"path":"2019/12/03/react-study-01/","link":"","permalink":"https://hyeok999.github.io/2019/12/03/react-study-01/","excerpt":"","text":"React Study 01 git commit 고치는 방법 3가지 prettier vs standard npm 기초 디스트럭처링 활용 백틱 Arrow Fn - ES6 미만 - 백틱이용 SPA , Single Page Application ( Vanila.js ) Proxy 리액트 프로젝트 생성하기 용어 - ( 러버덕 ) 디스터럭처링 활용 SPA Proxy 리액트 프로젝트 생성하기 git commit 고치는 방법 3가지커밋 합병하기git rebase -i HEAD~n(갯수) &gt; pick - 살릴 커밋 , s - 죽일 커밋 &gt; git push -f 12git rebase -i HEAD~5git push -f 푸쉬한 깃 커밋 수정12git commit --amendgit push -f 푸쉬하기 전 깃 커밋 수정1git commit --amend prettier vs standard npm 기초현업에서 코드를 어떻게 작성할 것 인가는 보통 이 2가지로 판별난다. prettier는 코드 끝에 ;를 작성하지 않는다. standard npm은 코드 끝에 ;를 작성한다. ###디스트럭처링 활용 배열 또는 객체 리터럴에서 필요한 값만을 추출하여 변수를 할당한다. 12345678910111213const name = 'kim';const email = 'a123@a123.com';const age = null;// 0번const obj = &#123; name, // name : name email, // email : email age // age : age&#125;const &#123; name : anotherName &#125; = obj; // 1번const &#123; age = 22 &#125; = obj; // 2번 0번 : 프로퍼티 축약 표현이다. 즉, 아래와 같은 유형의 코드다. 12345678910// ES5var x = 1, y = 2;var obj = &#123; x: x, y: y&#125;;// ES6const obj = &#123; x, y &#125;; 1번 : 새로운 상수를 만드는데 obj객체의 name프로퍼티를 anotherName으로 바꾸고 할당하여 만들겠다는 의미. 즉, 아래와 같은 코드다. 1const anotherName = obj.name; 2번 : 맨 위 코드에서 age 상수에는 null값으로 초기화가 되어있지 않다. 만약 obj객체로 상수를 생성하는데 age값을 22로 초기화해서 만든다는 의미. 즉, 아래와 같은 코드다. 12const age = obj.age;age = 22; 백틱() 대신에 백틱문자( ` )를 이용할 수 있다. 단, ()를 이용할 경우 함수 내부의 내용은 문자열로 취급되지만, 백틱문자( ` )를 이용할 경우 Rest 파라미터로 받게된다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. Arrow Fn - ES6 미만 - 백틱이용3번 백틱이용하는 것은 Redux에서 사용하는 함수형 프로그래밍이다. 123456789101112// 1 arrow fnconst getPrice = percent =&gt; price =&gt; price * percent; // 2 ES6 미만에서 사용시const getPrice2 = function getPrice2(percent) &#123; return function (price) &#123; return price * percent; &#125;;&#125;; // 3 백틱 이용시const getPrice3 = function getPrice3(percent)`$&#123;price * percent&#125;`; SPA , Single Page Application ( Vanila.js )Vanila.js에서 Two-way-binding 123456789101112131415161718192021222324252627282930const listeners = document.querySelectorAll('[data-model]');listeners.forEach(listener =&gt; &#123; const name = listener.dataset.model; listener.addEventListener('keyup', event =&gt; &#123; state[name] = listener.value; console.log(state); &#125;)&#125;)const render = () =&gt; &#123;&#125;;// 해당하는 state가 변화될떄마다 proxy가 실행이되면서 화면에 렌더링 하게끔 한다.const createState = _state =&gt; &#123; return new Proxy(_state, &#123; set (target, property, value) &#123; // target[property] = value; render(); return true; // 반드시 return true를 해야만한다. &#125; &#125;);&#125;// state는 애플리케이션 제작시 변화되는 모든 변수를 담는다.const state = createState(&#123; name: 'KimJunHyeok', email: 'kim@naver.com',&#125;)console.log(state); Proxy Proxy 객체는 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 새로운 행동을 정의할 때 사용 new Proxy(초기화할 객체, 핸들러) : 핸들러는 2가지다 - (get , set) 123456789new Proxy(&#123; &#125;,&#123; get(target, property, value)&#123; // 렌더 함수 &#125;, set(target, property, value)&#123; // 렌더 함수 return true; &#125;&#125;); 리액트 프로젝트 생성하기npx create-react-app [리액트 프로젝트 명] : [ 리액트 프로젝트 명 ]으로 리액트 설정이 완료된 폴더 생성 1npx create-react-app youtube-mini-clone","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"React","slug":"TIL/React","permalink":"https://hyeok999.github.io/categories/TIL/React/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://hyeok999.github.io/tags/React/"}]},{"title":"코어 자바 스크립트 세미나","slug":"conference01","date":"2019-12-01T16:49:40.000Z","updated":"2019-12-03T17:22:24.317Z","comments":true,"path":"2019/12/02/conference01/","link":"","permalink":"https://hyeok999.github.io/2019/12/02/conference01/","excerpt":"","text":"코어 자바스크립트 세미나정재남 저자님 Index Data Types 실핼 컨텍스트 This call back function 클로저 prototype 1강 : Data Types⇥ 원시 타입 Number String Boolean null undefined ⇥ 참조 타입 Array Function RegExp 2강 : 실행 컨텍스트 (Execution Context)실행에 필요한 코드 흐름상의 배경이 되는 조건/환경. 동일한 조건 / 환경을 지니는 코드 뭉치 ( = 함수 또는 전역공간) 를 실행할 때 필요한 조건 /환경 정보. 함수를 실행할 대 필요한 환경 정보. (를 담은 객체) 렉시컬 환경 environmentRecord (현재 문맥의 식별자 정보) - 호이스팅 : 식별자 정보를 끌어올린다. outerEnvrionmentReference (현재 문맥에 관련 있는 외부 식별자 정보) - 스코프 체인 3강 : ThisThisBinding은 실행컨텍스트가 활성화 되는 순간에 한다. 그렇다면 실행컨텍스트의 활성화는? 해당 실행 컨텐스트를 포함하고 있는 함수가 호출 됐을 때! 즉, 함수가 호출되는 방식에 따라 this가 달라진다. 전역 공간에서 this : window 함수 호출시 this : window 메소드 호출 시 this : 메소드를 호출하는 주체(.앞에 있는 것)를 가리킨다. (a.b.c( ) 호출 시 -&gt; a.b가 나온다.) 생성자 함수 호출 시 : 생성자 함수가 생성할 인스턴스. 콜백 호출 시 : 기본적으로 함수 내부에서의 동일.(제어권을 가진 함수가 this를 명시한 경우. 그것을 따름.) 내부 함수에서의 우회법 call, bind, apply 1234567891011121314function(x,y,x)&#123; console.log(this,x,y,z); var b=&#123; c:'eee'; &#125;; a.call(b,1,2,3); a.apply(b,[1,2,3]); var c=a.bind(b) c(1,2,3); var d=a.bind(b,1,2); d(3);&#125; 화살표 변수 이용. 3번 변수를 이용한 내부 함수에서의 우회법 문제 12345678910111213var a = 10;var obj = &#123; a : 20, b : function () &#123; console.log(this.a); // 1 : obj function c () &#123; cosnole.log(this.a); // 2 : window &#125; c(); &#125;&#125;obj.b(); 2번도 obj가 뜨게 하는 방법은? 답 1234567891011121314var a = 10;var obj = &#123; a : 20, b : function () &#123; var self = this; console.log(this.a); // 1 : obj function c () &#123; cosnole.log(self.a); // 2 : obj &#125; c(); &#125;&#125;obj.b(); 변수에 this를 미리 담아서 이용한다. 4강 : call back functioncall back : 호출 하다. 다시 돌려주다. return function : 함수 제어권 실행 시점 (setInterver, setTimeout) 인자 (forEach) 123456789101112let arr = [1,2,3,4,5];let entries = [];arr.forEach(function (v, i) &#123; entries.push([i,v,this[i]]);&#125;, [10, 20, 30, 40, 50]);console.log(entries); [ [ 0, 1, 10 ], [ 1, 2, 20 ], [ 2, 3, 30 ], [ 3, 4, 40 ], [ 4, 5, 50 ] ] this 콜백 함수의 특징 다른 함수 (A)의 인자로 콜백함수 (B)를 전달하면, A가 B의 제어권을 갖는다, A가 B의 제어권을 갖게 된다. 5강 : 클로저클로저 : 함수와 그 함수가 선언될 당시의 렉시컬 환경의 결합. 12345678910var outer = function () &#123; var a = 1; var inner = function () &#123; console.log(++a); &#125;; ineer();&#125;var outer2 = outer();console.log(outer2());console.log(outer2()); 컨텍스트 A(outer)에서 선언한 변수 a를 참조하는 내부함수B(inner())를 A의 외부(outer2)로 전달할 경우, A(outer)가 종료된 이후에도 a가 사라지지 않는 현상이 클로저다. 위 예제에서는 변수 a가 사라지지않고 게속 남아있다. 그것이 클로저다. 클로저의 활용 : 정보은닉, 초기화 정보은닉 예) 123456789101112function a() &#123; var localA : 1; var localB : 2; var localC : 3; return &#123; get a() &#123; return localA; &#125;, set a(v) &#123; localA = v; &#125;, get b() &#123; return localB + localC; &#125;, set b(v) &#123; throw Error('read only'); &#125; &#125;&#125;var obj = a(); localA , localB, localC 변수는 외부에서 접근이 불가능 하게 되었다. 외부에서 요구할 수 있는 건 get a() , set a(v) 가 된다. 즉, 함수 종료 이후에도 지역변수가 사라지지 않게 할 수 있다. 6강 : prototypePrototype 프로토 타입을 이용해 생성자 함수에 접근하는 방법 [생성자 함수].prototype.constructor Object.getPrototypeOf([instance]).constructor [instance].__ proto __.constructor [instace].constructor 프로토 타입의 활용 123456789101112fucntion Person(n, a)&#123; this.name = n; this.age = a;&#125;Person.prototype.setOlder = function() &#123; this.age += 1;&#125;Person.prototype.getAge = function() &#123; return this.age;&#125;var lee = new Person('이순신', 40);var ryu = new Person('류성룡', 30); 7강 : 클래스ES5 로 ES6에서 사용하는 클래스 구현해보기 ES5 에서 사용되는 즉시 실행함수로 클래스처럼 구현하기. 123456789101112131415161718192021222324252627282930313233var extendClass = (function()&#123; function Bridge()&#123;&#125; return function(Parent, Child)&#123; Bridge.prototype = Parent.prototype; Child.prototype = new Bridge(); Child.prototype.constructor = Child; Child.prototype.superClass = Parent; &#125;&#125;)();function Person(name, age) &#123; this.name = name || '이름없음'; this.age = age || '나이모름';&#125;Person.prototype.getName = function() &#123; return this.name;&#125;Person.prototype.getAge = function() &#123; return this.age;&#125;function Employee(name, age, position) &#123; this.superClass(name, age); this.position = position || '직책모름';&#125;extendClass(Person, Employee); // 소스Employee.prototype.getPosition = function()&#123; return this.position;&#125; 소스 : extendClass를 호출하게되면 인자로 함수 2개를 받는다. Person 함수와 Employee함수인데 extendClass 함수에서 정리를 깔끔하게 위해 빈 함수 bridge함수를 만들고 bridge함수의 프로토타입에 Person함수의 프로토타입을 대입한다. 그리고 2번째로 받은 인자 Employee함수의 프로토 타입에 bridge 함수를 생성자함수로 new호출한다. 위 과정을 클래스로 작성할 경우 다음과 같다. 123456789101112131415161718192021class Person &#123; constructor(name, age) &#123; this.name = name || '이름없음'; this.age = age || '나이모름'; &#125; getName() &#123; return this.name; &#125; getAge() &#123; return this.age; &#125;&#125;class Employee extends Person &#123; constructor (name, age, position) &#123; super(name, age); this.position = position || '직책모름'; &#125; getPosition() &#123; return this.position; &#125;&#125;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"IT Event","slug":"Develop/IT-Event","permalink":"https://hyeok999.github.io/categories/Develop/IT-Event/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Closer","slug":"Closer","permalink":"https://hyeok999.github.io/tags/Closer/"},{"name":"Arrow Function","slug":"Arrow-Function","permalink":"https://hyeok999.github.io/tags/Arrow-Function/"},{"name":"prototype","slug":"prototype","permalink":"https://hyeok999.github.io/tags/prototype/"},{"name":"Core JavaScript","slug":"Core-JavaScript","permalink":"https://hyeok999.github.io/tags/Core-JavaScript/"}]},{"title":"linux-study-04","slug":"linux-study-04","date":"2019-11-28T14:13:35.000Z","updated":"2019-11-30T17:13:57.169Z","comments":true,"path":"2019/11/28/linux-study-04/","link":"","permalink":"https://hyeok999.github.io/2019/11/28/linux-study-04/","excerpt":"","text":"Group폴더나 ,파일에게 특정 그룹에게만 사용권한을 줄수있다. groupadd develops : 그룹을 추가한다. (일반 사용자는 추가를 못한다.) su - root 한 후 groupadd develops 혹은 sudo groupadd develops sudo usermod -a -G [그룹명] [사용자명] : 그룹에 사용자를 추가한다. sudo chown [주인명]:[그룹명] [파일명] : 디렉토리 혹은 파일 권한을 [그룹명]으로 변경한다. sudo chmod g+w [파일명] : 그룹에 write권한을 준다. Internet | Network | Server인터넷은 컴퓨터( Client )와 컴퓨터( Server )간의 request , response의 연속. Domain-name : 일종의 ip-address에 대한 별명. 우리가 컴퓨터에게 예를들어, 구글의 IP주소를 알려주지 않아도 구글의 ip를 알아서 찾아가는 이유는 우리가 인터넷창에google.com이라고 치는 순간 DNS Server라는 이 세상의 모든 도메인을 저장하고있는 서버에 접속하여 구글에 대한 IP를 받아서 접속하는 형태이다. ip 확인 명령어 curl ipinfo.io/ip : 외부에 접속할 때 사용하는 아이피 (즉, Public Address 를 알아냄.) ip addr : 내 컴퓨터에 접속한 실제 아이피 ( 내 컴퓨터에 실제로 할당된 아이피.) apache 웹 서버 웹서버의 종류 : apache, nginx등등 아파치를 설치하고 실행하면 여러 접속을 분산으로 받기 위해서 여러개가 실행이된다. elinks : 쉘환경에서 인터넷을 할 수 있도록 하는 프로그램 localhost : 자신의 로컬주소 (127.0.0.1) 에 대한 domain-name 예) Web-Broser에서 10.0.2.15/index.html 로 요청하면 Web-Serverd에서 index.html을 찾게된다. 웹페이지를 찾는 최상위 디렉토리 : document root /etc/apache2/sites-enabled/000-default.conf 에 document root가 적혀있다. log 파일 위치 : /var/log/apache2/ 서버에 관한 문제 해결시 log가 어디있는지 || root폴더 위치를 먼저 파악하는것이 좋다. SSH 원격제어 SSH란 Secure Shell Protocol, 즉 네트워크 프로토콜 중 하나로 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할 때 보안적으로 안전하게 통신을 하기 위해 사용하는 프로토콜. 사용조건 : 서버와 클라이언트 구조 서버에 SSH SERVER를 설치 클라이언트에 SSH CLIENT를 설치 클라이언트 -&gt; 서버 접속 ssh 서버명@아이피주소 접속이 완료되면, 클라이언트가 내리는 명령은 서버컴퓨터에서 처리되고 그 결과를 클라이언트 컴퓨터에 표시한다. port 웹서버는 80번 포트로 약속됨. SSH는 22번 포트로 약속됨. 0~1024 번까지의 포트번호는 ‘’표준’’으로 할당이 되어있다. 기본 포트는 80으로 간주한다. ( 생략시 80이라는 뜻 ) ssh -p [포트번호] 서버명@아이피 : -p [포트번호] 생략시 80포트. port forwarding 내부 IP는 특별한 작업을 거치지 않는 한 외부에서 접속할 수 없다. 오로지 외부 IP를 통해서만 접속이 가능하다. 따라서 라우터 포트 번호에 사설 ip와 포트를 포워딩 시킬 수 있다. 예를들면 다음과 같다. 공유기의 공인IP가 211.123.123.123 내 공유기에 연결된 호스트가 3개라고 가정 A 호스트 (192.168.1.100)B 호스트 (192.168.1.101)C호스트 (192.168.1.102)라고 가정하자. C호스트가 A호스트로 접속할 떄 192.168.1.100:22라고 입력을 한다면 A라는 호스트에 22포트로 접속을 한다는것을 알 수 있다. 하지만, 외부 IP 211.123.123.123이 211.123.123.123:22를 입력해도 A호스트의 ssh로 접속할 수 없다. 이유는 저 IP주소가 공유기를 지칭하는지, A,B,C를 지칭하는지 알 수 없기 때문이다. 따라서, 이럴 때 포트 포워딩을 이용한다. 외부에서 A호스트의 ssh로 접속하고 싶다면 공유기에서 구분하면 된다. “외부에서 특정 포트번호로 들어오게 된다면 A호스트의 22번 포트를 지칭하는것이다” 라는 규칙을 설정하면 된다. 공유기의 공인IP 뒤에 서비스 포트 번호 처럼 특정 포트번호를 입력하면 지정한 내부 호스트의 특정포트로 보내버린다. 공유기의 공인IP가 211.123.123.123이므로 211.123.123.123:1000 또는 1000~1010까지의 숫자를 입력하면 C호스트가 192.168.1.100:22라는 주소를 입력한 것과 동일하게 접속이 가능하게 된다. 이처럼 외부에서 접속 시 어떤 호스트의 어떤 서비스포트에 연결을 해주는지 설정을 해주는 것을 포트포워딩이라 한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"https://hyeok999.github.io/categories/TIL/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hyeok999.github.io/tags/linux/"},{"name":"OS","slug":"OS","permalink":"https://hyeok999.github.io/tags/OS/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"unix","slug":"unix","permalink":"https://hyeok999.github.io/tags/unix/"}]},{"title":"daily_algorithm44","slug":"daily44","date":"2019-11-27T13:27:53.000Z","updated":"2019-11-30T17:14:31.498Z","comments":true,"path":"2019/11/27/daily44/","link":"","permalink":"https://hyeok999.github.io/2019/11/27/daily44/","excerpt":"","text":"문제 출처 : 프로그래머스 정수 제곱근 판별문제 설명임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다.n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요. 제한 사항 n은 1이상, 50000000000000 이하인 양의 정수입니다. 입출력 예 n return 121 144 3 -1 입출력 예 설명입출력 예#1121은 양의 정수 11의 제곱이므로, (11+1)를 제곱한 144를 리턴합니다. 입출력 예#23은 양의 정수의 제곱이 아니므로, -1을 리턴합니다. 1234567891011121314function solution(n) &#123; let answer = 0; if (n === undefined) return -1; for (let i = 0; i &lt;= n; i++) &#123; if (i ** 2 === n) &#123; answer = (i + 1) ** 2; break; &#125; else &#123; answer = -1; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm43","slug":"daily43","date":"2019-11-26T14:22:49.000Z","updated":"2019-11-30T17:14:41.351Z","comments":true,"path":"2019/11/26/daily43/","link":"","permalink":"https://hyeok999.github.io/2019/11/26/daily43/","excerpt":"","text":"문제 출처 : 프로그래머스 위장문제 설명스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[yellow_hat, headgear], [blue_sunglasses, eyewear], [green_turban, headgear]] 5 [[crow_mask, face], [blue_sunglasses, face], [smoky_makeup, face]] 3 입출력 예 설명예제 #1headgear에 해당하는 의상이 yellowhat, greenturban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. 123451. yellow_hat2. blue_sunglasses3. green_turban4. yellow_hat + blue_sunglasses5. green_turban + blue_sunglasses 예제 #2face에 해당하는 의상이 crowmask, bluesunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. 1231. crow_mask2. blue_sunglasses3. smoky_makeup 12345678910111213141516171819202122function solution(clothes) &#123; let answer = 1; const clothesFind = clothes.map((a) =&gt; a[1]); const obj = &#123;&#125;; for (let i = 0; i &lt; clothesFind.length; i++) &#123; obj[clothesFind[i]] = 0; &#125; for (let i = 0; i &lt; clothesFind.length; i++) &#123; if (clothesFind[i] in obj) obj[clothesFind[i]]++; &#125; const result = Object.values(obj); for (let i = 0; i &lt; result.length; i++) &#123; answer *= (result[i] + 1); &#125; answer--; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"GitHub Commit 독려 애플리케이션","slug":"CarrotAndStick","date":"2019-11-25T04:15:50.000Z","updated":"2019-11-30T17:15:10.067Z","comments":true,"path":"2019/11/25/CarrotAndStick/","link":"","permalink":"https://hyeok999.github.io/2019/11/25/CarrotAndStick/","excerpt":"","text":"Carrot and StickGitHub Commit 독려 애플리케이션 1. 팀 소개 팀명 : 채찍과 당근 팀장 : 김준혁 팀원 : 정다희, 박홍빈 2. 팀 주제Git Commit 수에 따른 캐릭터 표정 변화 어플리케이션 입니다. 사용자의 학습 욕구를 도모하기 위해 만들었습니다. 3. 주제 선정 이유기능적인 측면 : GITHUB 관리를 위해 자신의 목표 커밋 수에 따라 스스로를 채찍질 하고, 스스로에게 칭찬(당근)을 할 수 있는 애플리케이션이 있다면 좋지 않을까? 기술적인 측면 : 이 애플리케이션 구현을 위해서 Git API와 여러 라이브러리를 직접 사용해보고, 프론트엔드 와 백엔드를 직⚬간접적으로 구축하여 어플리케이션의 흐름을 경험 할 수 있다. 4. 프로젝트 요구 사항 W3C에서 제공한 MarkUp Validation Service 에서 이상이 없을 것. 최대한 시멘틱 하게 작성할 것. Express + Mongo DB로 백엔드 구축 여러 라이브러리 경험 GitHub API 로드 및 가공 캐릭터 및 로고 렌더링 ( SVG 활용 ) todo list 기능을 이용한 닉네임별로 관리되는 Git Daily Planner 개발 Git flow를 사용하여 협업을 할 것. Git 컨벤션을 최대한 지킬 것 5. 구현 기술 6. MVP Flow Chart 7. Mark Up 8. 구현 일정 9. 프로젝트 구현 영상 10. 한계점 및 보완점 ( Git Api 에서 DDOS 공격을 방지하고자 IP 단위로 접근 수를 제한하고 있다. )한계점 1 : ⇢ 인증되지 않은 유저로 Git Api의 접근 보완점 : ⇢ 비밀번호 필요 ( limit 초기화 ) ⇢ Git 개발자 도구에서 사용자가 인증하도록 요구 ( limit 6000 번 할당 ) ⇢ 사용자가 실시간으로 새로고침 버튼을 누름 으로서 최대한 limit을 사용하지 않도록 함. 한계점 2 : ⇢ Git Api의 데이터를 실시간으로 감시할 수 없음. 보완점 : ⇢ 일정 시간 이상 시 직속적으로 Api를 Get한다. ( setInterval 함수 사용 ) ⇢ 프레임워크를 이용한다. ( Vue.js 의 watch 기능 등등 ) ⇢ 사용자가 실시간으로 새로고침 버튼을 누르게 요구. View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Project","slug":"Project","permalink":"https://hyeok999.github.io/tags/Project/"}]},{"title":"iteration","slug":"iteration","date":"2019-11-23T12:00:17.000Z","updated":"2019-11-30T17:14:13.335Z","comments":true,"path":"2019/11/23/iteration/","link":"","permalink":"https://hyeok999.github.io/2019/11/23/iteration/","excerpt":"","text":"JavaScript 이터레이션 프로토콜 이터레이션 프로토콜 이터러블 이터레이터 빌트인 이터러블 이터레이션 프로토콜의 필요성 for…of 문 커스텀 이터러블 커스텀 이터러블 구현 이터러블을 생성하는 함수 무한 이터러블과 Lazy evaluation(지연 평가) 이터레이션 프로토콜 ES6부터 도입된 이터레이션 프로토콜은 데이터 컬렉션을 순회하기 위한 프로토콜. 이터레이션 프로토콜을 준수한 객체는 for…of로 순회가 가능하며 spread문법의 피연산자가 될 수 있다. 이터레이션 프로토콜에는 2가지가 있다. 이터러블 프로토콜 이터레이터 프로토콜 이터러블이터러블 프로토콜을 준수한 객체를 이터러블이라 칭한다. 이터러블은 Symbol.iterator 메소드를 구현하거나 프로토 타입 체인에 의해 상속한 객체를 일컫는다. Symbol.iterator 메소드는 이터레이터를 반환한다. 배열은 Symbol.iterator 메소드를 소유한다. 따라서 배열은 이터러블 프로토콜을 준수한 이터러블이다. 반대로 일반 객체는 Symbol.iterator 메소드를 소유하고 있지 않다. 따라서 일반 객체는 이터러블이 아니다. 1234567891011const array = [1, 2, 3];// 배열은 Symbol.iterator 메소드를 소유한다.// 따라서 배열은 이터러블 프로토콜을 준수한 이터러블이다.console.log(Symbol.iterator in array); // trueconst obj = &#123; a: 1, b: 2 &#125;;// 일반 객체는 Symbol.iterator 메소드를 소유하지 않는다.// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.console.log(Symbol.iterator in obj); // false 일반 객체는 이터러블이 아니기 때문에 for…of 문에서 순회할 수 없으며 Spread 문법의 대상으로 사용할 수도 없다. 하지만 이터러블이 아닌 일반 객체를 이터러블처럼 동작하도록 구현하고 싶다면 이터레이션 프로토콜을 따르면 된다. Symbol.iterator를 키로 갖는 메소드를 객체에 추가하고 이터레이터(iterator)를 반환하도록 구현하면 그 객체는 이터러블이 된다. ( = 커스텀 이터러블 ) 123456789101112131415161718192021// 1 ~ 5 사이의 정수로 이루어진 이터러블const iterable = &#123; // Symbol.iterator 메소드를 구현하여 이터러블 프로토콜을 준수 [Symbol.iterator]() &#123; let cur = 1; const max = 5; // Symbol.iterator 메소드는 next 메소드를 소유한 이터레이터를 반환 return &#123; next() &#123; return &#123; value: cur++, done: cur &gt; max + 1 &#125;; &#125; &#125;; &#125;&#125;;for (const num of iterable) &#123; console.log(num); // 1 2 3 4 5&#125; 이터레이터이터레이터 프로토콜은 next 메소드를 소유 ➤ 호출 시 이터러블을 순회함 next 메소드의 호출 후 반환 ➤ value, done 프로퍼티 를 갖는 이터레이터 리절트 객체 이 규약을 준수한 것이 이터레이터. 즉슨, 이터러블(Symbol.iterator 소유) ➤ Symbol.iterator 메소드 호출 ➤ 이터레이터 반환 ➤ 이터레이터(next 메소드 소유) next메소드 호출 ➤ 이터레이터 리절트 객체 반환(value, done 프로퍼티 소유) 123456789101112131415// 배열은 이터러블 프로토콜을 준수한 이터러블이다.const array = [1, 2, 3];// Symbol.iterator 메소드는 이터레이터를 반환한다.const iterator = array[Symbol.iterator]();// 이터레이터 프로토콜을 준수한 이터레이터는 next 메소드를 갖는다.console.log('next' in iterator); // true// 이터레이터의 next 메소드를 호출하면 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다.// next 메소드를 호출할 때 마다 이터러블을 순회하며 이터레이터 리절트 객체를 반환한다.console.log(iterator.next()); // &#123;value: 1, done: false&#125;console.log(iterator.next()); // &#123;value: 2, done: false&#125;console.log(iterator.next()); // &#123;value: 3, done: false&#125;console.log(iterator.next()); // &#123;value: undefined, done: true&#125; 이터레이터의 next 메소드가 반환하는 이터레이터 리절트 객체의 value 프로퍼티는 현재 순회 중인 이터러블의 값을 반환하고 done 프로퍼티는 이터러블의 순회 완료 여부를 반환한다. 빌트인 이터러블ES6에서 제공하는 빌트인 이터러블들 Array, String, Map, Set, TypedArray(Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array), DOM data structure(NodeList, HTMLCollection), Arguments 이터레이션 프로토콜의 필요성이터러블은 데이터 공급자(Data provider)의 역할을 한다. 만약 다양한 데이터들(Array, String, Map, Set 등등 빌트인 이터러블들)의 순회방식이 각자만의 방식을 가지고 있다면 사용자는 해당 데이터를 사용할 때마다 그 방식을 일일히 지켜가야만 한다. 이러한 방법은 매우 비효율적이다. 하지만, 다양한 데이터가 이터레이션 프로토콜을 준수하도록 규정하면 데이터 소비자는 이터레이션 프로토콜만을 지원하도록 구현하면 된다. 즉, 이터레이션 프로토콜은 다양한 데이터 소스가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 소스를 사용할 수 있도록 데이터 소비자와 데이터 소스를 연결하는 인터페이스의 역할을 한다. 이터러블을 지원하는 데이터 소비자는 내부에서 Symbol.iterator 메소드를 호출해 이터레이터를 생성한다. 이터레이터의 next 메소드를 호출하여 이터러블을 순회한다. next 메소드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 취득한다. for…of 문for…of 문은 내부적으로 이터레이터의 next 메소드를 호출하여 이터러블을 순회하며 next 메소드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 for…of 문의 변수에 할당한다. 그리고 이터레이터 리절트 객체의 done 프로퍼티 값이 false이면 이터러블의 순회를 계속하고 true이면 이터러블의 순회를 중단한다. 12345678910111213141516171819// 배열for (const item of ['a', 'b', 'c']) &#123; console.log(item);&#125;// 문자열for (const letter of 'abc') &#123; console.log(letter);&#125;// Mapfor (const [key, value] of new Map([['a', '1'], ['b', '2'], ['c', '3']])) &#123; console.log(`key : $&#123;key&#125; value : $&#123;value&#125;`); // key : a value : 1 ...&#125;// Setfor (const val of new Set([1, 2, 3])) &#123; console.log(val);&#125; for…of 문이 내부적으로 동작하는 것을 for 문으로 표현하면 아래와 같다. 123456789101112131415// 이터러블const iterable = [1, 2, 3];// 이터레이터const iterator = iterable[Symbol.iterator]();for (;;) &#123; // 이터레이터의 next 메소드를 호출하여 이터러블을 순회한다. const res = iterator.next(); // next 메소드가 반환하는 이터레이터 리절트 객체의 done 프로퍼티가 true가 될 때까지 반복한다. if (res.done) break; console.log(res);&#125; 커스텀 이터러블Poiema 커스텀 이터러블 참고 커스텀 이터러블 구현일반 객체는 Symbol.iterator 메소드를 소유하지 않는다.즉, 일반 객체는 이터러블 프로토콜을 준수하지 않으므로 for…of 문으로 순회할 수 없다. 하지만 일반 객체가 이터레이션 프로토콜을 준수하도록 구현하면 이터러블이 된다. 예 : 피보나치 수열(1, 2, 3, 5…)을 구현한 간단한 이터러블 12345678910111213141516171819202122232425262728const fibonacci = &#123; // Symbol.iterator 메소드를 구현하여 이터러블 프로토콜을 준수 [Symbol.iterator]() &#123; let [pre, cur] = [0, 1]; // 최대값 const max = 10; // Symbol.iterator 메소드는 next 메소드를 소유한 이터레이터를 반환해야 한다. // next 메소드는 이터레이터 리절트 객체를 반환 return &#123; // fibonacci 객체를 순회할 때마다 next 메소드가 호출된다. next() &#123; [pre, cur] = [cur, pre + cur]; return &#123; value: cur, done: cur &gt;= max &#125;; &#125; &#125;; &#125;&#125;;// 이터러블의 최대값을 외부에서 전달할 수 없다.for (const num of fibonacci) &#123; // for...of 내부에서 break는 가능하다. // if (num &gt;= 10) break; console.log(num); // 1 2 3 5 8&#125; Symbol.iterator 메소드는 next 메소드를 갖는 이터레이터를 반환하여야 한다. 그리고 next 메소드는 done과 value 프로퍼티를 가지는 이터레이터 리절트 객체를 반환한다. for…of 문은 done 프로퍼티가 true가 될 때까지 반복하며 done 프로퍼티가 true가 되면 반복을 중지한다. 이터러블은 for…of 문뿐만 아니라 spread 문법, 디스트럭쳐링 할당, Map과 Set의 생성자에도 사용된다. 12345678// spread 문법과 디스트럭처링을 사용하면 이터러블을 손쉽게 배열로 변환할 수 있다.// spread 문법const arr = [...fibonacci];console.log(arr); // [ 1, 2, 3, 5, 8 ]// 디스트럭처링const [first, second, ...rest] = fibonacci;console.log(first, second, rest); // 1 2 [ 3, 5, 8 ] 이터러블을 생성하는 함수위 fibonacci 이터러블에는 외부에서 값을 전달할 방법이 없다는 아쉬운 점이 있다. fibonacci 이터러블의 최대값을 외부에서 전달할 수 있도록 수정해 보자. 이터러블의 최대 순회수를 전달받아 이터러블을 반환하는 함수를 만들면 된다. 123456789101112131415161718192021222324252627// 이터러블을 반환하는 함수const fibonacciFunc = function (max) &#123; let [pre, cur] = [0, 1]; return &#123; // Symbol.iterator 메소드를 구현하여 이터러블 프로토콜을 준수 [Symbol.iterator]() &#123; // Symbol.iterator 메소드는 next 메소드를 소유한 이터레이터를 반환해야 한다. // next 메소드는 이터레이터 리절트 객체를 반환 return &#123; // fibonacci 객체를 순회할 때마다 next 메소드가 호출된다. next() &#123; [pre, cur] = [cur, pre + cur]; return &#123; value: cur, done: cur &gt;= max &#125;; &#125; &#125;; &#125; &#125;;&#125;;// 이터러블을 반환하는 함수에 이터러블의 최대값을 전달한다.for (const num of fibonacciFunc(10)) &#123; console.log(num); // 1 2 3 5 8&#125; 이터러블이면서 이터레이터인 객체를 생성하는 함수이터레이터를 생성하려면 이터러블의 Symbol.iterator 메소드를 호출해야 한다. 이터러블이면서 이터레이터인 객체를 생성하면 Symbol.iterator 메소드를 호출하지 않아도 된다. 123456789101112131415161718192021222324252627282930313233343536373839// 이터러블이면서 이터레이터인 객체를 반환하는 함수const fibonacciFunc = function (max) &#123; let [pre, cur] = [0, 1]; // Symbol.iterator 메소드와 next 메소드를 소유한 // 이터러블이면서 이터레이터인 객체를 반환 return &#123; // Symbol.iterator 메소드 [Symbol.iterator]() &#123; return this; &#125;, // next 메소드는 이터레이터 리절트 객체를 반환 next() &#123; [pre, cur] = [cur, pre + cur]; return &#123; value: cur, done: cur &gt;= max &#125;; &#125; &#125;;&#125;;// iter는 이터러블이면서 이터레이터이다.let iter = fibonacciFunc(10);// iter는 이터레이터이다.console.log(iter.next()); // &#123;value: 1, done: false&#125;console.log(iter.next()); // &#123;value: 2, done: false&#125;console.log(iter.next()); // &#123;value: 3, done: false&#125;console.log(iter.next()); // &#123;value: 5, done: false&#125;console.log(iter.next()); // &#123;value: 8, done: false&#125;console.log(iter.next()); // &#123;value: 13, done: true&#125;iter = fibonacciFunc(10);// iter는 이터러블이다.for (const num of iter) &#123; console.log(num); // 1 2 3 5 8&#125; 아래의 객체는 Symbol.iterator 메소드와 next 메소드를 소유한 이터러블이면서 이터레이터이다. Symbol.iterator 메소드는 this를 반환하므로 next 메소드를 갖는 이터레이터를 반환한다. 123456&#123; [Symbol.iterator]() &#123; return this; &#125;, next() &#123; /***/ &#125;&#125; 무한 이터러블과 Lazy evaluation(지연 평가)무한 이터러블(infinite sequence)을 생성하는 함수를 정의해보자.이를 통해 무한 수열(infinite sequence)을 간단히 표현할 수 있다. 12345678910111213141516171819202122232425// 무한 이터러블을 생성하는 함수const fibonacciFunc = function () &#123; let [pre, cur] = [0, 1]; return &#123; [Symbol.iterator]() &#123; return this; &#125;, next() &#123; [pre, cur] = [cur, pre + cur]; // done 프로퍼티를 생략한다. return &#123; value: cur &#125;; &#125; &#125;;&#125;;// fibonacciFunc 함수는 무한 이터러블을 생성한다.for (const num of fibonacciFunc()) &#123; if (num &gt; 10000) break; console.log(num); // 1 2 3 5 8...&#125;// 무한 이터러블에서 3개만을 취득한다.const [f1, f2, f3] = fibonacciFunc();console.log(f1, f2, f3); // 1 2 3 “이터레이션 프로토콜의 필요성“에서 살펴보았듯이 이터러블은 데이터 공급자(Data provider)의 역할을 한다.배열, 문자열, Map, Set 등의 빌트인 이터러블은 데이터를 모두 메모리에 확보한 다음 동작한다.하지만 이터러블은 Lazy evaluation(지연 평가)를 통해 값을 생성한다.Lazy evaluation은 평가 결과가 필요할 때까지 평가를 늦추는 기법이다. 위 예제의 fibonacciFunc 함수는 무한 이터러블을 생성한다.하지만 fibonacciFunc 함수가 생성한 무한 이터러블은 데이터를 공급하는 메커니즘을 구현한 것으로 데이터 소비자인 for…of 문이나 디스트럭처링 할당이 실행되기 이전까지 데이터를 생성하지는 않는다.for…of 문의 경우, 이터러블을 순회할 때 내부에서 이터레이터의 next 메소드를 호출하는데 바로 이때 데이터가 생성된다. next 메소드가 호출되기 이전까지는 데이터를 생성하지 않는다.즉, 데이터가 필요할 때까지 데이터의 생성을 지연하다가 데이터가 필요한 순간 데이터를 생성한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"iteration","slug":"iteration","permalink":"https://hyeok999.github.io/tags/iteration/"}]},{"title":"Symbol","slug":"Symbol","date":"2019-11-22T12:32:28.000Z","updated":"2019-11-30T16:57:05.963Z","comments":true,"path":"2019/11/22/Symbol/","link":"","permalink":"https://hyeok999.github.io/2019/11/22/Symbol/","excerpt":"","text":"JavaScript Symbol Symbol Symbol.for 메소드 Symbol의 쓰임 프로퍼티 키 프로퍼티 은닉 표준 빌트인 객체 확장 이용 Well known Symbol 용어 - ( 러버덕 ) Symbol Symbol.for Symbol원시값을 만드는 방법은 리터럴이 있다. 근데 Symbol로도 원시값을 만들어낼 수 있는데 이 때 Symbol함수로 호출해야만 한다. 생성된 Symbol은 객체가 아니라 변경 불가능한 원시 타입의 값이다. 1234567// 심볼 mySymbol은 이름의 충돌 위험이 없는 유일한 프로퍼티 키let mySymbol = Symbol();console.log(mySymbol); // Symbol()console.log(typeof mySymbol); // symbolnew Symbol(); // TypeError: Symbol is not a constructor Symbol 함수는 래퍼 객체를 생성하는 생성자 함수(String, Number, Boolean 등등)과는 달리 new연산자를 이용하지 않는다. Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 심볼 값에 대한 설명으로 디버깅용도로만 이용된다. 심볼 값에 대한 설명이 같더라도 생성된 심볼 값은 유일무이한 값이다. 12345// 심볼 값에 대한 설명이 같더라도 유일무이한 심볼 값을 생성한다.const mySymbol1 = Symbol('mySymbol');const mySymbol2 = Symbol('mySymbol');console.log(mySymbol1 === mySymbol2); // false 심볼 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다. 12345const mySymbol = Symbol();// 심볼 값은 암묵적으로 타입 변환이 되지 않는다.console.log(mySymbol + ''); // TypeError: Cannot convert a Symbol value to a stringconsole.log(+mySymbol); // TypeError: Cannot convert a Symbol value to a string 단, 불리언 타입으로는 암묵적으로 타입 변환된다. 이를 통해 if 문 등에서 존재 확인이 가능하다. 1234567const mySymbol = Symbol();// 불리언 타입으로는 암묵적으로 타입 변환된다console.log(!!mySymbol); // true// if 문 등에서 존재 확인을 위해 사용할 수 있다.if (mySymbol) console.log('mySymbol is not empty.'); Symbol.for 메소드Symbol.for 메소드는 인수로 전달받은 문자열을 키로 사용하여 키와 심볼 값의 쌍들이 저장되어 있는 전역 심볼 레지스트리(global symbol registry)에서 해당 키와 일치하는 심볼 값을 검색한다. 검색에 성공하면 새로운 심볼 값을 생성하지 않고 검색된 심볼 값을 반환한다. 검색에 실패하면 새로운 심볼 값을 생성하여 Symbol.for 메소드의 인수로 전달된 키로 전역 Symbol 레지스트리에 저장한 후, 생성된 심볼 값을 반환한다. 그냥 Symbol은 유일무이한 심볼 값을 단 하나만 생성하기 때문에 전역 심볼 레지스트리에서 관리하지 않는다. 하지만, Symbol.for 메소드를 이용하면 전역에서 심볼 레지스트리를 통해 공유가 가능하다. 123456// 전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 없으면 새로운 심볼 값을 생성const s = Symbol.for('mySymbol');// 전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출console.log(Symbol.keyFor(s)); // mySymbolconsole.log(s); // Symbol(mySymbol) Symbol의 쓰임1. 프로퍼티 키심볼 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심볼 값에 대괄호를 사용해야 한다. 프로퍼티에 접근할 때도 마찬가지로 대괄호를 사용해야 한다. 123456const obj = &#123; // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol.for('mySymbol')]: 1&#125;;console.log(obj[Symbol.for('mySymbol')]); // 1 심볼 값은 유일무이한 값이므로 심볼 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다. 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 미래에 추가될 어떤 프로퍼티 키와도 충돌할 위험이 없다. 2. 프로퍼티 은닉심볼 값으로 동적 생성한 프로퍼티 키로 만든 프로퍼티는 for…in 문이나 Object.keys, Object.getOwnPropertyNames 메소드로 찾을 수 없다. 즉, 프로퍼티를 은닉할 수 있다. 1234567891011const obj = &#123; // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol('mySymbol')]: 1&#125;;for (const key in obj) &#123; console.log(key); // 아무것도 출력되지 않는다.&#125;console.log(Object.keys(obj)); // []console.log(Object.getOwnPropertyNames(obj)); // [] 은닉된 Symbor을 찾기 위해서는 Object.getOwnPropertySymbols 메소드를 이용해야만 한다. 1234567891011const obj = &#123; // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol('mySymbol')]: 1&#125;;// ES6 : getOwnPropertySymbolsconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(mySymbol)]// 심볼 값을 찾을 수 있다.const symbolKey1 = Object.getOwnPropertySymbols(obj)[0];console.log(obj[symbolKey1]); // 1 3. 표준 빌트인 객체 확장 이용보통으로는 표준 빌트인에 사용자 정의 메소드를 직접 추가해서 확장하여 사용하지는 않는다. 그럼에도 불구하고 아래처럼 확장했다고 가정하자. 1234567// 표준 빌트인 객체를 확장하는 것은 권장하지 않는다.// 즉, Array.prototype은 읽기 전용으로 사용하는 것이 좋다.Array.prototype.sum = function () &#123; return this.reduce((p, c) =&gt; p + c, 0);&#125;;console.log([1, 2].sum()); // 3 나는 sum이라는 메소드를 Array.prototype에 확장해서 사용했다. 그런데 만약에 차후에 생긴 ES~~ 버전에서 sum이라는 메소드를 만들어 배포했다고 할 경우, 내 메소드가 빌트인 메소드를 덮어씌우게 된다. 이는 나중에 문제로 야기될 확률이 매우 높다. 하지만 중복될 가능성이 없는 심볼 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 버전이 올라감에 따라 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있다. 123456// 심볼 값으로 프로퍼티 키를 동적 생성하면 다른 프로퍼티 키와 절대 충돌하지 않는다.Array.prototype[Symbol.for('sum')] = function () &#123; return this.reduce((p, c) =&gt; p + c, 0);&#125;;console.log([1, 2][Symbol.for('sum')]()); // 3 Well know SymbolJS가 기본 제공하는 빌트인 심볼값이 존재한다. 빌트인 심볼 값은 Symbol 함수의 프로퍼티에 할당되어 있다. 이처럼 JS에서 기본 제공하는 빌트인 심볼 값을 Well-Known Symbol이라 부른다. Well-Known Symbol은 자바스크립트 엔진의 내부 알고리즘에 사용된다. 내부 알고리즘의 예 : 배열, String 객체, arguments 객체 for…of 문으로 순회 가능한 빌트인 이터러블(iterable)은 Well-Known Symbol인 Symbol.iterator를 키로 갖는 메소드를 갖으며, Symbol.iterator 메소드를 호출하면 이터레이터(iterator)를 반환하도록 ECMAScript 사양에 규정되어 있다. 빌트인 이터러블은 이 규정(이터레이션 프로토콜)을 준수하고 있다. 빌트인 이터러블 이터러블은 for…of 문으로 순회할 수 있고 스프레드 문법의 피연산자가 될 수 있는 객체를 말한다. 자바스크립트가 기본 제공하는 빌트인 이터러블은 아래와 같다. 빌트인 이터러블 프로퍼티 키가 Symbol.iterator인 메소드 Array Array.prototype[Symbol.iterator] String String.prototype[Symbol.iterator] Map Map.prototype[Symbol.iterator] Set Set.prototype[Symbol.iterator] TypedArray TypedArray.prototype[Symbol.iterator] arguments arguments[Symbol.iterator] DOM 컬렉션 NodeList.prototype[Symbol.iterator], HTMLCollection.prototype[Symbol.iterator] 일반 객체에 추가해야 하는 메소드의 키 Symbol.iterator은 기존 프로퍼티 키 또는 미래에 추가될 프로퍼티 키와 절대로 중복되지 않을 것이다. 이처럼 심볼은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입되었다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Symbol","slug":"Symbol","permalink":"https://hyeok999.github.io/tags/Symbol/"}]},{"title":"javascript-study-27","slug":"javascript-study-27","date":"2019-11-19T14:42:20.000Z","updated":"2019-11-30T16:58:23.139Z","comments":true,"path":"2019/11/19/javascript-study-27/","link":"","permalink":"https://hyeok999.github.io/2019/11/19/javascript-study-27/","excerpt":"","text":"JavaScript Study 27 Symbol Symbol.for 메소드 Symbol의 쓰임 프로퍼티 키 프로퍼티 은닉 표준 빌트인 객체 확장 이용 개발 커뮤니티 이용법 용어 - ( 러버덕 ) Symbol Symbol.for Symbol원시값을 만드는 방법은 리터럴이 있다. 근데 Symbol로도 원시값을 만들어낼 수 있는데 이 때 Symbol함수로 호출해야만 한다. 생성된 Symbol은 객체가 아니라 변경 불가능한 원시 타입의 값이다. 1234567// 심볼 mySymbol은 이름의 충돌 위험이 없는 유일한 프로퍼티 키let mySymbol = Symbol();console.log(mySymbol); // Symbol()console.log(typeof mySymbol); // symbolnew Symbol(); // TypeError: Symbol is not a constructor Symbol 함수는 래퍼 객체를 생성하는 생성자 함수(String, Number, Boolean 등등)과는 달리 new연산자를 이용하지 않는다. Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 심볼 값에 대한 설명으로 디버깅용도로만 이용된다. 심볼 값에 대한 설명이 같더라도 생성된 심볼 값은 유일무이한 값이다. 12345// 심볼 값에 대한 설명이 같더라도 유일무이한 심볼 값을 생성한다.const mySymbol1 = Symbol('mySymbol');const mySymbol2 = Symbol('mySymbol');console.log(mySymbol1 === mySymbol2); // false 심볼 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다. 12345const mySymbol = Symbol();// 심볼 값은 암묵적으로 타입 변환이 되지 않는다.console.log(mySymbol + ''); // TypeError: Cannot convert a Symbol value to a stringconsole.log(+mySymbol); // TypeError: Cannot convert a Symbol value to a string 단, 불리언 타입으로는 암묵적으로 타입 변환된다. 이를 통해 if 문 등에서 존재 확인이 가능하다. 1234567const mySymbol = Symbol();// 불리언 타입으로는 암묵적으로 타입 변환된다console.log(!!mySymbol); // true// if 문 등에서 존재 확인을 위해 사용할 수 있다.if (mySymbol) console.log('mySymbol is not empty.'); Symbol.for 메소드Symbol.for 메소드는 인수로 전달받은 문자열을 키로 사용하여 키와 심볼 값의 쌍들이 저장되어 있는 전역 심볼 레지스트리(global symbol registry)에서 해당 키와 일치하는 심볼 값을 검색한다. 검색에 성공하면 새로운 심볼 값을 생성하지 않고 검색된 심볼 값을 반환한다. 검색에 실패하면 새로운 심볼 값을 생성하여 Symbol.for 메소드의 인수로 전달된 키로 전역 Symbol 레지스트리에 저장한 후, 생성된 심볼 값을 반환한다. 그냥 Symbol은 유일무이한 심볼 값을 단 하나만 생성하기 때문에 전역 심볼 레지스트리에서 관리하지 않는다. 하지만, Symbol.for 메소드를 이용하면 전역에서 심볼 레지스트리를 통해 공유가 가능하다. 123456// 전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 없으면 새로운 심볼 값을 생성const s = Symbol.for('mySymbol');// 전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출console.log(Symbol.keyFor(s)); // mySymbolconsole.log(s); // Symbol(mySymbol) Symbol의 쓰임1. 프로퍼티 키심볼 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심볼 값에 대괄호를 사용해야 한다. 프로퍼티에 접근할 때도 마찬가지로 대괄호를 사용해야 한다. 123456const obj = &#123; // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol.for('mySymbol')]: 1&#125;;console.log(obj[Symbol.for('mySymbol')]); // 1 심볼 값은 유일무이한 값이므로 심볼 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다. 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 미래에 추가될 어떤 프로퍼티 키와도 충돌할 위험이 없다. 2. 프로퍼티 은닉심볼 값으로 동적 생성한 프로퍼티 키로 만든 프로퍼티는 for…in 문이나 Object.keys, Object.getOwnPropertyNames 메소드로 찾을 수 없다. 즉, 프로퍼티를 은닉할 수 있다. 1234567891011const obj = &#123; // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol('mySymbol')]: 1&#125;;for (const key in obj) &#123; console.log(key); // 아무것도 출력되지 않는다.&#125;console.log(Object.keys(obj)); // []console.log(Object.getOwnPropertyNames(obj)); // [] 은닉된 Symbor을 찾기 위해서는 Object.getOwnPropertySymbols 메소드를 이용해야만 한다. 1234567891011const obj = &#123; // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol('mySymbol')]: 1&#125;;// ES6 : getOwnPropertySymbolsconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(mySymbol)]// 심볼 값을 찾을 수 있다.const symbolKey1 = Object.getOwnPropertySymbols(obj)[0];console.log(obj[symbolKey1]); // 1 3. 표준 빌트인 객체 확장 이용보통으로는 표준 빌트인에 사용자 정의 메소드를 직접 추가해서 확장하여 사용하지는 않는다. 그럼에도 불구하고 아래처럼 확장했다고 가정하자. 1234567// 표준 빌트인 객체를 확장하는 것은 권장하지 않는다.// 즉, Array.prototype은 읽기 전용으로 사용하는 것이 좋다.Array.prototype.sum = function () &#123; return this.reduce((p, c) =&gt; p + c, 0);&#125;;console.log([1, 2].sum()); // 3 나는 sum이라는 메소드를 Array.prototype에 확장해서 사용했다. 그런데 만약에 차후에 생긴 ES~~ 버전에서 sum이라는 메소드를 만들어 배포했다고 할 경우, 내 메소드가 빌트인 메소드를 덮어씌우게 된다. 이는 나중에 문제로 야기될 확률이 매우 높다. 하지만 중복될 가능성이 없는 심볼 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 버전이 올라감에 따라 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있다. 123456// 심볼 값으로 프로퍼티 키를 동적 생성하면 다른 프로퍼티 키와 절대 충돌하지 않는다.Array.prototype[Symbol.for('sum')] = function () &#123; return this.reduce((p, c) =&gt; p + c, 0);&#125;;console.log([1, 2][Symbol.for('sum')]()); // 3 개발 커뮤니티 이용법 twitter 이용 : 예) JS에서 유명한 사람들을 팔로우한다.(TC39에서 유명한 사람들) 그러면 그들과 관련된 트윗이 날라오는데 그것을 이용한다. facebook 이용 : 프론트엔드 개발 그룹, 프론트엔드 스터디 그룹 과 같은 그룹들을 이용한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"TodoList Async/Await","slug":"daily42","date":"2019-11-16T14:49:45.000Z","updated":"2019-12-06T11:04:40.538Z","comments":true,"path":"2019/11/16/daily42/","link":"","permalink":"https://hyeok999.github.io/2019/11/16/daily42/","excerpt":"","text":"TODO LIST FULL VERSION - async / awaitAjax 란? JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술. Ajax 요청 방법 3가지 XMLHttpRequest Axios fetch async / await package.json .eslintrc.js app.js 서버 public폴더 ▼ index.html css/style.css js/05async.js package.json 123456789101112131415161718192021&#123; \"name\": \"server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"start\": \"nodemon app\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.17.1\" &#125;, \"devDependencies\": &#123; \"eslint\": \"^6.6.0\", \"eslint-config-airbnb-base\": \"^14.0.0\", \"eslint-plugin-html\": \"^6.0.0\", \"eslint-plugin-import\": \"^2.18.2\" &#125;&#125; .eslintrc.js 12345678910111213141516171819202122232425262728293031module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) // \"no-var\": 0, \"prefer-arrow-callback\": 0, \"no-console\": 0, // \"warn\" \"no-plusplus\": \"off\", // x \"vars-on-top\": 0, // x \"eqeqeq\": 0, \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", // \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"], \"no-nested-ternary\": 0, \"no-param-reassign\": 0, \"no-return-assign\" : 0, &#125;&#125;; app.js 서버 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascirpt', completed: false &#125;];// 루트 폴더의 이름을 퍼블릭으로 할거야.// 미들웨어 딱 1번만 실행됨.app.use(express.static('public'));app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsing// app.get('/', (req, res) =&gt; &#123;// res.send('hello world!');// &#125;);app.get('/todos', (req, res) =&gt; &#123; todos.sort((t1, t2) =&gt; t2.id - t1.id); res.send(todos);&#125;);app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); todos = [req.body, ...todos]; res.send(todos);&#125;);// app.patch('/todos/:id([0-9])', (req, res) =&gt; &#123;app.patch('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id const &#123; completed &#125; = req.body; // req.body.completed; todos = todos.map((todo) =&gt; (todo.id === +id ? &#123; ...todo, completed &#125; : todo)); res.send(todos);&#125;);app.delete('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id todos = todos.filter((todo) =&gt; todo.id !== +id); res.send(todos);&#125;);app.delete('/completedTodos', (req, res) =&gt; &#123; todos = todos.filter((todo) =&gt; !todo.completed); res.send(todos);&#125;);app.patch('/todos', (req, res) =&gt; &#123; const &#123; completed &#125; = req.body; todos = todos.map((todo) =&gt; (&#123; ...todo, completed &#125;)); res.send(todos);&#125;);app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"./css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"./js/05async.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;footer&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css/style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; font-size: 0.9em; color: #a9b0b4; /*#58666e;*/ background-color: #505455;/*#f0f3f4;*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todos &#123; margin-top: 20px;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .checkbox .checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 .checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.checkbox &#123; display: none;&#125;.checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; js/05async.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136let todos = [];let navId = 'all';const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $nav = document.querySelector('.nav');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');const $completeAll = document.querySelector('.complete-all');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');const render = () =&gt; &#123; let html = ''; const _todos = todos.filter((todo) =&gt; (navId === 'all' ? true : navId === 'active' ? !todo.completed : todo.completed)); _todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;button class=\"remove-todo\"&gt;X&lt;/button&gt; &lt;/li&gt;`; &#125;); $completedTodos.textContent = todos.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = todos.filter((todo) =&gt; !todo.completed).length; $todos.innerHTML = html;&#125;;// 기능const findMaxId = () =&gt; Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;// 이벤트 함수const getTodos = async () =&gt; &#123; try &#123; const res = await axios.get('/todos'); todos = res.data; render(); &#125; catch (error) &#123; console.error(error); &#125;&#125;;const addTodos = async () =&gt; &#123; try &#123; const todo = &#123; id: findMaxId(), content: $inputTodo.value, completed: false &#125;; const res = await axios.post('/todos', todo); todos = res.data; render(); &#125; catch (error) &#123; console.error(error); &#125; $inputTodo.value = '';&#125;;const removeTodo = async (id) =&gt; &#123; try &#123; const res = await axios.delete(`/todos/$&#123;id&#125;`); todos = res.data; render(); &#125; catch (error) &#123; console.log(error); &#125;&#125;;// test5const toggleTodo = async (id) =&gt; &#123; try &#123; const completed = !todos.find((todo) =&gt; todo.id === +id).completed; const res = await axios.patch(`/todos/$&#123;id&#125;`, &#123; completed &#125;); todos = res.data; render(); &#125; catch (error) &#123; console.log(error); &#125;&#125;;const toggleAll = async (completed) =&gt; &#123; try &#123; const res = await axios.patch('./todos', &#123; completed &#125;); todos = res.data; render(); &#125; catch (error) &#123; console.error(error); &#125;&#125;;const clearTodos = async () =&gt; &#123; try &#123; const res = await axios.delete('./completedTodos'); todos = res.data; render(); &#125; catch (error) &#123; console.error(error); &#125;&#125;;const changeNav = (li) =&gt; &#123; [...$nav.children].forEach(($list) =&gt; &#123; $list.classList.toggle('active', $list === li); &#125;); navId = li.id; render();&#125;;// 이벤트window.onload = () =&gt; &#123; getTodos(); console.log('async');&#125;;$inputTodo.onkeyup = (&#123; target, keyCode &#125;) =&gt; &#123; if (keyCode !== 13 || target.value.trim() === '') return; addTodos();&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(target.parentNode.id);&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; toggleTodo(target.parentNode.id);&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; toggleAll(target.checked);&#125;;$clearCompleted.onclick = () =&gt; &#123; clearTodos();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target);&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"},{"name":"Async Await","slug":"Async-Await","permalink":"https://hyeok999.github.io/tags/Async-Await/"}]},{"title":"TodoList axios","slug":"daily41","date":"2019-11-16T14:43:49.000Z","updated":"2019-12-06T11:04:09.649Z","comments":true,"path":"2019/11/16/daily41/","link":"","permalink":"https://hyeok999.github.io/2019/11/16/daily41/","excerpt":"","text":"TODO LIST FULL VERSION - axiosAjax 란? JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술. Ajax 요청 방법 3가지 XMLHttpRequest Axios fetch axios package.json .eslintrc.js app.js 서버 public폴더 ▼ index.html css/style.css js/04axios.js package.json 123456789101112131415161718192021&#123; \"name\": \"server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"start\": \"nodemon app\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.17.1\" &#125;, \"devDependencies\": &#123; \"eslint\": \"^6.6.0\", \"eslint-config-airbnb-base\": \"^14.0.0\", \"eslint-plugin-html\": \"^6.0.0\", \"eslint-plugin-import\": \"^2.18.2\" &#125;&#125; .eslintrc.js 12345678910111213141516171819202122232425262728293031module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) // \"no-var\": 0, \"prefer-arrow-callback\": 0, \"no-console\": 0, // \"warn\" \"no-plusplus\": \"off\", // x \"vars-on-top\": 0, // x \"eqeqeq\": 0, \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", // \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"], \"no-nested-ternary\": 0, \"no-param-reassign\": 0, \"no-return-assign\" : 0, &#125;&#125;; app.js 서버 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascirpt', completed: false &#125;];// 루트 폴더의 이름을 퍼블릭으로 할거야.// 미들웨어 딱 1번만 실행됨.app.use(express.static('public'));app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsing// app.get('/', (req, res) =&gt; &#123;// res.send('hello world!');// &#125;);app.get('/todos', (req, res) =&gt; &#123; todos.sort((t1, t2) =&gt; t2.id - t1.id); res.send(todos);&#125;);app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); todos = [req.body, ...todos]; res.send(todos);&#125;);// app.patch('/todos/:id([0-9])', (req, res) =&gt; &#123;app.patch('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id const &#123; completed &#125; = req.body; // req.body.completed; todos = todos.map((todo) =&gt; (todo.id === +id ? &#123; ...todo, completed &#125; : todo)); res.send(todos);&#125;);app.delete('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id todos = todos.filter((todo) =&gt; todo.id !== +id); res.send(todos);&#125;);app.delete('/completedTodos', (req, res) =&gt; &#123; todos = todos.filter((todo) =&gt; !todo.completed); res.send(todos);&#125;);app.patch('/todos', (req, res) =&gt; &#123; const &#123; completed &#125; = req.body; todos = todos.map((todo) =&gt; (&#123; ...todo, completed &#125;)); res.send(todos);&#125;);app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"./css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"./js/04axios.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;footer&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css/style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; font-size: 0.9em; color: #a9b0b4; /*#58666e;*/ background-color: #505455;/*#f0f3f4;*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todos &#123; margin-top: 20px;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .checkbox .checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 .checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.checkbox &#123; display: none;&#125;.checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; js/04axios.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120let todos = [];let navId = 'all';const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $nav = document.querySelector('.nav');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');const $completeAll = document.querySelector('.complete-all');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');// 렌더const render = () =&gt; &#123; let html = ''; const _todos = todos.filter((todo) =&gt; (navId === 'all' ? true : navId === 'active' ? !todo.completed : todo.completed)); _todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;button class=\"remove-todo\"&gt;X&lt;/button&gt; &lt;/li&gt;`; &#125;); $completedTodos.textContent = todos.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = todos.filter((todo) =&gt; !todo.completed).length; $todos.innerHTML = html;&#125;;// 기능const findMaxId = () =&gt; Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;// 이벤트 함수const getTodos = () =&gt; &#123; axios.get('/todos') .then((res) =&gt; todos = res.data) .then(render) .catch((err) =&gt; console.log(err));&#125;;const addTodos = () =&gt; &#123; const todo = &#123; id: findMaxId(), content: $inputTodo.value, completed: false &#125;; axios.post('/todos', todo) .then((res) =&gt; todos = res.data) .then(render) .catch((err) =&gt; console.log(err)); $inputTodo.value = '';&#125;;const removeTodo = (id) =&gt; &#123; axios.delete(`/todos/$&#123;id&#125;`) .then((res) =&gt; todos = res.data) .then(render) .catch((err) =&gt; console.log(err));&#125;;const toggleTodo = (id) =&gt; &#123; const completed = !todos.find((todo) =&gt; todo.id === +id).completed; axios.patch(`/todos/$&#123;id&#125;`, &#123; completed &#125;) .then((res) =&gt; todos = res.data) .then(render) .catch((err) =&gt; console.log(err));&#125;;const toggleAll = (completed) =&gt; &#123; axios.patch('./todos', &#123; completed &#125;) .then((res) =&gt; todos = res.data) .then(render) .catch((err) =&gt; console.error(err));&#125;;const clearTodos = () =&gt; &#123; axios.delete('./completedTodos') .then((res) =&gt; todos = res.data) .then(render) .catch((err) =&gt; console.error(err));&#125;;const changeNav = (li) =&gt; &#123; [...$nav.children].forEach(($list) =&gt; &#123; $list.classList.toggle('active', $list === li); &#125;); navId = li.id; render();&#125;;// 이벤트window.onload = () =&gt; &#123; getTodos(); console.log('axios');&#125;;$inputTodo.onkeyup = (&#123; target, keyCode &#125;) =&gt; &#123; if (keyCode !== 13 || target.value.trim() === '') return; addTodos();&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(target.parentNode.id);&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; toggleTodo(target.parentNode.id);&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; toggleAll(target.checked);&#125;;$clearCompleted.onclick = () =&gt; &#123; clearTodos();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target);&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"},{"name":"Axios","slug":"Axios","permalink":"https://hyeok999.github.io/tags/Axios/"}]},{"title":"javascript-study-26","slug":"javascript-study-26","date":"2019-11-15T13:51:53.000Z","updated":"2019-11-30T16:58:41.172Z","comments":true,"path":"2019/11/15/javascript-study-26/","link":"","permalink":"https://hyeok999.github.io/2019/11/15/javascript-study-26/","excerpt":"","text":"JavaScript Study 26 모듈 ES6 모듈 export 키워드 import 키워드 Babel과 Webpack을 이용한 ES6 환경 구축 npm 패키지 설치시 –save-dev 옵션 babel-polyfill .babelrc 설정 파일 Webpack webpack.config.js 설정 파일 용어 - ( 러버덕 ) 모듈 Babel Webpack 모듈 JS의 가장 큰 단점은 모듈이 존재하지 않는다는 것. 예를들어, script태그를 여러개 이용해서 서로 다른 .js 을 불러들인 다면 js간의 충돌을 야기할 수 있다. 이유는 모든 스크립트의 JS파일은 전역스코프를 공유하기 때문이다. 모듈은 파일 단위로 분리 되어있다. 이러한 모듈들은 독자적인 스코프를 나눠진다. 스코프들간에 서로 통신하기 위해서는 export , import를 이용한다. API들은 모듈패턴으로 구성된 코드들이다. 함수 : 전역 스코프 내에서 재사용과 가독성을 높이는 코드의 조합, 입력을 받고 출력을 내보내는 일련의 과정 모듈 : 파일 스코프 내에서 재사용과 가독성을 높이는 코드의 조합 (export. import) ES6 모듈 : ESM =&gt; script 태그의 일부로 사용 (현업에 안쓰임) JS의 모듈 : CommonJs(동기식) , AMD(Asynchronous Module Definition)(비동기식) 모듈을 한파일로 번들링하는 Babel + Webpack을 이용하여 사용한다. 번들링(여러개의 파일을 하나로 모음) 하는 이유 script파일이 여러군데 흩어져있을 경우 문제가 생기므로 하나로 합쳐서 문제를 방지한다. 크로스 브라우징을 하기 위해서 ( Babel ) : 폴리필하여 구현함. 폴리필은 웹 개발에서 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 뜻한다. 모든 리소스를 전부 번들링이 가능하다.( 분리해서 번들링 하는 것도 가능함. ) ES6 모듈script 태그에 type=&quot;module&quot; 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 12&lt;script type=\"module\" src=\"lib.mjs\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"app.mjs\"&gt;&lt;/script&gt; ES6 모듈의 파일 확장자는 모듈임을 명확히 하기 위해 mjs를 사용하도록 권장한다. .mjs를 사용하게 되면 script는 자동으로 defer로 동작하게 되며 module 엄격모드(Strict Mode)로 한다. 그냥 .js 확장자를 이용해도 사용은 가능하다. export 키워드 모듈은 독자적인 모듈 스코프를 갖기 때문에 모듈 안에 선언한 모든 식별자는 기본적으로 해당 모듈 내부에서만 참조할 수 있다. 만약 모듈 안에 선언한 식별자를 외부에 공개하여 다른 모듈들이 참조할 수 있게 하고 싶다면 export 키워드를 사용한다. 선언된 변수, 함수, 클래스 모두 export할 수 있다. 모듈을 공개하려면 선언문 앞에 export 키워드를 사용한다. 여러 개를 export할 수 있는데 이때 각각의 export는 이름으로 구별할 수 있다. 123456789101112131415// lib.mjs// 변수의 공개export const pi = Math.PI;// 함수의 공개export function square(x) &#123; return x * x;&#125;// 클래스의 공개export class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125; 선언문 앞에 매번 export 키워드를 붙이는 것이 싫다면 export 대상을 모아 하나의 객체로 구성하여 한번에 export할 수도 있다. 123456789101112131415// lib.mjsconst pi = Math.PI;function square(x) &#123; return x * x;&#125;class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;// 변수, 함수 클래스를 하나의 객체로 구성하여 공개export &#123; pi, square, Person &#125;; 모듈에서 하나만을 export할 때는 default 키워드를 사용할 수 있다. 1234// lib.mjsexport default function (x) &#123; return x * x;&#125; 다만, default를 사용하는 경우, var, let, const는 사용할 수 없다. defualt를 import 할 때는 식별자만 적어주면 되기 떄문에 간편한다. 123import sqaure from './lib.mjs';console.log(sqaure(10)); // 100 import 키워드모듈에서 공개(export)한 대상을 로드하려면 import 키워드를 사용한다. 모듈이 export한 식별자로 import하며 ES6 모듈의 파일 확장자를 생략할 수 없다. 123456789// app.mjs// 같은 폴더 내의 lib.mjs 모듈을 로드.// lib.mjs 모듈이 export한 식별자로 import한다.// ES6 모듈의 파일 확장자를 생략할 수 없다.import &#123; pi, square, Person &#125; from './lib.mjs';console.log(pi); // 3.141592653589793console.log(square(10)); // 100console.log(new Person('Lee')); // Person &#123; name: 'Lee' &#125; Babel과 Webpack을 이용한 ES6 환경 구축참고 : https://poiemaweb.com/es6-babel-webpack-1 , https://poiemaweb.com/es6-babel-webpack-2 현재 대부분의 브라우저가 ES6를 지원하고 있지만 IE 혹은 몇 브라우저는 지원을 안하고 있기도 하다. 따라서 이러한 문제를 해결하기 위해서 Babel과 Webpack을 사용한다. 추가적으로 ES6 의 모듈 기능보다는 Webpack의 모듈 번들러 기능이 더 유용해서 Webpack을 이용한다. ES6의 모듈을 사용하지 않는 이유는 다음과 같다. IE를 포함한 구형 브라우저는 ES6 모듈을 지원하지 않는다. 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하다. 아직 지원하지 않는 기능(Bare import 등)이 있다. 점차 해결되고는 있지만 아직 몇가지 이슈가 있다. 트랜스파일러(Transpiler) Babel과 모듈 번들러(Module bundler) Webpack을 이용하여 ES6+ 개발환경을 구축한다. 다시 정리하면 &lt;script&gt; 태그를 그냥 사용할경우 해당 스크립트의 파일의 js들은 전역스코프를 가진다.이러한 전역 스코프를 피하기 위해서 파일 스코프단위로 끊는 ES6의 모듈기능을 이용을 하는데 ES6의 모듈 기능은 우선 ES6에서만 가능하다는 점 때문에 하위 호환을 해줄 필요가 있는 트랜스파일러 Babel을 이용해야만 한다.그리고 모듈화를 위해서는 &lt;script&gt; 파일이 점점 많아질 것이다. 이러한 현상은 네트웤 비용을 점차 늘리게 된다. 왜냐하면 각각의 js파일을 전부 불러들어야만 하기 때문이다. 그렇다고 js파일을 한개로 모으자니 모듈화의 의미가 없기 때문에 이것 조차 안된다. 이러한 현상을 막기 위해서 번들러 Webpack을 이용해야만 한다. 웹팩은 js, css를 묶어서 하나의 파일들로 만들어준다. npm 패키지 설치시 –save-dev 옵션–save-dev : 이 옵션으로 npm 설치 시 그냥 dependencies가 아니라 devDependencies가 생긴다. 두개의 차이는 실제로 서버에서 사용해야하는지 와 사용을 하지 말아햐하는지의 차이다. 예를들어 eslint같은 것은 개발자를 위한 패키지 모듈인데 굳이 본서버에 올려서 노드모듈에 추가할 필요가 없다. 단지 개발을 쉽게하기 위한 툴이기 때문이다. 이러한 패키지들은 –save-dev로 설치하고 이러한 툴이 필요없는 패키지들은 해당 옵션을 사용하지 않는다. babel-polyfillBabel을 사용하여 ES6+코드를 하위버전으로 트랜스파일링 했다고 가정하자. 그런데도 ES6 문법 Promise, Object.assign, Array, from 등과 같은 문법은 하위버전에서 대체할만한 수단이 존재하지 않는다. 따라서 babel로 트랜스파일링을 해도 위 문법들은 그대로 남아있다. 이런 문제들은 polyfill을 사용해서 구현해야만 한다. polyfill이란? 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 의미한다. .babelrc 설정 파일Babel을 사용하려면 @babel/preset-env을 설치해야 한다. @babel/preset-env은 함께 사용되어야 하는 Babel 플러그인을 모아 둔 것으로 Babel 프리셋이라고 부른다. Babel이 제공하는 공식 Babel 프리셋(Official Preset)은 아래와 같다. @babel/preset-env @babel/preset-flow @babel/preset-react @babel/preset-typescript @babel/preset-env도 공식 프리셋의 하나이며 필요한 플러그인 들을 프로젝트 지원 환경에 맞춰서 동적으로 결정해 준다. 프로젝트 지원 환경은 Browserslist 형식으로 .browserslistrc 파일에 상세히 설정할 수 있다. 프로젝트 지원 환경 설정 작업을 생략하면 기본값으로 설정된다. WebpackWebpack은 의존관계에 있는 모듈들을 하나의 자바스크립트 파일로 번들링하는 모듈 번들러이다. Webpack을 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈로더가 필요없다. 다수의 자바스크립트 파일을 하나의 파일로 번들링하므로 html 파일에서 script 태그로 다수의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다. webpack.config.js 설정 파일webpack.config.js은 Webpack이 실행될 때 참조하는 설정 파일이다. 프로젝트 루트에 webpack.config.js 파일을 생성하고 아래처럼 작성한다. (예) 1234567891011121314151617181920212223242526272829303132const path = require('path');module.exports = &#123; // enntry file entry: ['@babel/polyfill', './src/js/main.js'], // 컴파일 + 번들링된 js 파일이 저장될 경로와 이름 지정 output: &#123; path: path.resolve(__dirname, 'dist/js'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, include: [ path.resolve(__dirname, 'src/js') ], exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'], plugins: ['@babel/plugin-proposal-class-properties'] &#125; &#125; &#125; ] &#125;, devtool: 'source-map', // https://webpack.js.org/concepts/mode/#mode-development mode: 'development'&#125;; entry: [‘@babel/polyfill’, ‘./src/js/main.js’] : 이 코드는 해당 위치에 있는 파일을 번들링 하겠다는 의미다. output: {path: path.resolve(__dirname, ‘dist/js’),filename: ‘bundle.js’} : path는 위치를 의미한다. 즉, dist/js에 bundle.js라는 의미로 번들링 파일이 생성된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"TodoList fetch","slug":"daily40","date":"2019-11-15T02:17:56.000Z","updated":"2019-12-06T11:02:00.923Z","comments":true,"path":"2019/11/15/daily40/","link":"","permalink":"https://hyeok999.github.io/2019/11/15/daily40/","excerpt":"","text":"TODO LIST FULL VERSION - fetchAjax 란? JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술. Ajax 요청 방법 3가지 XMLHttpRequest Axios fetch fetch package.json .eslintrc.js app.js 서버 public폴더 ▼ index.html css/style.css js/03fetch.js package.json 123456789101112131415161718192021&#123; \"name\": \"server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"start\": \"nodemon app\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.17.1\" &#125;, \"devDependencies\": &#123; \"eslint\": \"^6.6.0\", \"eslint-config-airbnb-base\": \"^14.0.0\", \"eslint-plugin-html\": \"^6.0.0\", \"eslint-plugin-import\": \"^2.18.2\" &#125;&#125; .eslintrc.js 12345678910111213141516171819202122232425262728293031module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) // \"no-var\": 0, \"prefer-arrow-callback\": 0, \"no-console\": 0, // \"warn\" \"no-plusplus\": \"off\", // x \"vars-on-top\": 0, // x \"eqeqeq\": 0, \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", // \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"], \"no-nested-ternary\": 0, \"no-param-reassign\": 0, \"no-return-assign\" : 0, &#125;&#125;; app.js 서버 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascirpt', completed: false &#125;];// 루트 폴더의 이름을 퍼블릭으로 할거야.// 미들웨어 딱 1번만 실행됨.app.use(express.static('public'));app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsing// app.get('/', (req, res) =&gt; &#123;// res.send('hello world!');// &#125;);app.get('/todos', (req, res) =&gt; &#123; todos.sort((t1, t2) =&gt; t2.id - t1.id); res.send(todos);&#125;);app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); todos = [req.body, ...todos]; res.send(todos);&#125;);// app.patch('/todos/:id([0-9])', (req, res) =&gt; &#123;app.patch('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id const &#123; completed &#125; = req.body; // req.body.completed; todos = todos.map((todo) =&gt; (todo.id === +id ? &#123; ...todo, completed &#125; : todo)); res.send(todos);&#125;);app.delete('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id todos = todos.filter((todo) =&gt; todo.id !== +id); res.send(todos);&#125;);app.delete('/completedTodos', (req, res) =&gt; &#123; todos = todos.filter((todo) =&gt; !todo.completed); res.send(todos);&#125;);app.patch('/todos', (req, res) =&gt; &#123; const &#123; completed &#125; = req.body; todos = todos.map((todo) =&gt; (&#123; ...todo, completed &#125;)); res.send(todos);&#125;);app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"./css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"./js/03fetch.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;footer&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css/style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; font-size: 0.9em; color: #a9b0b4; /*#58666e;*/ background-color: #505455;/*#f0f3f4;*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todos &#123; margin-top: 20px;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .checkbox .checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 .checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.checkbox &#123; display: none;&#125;.checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; js/03fetch.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143let todos = [];let navId = 'all';const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $nav = document.querySelector('.nav');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');const $completeAll = document.querySelector('.complete-all');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');// 렌더const render = () =&gt; &#123; let html = ''; const _todos = todos.filter((todo) =&gt; (navId === 'all' ? true : navId === 'active' ? !todo.completed : todo.completed)); _todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;button class=\"remove-todo\"&gt;X&lt;/button&gt; &lt;/li&gt;`; &#125;); $completedTodos.textContent = todos.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = todos.filter((todo) =&gt; !todo.completed).length; $todos.innerHTML = html;&#125;;// 기능const findMaxId = () =&gt; Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;// 이벤트 함수const getTodos = () =&gt; &#123; fetch('/todos') .then((res) =&gt; res.json()) .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.log(err));&#125;;const addTodos = () =&gt; &#123; const todo = &#123; id: findMaxId(), content: $inputTodo.value, completed: false &#125;; fetch('/todos', &#123; method: 'POST', headers: &#123; 'Content-type': 'application/json' &#125;, body: JSON.stringify(todo) &#125;) .then((res) =&gt; res.json()) .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.log(err)); $inputTodo.value = '';&#125;;const removeTodo = (id) =&gt; &#123; fetch(`/todos/$&#123;id&#125;`, &#123; method: 'DELETE' &#125;) .then((res) =&gt; res.json()) .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.log(err));&#125;;const toggleTodo = (id) =&gt; &#123; const completed = !todos.find((todo) =&gt; todo.id === +id).completed; fetch(`/todos/$&#123;id&#125;`, &#123; method: 'PATCH', headers: &#123; 'Content-type': 'application/json' &#125;, body: JSON.stringify(&#123; completed &#125;) &#125;) .then((res) =&gt; res.json()) .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.log(err));&#125;;const toggleAll = (completed) =&gt; &#123; fetch('./todos', &#123; method: 'PATCH', headers: &#123; 'Content-type': 'application/json' &#125;, body: JSON.stringify(&#123; completed &#125;) &#125;) .then((res) =&gt; res.json()) .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.error(err));&#125;;const clearTodos = () =&gt; &#123; fetch('./completedTodos', &#123; method: 'DELETE' &#125;) .then((res) =&gt; res.json()) .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.error(err));&#125;;const changeNav = (li) =&gt; &#123; [...$nav.children].forEach(($list) =&gt; &#123; $list.classList.toggle('active', $list === li); &#125;); navId = li.id; render();&#125;;// 이벤트window.onload = () =&gt; &#123; getTodos(); console.log('fetch');&#125;;$inputTodo.onkeyup = (&#123; target, keyCode &#125;) =&gt; &#123; if (keyCode !== 13 || target.value.trim() === '') return; addTodos();&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(target.parentNode.id);&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; toggleTodo(target.parentNode.id);&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; toggleAll(target.checked);&#125;;$clearCompleted.onclick = () =&gt; &#123; clearTodos();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target);&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"},{"name":"Fetch","slug":"Fetch","permalink":"https://hyeok999.github.io/tags/Fetch/"}]},{"title":"TodoList Promise","slug":"daily39","date":"2019-11-14T14:02:42.000Z","updated":"2019-12-06T11:03:26.602Z","comments":true,"path":"2019/11/14/daily39/","link":"","permalink":"https://hyeok999.github.io/2019/11/14/daily39/","excerpt":"","text":"TODO LIST FULL VERSION - PROMISE xhrAjax 란? JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술. Ajax 요청 방법 3가지 XMLHttpRequest Axios fetch PROMISE XMLHttpRequest package.json .eslintrc.js app.js 서버 public폴더 ▼ index.html css/style.css js/02promise.js package.json 123456789101112131415161718192021&#123; \"name\": \"server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"start\": \"nodemon app\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.17.1\" &#125;, \"devDependencies\": &#123; \"eslint\": \"^6.6.0\", \"eslint-config-airbnb-base\": \"^14.0.0\", \"eslint-plugin-html\": \"^6.0.0\", \"eslint-plugin-import\": \"^2.18.2\" &#125;&#125; .eslintrc.js 12345678910111213141516171819202122232425262728293031module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) // \"no-var\": 0, \"prefer-arrow-callback\": 0, \"no-console\": 0, // \"warn\" \"no-plusplus\": \"off\", // x \"vars-on-top\": 0, // x \"eqeqeq\": 0, \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", // \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"], \"no-nested-ternary\": 0, \"no-param-reassign\": 0, \"no-return-assign\" : 0, &#125;&#125;; app.js 서버 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascirpt', completed: false &#125;];// 루트 폴더의 이름을 퍼블릭으로 할거야.// 미들웨어 딱 1번만 실행됨.app.use(express.static('public'));app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsing// app.get('/', (req, res) =&gt; &#123;// res.send('hello world!');// &#125;);app.get('/todos', (req, res) =&gt; &#123; todos.sort((t1, t2) =&gt; t2.id - t1.id); res.send(todos);&#125;);app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); todos = [req.body, ...todos]; res.send(todos);&#125;);// app.patch('/todos/:id([0-9])', (req, res) =&gt; &#123;app.patch('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id const &#123; completed &#125; = req.body; // req.body.completed; todos = todos.map((todo) =&gt; (todo.id === +id ? &#123; ...todo, completed &#125; : todo)); res.send(todos);&#125;);app.delete('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id todos = todos.filter((todo) =&gt; todo.id !== +id); res.send(todos);&#125;);app.delete('/completedTodos', (req, res) =&gt; &#123; todos = todos.filter((todo) =&gt; !todo.completed); res.send(todos);&#125;);app.patch('/todos', (req, res) =&gt; &#123; const &#123; completed &#125; = req.body; todos = todos.map((todo) =&gt; (&#123; ...todo, completed &#125;)); res.send(todos);&#125;);app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"./css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"./js/02promise.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;footer&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css/style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; font-size: 0.9em; color: #a9b0b4; /*#58666e;*/ background-color: #505455;/*#f0f3f4;*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todos &#123; margin-top: 20px;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .checkbox .checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 .checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.checkbox &#123; display: none;&#125;.checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; js/02promise.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156let todos = [];let navId = 'all';const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $nav = document.querySelector('.nav');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');const $completeAll = document.querySelector('.complete-all');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');const ajax = (() =&gt; &#123; const request = (method, url, payload) =&gt; new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onload = () =&gt; &#123; if (xhr.status === 200 || xhr.status === 201) &#123; resolve(JSON.parse(xhr.response)); &#125; &#125;; xhr.onerror = () =&gt; &#123; reject(xhr.status); &#125;; &#125;); return &#123; get(url) &#123; return request('GET', url); &#125;, post(url, payload) &#123; return request('POST', url, payload); &#125;, delete(url) &#123; return request('DELETE', url); &#125;, patch(url, payload) &#123; return request('PATCH', url, payload); &#125;, put(url, payload) &#123; return request('PUT', url, payload); &#125; &#125;;&#125;)();// 렌더const render = () =&gt; &#123; let html = ''; const _todos = todos.filter((todo) =&gt; (navId === 'all' ? true : navId === 'active' ? !todo.completed : todo.completed)); _todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;button class=\"remove-todo\"&gt;X&lt;/button&gt; &lt;/li&gt;`; &#125;); $completedTodos.textContent = todos.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = todos.filter((todo) =&gt; !todo.completed).length; $todos.innerHTML = html;&#125;;// 기능const findMaxId = () =&gt; Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;// 이벤트 함수const getTodos = () =&gt; &#123; ajax.get('./todos') .then((res) =&gt; todos = res) .then(render) .catch((err) =&gt; console.log(err));&#125;;const addTodos = () =&gt; &#123; const todo = &#123; id: findMaxId(), content: $inputTodo.value, completed: false &#125;; ajax.post('./todos', todo) .then((res) =&gt; todos = res) .then(render) .catch((err) =&gt; console.log(err)); $inputTodo.value = '';&#125;;const removeTodo = (id) =&gt; &#123; ajax.delete(`./todos/$&#123;id&#125;`) .then((res) =&gt; todos = res) .then(render) .catch((err) =&gt; console.log(err));&#125;;const toggleTodo = (id) =&gt; &#123; const completed = !todos.find((todo) =&gt; todo.id === +id).completed; ajax.patch(`/todos/$&#123;id&#125;`, &#123; completed &#125;) .then((res) =&gt; todos = res) .then(render) .catch((err) =&gt; console.log(err));&#125;;const toggleAll = (completed) =&gt; &#123; ajax.patch('./todos', &#123; completed &#125;) .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.error(err));&#125;;const clearTodos = () =&gt; &#123; ajax.delete('./completedTodos') .then((_todos) =&gt; todos = _todos) .then(render) .catch((err) =&gt; console.error(err));&#125;;const changeNav = (li) =&gt; &#123; [...$nav.children].forEach(($list) =&gt; &#123; $list.classList.toggle('active', $list === li); &#125;); navId = li.id; render();&#125;;// 이벤트window.onload = () =&gt; &#123; getTodos(); console.log('promise');&#125;;$inputTodo.onkeyup = (&#123; target, keyCode &#125;) =&gt; &#123; if (keyCode !== 13 || target.value.trim() === '') return; addTodos();&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(target.parentNode.id);&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; toggleTodo(target.parentNode.id);&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; toggleAll(target.checked);&#125;;$clearCompleted.onclick = () =&gt; &#123; clearTodos();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target);&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Promise","slug":"Promise","permalink":"https://hyeok999.github.io/tags/Promise/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"TodoList XHR 결합","slug":"xhr-02","date":"2019-11-14T13:42:42.000Z","updated":"2019-12-06T11:07:45.651Z","comments":true,"path":"2019/11/14/xhr-02/","link":"","permalink":"https://hyeok999.github.io/2019/11/14/xhr-02/","excerpt":"","text":"TODO LIST FULL VERSION - XHR CombineAjax 란? JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술. Ajax 요청 방법 3가지 XMLHttpRequest Axios fetch PROMISE XMLHttpRequest package.json .eslintrc.js app.js 서버 public폴더 ▼ index.html css/style.css js/01xhr-2.js package.json 123456789101112131415161718192021&#123; \"name\": \"server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"start\": \"nodemon app\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.17.1\" &#125;, \"devDependencies\": &#123; \"eslint\": \"^6.6.0\", \"eslint-config-airbnb-base\": \"^14.0.0\", \"eslint-plugin-html\": \"^6.0.0\", \"eslint-plugin-import\": \"^2.18.2\" &#125;&#125; .eslintrc.js 12345678910111213141516171819202122232425262728293031module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) // \"no-var\": 0, \"prefer-arrow-callback\": 0, \"no-console\": 0, // \"warn\" \"no-plusplus\": \"off\", // x \"vars-on-top\": 0, // x \"eqeqeq\": 0, \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", // \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"], \"no-nested-ternary\": 0, \"no-param-reassign\": 0, \"no-return-assign\" : 0, &#125;&#125;; app.js 서버 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascirpt', completed: false &#125;];// 루트 폴더의 이름을 퍼블릭으로 할거야.// 미들웨어 딱 1번만 실행됨.app.use(express.static('public'));app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsing// app.get('/', (req, res) =&gt; &#123;// res.send('hello world!');// &#125;);app.get('/todos', (req, res) =&gt; &#123; todos.sort((t1, t2) =&gt; t2.id - t1.id); res.send(todos);&#125;);app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); todos = [req.body, ...todos]; res.send(todos);&#125;);// app.patch('/todos/:id([0-9])', (req, res) =&gt; &#123;app.patch('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id const &#123; completed &#125; = req.body; // req.body.completed; todos = todos.map((todo) =&gt; (todo.id === +id ? &#123; ...todo, completed &#125; : todo)); res.send(todos);&#125;);app.delete('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id todos = todos.filter((todo) =&gt; todo.id !== +id); res.send(todos);&#125;);app.delete('/completedTodos', (req, res) =&gt; &#123; todos = todos.filter((todo) =&gt; !todo.completed); res.send(todos);&#125;);app.patch('/todos', (req, res) =&gt; &#123; const &#123; completed &#125; = req.body; todos = todos.map((todo) =&gt; (&#123; ...todo, completed &#125;)); res.send(todos);&#125;);app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"./css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"./js/01xhr-2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;footer&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css/style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; font-size: 0.9em; color: #a9b0b4; /*#58666e;*/ background-color: #505455;/*#f0f3f4;*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todos &#123; margin-top: 20px;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .checkbox .checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 .checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.checkbox &#123; display: none;&#125;.checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; js/01xhr-2.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');const $completeAll = document.querySelector('.complete-all');const $nav = document.querySelector('.nav');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');let todos = [];let navID = 'all';// TODOS 데이터 요청 및 받아오기.const ajax = (() =&gt; &#123; const request = (method, url, fn, payload) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; // 200 정상 응답, POST는 가끔 201로 반환함. if (xhr.status === 200 || xhr.status === 201) &#123; fn(JSON.parse(xhr.response)); // 요청의 응답 된 데이터 처리 &#125; else &#123; console.error('error', xhr.status, xhr.statusText); &#125; &#125;; &#125;; return &#123; get(url, fn) &#123; request('GET', url, fn); &#125;, post(url, fn, payload) &#123; request('POST', url, fn, payload); &#125;, delete(url, fn) &#123; request('DELETE', url, fn); &#125;, patch(url, fn, payload) &#123; request('PATCH', url, fn, payload); &#125;, put(url, fn, payload) &#123; request('PUT', url, fn, payload); &#125; &#125;;&#125;)();// render 함수const render = (data) =&gt; &#123; let html = ''; todos = data; todos = data.filter((todo) =&gt; (navID === 'all' ? true : navID === 'active' ? !todo.completed : todo.completed)); todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;`; &#125;); $completedTodos.textContent = data.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = data.filter((todo) =&gt; !todo.completed).length; $todos.innerHTML = html; console.log('[RENDER]', todos);&#125;;// 부가 기능 함수const findMaxId = () =&gt; Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;// 기능 함수const getTodos = () =&gt; &#123; ajax.get('./todos', render);&#125;;const postTodos = (content) =&gt; &#123; ajax.post('./todos', render, &#123; id: findMaxId(), content, completed: false &#125;); $inputTodo.value = '';&#125;;const removeTodo = (id) =&gt; &#123; ajax.delete(`./todos/$&#123;id&#125;`, render);&#125;;// patchconst checkTodo = (id, checked) =&gt; &#123; const completed = checked; // const completed = !todos.find((todo) =&gt; todo.id === +id).completed; ajax.patch(`./todos/$&#123;id&#125;`, render, &#123; completed &#125;);&#125;;const toggleAll = (checked) =&gt; &#123; const completed = checked; ajax.patch('./todos', render, &#123; completed &#125;);&#125;;const clearTodos = () =&gt; &#123; ajax.delete('./completedTodos', render);&#125;;const changeNav = (target) =&gt; &#123; [...$nav.children].forEach(($list) =&gt; &#123; $list.classList.toggle('active', $list == target); navID = target.id; &#125;); ajax.get('./todos', render);&#125;;// 이벤트 핸들러window.onload = () =&gt; &#123; getTodos();&#125;;$inputTodo.onkeyup = (&#123; target, keyCode &#125;) =&gt; &#123; if (target.value.trim() === '' || keyCode !== 13) return; postTodos(target.value.trim());&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(target.parentNode.id);&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; checkTodo(target.parentNode.id, target.checked);&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; toggleAll(target.checked);&#125;;$clearCompleted.onclick = () =&gt; &#123; clearTodos();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target);&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Promise","slug":"Promise","permalink":"https://hyeok999.github.io/tags/Promise/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"TodoList XHR 분리","slug":"xhr-01","date":"2019-11-14T13:02:42.000Z","updated":"2019-12-06T11:06:40.332Z","comments":true,"path":"2019/11/14/xhr-01/","link":"","permalink":"https://hyeok999.github.io/2019/11/14/xhr-01/","excerpt":"","text":"TODO LIST FULL VERSION - XHR DispartAjax 란? JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술. Ajax 요청 방법 3가지 XMLHttpRequest Axios fetch PROMISE XMLHttpRequest package.json .eslintrc.js app.js 서버 public폴더 ▼ index.html css/style.css js/00xhr-1.js package.json 123456789101112131415161718192021&#123; \"name\": \"server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"start\": \"nodemon app\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.17.1\" &#125;, \"devDependencies\": &#123; \"eslint\": \"^6.6.0\", \"eslint-config-airbnb-base\": \"^14.0.0\", \"eslint-plugin-html\": \"^6.0.0\", \"eslint-plugin-import\": \"^2.18.2\" &#125;&#125; .eslintrc.js 12345678910111213141516171819202122232425262728293031module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) // \"no-var\": 0, \"prefer-arrow-callback\": 0, \"no-console\": 0, // \"warn\" \"no-plusplus\": \"off\", // x \"vars-on-top\": 0, // x \"eqeqeq\": 0, \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", // \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"], \"no-nested-ternary\": 0, \"no-param-reassign\": 0, \"no-return-assign\" : 0, &#125;&#125;; app.js 서버 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascirpt', completed: false &#125;];// 루트 폴더의 이름을 퍼블릭으로 할거야.// 미들웨어 딱 1번만 실행됨.app.use(express.static('public'));app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsing// app.get('/', (req, res) =&gt; &#123;// res.send('hello world!');// &#125;);app.get('/todos', (req, res) =&gt; &#123; todos.sort((t1, t2) =&gt; t2.id - t1.id); res.send(todos);&#125;);app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); todos = [req.body, ...todos]; res.send(todos);&#125;);// app.patch('/todos/:id([0-9])', (req, res) =&gt; &#123;app.patch('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id const &#123; completed &#125; = req.body; // req.body.completed; todos = todos.map((todo) =&gt; (todo.id === +id ? &#123; ...todo, completed &#125; : todo)); res.send(todos);&#125;);app.delete('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id todos = todos.filter((todo) =&gt; todo.id !== +id); res.send(todos);&#125;);app.delete('/completedTodos', (req, res) =&gt; &#123; todos = todos.filter((todo) =&gt; !todo.completed); res.send(todos);&#125;);app.patch('/todos', (req, res) =&gt; &#123; const &#123; completed &#125; = req.body; todos = todos.map((todo) =&gt; (&#123; ...todo, completed &#125;)); res.send(todos);&#125;);app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"./css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"./js/00xhr-1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;footer&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css/style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; font-size: 0.9em; color: #a9b0b4; /*#58666e;*/ background-color: #505455;/*#f0f3f4;*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todos &#123; margin-top: 20px;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .checkbox .checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 .checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.checkbox &#123; display: none;&#125;.checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; js/00xhr-1.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173let navId = 'all';let todos = [];const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $nav = document.querySelector('.nav');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');const $completeAll = document.querySelector('.complete-all');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');// 렌더const render = (data) =&gt; &#123; let html = ''; todos = data; console.log(todos); const _todos = todos.filter((todo) =&gt; (navId === 'all' ? true : navId === 'active' ? !todo.completed : todo.completed)); _todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;button class=\"remove-todo\"&gt;X&lt;/button&gt; &lt;/li&gt;`; &#125;); $completedTodos.textContent = todos.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = todos.filter((todo) =&gt; !todo.completed).length; $todos.innerHTML = html;&#125;;const get = (url, fn) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.send(); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; // 200 정상 응답, POST는 가끔 201로 반환함. if (xhr.status === 200 || xhr.status === 201) &#123; // todos = JSON.parse(xhr.response); fn(JSON.parse(xhr.response)); // 요청의 응답 된 데이터 처리 &#125; else &#123; console.error('error', xhr.status, xhr.statusText); &#125; &#125;;&#125;;const post = (url, fn, payload) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open('POST', url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); console.log('data1', payload); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; // 200 정상 응답, POST는 가끔 201로 반환함. if (xhr.status === 200 || xhr.status === 201) &#123; console.log('data2', JSON.parse(xhr.response)); fn(JSON.parse(xhr.response)); // 요청의 응답 된 데이터 처리 &#125; else &#123; console.error('error', xhr.status, xhr.statusText); &#125; &#125;;&#125;;const del = (url, fn) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open('DELETE', url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; // 200 정상 응답, POST는 가끔 201로 반환함. if (xhr.status === 200 || xhr.status === 201) &#123; fn(JSON.parse(xhr.response)); // 요청의 응답 된 데이터 처리 &#125; else &#123; console.error('error', xhr.status, xhr.statusText); &#125; &#125;;&#125;;const patch = (url, fn, payload) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open('PATCH', url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; // 200 정상 응답, POST는 가끔 201로 반환함. if (xhr.status === 200 || xhr.status === 201) &#123; todos = JSON.parse(xhr.response); fn(JSON.parse(xhr.response)); // 요청의 응답 된 데이터 처리 &#125; else &#123; console.error('error', xhr.status, xhr.statusText); &#125; &#125;;&#125;;// 기능const findMaxId = () =&gt; Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;// 이벤트 함수const getTodos = () =&gt; &#123; get('./todos', render);&#125;;const addTodos = () =&gt; &#123; post('./todos', render, &#123; id: findMaxId(), content: $inputTodo.value, completed: false &#125;); $inputTodo.value = '';&#125;;const removeTodo = (id) =&gt; &#123; del(`./todos/$&#123;id&#125;`, render);&#125;;const toggleTodo = (id) =&gt; &#123; console.log('todos=', todos); const completed = !todos.find((todo) =&gt; todo.id === +id).completed; patch(`/todos/$&#123;id&#125;`, render, &#123; completed &#125;);&#125;;const toggleAll = (completed) =&gt; &#123; patch('./todos', render, &#123; completed &#125;);&#125;;const clearTodos = () =&gt; &#123; del('./completedTodos', render);&#125;;const changeNav = (li) =&gt; &#123; [...$nav.children].forEach(($list) =&gt; &#123; $list.classList.toggle('active', $list === li); &#125;); navId = li.id; render();&#125;;// 이벤트window.onload = () =&gt; &#123; getTodos();&#125;;$inputTodo.onkeyup = (&#123; target, keyCode &#125;) =&gt; &#123; if (keyCode !== 13 || target.value.trim() === '') return; addTodos();&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(target.parentNode.id);&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; toggleTodo(target.parentNode.id);&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; toggleAll(target.checked);&#125;;$clearCompleted.onclick = () =&gt; &#123; clearTodos();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target);&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Promise","slug":"Promise","permalink":"https://hyeok999.github.io/tags/Promise/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"javascript-study-25","slug":"javascript-study-25","date":"2019-11-13T17:30:46.000Z","updated":"2019-11-30T16:58:47.631Z","comments":true,"path":"2019/11/14/javascript-study-25/","link":"","permalink":"https://hyeok999.github.io/2019/11/14/javascript-study-25/","excerpt":"","text":"JavaScript Study 25 프로미스 프로미스를 만드는 방법 프로미스 xhr , fetch, axios, async/await 프로미스 xhr fetch axios async/await REST API JSON Server 와 POSTMAN GraphQL 용어 - ( 러버덕 ) 프로미스 fetch axios async/await postman REST API 프로미스 비동기 처리에 대한 약속 브라우저는 멀티 스레드가 맞으나 JS는 싱글 스레드이다. 프로미스 질문 시 나와야하는 단어 : 후속처리함수, 순서보장, 비동기처리에 대한 약속, 콜백패턴 콜백 패턴은 XHR(XMLHTTPRequset)의 readyState와 onreadystatechange 함수 내에서 후속처리를 해야만하는데 이는 가독성을 크게 감속시킨다. 또한 콜백헬이나 에러처리등의 문제를 가지고 있다. 추가로 비동기처리는 순서를 보장하지 않는다. 이러한 문제들을 해결하기 위해서 프로미스가 나왔다. 기본 콜백패턴에서 에러처리를 해결하기 위해서는 실패에대한 콜백을 또 던져주어야한다. 프로미스를 만드는 방법new Promise((resolve, reject) =&gt; { 비동기 처리 내용 }) 프로미스는 고차함수다. 고차함수는 인수로 함수를 받을 수 있다. 프로미스는 내부에서 상태를 가지고 있다. 12345678910111213141516// 프로미스 객체는 인수 2개를 받을 수 있다. 성공-resolve, 실패-rejectconst promise = new Promise((resolve, reject) =&gt; &#123; // 여기서 비동기를 처리한다. const x = 1; setTimeout(() =&gt; &#123; if (x % 2) resolve(x); else reject(new Error('Error')); &#125;);&#125;);console.log(typeof promise);// 프로미스 객체의 후속 처리 함수promise .then((res) =&gt; console.log(res)) .catch((err) =&gt; console.log(err)); .then 은 무조건 promise를 return 한다. .then이 게속해서 이어지는 것을 프로미스 체인닝 이라 한다. 12345678const p = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);p.then((num) =&gt; ++num) .then((num) =&gt; ++num) .then((num) =&gt; ++num) .then((num) =&gt; console.log(num)); 정답은 4가 나온다. 프로미스 xhr , fetch, axios, async/await프로미스 xhr 기본적으로 프로미스를 이용한 ajax통신을 위해서는 XMLHttpRequest 객체가 있어야만 사용할 수 있다. 1234567891011121314151617181920212223242526272829303132const ajax = (() =&gt; &#123; const req = (method, url, payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onload = () =&gt; &#123; if (xhr.status === 200 || xhr.status === 201) &#123; resolve(JSON.parse(xhr.response)); &#125; &#125;; xhr.onerror = () =&gt; &#123; reject(new Error(xhr.status)); &#125;; &#125;); &#125;; return &#123; get(url) &#123; return req('GET', url); &#125;, post(url, payload) &#123; return req('POST', url, payload); &#125;, patch(url, payload) &#123; return req('PATCH', url, payload); &#125;, delete(url) &#123; return req('DELETE', url); &#125; &#125;;&#125;)(); 12345// ajax get 통신ajax.get('/todos') .then((data) =&gt; Math.max(0, ...data.map((a) =&gt; a.id))) .then((id) =&gt; ajax.delete(`/todos/$&#123;id&#125;`)) .then(console.log); fetch를 사용했을 경우 기본적인 베이스는 promise를 따라간다. fetch는 xhr 함수를 만들 필요가 없다. 함수가 ajax 기능을 제공해주기 때문이다. 다만 소스가 조금 가독성이 떨이지는 단점이 있다. 12345678fetch('/todos') .then((res) =&gt; res.json()) .then((data) =&gt; Math.max(0, ...data.map((a) =&gt; a.id))) .then((id) =&gt; fetch(`/todos/$&#123;id&#125;`, &#123; method: 'DELETE' &#125;)) .then((res) =&gt; res.json()) .then(console.log); axios를 사용했을 경우 기본적인 베이스는 promise를 따라간다. axios 역시 fetch처럼 xhr함수를 만들 필요가 없다. fetch보다 훨씬 간결하고 가독성이 좋다. 다만, html에서 axios의 API를 로드 해줘야만 한다. (CDN: &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;) 1234axios.get('/todos') .then((res) =&gt; Math.max(0, ...(res.data).map((a) =&gt; a.id))) .then((id) =&gt; ajax.delete(`/todos/$&#123;id&#125;`)) .then(console.log); async, await를 사용했을 경우 xhr , fetch, axios의 비동기 방식을 동기 방식 처럼 사용하기 위해서 사용한다. async 함수 내에 있어야만 반드시 순서가 보장된다. 프로미스로 짠 코드들의 then은 전부다 async 안에 반드시 들어가 있어야한다! 123456(async () =&gt; &#123; let todos = await ajax.get('/todos'); const id = Math.max(0, ...todos.map((todo) =&gt; todo.id)); todos = await ajax.delete(`/todos/$&#123;id&#125;`); console.log(todos);&#125;)(); REST API REST란, 자원을 정의하고 자원에 대한 주소를 지정하는 방법의 모음 백엔드가 개발이 늦을 경우 프론트는 짝퉁서버 Mock Server를 만들어서 사용할 수도 있다.백엔드가 완료될 경우 프론트는 url만 백엔드 서버로 교체해서 사용한다.MockServer를 만드는 방법은 여라가지가 있다. tool(JSON-Server)을 이용하여 사용할 수도 있다. 백엔드가 개발이 빠를 경우 해당 백엔드가 잘되는지 테스트를 해야만한다. 여기서 프론트는 Postman과 같은 tool 을 이용하여 이를 테스트 할 수 있다. JSON Server 와 POSTMANJSON.Server의 db.json에서 모든 프로퍼티 키는 반드시 쌍따옴표(&quot;)로 열고 닫는다. 그냥 따옴표(&#39;) 안된다. 반드시 쌍따옴표(&quot;) postman에서 테스트 주소를 작성할 때 반드시 http://를 적어주어야만 한다. POST ➤ Body ➤ raw ➤ JSON 체크 GraphQLfacebook이 만든 새로운 패러다임. REST API와는 달리 정해진 형태가 있지 않다. REST API 다음 차세대 데이터 질의어(SQL)로 각광을 받고 있으며 REST 및 부속 웹서비스 아키텍쳐를 대체할 수 있다. 클라이언트는 필요한 데이터의 구조를 지정할 수 있으며, 서버는 정확히 동일한 구조로 데이터를 반환한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_quiz38","slug":"daily-algorithm38","date":"2019-11-11T18:06:22.000Z","updated":"2019-11-30T17:11:58.409Z","comments":true,"path":"2019/11/12/daily-algorithm38/","link":"","permalink":"https://hyeok999.github.io/2019/11/12/daily-algorithm38/","excerpt":"","text":"문제 출처 : poiema Tabs UI 요구 사항 탭을 구성하는 데이터를 전달해 Tabs UI를 생성한다. 라이브러리를 사용하지 않고 Vanilla javascript로 구현한다. ES6의 class로 구현한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Open+Sans:400,600,700\" rel=\"stylesheet\"&gt; &lt;link href=\"https://use.fontawesome.com/releases/v5.3.1/css/all.css\" rel=\"stylesheet\"&gt; &lt;title&gt;Tabs&lt;/title&gt; &lt;style&gt; *, *:before, *:after &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; html, body &#123; height: 100%; &#125; body &#123; background-image: linear-gradient(20deg, #08aeea 0%, #2af598 100%); font-family: 'Open Sans', Sans-serif; &#125; .tabs &#123; min-width: 320px; max-width: 800px; padding: 50px; margin: 50px auto; background: #fff; border-radius: 4px; &#125; .tab &#123; display: inline-block; margin: 0 0 -1px; padding: 15px 25px; text-align: center; color: #555; border: 1px solid transparent; cursor: pointer; &#125; .icon &#123; margin-right: 10px; &#125; .tab.active &#123; border: 1px solid #ddd; border-top: 2px solid #f44336; border-bottom: 1px solid #fff; &#125; .tab-content &#123; /* display: none; */ padding: 20px; border: 1px solid #ddd; line-height: 1.6rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tabs\"&gt;&lt;/div&gt; &lt;script&gt; class Tab &#123; constructor(tabsData) &#123; this.tabsData = tabsData; // active 클래스가 지정된 tab 요소와 같은 인덱스의 tab-content 요소만 표시 this.renderTabs(); const $tabContent = document.querySelectorAll('.tab-content'); const $tab = document.querySelectorAll('.tab'); // 탭 전환 this.toggleDisplay($tabContent); console.log('[constructor]', this); // tab 클릭 이벤트 핸들러 등록 document.querySelector('.tabs').onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('tab')) return; console.log('[constructor,document]', this); this.changeActive(target, $tab, $tabContent); &#125;; &#125; // tabsData 객체를 기반으로 tab-group 요소를 생성 renderTabs() &#123; const html = ` &lt;ul class=\"tab-group\"&gt; $&#123;this.tabsData.map((tab) =&gt; ` &lt;li class=\"tab$&#123;tab.active ? ' active' : ''&#125;\"&gt; &lt;i class=\"icon $&#123;tab.iconClass&#125;\"&gt;&lt;/i&gt;$&#123;tab.title&#125; &lt;/li&gt;`).join('')&#125; &lt;/ul&gt; &lt;div class=\"tab-content-group\"&gt; $&#123;this.tabsData.map((tab) =&gt; ` &lt;div class=\"tab-content\"&gt;$&#123;tab.content&#125;&lt;/div&gt;`).join('')&#125; &lt;/div&gt;`; document.querySelector('.tabs').insertAdjacentHTML('beforeend', html); &#125; toggleDisplay($tabContent) &#123; this.tabsData.forEach((tab, index) =&gt; &#123; if (!tab.active) &#123; $tabContent[index].style.display = 'none'; &#125; &#125;); &#125; changeActive(target, $tab, $tabContent) &#123; console.log('[changeActive]', this); this.tabsData = this.tabsData.map((tab) =&gt; ( tab.title === target.textContent.trim() ? &#123; ...tab, active: true &#125; : &#123; ...tab, active: false &#125; )); this.tabsData.forEach((tab, index) =&gt; &#123; if (!tab.active) &#123; $tab[index].classList.remove('active'); $tabContent[index].style.display = 'none'; &#125; else &#123; $tab[index].classList.add('active'); $tabContent[index].style.display = 'block'; &#125; &#125;); &#125; // do something! &#125; window.onload = function () &#123; const tab = new Tab([ &#123; title: 'HTML', active: true, iconClass: 'fab fa-html5', content: `&lt;strong&gt;HTML(HyperText Markup Language)&lt;/strong&gt; is the most basic building block of the Web. It describes and defines the content of a webpage along with the basic layout of the webpage. Other technologies besides HTML are generally used to describe a web page's appearance/presentation(CSS) or functionality/ behavior(JavaScript).` &#125;, &#123; title: 'CSS', active: false, iconClass: 'fab fa-css3', content: `&lt;strong&gt;Cascading Style Sheets(CSS)&lt;/strong&gt; is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.` &#125;, &#123; title: 'JavaScript', active: false, iconClass: 'fab fa-js-square', content: `&lt;strong&gt;JavaScript(JS)&lt;/strong&gt; is a lightweight interpreted or JIT-compiled programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles.` &#125; ]); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 주요 코드 this.renderTabs(); 상단 존재 타 문제와 다르게 위 코드가 상단에 존재해서 애를 먹은 문제이다. renderTabs가 작성이 미리 되어져 있었기 때문에 렌더링 후에 Dom 요소에 접근하였다. changeActive함수 12345678910111213141516changeActive(target, $tab, $tabContent) &#123; console.log('[changeActive]', this); this.tabsData = this.tabsData.map((tab) =&gt; ( tab.title === target.textContent.trim() ? &#123; ...tab, active: true &#125; : &#123; ...tab, active: false &#125; )); this.tabsData.forEach((tab, index) =&gt; &#123; if (!tab.active) &#123; $tab[index].classList.remove('active'); $tabContent[index].style.display = 'none'; &#125; else &#123; $tab[index].classList.add('active'); $tabContent[index].style.display = 'block'; &#125; &#125;); &#125; 처음에는 선택한 요소의 Content의 여부에 따라 tab을 결정한다. 그후 tab 상태가 active라면 active클래스를 제거하고 display를 none처리하며 반대의 경우에는 active클래스를 추가하고 display를 block으로 보여준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"},{"name":"Quiz","slug":"Quiz","permalink":"https://hyeok999.github.io/tags/Quiz/"}]},{"title":"daily_algorithm37","slug":"daily-algorithm37","date":"2019-11-10T18:26:18.000Z","updated":"2019-11-30T17:12:04.525Z","comments":true,"path":"2019/11/11/daily-algorithm37/","link":"","permalink":"https://hyeok999.github.io/2019/11/11/daily-algorithm37/","excerpt":"","text":"문제 출처 : 프로그래머스 올바른 괄호문제 설명괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어 ()() 또는 (())() 는 올바른 괄호입니다. )()( 또는 (()( 는 올바르지 않은 괄호입니다. ‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 제한사항 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다. 입출력 예 s answer ()() true (())() true )()( false (()( false 입출력 예 설명입출력 예 #1,2,3,4문제의 예시와 같습니다. 1차 풀이1234567891011function solution(s) &#123; var answer = true; if (s.length % 2) return false; while (s.indexOf('()') !== -1) &#123; s = s.replace('()', ''); &#125; answer = s.length == 0 ? true : false; return answer;&#125; TestCase는 모두 통과했지만 효율성 테스트에서 모두 떨어졌다. 아무래도 반복문을 최대한 적게돌면서 중간중간에 체크하는 과정을 추가해야만 할 것 같다. 2차 풀이123456789101112function solution(s) &#123; let arr = []; for (let i = 0; i &lt; s.length; i++) &#123; if (s[i] == '(') arr.push('('); else &#123; if (arr.length == 0) return false; arr.pop(); &#125; &#125; return arr.length == 0 ? true : false;&#125; 올바른 괄호라면 ‘(‘ 로 시작해 ‘)’로 끝나야 한다. 따라서 배열을 추가하고 배열에 ‘(‘ 일경우 배열에 스택으로 추가한다. 만약 ‘(‘이 아니라면 ‘)’인것이다. 따라서 스택에 추가할 필요없이 스택을 제거한다. 만약 스택이 비워져있는 상태에서 ‘)’ 을 만난다면 배열길이는 0이므로 false를 반환한다. 수가 잘 맞게 ‘(‘과 ‘)’을 비교했다면 반복문을 다 돌고나서 배열의 길이는 0이기 때문에 true를 반환한다. 하지만 ‘(‘이 중복으로 겹쳐서 나왔다면 분명 길이는 0이상이기 때문에 false를 반환한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"module","slug":"module","date":"2019-11-10T17:02:27.000Z","updated":"2019-11-30T16:58:02.174Z","comments":true,"path":"2019/11/11/module/","link":"","permalink":"https://hyeok999.github.io/2019/11/11/module/","excerpt":"","text":"JavaScript Module ECMAScript 모듈 JS는 모듈기능이 없었다. (ES6 - 19년 5월부터 모듈기능 추가) 파일 스코프 export 키워드 기본 export 모아서 export default export import 키워드 기본 import 이름 변경 import default export모듈을 import import ~ export 동작 확인 ECMAScript 모듈 모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 일컫는다.세부 사항을 캡슐화하고 공개가 필요한 API만을 외부에 노출한다. 모듈은 파일 단위(기능 별로 분리되어 작성)로 분리되어 개별적으로 존재함. 애플리케이션은 필요에 따라 명시적으로 모듈을 로드하여 재사용. 기능별로 분리 구성되어 코드의 단위를 명확히 분리하여 구성했기에 재사용성, 효율성, 유지보수성을 높인다. JS는 모듈기능이 없었다. (ES6 - 19년 5월부터 모듈기능 추가) C언어 / Java JavaScript #include / import script 외부 파일을 가지고 올 수 있다. 외부 파일을 가지고 올 수 있다. 외부 파일들은 각 파일마다 독립적인 스코프를 지닌다. 외부 파일들은 모두 하나의 전역 스코프를 지닌다. 모듈화가 가능하다. 전역 스코프로 모듈화가 불가능하다. 2019년 5월부터 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다.script 태그에 type=&quot;module&quot; 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.모듈의 파일 확장자는 mjs를 권장한다. 12&lt;script type=\"module\" src=\"lib.mjs\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"app.mjs\"&gt;&lt;/script&gt; 하지만 아직까지는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다. IE를 포함한 구형 브라우저는 ES6 모듈을 지원하지 않는다. 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하다. 아직 지원하지 않는 기능(Bare import 등)이 있다. (ECMAScript modules in browsers 참고) 점차 해결되고는 있지만 아직 몇가지 이슈가 있다. (ECMAScript modules in browsers 참고) 따라서 ES6 를 아울러 ES5 하위 버전까지 모듈을 사용하기 위해서는 Babel과 Webpack을 이용한 ES6 개발환경 구축이 필요하다. 파일 스코프 모듈은 파일 스코프를 갖는다.즉, 모듈 내에서 var 키워드로 선언한 변수는 더 이상 전역 변수가 아니며 window 객체의 프로퍼티도 아니다. 1234// foo.jsvar x = 'foo';console.log(x); 12345// bar.js// 중복 선언이 아니다. 스코프가 다른 변수이다.var x = 'bar';console.log(x); 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"bar.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과는 순서대로 다음과 같이 출력된다. 12&apos;foo&apos;&apos;bar&apos; 만약 bar.js 에서 아무것도 선언안하고 x를 출력할 경우, Uncaught ReferenceError: x is not defined 를 출력한다. 이유 : 모듈화된 foo를 외부에서 참조할 수 없고, bar자체에서는 암묵적 선언이 없다. bar에서 var키워드로 생성된 변수는 window객체의 프로퍼티가 아니기 때문에 undefined도 안뜨기 때문이다. ###export 키워드 모듈은 독립적인 파일 스코프를 갖기 때문에 모듈 안에서 선언한 모든 것들은 기본적으로 해당 모듈 내부에서만 참조가 가능하다. 모듈 안에 선언한 항복을 외부에 공개하여 다른 모듈이 사용할 수 있게 하고 싶다면 export 해야 한다. 선언한 변수, 함수, 클래스 모두 export가 가능하다. 기본 export 123456789101112131415// lib.js// 변수의 공개export const pi = Math.PI;// 함수의 공개export function square(x) &#123; return x * x;&#125;// 클래스의 공개export class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125; 모아서 export 선언문 앞에 매번 export 키워드를 붙이는 것이 싫다면 export 대상을 모아 하나의 객체로 구성하여 한번에 export할 수도 있다. 123456789101112131415// lib.jsconst pi = Math.PI;function square(x) &#123; return x * x;&#125;class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;// 변수, 함수 클래스를 하나의 객체로 구성하여 공개export &#123; pi, square, Person &#125;; default export 모듈에서 하나만을 export할 때는 default 키워드를 사용할 수 있다. 다만, default를 사용하는 경우, var, let, const는 사용할 수 없다. 123456// lib.jsfunction (x) &#123; return x * x;&#125;export default; 위 코드를 아래와 같이 축약 표현할 수 있다. 1234// lib.jsexport default function (x) &#123; return x * x;&#125; import 키워드 export한 모듈을 import하기 위해서 사용한다. 기본 import export한 모듈을 로드 시 export한 이름으로 import한다. 12345678// app.js// 같은 폴더 내의 lib.js 모듈을 로드. 확장자 js는 생략 가능.// 단, 브라우저 환경에서는 모듈의 파일 확장자를 생략할 수 없다.import &#123; pi, square, Person &#125; from './lib';console.log(pi); // 3.141592653589793console.log(square(10)); // 100console.log(new Person('Lee')); // Person &#123; name: 'Lee' &#125; 각각의 이름을 지정하지 않고 하나의 이름으로 한꺼번에 import할 수도 있다. 이때 import되는 항목은 as 뒤에 지정한 이름의 변수에 할당된다. 123456// app.jsimport * as lib from './lib';console.log(lib.pi); // 3.141592653589793console.log(lib.square(10)); // 100console.log(new lib.Person('Lee')); // Person &#123; name: 'Lee' &#125; 이름 변경 import 이름을 변경하여 import할 수도 있다. 123456// app.jsimport &#123; pi as PI, square as sq, Person as P &#125; from './lib';console.log(PI); // 3.141592653589793console.log(sq(2)); // 4console.log(new P('Kim')); // Person &#123; name: 'Kim' &#125; default export모듈을 import default 키워드와 함께 export한 모듈은 {} 없이 임의의 이름으로 import한다. 1234// app.jsimport square from './lib';console.log(square(3)); // 9 import ~ export 동작 확인 브라우저가 지원하는 ES6 모듈 기능을 이용하여 import와 export가 동작하는지 확인해보자. 12// lib.jsexport default x =&gt; x * x; 12345// app.js// 브라우저 환경에서는 모듈의 파일 확장자를 생략할 수 없다.// 모듈의 파일 확장자는 .mjs를 권장한다.import square from './lib.js';console.log(square(10)); // 100 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script type=\"module\" src=\"./lib.js\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"./app.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과 1100","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Module","slug":"Module","permalink":"https://hyeok999.github.io/tags/Module/"}]},{"title":"javascript-study-24[Ajax-TodoApp]","slug":"javascript-study-24","date":"2019-11-09T08:12:26.000Z","updated":"2019-11-30T16:59:09.051Z","comments":true,"path":"2019/11/09/javascript-study-24/","link":"","permalink":"https://hyeok999.github.io/2019/11/09/javascript-study-24/","excerpt":"","text":"JavaScript Study 24 Ajax를 이용한 Todos App 개발 용어 - ( 러버덕 ) GET POST PETCH POP DELETE Ajax를 이용한 Todos App 개발1. package.json 파일 및 app.js 파일 생성123456789101112131415161718192021&#123; \"name\": \"server\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"start\": \"nodemon app\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"express\": \"^4.17.1\" &#125;, \"devDependencies\": &#123; \"eslint\": \"^6.6.0\", \"eslint-config-airbnb-base\": \"^14.0.0\", \"eslint-plugin-html\": \"^6.0.0\", \"eslint-plugin-import\": \"^2.18.2\" &#125;&#125; 2. npm installpackage.json 파일 내용을 토대로 npm install 한다. 1npm install 3. eslint 설치 및 적용파일 코드를 깔끔하게 작성하기 위해서 eslint를 사용한다. 1npm install eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-html --save-dev 그 후 .eslintrc.js 파일을 생성한다. .eslintrc.js 에 내용 추가 123456789101112131415161718192021222324252627282930module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) // \"no-var\": 0, \"prefer-arrow-callback\": 0, \"no-console\": 0, // \"warn\" \"no-plusplus\": \"off\", // x \"vars-on-top\": 0, // x \"eqeqeq\": 0, \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", // \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"], \"no-nested-ternary\": 0, \"no-param-reassign\": 0 &#125;&#125;; 현재 폴더 상태 4. app.js에 내용 추가 ( 백엔드 )1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascirpt', completed: false &#125;];// 루트 폴더의 이름을 퍼블릭으로 할거야.// 미들웨어 딱 1번만 실행됨.app.use(express.static('public'));app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsingapp.get('/', (req, res) =&gt; &#123; res.send('hello world!');&#125;);app.get('/todos', (req, res) =&gt; &#123; res.send(todos);&#125;);app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); todos = [req.body, ...todos]; res.send(todos);&#125;);// app.patch('/todos/:id([0-9])', (req, res) =&gt; &#123;app.patch('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id const &#123; completed &#125; = req.body; // req.body.completed; todos = todos.map((todo) =&gt; (todo.id === +id ? &#123; ...todo, completed &#125; : todo)); res.send(todos);&#125;);app.delete('/todos/:id', (req, res) =&gt; &#123; const &#123; id &#125; = req.params; // req.params.id todos = todos.filter((todo) =&gt; todo.id !== +id); res.send(todos);&#125;);app.delete('/completedTodos', (req, res) =&gt; &#123; todos = todos.filter((todo) =&gt; !todo.completed); res.send(todos);&#125;);app.put('/todos', (req, res) =&gt; &#123; const &#123; completed &#125; = req.body; todos = todos.map((todo) =&gt; (&#123; ...todo, completed &#125;)); res.send(todos);&#125;);app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); 5. public/index.html 추가12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Todos 2.0&lt;/title&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;script defer src=\"js/index.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"title\"&gt;Todos&lt;/h1&gt; &lt;div class=\"ver\"&gt;2.0&lt;/div&gt; &lt;input class=\"input-todo\" placeholder=\"What needs to be done?\" autofocus&gt; &lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"todos\"&gt; &lt;!-- &lt;li id=\"myId\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-myId\"&gt; &lt;label for=\"ck-myId\"&gt;HTML&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;footer&gt; &lt;div class=\"complete-all\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-complete-all\"&gt; &lt;label for=\"ck-complete-all\"&gt;Mark all as complete&lt;/label&gt; &lt;/div&gt; &lt;div class=\"clear-completed\"&gt; &lt;button class=\"btn\"&gt;Clear completed (&lt;span class=\"completed-todos\"&gt;0&lt;/span&gt;)&lt;/button&gt; &lt;strong class=\"active-todos\"&gt;0&lt;/strong&gt; items left &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. public/css/style.css 추가123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207@import url('https://fonts.googleapis.com/css?family=Roboto:100,300,400,700|Noto+Sans+KR');@import url('https://use.fontawesome.com/releases/v5.5.0/css/all.css');* &#123; box-sizing: border-box; margin: 0; padding: 0;&#125;body &#123; font-family: 'Roboto', 'Noto Sans KR', sans-serif; font-size: 0.9em; color: #a9b0b4; /*#58666e;*/ background-color: #505455;/*#f0f3f4;*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.container &#123; max-width: 750px; min-width: 450px; margin: 0 auto; padding: 15px;&#125;.title &#123; /* margin: 10px 0; */ font-size: 4.5em; font-weight: 100; text-align: center; color: #23b7e5;&#125;.ver &#123; font-weight: 100; text-align: center; color: #23b7e5; margin-bottom: 30px;&#125;/* .input-todo */.input-todo &#123; display: block; width: 100%; height: 45px; padding: 10px 16px; font-size: 18px; line-height: 1.3333333; color: #555; border: 1px solid #ccc; border-color: #e7ecee; border-radius: 6px; outline: none; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;&#125;.input-todo:focus &#123; border-color: #23b7e5; box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125;.input-todo::-webkit-input-placeholder &#123; color: #999;&#125;/* .nav */.nav &#123; display: flex; margin: 15px; list-style: none;&#125;.nav &gt; li &#123; padding: 4px 10px; border-radius: 4px; cursor: pointer;&#125;.nav &gt; li.active &#123; color: #fff; background-color: #23b7e5;&#125;.todos &#123; margin-top: 20px;&#125;/* .todo-item */.todo-item &#123; position: relative; /* display: block; */ height: 50px; padding: 10px 15px; margin-bottom: -1px; background-color: #fff; border: 1px solid #ddd; border-color: #e7ecee; list-style: none;&#125;.todo-item:first-child &#123; border-top-left-radius: 4px; border-top-right-radius: 4px;&#125;.todo-item:last-child &#123; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;&#125;/* .checkbox .checkbox 바로 뒤에 위치한 label의 before와 after를 사용해 .checkbox의 외부 박스와 내부 박스를 생성한다. &lt;input class=\"checkbox\" type=\"checkbox\" id=\"myId\"&gt; &lt;label for=\"myId\"&gt;Content&lt;/label&gt;*/.checkbox &#123; display: none;&#125;.checkbox + label &#123; position: absolute; /* 부모 위치를 기준으로 */ top: 50%; left: 15px; transform: translate3d(0, -50%, 0); display: inline-block; width: 90%; line-height: 2em; padding-left: 35px; cursor: pointer; user-select: none;&#125;.checkbox + label:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; transform: translate3d(0, -50%, 0); width: 20px; height: 20px; background-color: #fff; border: 1px solid #cfdadd;&#125;.checkbox:checked + label:after &#123; content: \"\"; position: absolute; top: 50%; left: 6px; transform: translate3d(0, -50%, 0); width: 10px; height: 10px; background-color: #23b7e5;&#125;/* .remove-todo button */.remove-todo &#123; display: none; position: absolute; top: 50%; right: 10px; cursor: pointer; transform: translate3d(0, -50%, 0);&#125;/* todo-item이 호버 상태이면 삭제 버튼을 활성화 */.todo-item:hover &gt; .remove-todo &#123; display: block;&#125;footer &#123; display: flex; justify-content: space-between; margin: 20px 0;&#125;.complete-all, .clear-completed &#123; position: relative; flex-basis: 50%;&#125;.clear-completed &#123; text-align: right; padding-right: 15px;&#125;.btn &#123; padding: 1px 5px; font-size: .8em; line-height: 1.5; border-radius: 3px; outline: none; color: #333; background-color: #fff; border-color: #ccc; cursor: pointer;&#125;.btn:hover &#123; color: #333; background-color: #e6e6e6; border-color: #adadad;&#125; 7. public/js/index.js 추가123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');const $completeAll = document.querySelector('.complete-all');const $nav = document.querySelector('.nav');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');let todos = [];let navID = 'all';// TODOS 데이터 요청 및 받아오기.const ajax = (() =&gt; &#123; const request = (method, url, fn, payload) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; // 200 정상 응답, POST는 가끔 201로 반환함. if (xhr.status === 200 || xhr.status === 201) &#123; fn(JSON.parse(xhr.response)); // 요청의 응답 된 데이터 처리 &#125; else &#123; console.error('error', xhr.status, xhr.statusText); &#125; &#125;; &#125;; return &#123; get(url, fn) &#123; request('GET', url, fn); &#125;, post(url, fn, payload) &#123; request('POST', url, fn, payload); &#125;, delete(url, fn) &#123; request('DELETE', url, fn); &#125;, patch(url, fn, payload) &#123; request('PATCH', url, fn, payload); &#125;, put(url, fn, payload) &#123; request('PUT', url, fn, payload); &#125; &#125;;&#125;)();// render 함수const render = (data) =&gt; &#123; let html = ''; todos = data; todos = data.filter((todo) =&gt; (navID === 'all' ? true : navID === 'active' ? !todo.completed : todo.completed)); todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;`; &#125;); $completedTodos.textContent = data.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = data.filter((todo) =&gt; !todo.completed).length; $todos.innerHTML = html; console.log('[RENDER]', todos);&#125;;// 부가 기능 함수const findMaxId = () =&gt; Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;// 기능 함수const getTodos = () =&gt; &#123; ajax.get('./todos', render);&#125;;const postTodos = (content) =&gt; &#123; ajax.post('./todos', render, &#123; id: findMaxId(), content, completed: false &#125;); $inputTodo.value = '';&#125;;const removeTodo = (id) =&gt; &#123; ajax.delete(`./todos/$&#123;id&#125;`, render);&#125;;// patchconst checkTodo = (id, checked) =&gt; &#123; const completed = checked; // const completed = !todos.find((todo) =&gt; todo.id === +id).completed; ajax.patch(`./todos/$&#123;id&#125;`, render, &#123; completed &#125;);&#125;;const toggleAll = (checked) =&gt; &#123; const completed = checked; ajax.put('./todos', render, &#123; completed &#125;);&#125;;const clearTodos = () =&gt; &#123; ajax.delete('./completedTodos', render);&#125;;const changeNav = (target) =&gt; &#123; [...$nav.children].forEach(($list) =&gt; &#123; $list.classList.toggle('active', $list == target); navID = target.id; &#125;); ajax.get('./todos', render);&#125;;// 이벤트 핸들러window.onload = () =&gt; &#123; getTodos();&#125;;$inputTodo.onkeyup = (&#123; target, keyCode &#125;) =&gt; &#123; if (target.value.trim() === '' || keyCode !== 13) return; postTodos(target.value.trim());&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(target.parentNode.id);&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; checkTodo(target.parentNode.id, target.checked);&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; toggleAll(target.checked);&#125;;$clearCompleted.onclick = () =&gt; &#123; clearTodos();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target);&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"Ajax","slug":"Ajax","permalink":"https://hyeok999.github.io/tags/Ajax/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"daily_quiz36","slug":"daily-quiz36","date":"2019-11-09T07:33:46.000Z","updated":"2019-11-30T17:11:18.073Z","comments":true,"path":"2019/11/09/daily-quiz36/","link":"","permalink":"https://hyeok999.github.io/2019/11/09/daily-quiz36/","excerpt":"","text":"문제 출처 : poiema Tabs UI 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Popup&lt;/title&gt; &lt;style&gt; @import url(https://fonts.googleapis.com/css?family=Open+Sans:300,400); body &#123; font-family: 'Open Sans'; font-weight: 300; background-color: #D6E1E5; &#125; h1 &#123; color: #DB5B33; font-weight: 300; text-align: center; &#125; /* CSS 작성 바랍니다. */ .overlay&#123; position: absolute; top: 0; left: 0; background: rgba(0,0,0,.3); width: 100vw; height: 100vh; display: none; z-index: 10; &#125; .popup &#123; background: white; width: 700px; position: absolute; top: 50%; left: 50%; padding: 30px 20px; margin: 0 auto; box-shadow: 0 35px 15px 0 rgba(0,0,0,.3); transform: translate(-50%, -50%); display: none; z-index: 15; &#125; .btn-close&#123; position: absolute; top: 0; right: 0;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;JavaScript Popup&lt;/h1&gt; &lt;div class=\"popup\"&gt; &lt;h1&gt;JavaScript Popup&lt;/h1&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam&lt;/p&gt; &lt;button class=\"btn-close\"&gt;X&lt;/button&gt; &lt;input type=\"text\"&gt; &lt;button class=\"btn-ok\"&gt;OK&lt;/button&gt; &lt;button class=\"btn-cancel\"&gt;Cancel&lt;/button&gt; &lt;/div&gt; &lt;div class=\"overlay\"&gt;&lt;/div&gt; &lt;button class=\"toggle-popup\"&gt;show popup&lt;/button&gt; &lt;p class=\"popup-message\"&gt;&lt;/p&gt; &lt;script&gt; const $popup = document.querySelector('.popup'); const $togglePopup = document.querySelector('.toggle-popup'); const $overlay = document.querySelector('.overlay'); const $input = document.querySelector('.popup &gt; input'); const $popupMessage = document.querySelector('.popup-message'); // 기능 const showDisplay = () =&gt; &#123; $overlay.style.display = 'inline'; $popup.style.display = 'inline'; &#125;; const nonShowDisplay = () =&gt; &#123; $overlay.style.display = 'none'; $popup.style.display = 'none'; &#125;; // 이벤트 $togglePopup.onclick = () =&gt; &#123; showDisplay(); &#125;; $overlay.onclick = () =&gt; &#123; nonShowDisplay(); &#125;; $popup.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('btn-cancel') || target.classList.contains('btn-close')) &#123; nonShowDisplay(); &#125; if (target.classList.contains('btn-ok')) &#123; $popupMessage.textContent = `form popup : $&#123;$input.value&#125;`; nonShowDisplay(); $input.value = ''; &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 주요 코드JS 보다 css때문에 힘들었던 문제다. 팝업시 나타나는 회색 배경 처리 12345678910.overlay&#123; position: absolute; top: 0; left: 0; background: rgba(0,0,0,.3); width: 100vw; height: 100vh; display: none; z-index: 10;&#125; position을 absolute하여 화면에서 띄우고 화면의 넓이 , 높이를 전부다 다 100view로 맞춰놓았다. 클릭시 display만 바꿔주면 되기 때문에 none처리 하였고 마크업상 overlay 나중에 나오기 때문에 z-index를 낮게 줌으로써 뒤에서 보이게끔 설정하였다. 팝업시 나타는 화면 처리 12345678910111213.popup &#123; background: white; width: 700px; position: absolute; top: 50%; left: 50%; padding: 30px 20px; margin: 0 auto; box-shadow: 0 35px 15px 0 rgba(0,0,0,.3); transform: translate(-50%, -50%); display: none; z-index: 15;&#125; 팝업 클릭시 나타나는 화면은 현재 보는 화면에서 정중앙에 띄워서 나타나야 되기 때문에, position : absolute 를 주었고, 현재 위치에 중앙 위치인 top 50% , left 50% 에 transform: translate(-50%,-50%)를 줘서 정확히 반에 위치하게끔 설정하였다. overlay보다 위에 있어야되기 때문에 z-index를 15주로 설정하였다. 삭제 버튼 12345.btn-close&#123; position: absolute; top: 0; right: 0;;&#125; 삭제 버튼의 위치가 오른쪽 상단에 걸쳐야되기 때문에 absolute로 하여 top:0 right:0을 주웠다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"},{"name":"Quiz","slug":"Quiz","permalink":"https://hyeok999.github.io/tags/Quiz/"}]},{"title":"daily_quiz35","slug":"daily-quiz35","date":"2019-11-08T07:31:45.000Z","updated":"2019-11-30T17:11:06.714Z","comments":true,"path":"2019/11/08/daily-quiz35/","link":"","permalink":"https://hyeok999.github.io/2019/11/08/daily-quiz35/","excerpt":"","text":"문제 출처 : poiema Stop Watch 요구 사항 : 현재 시간을 표시하여야 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Analog Clock&lt;/title&gt; &lt;style&gt; @import url('https://fonts.googleapis.com/css?family=Source+Code+Pro'); .analog-clock &#123; position: relative; margin: 100px auto 0; width: 200px; height: 200px; background-color: aliceblue; border-radius: 50%; &#125; .hand &#123; position: absolute; left: 50%; width: 1px; height: 100px; /* 자바스크립트에 의해 덮어써진다. */ /* transform: translate3d(-50%, 0, 0); */ transform-origin: 100% 100%; &#125; .hour &#123; background-color: #f44336; &#125; .minute &#123; background-color: #3f51b5; &#125; .second &#123; background-color: #9e9e9e; /* transform: rotate(100deg); */ &#125; .center-circle &#123; position: absolute; top: 50%; left: 50%; transform: translate3d(-50%, -50%, 0); width: 12px; height: 12px; background-color: black; border-radius: 50%; &#125; .digital-clock &#123; position: absolute; top: 350px; left: 50%; transform: translate3d(-50%, 0, 0); font-size: 2em; font-family: 'Source Code Pro', monospace; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"clock\"&gt; &lt;div class=\"analog-clock\"&gt; &lt;div class=\"hour hand\"&gt;&lt;/div&gt; &lt;div class=\"minute hand\"&gt;&lt;/div&gt; &lt;div class=\"second hand\"&gt;&lt;/div&gt; &lt;div class=\"center-circle\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"digital-clock\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // transform: rotate(100deg); const $second = document.querySelector('.second'); const $minute = document.querySelector('.minute'); const $hour = document.querySelector('.hour'); const $digitalClock = document.querySelector('.digital-clock'); let sTime = new Date().getSeconds(); let mTime = new Date().getMinutes(); let hTime = new Date().getHours(); // const format = (num) =&gt; &#123; // num += ''; // if (num.length == 1) &#123; // num = `0$&#123;num&#125;`; // &#125; // return num; // &#125;; const format2 = (num) =&gt; (String(num).length == 1 ? `0$&#123;num&#125;` : `$&#123;num&#125;`); const timer = () =&gt; &#123; $second.style.transform = `rotate($&#123;sTime * 6&#125;deg)`; $minute.style.transform = `rotate($&#123;mTime * 6 + sTime * 0.1&#125;deg)`; $hour.style.transform = `rotate($&#123;(hTime % 12) * 30 + mTime * 0.5&#125;deg)`; $digitalClock.innerHTML = `$&#123;format2(hTime)&#125;:$&#123;format2(mTime)&#125;:$&#123;format2(sTime)&#125;`; sTime++; if (sTime &gt;= 60) &#123; mTime++; sTime = 0; &#125; if (mTime &gt;= 60) &#123; hTime++; mTime = 0; &#125; if (hTime &gt; 23) &#123; hTime = 0; &#125; &#125;; window.setInterval(timer, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 주요 코드 숫자가 1자리 수 일 때는 앞에 0을 붙인 문자열 변환 해당 문제에서 제일 난해한 부분은 특정 수 일 때 문자열로 변환을 해줘야만 한다는 것이었다. 따라 해당 시간을 화면에 보여주기 전에 먼저 문자열로 바꿔주면서 문자열 1자리 수라면 0을 앞에 붙이는 함수를 추가하였다. 123456789// const format = (num) =&gt; &#123;// num += '';// if (num.length == 1) &#123;// num = `0$&#123;num&#125;`;// &#125;// return String(num);// &#125;;const format2 = (num) =&gt; ((num + '').length === 1 ? `0$&#123;num&#125;` : `$&#123;num&#125;`); 시간 알고리즘 123456789101112131415161718192021const timer = () =&gt; &#123; $second.style.transform = `rotate($&#123;sTime * 6&#125;deg)`; $minute.style.transform = `rotate($&#123;mTime * 6 + sTime * 0.1&#125;deg)`; $hour.style.transform = `rotate($&#123;(hTime % 12) * 30 + mTime * 0.5&#125;deg)`; $digitalClock.innerHTML = `$&#123;format2(hTime)&#125;:$&#123;format2(mTime)&#125;:$&#123;format2(sTime)&#125;`; sTime++; if (sTime &gt;= 60) &#123; mTime++; sTime = 0; &#125; if (mTime &gt;= 60) &#123; hTime++; mTime = 0; &#125; if (hTime &gt; 23) &#123; hTime = 0; &#125; &#125;; 360도 기준 1초는 6도이므로 x6을 한다. : rotate(${sTime * 6}deg) 360도 기준 1분은 6도이므로 x6을 하고 1초가 60번을 움직여야만 1분이 움직이게 되므로 자연스러운 움직임을 위해 1초당 0.1도씩(60초 후 6도)움직이게 설정한다. : rotate(${mTime * 6 + sTime * 0.1}deg) 360도 기준 1시간은 30도인데 시간은 24시간이므로 12를 나눠서 나온 나머지를 가지고 처리한다.그리고 1분이 60번을 움직여야 1시간이 움직이게 되므로 자연스러운 움직임을 위해 1분당 0.5도씩(60분 후 30도) 움직이게 설정한다. : rotate(${(hTime % 12) * 30 + mTime * 0.5}deg) 디지털 시계 디지털 시계는 초부터 1씩 숫자를 증가시켜 초가 60을 넘기게 될 경우 0으로 만들고 분에 1을 더해준다. 분 역시 60을 넘기게 될 경우 0으로 만들고 시간에 1을 더 해준다. 시간은 23시( 정수이므로 24가 딱 되는 순간 )를 넘어가게 될 경우 0으로 초기화 해준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"},{"name":"Quiz","slug":"Quiz","permalink":"https://hyeok999.github.io/tags/Quiz/"}]},{"title":"Promise","slug":"Promise","date":"2019-11-08T00:33:48.000Z","updated":"2019-11-30T16:57:50.165Z","comments":true,"path":"2019/11/08/Promise/","link":"","permalink":"https://hyeok999.github.io/2019/11/08/Promise/","excerpt":"","text":"JavaScript 프로미스 ( Promise ) 프로미스 ( Promise ) 프로미스란? 콜백 패턴의 단점 콜백 헬 에러 처리의 한계 프로미스의 생성 프로미스의 후속 처리 메소드 프로미스의 에러 처리 프로미스 체이닝 프로미스의 정적 메소드 Promise.resolve / Promise.reject Promise.all Promise.race 프로미스 ( Promise ) 프로미스란? 콜백함수의 단점(구린 가독성, 에러의 예외처리가 힘듬, 여러개의 비동기 처리 로직 불가 등등)을 해결하기 위해서 ES6에 생긴 패턴. 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현한다. 콜백 패턴의 단점1. 콜백 헬JS의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다. 이러한 비동기식 처리 모델은 요청을 병렬로 처리해 다른 요청이 블로킹되지 않고 수행된다는 장점이 있다. 문제는, 비동기 처리를 위해 콜백 패턴을 남발하고 처리 순서 보장을 위해서 여러개의 콜백 함수가 중첩되어 복잡도가 증가한다면, 콜벡 헬이 발생한다. 콜백 헬은 가독성을 나쁘게 하며 실수를 유발하는 원인이 된다. 123456789101112// 콜백헬. 멸망의 피라미드step1(function(value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; step5(value4, function(value5) &#123; // value5를 사용하는 처리 &#125;); &#125;); &#125;); &#125;);&#125;); 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; // 비동기 함수 function get(url) &#123; // XMLHttpRequest 객체 생성 const xhr = new XMLHttpRequest(); // 서버 응답 시 호출될 이벤트 핸들러 xhr.onreadystatechange = function () &#123; // 서버 응답 완료가 아니면 무시 if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status === 200) &#123; // 정상 응답 console.log(xhr.response); // 비동기 함수의 결과에 대한 처리는 반환할 수 없다. return xhr.response; // ① &#125; else &#123; // 비정상 응답 console.log('Error: ' + xhr.status); &#125; &#125;; // 비동기 방식으로 Request 오픈 xhr.open('GET', url); // Request 전송 xhr.send(); &#125; // 비동기 함수 내의 readystatechange 이벤트 핸들러에서 처리 결과를 반환(①)하면 순서가 보장되지 않는다. const res = get('http://jsonplaceholder.typicode.com/posts/1'); console.log(res); // ② undefined &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 현재 실행 순서는 크게 다음 과 같다. get 함수 호출 -&gt; get함수 내부의 onreadystatechange 별도로 실행(콜백함수) -&gt; xhr.open호출 -&gt; xhr.send호출 -&gt; get함수 종료(return이 없으므로 undefined 반환) -&gt; console.log호출 -&gt; onreadystatechange호출 순이다. 즉, get함수는 제대로된 값을 반환하지 못한다. get 함수의 반환 결과를 제대로 하기 위해서는 해당 비동기 함수(get)의 콜백함수(onreadystatechange) 내에서 처리를 해야한다. 이로 인해 콜백 헬( Callback Hell )이 발생한다. 이러한 콜백 헬( Callback Hell )은 코드의 가독성을 나쁘게 하고 복잡도를 증가시켜 실수를 유발하는 원인이 되며 에러 처리가 곤란하다. 2. 에러 처리의 한계콜백 방식의 비동기 처리가 갖는 문제점 중에서 가장 심각한 것은 에러 처리가 곤란하다는 것. 123456try &#123; setTimeout(() =&gt; &#123; throw new Error('Error!'); &#125;, 1000);&#125; catch (e) &#123; console.log('에러를 캐치하지 못한다..'); console.log(e);&#125; try 블록 안에서 setTimeout 함수가 실행된다. (여기서 setTimeout은 비동기 함수다.) setTimeout함수는 호출 스택으로 들어가고 즉시 종료된다. tick 이벤트가 발생하면 콜백함수는 태스크 큐로 넘어간다. 태스크큐에 있는 콜백함수는 호출 스택이 비워진 것을 확인하고 호출 스택으로 넘어가고 실행된다. 이 때 예외처리는 호출자 방향( setTimeout 함수 ) 으로 전파된다. 강제로 throw 에러를 던져도 콜백함수가 호출 스택에 도착했을 때 이미 setTimeout은 호출스택에서 사라졌기 때문에 콜백함수를 호출 한 것은 setTimeout 함수가 아니라는 결론을 내리게된다. 따라서 setTimeout 함수의 콜백 함수 내에서 발생시킨 에러는 catch 블록에서 캐치되지 않아 프로세스는 종료된다. 프로미스의 생성 프로미스는 Promise 생성자 함수를 통해 인스턴스화한다. 비동기 작업을 수행할 콜백 함수를 인자로 전달 받는다. (resolve , reject) 1234567891011// Promise 객체의 생성const promise = new Promise((resolve, reject) =&gt; &#123; // 비동기 작업을 수행한다. if (/* 비동기 작업 수행 성공 */) &#123; resolve('result'); &#125; else &#123; /* 비동기 작업 수행 실패 */ reject('failure reason'); &#125;&#125;); Promise는 비동기 처리가 성공(fulfilled)하였는지 또는 실패(rejected)하였는지 등의 상태(state) 정보를 갖는다. 상태 의미 구현 pending 비동기 처리가 아직 수행되지 않은 상태 resolve 또는 reject 함수가 아직 호출되지 않은 상태 fulfilled 비동기 처리가 수행된 상태 (성공) resolve 함수가 호출된 상태 rejected 비동기 처리가 수행된 상태 (실패) reject 함수가 호출된 상태 settled 비동기 처리가 수행된 상태 (성공 또는 실패) resolve 또는 reject 함수가 호출된 상태 Promise 함수가 인자(resolve, reject)로 전달 받은 콜백함수는 내부에서 비동기 처리 작업을 수행한다. 비동기 처리가 성공시 resolve를 호출하고 ‘fullfilled’ 상태가 된다. 비동기 처리가 실패시 reject를 호출하고 ‘rejected’ 상태가 된다. 123456789101112131415161718192021const promiseAjax = (method, url, payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onreadystatechange = function () &#123; // 서버 응답 완료가 아니면 무시 if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) &#123; // resolve 메소드를 호출하면서 처리 결과를 전달 resolve(xhr.response); // Success! &#125; else &#123; // reject 메소드를 호출하면서 에러 메시지를 전달 reject(new Error(xhr.status)); // Failed... &#125; &#125;; &#125;);&#125;; 비동기 함수 내에서 Promise 객체를 생성하고 Promise 내부에서 비동기 처리를 구현한다. 비동기 처리에 성공하면 resolve 메소드를 호출한다. (실패하면 reject 메소드 호출) 이 때, resolve 메소드의 인자로 비동기 처리를 전달힌다. (reject 메소드의 인자로 에러메시지 전달) 처리 결과는 Promise 객체의 후속 처리 메소드로 전달된다. 프로미스의 후속 처리 메소드 Promise로 구현된 비동기 함수는 Promise 객체를 반환하여야 한다 Promise로 구현된 비동기 함수를 호출하는 측(promise consumer)에서는 Promise 객체의 후속 처리 메소드(then, catch)를 통해 비동기 처리 결과 또는 에러 메시지를 전달받아 처리한다. Promise의 상태에 따라 후속 처리 메소드를 체이닝 방식으로 호출한다. then then 메소드는 두 개의 콜백 함수를 인자로 전달 받는다.첫 번째 콜백 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출된다.두 번째 함수는 실패(rejected, reject 함수가 호출된 상태) 시 호출된다.then 메소드는 Promise를 반환한다. catch 예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출된다.catch 메소드는 Promise를 반환한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;pre class=\"result\"&gt;&lt;/pre&gt; &lt;script&gt; const $result = document.querySelector('.result'); const render = content =&gt; &#123; $result.textContent = JSON.stringify(content, null, 2); &#125;; const promiseAjax = (method, url, payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onreadystatechange = function () &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) &#123; resolve(xhr.response); // Success! &#125; else &#123; reject(new Error(xhr.status)); // Failed... &#125; &#125;; &#125;); &#125;; /* 비동기 함수 promiseAjax은 Promise 객체를 반환한다. Promise 객체의 후속 메소드를 사용하여 비동기 처리 결과에 대한 후속 처리를 수행한다. */ promiseAjax('GET', 'http://jsonplaceholder.typicode.com/posts/1') .then(JSON.parse) .then( // 첫 번째 콜백 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출된다. render, // 두 번째 함수는 실패(rejected, reject 함수가 호출된 상태) 시 호출된다. console.error ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 프로미스의 에러 처리 위 예제의 비동기 함수 get은 Promise 객체를 반환한다. Promise 객체의 후속 처리 메소드를 사용하여 비동기 처리 결과에 대한 후속 처리를 수행한다. 비동기 처리 시 발생한 에러 메시지는 then 메소드의 두 번째 콜백 함수로 전달된다. Promise 객체의 후속 처리 메소드 catch을 사용하여도 에러를 처리할 수 있다. 1234promiseAjax('GET', 'http://jsonplaceholder.typicode.com/posts/1') .then(JSON.parse) .then(render) .catch(console.error); then 메소드의 두 번째 콜백 함수는 비동기 처리에서 발생한 에러( reject 함수가 호출된 상태 )만을 캐치한다. catch 메소드는 비동기 처리에서 발생한 에러( reject 함수가 호출된 상태 )뿐만 아니라 then 메소드 내부에서 발생한 에러도 캐치한다. 따라서 에러 처리는 catch 메소드를 사용하는 편이 보다 효율적이다. 프로미스 체이닝 비동기 함수의 처리 결과를 가지고 다른 비동기 함수를 호출해야 하는 경우, 함수의 호출이 중첩(nesting)이 되어 복잡도가 높아지는 콜백 헬이 발생한다. 프로미스는 후속 처리 메소드를 체이닝(chainning)하여 여러 개의 프로미스를 연결하여 사용할 수 있다. 이로써 콜백 헬을 해결한다. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;pre class=\"result\"&gt;&lt;/pre&gt; &lt;script&gt; const $result = document.querySelector('.result'); const render = content =&gt; &#123; $result.textContent = JSON.stringify(content, null, 2); &#125;; const promiseAjax = (method, url, payload) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); xhr.onreadystatechange = function () &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) &#123; resolve(xhr.response); // Success! &#125; else &#123; reject(new Error(xhr.status)); // Failed... &#125; &#125;; &#125;); &#125;; const url = 'http://jsonplaceholder.typicode.com/posts'; // 포스트 id가 1인 포스트를 검색하고 프로미스를 반환한다. promiseAjax('GET', `$&#123;url&#125;/1`) // 포스트 id가 1인 포스트를 작성한 사용자의 아이디로 작성된 모든 포스트를 검색하고 프로미스를 반환한다. .then(res =&gt; promiseAjax('GET', `$&#123;url&#125;?userId=$&#123;JSON.parse(res).userId&#125;`)) .then(JSON.parse) .then(render) .catch(console.error); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Promise 객체를 반환한 비동기 함수는 프로미스 후속 처리 메소드인 then이나 catch 메소드를 사용할 수 있다. 따라서 then 메소드가 Promise 객체를 반환하도록 하면(then 메소드는 기본적으로 Promise를 반환한다.) 여러 개의 프로미스를 연결하여 사용할 수 있다. 프로미스의 정적 메소드 Promise는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메소드를 갖을 수 있다. Promise 객체는 4가지 정적 메소드를 제공한다. (resolve, reject, all, race) Promise.resolve / Promise.reject Promise.resolve와 Promise.reject 메소드는 존재하는 값을 Promise로 래핑하기 위해 사용한다. 정적 메소드 Promise.resolve 메소드는 인자로 전달된 값을 resolve하는 Promise를 생성한다. 12const resolvedPromise = Promise.resolve([1, 2, 3]);resolvedPromise.then(console.log); // [ 1, 2, 3 ] 위 예제는 아래 예제와 동일하게 동작한다. 12const resolvedPromise = new Promise(resolve =&gt; resolve([1, 2, 3]));resolvedPromise.then(console.log); // [ 1, 2, 3 ] Promise.reject 메소드는 인자로 전달된 값을 reject하는 프로미스를 생성한다. 12const rejectedPromise = Promise.reject(new Error('Error!'));rejectedPromise.catch(console.log); // Error: Error! 위 예제는 아래 예제와 동일하게 동작한다. 12const rejectedPromise = new Promise((resolve, reject) =&gt; reject(new Error('Error!')));rejectedPromise.catch(console.log); // Error: Error! Promise.all Promise.all 메소드는 프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다. 전달받은 모든 프로미스를 병렬로 처리하고 그 처리 결과를 resolve하는 새로운 프로미스를 반환한다. 123456Promise.all([ new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)) // 3]).then(console.log) // [ 1, 2, 3 ] .catch(console.log); Promise.all 메소드는 3개의 프로미스를 담은 배열을 전달받았다. 각각의 프로미스는 아래와 같이 동작한다. 첫번째 프로미스는 3초 후에 1을 resolve하여 처리 결과를 반환한다. 두번째 프로미스는 2초 후에 2을 resolve하여 처리 결과를 반환한다. 세번째 프로미스는 1초 후에 3을 resolve하여 처리 결과를 반환한다. Promise.all 메소드는 전달받은 모든 프로미스를 병렬로 처리한다. 이때 모든 프로미스의 처리가 종료될 때까지 기다린 후 아래와 모든 처리 결과를 resolve 또는 reject한다. 모든 프로미스의 처리가 성공하면 각각의 프로미스가 resolve한 처리 결과를 배열에 담아 resolve하는 새로운 프로미스를 반환한다. 첫번째 프로미스가 가장 나중에 처리되어도 Promise.all 메소드가 반환하는 프로미스는 첫번째 프로미스가 resolve한 처리 결과부터 차례대로 배열에 담아 그 배열을 resolve하는 새로운 프로미스를 반환한다. 즉, 처리 순서가 보장된다. Promise.all은 병렬로 처리한다. 다만 순서를 보장해주기 때문에 먼저 처리되어도 프로미스 순서대로 처리결과를 배열에 담는다. 프로미스의 처리가 하나라도 실패하면 가장 먼저 실패한 프로미스가 reject한 에러를 reject하는 새로운 프로미스를 즉시 반환한다. 123456Promise.all([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 1!')), 3000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 2!')), 2000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 3!')), 1000))]).then(console.log) .catch(console.log); // Error: Error 3! 위 예제의 경우, 세번째 프로미스가 가장 먼저 실패하므로 세번째 프로미스가 reject한 에러가 catch 메소드로 전달된다. Promise.all 메소드는 전달 받은 이터러블의 요소가 프로미스가 아닌 경우, Promise.resolve 메소드를 통해 프로미스로 래핑된다. 123456Promise.all([ 1, // =&gt; Promise.resolve(1) 2, // =&gt; Promise.resolve(2) 3 // =&gt; Promise.resolve(3)]).then(console.log) // [1, 2, 3] .catch(console.log); github id로 github 사용자 이름을 취득하는 예제이다. 12345678910const githubIds = ['jeresig', 'ahejlsberg', 'ungmo2'];Promise.all(githubIds.map(id =&gt; fetch(`https://api.github.com/users/$&#123;id&#125;`))) // [Response, Response, Response] =&gt; Promise .then(responses =&gt; Promise.all(responses.map(res =&gt; res.json()))) // [user, user, user] =&gt; Promise .then(users =&gt; users.map(user =&gt; user.name)) // [ 'John Resig', 'Anders Hejlsberg', 'Ungmo Lee' ] .then(console.log) .catch(console.log); Promise.all 메소드는 fetch 함수가 반환한 3개의 프로미스의 배열을 인수로 전달받고 이 프로미스들을 병렬 처리한다. 모든 프로미스의 처리가 성공하면 Promise.all 메소드는 각각의 프로미스가 resolve한 3개의 Response 객체가 담긴 배열을 resolve하는 새로운 프로미스를 반환하고 후속 처리 메소드 then에는 3개의 Response 객체가 담긴 배열이 전달된다. 이때 json 메소드는 프로미스를 반환하므로 한번 더 Promise.all 메소드를 호출해야 하는 것에 주의. 두번째 호출한 Promise.all 메소드는 github로 부터 취득한 3개의 사용자 정보 객체가 담긴 배열을 resolve하는 프로미스를 반환하고 후속 처리 메소드 then에는 3개의 사용자 정보 객체가 담긴 배열이 전달된다. Promise.race Promise.race 메소드는 Promise.all 메소드와 동일하게 프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받는다. Promise.race 메소드는 Promise.all 메소드처럼 모든 프로미스를 병렬 처리하는 것이 아니라 가장 먼저 처리된 프로미스가 resolve한 처리 결과를 resolve하는 새로운 프로미스를 반환 123456Promise.race([ new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)) // 3]).then(console.log) // 3 .catch(console.log); 에러가 발생한 경우는 Promise.all 메소드와 동일하게 처리. Promise.race 메소드에 전달된 프로미스 처리가 하나라도 실패하면 가장 먼저 실패한 프로미스가 reject한 에러를 reject하는 새로운 프로미스를 즉시 반환한다. 123456Promise.race([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 1!')), 3000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 2!')), 2000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 3!')), 1000))]).then(console.log) .catch(console.log); // Error: Error 3!","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Promise","slug":"Promise","permalink":"https://hyeok999.github.io/tags/Promise/"}]},{"title":"javascript-study-23","slug":"javascript-study-23","date":"2019-11-07T15:49:12.000Z","updated":"2019-11-30T16:59:13.230Z","comments":true,"path":"2019/11/08/javascript-study-23/","link":"","permalink":"https://hyeok999.github.io/2019/11/08/javascript-study-23/","excerpt":"","text":"JavaScript Study 23 비동기식 처리 모델과 Ajax 상대 경로 와 절대 경로 클라이언트 및 서버 지식 NPM &amp; Express 를 이용한 로컬 서버 개설 Ajax 란? Ajax 장점 Ajax 단점 Ajax 요청 방법 REST API Method : GET . POST , PUT , DELETE , PATCH 콜백의 단점 실습 용어 - ( 러버덕 ) 상대경로 절대경로 Ajax REST API 요청 Method 콜백의 단점 비동기식 처리 모델과 Ajax 상대 경로 와 절대 경로. : 지금 이 경로를 실행하고 있는 파일의 위치/ : 서버의 루트 상대 경로 : 특정 곳을 기준으로 해서 위치의 경로를 기입하는 방식 Desktop\\test.txt 절대 경로 : 최초의 시작점으로 경유한 경로를 전부 기입하는 방식 C:\\Users\\KJH\\Desktop\\test.txt 클라이언트 및 서버 지식 브라우저에게 어떤 파일을 달라고 할 때는 위치를 알려줌 (일단 서버부터 알려주기.) 서버마다 중복되지 않는 식별자가 있어야 함(IP) 도매인과 IP는 맵핑되어야 함. naver.com이라고 치면 IP로 찾아가야함. (DNS에 접근) DNS는 Domain Name System sever는 폴더를 가지고 있음. 필요한 파일을 찾아서 읽어야함. 파일 안에는 2진수가 들어있음. 하드디스크에 있는 파일을 읽는다는 것은 메모리에 올린다는 것을 의미. 하드디스크에 물리적으로 있었던 파일이 메모리 상으로 올라옴. 랜선을 타고 아스키코드를 보낸다. 브라우저가 아스키코드를 받으면 메모리에 가지고 있다가 파싱. ( = 다운로드 ) 아스키코드는 문자열. 유니코드는 언어에 종속되어있지 않음. src는 서버의 경로로 써줘야 함. Ajax는 통신을 하는 수단을 배우는 것. Request가 가면 Response가 와야 함. Node.js 프레임워크 Express. npm은 Node Package Manager. Node.js는 모두 비동기, 콜백이다. 정적인 데이터를 넘기려고 하면 어디에 가져다놓을지 생각해봐야함. (보통 루트에 갖다놔야 함.) 우리가 만든 서버가 루트로 어디를 갖게 할지 설정, 기본적으로 루트로 접근했을 때 index.html을 리턴할 수 있도록 해야함. 정적 파일의 제공. 서버가 보내온 파일은 아스키코드(1바이트 문자열)로 보내진다. 실무에 나갈 수록 오픈소스 등이 많아지는데 이런 것들을 통합적으로 관리 하기 위해 나온것이 Package Manager다. 서버와 클라이언트를 명확하게 나눌 수 있어야 함. 클라이언트가 요청을 날리는 방법 알아야 함. NPM &amp; Express 를 이용한 로컬 서버 개설node 상에서 사용되는 패키지 매니저는 npm 이다.node는 전부 비동기고 전부 콜백 방식이다.localhost : 개발단계에서 자신의 로컬 컴퓨터에서 테스트를 하기 위해서 서버환경을 만들어서 사용한 루프백 호스트명. 아래 명령어를 통해 간단한 서버를 개설한다. npm init -y : package.json 을 생성한다. npm install express : express라는 패키지를 설치하겠다. (위치는 현재 디렉토리 위치) 위 명령어 실행 후 package.json 의 dependencies에 설치된 패키지 명과 버전이 적히게 된다. node_modules폴더가 생기는데 패키지를 uninstall하고 싶다면 해당 폴더를 삭제 하면된다. 재 설치를 원할 경우 npm i만 쳐주면 된다. npm install -g nodemon : nodemon 패키지 전역 설치 -&gt; 서버를 수시로 재시작 안해도 작동하게끔 해준다. Ajax 란? JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술, XML : 데이터 형식의 일종 Ajax 장점 페이지 이동없이 고속으로 화면 전환 가능 서버처리를 기다리 않고 비동기 요청 가능 수신하는 데이터 양을 줄일 수 있고, 클라이언트에게 처리를 위임할 수 있다. Ajax 단점 동일-출처 정책으로 인해 다른 도메인과는 통신이 불가능하다.( 이를 해결하기 위해 JSONP , CORS 등이 나옴) Ajax를 쓸 수 없는 브라우저가 있다. Http 클라이언트 기능이 한정됨. 페이지 이동없는 통신으로 인한 보안상 문제 지원하는 Charset이 한정됨. 요청을 남발시 서버 부하가 늘어남. Debugging에 용이하지 않음. ( 에러를 잡기가 쉽지 않다. ) Ajax 요청 방법 XMLHttpRequest Axios : XMLHttpRequest를 좀 더 편리하게 쓰고자 나온 라이브러리. 현재 가장 많이 사용되는 HTTP 통신 라이브러리. fetch : Axios라이브러리를 대체 하기 위해 나온 Web API( 라이브러리 import가 필요없다. ) REST API Method 작성 시 시멘틱하게 작성하는 것. 따르지 않더라도 에러가 나는 것은 아니지만 협업하기 위해 필요로 한다. Method : GET . POST , PUT , DELETE , PATCH Method는 클라이언트가 서버로 요청을 날리는 방법. GET -&gt; /todos : 모든 todos를 전부 가지고 온다.GET -&gt; /todos/1 : 모든 todos데이터 중에서 id가 1인 것만 가지고 온다. POST -&gt; 데이터를 생성할 떄 , payload PUT -&gt; 데이터 전체를 고칠떄 (예, content도 고치고 completed도 고칠떄) , payload PATCH -&gt; 데이터 일부를 고칠떄 (예, content만 고칠 떄) , payload DELETE -&gt; 전체 지우기 , 일부 지우기 (일부를 지우려면 조건을 필요로 함) 콜백의 단점Node Js의 모든 메서드는 전부 비동기이기 떄문에 순서를 보장해주기 위해서 비동기 함수 내부에서 콜백으로 주는 방법밖에 없다. 콜백의 단점 : 콜백헬, 에러처리 불가 따라서 추가 된 것 , Promise(ES6) , Generate(문법이 어려움) , async(await) , RxJS 실습 서버 실행 : npm start 서버 개설 및 준비cd ~/Desktop/ : Desktop 디렉토리로 이동. mkdir practice-server &amp;&amp; cd practice-server : practice-server 폴더 만들고 이동. npm init -y : package.json 을 생성한다. npm install express : express 패키지를 설치 npm install -g nodemon : nodemon 패키지 전역 설치 -&gt; 서버를 수시로 재시작 안해도 작동하게끔 해준다. code . : VSCode로 해당 폴더 열기. 1234567// 터미널cd ~/Desktop/mkdir practice-server &amp;&amp; cd practice-servernpm init -y npm install express npm install -g nodemon code . 만들어진 폴더에 package.json 파일의 dependencies에 express가 적혀져 있는 지 확인한다. package.json 파일에 scripts내용을 지우고 다음과 같이 적는다. 1234// package.json\"scripts\": &#123; \"start\": \"nodemon app\" &#125; public 폴더 생성 ➤ 하위에 index.html 파일 , js 폴더 생성 ➤ js 폴더 하위에 index.js 생성 app.js 작성requestBody에는 key와 value를 담고 있는데 기본적으로 undefined 이기 떄문에, 바디 파싱 미들웨어 app.use(express.json()); app.use(express.urlencoded({ extended: true })); 를 사용해야만 키와 값을 제대로 사용할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738// express 패키지(모듈)를 가지고 온다.const express = require('express');const app = express();let todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 2, content: 'CSS', completed: false &#125; ];// 루트 폴더를 'public'폴더로 지정함.// app.use는 미들웨어다. 미들웨어는 딱 1번만 실행됨.app.use(express.static('public'));// 바디 파싱 미들웨어app.use(express.json());app.use(express.urlencoded(&#123; extended: true &#125;)); // for parsing// request와 response 객체는 express가 제공함 // 보통 response는 html을 갖고있음// rest명령규칙으로 정함app.get('/',(req, res) =&gt; &#123; res.send('hello world!');&#125;);app.get('/todos', (req, res) =&gt; &#123; res.send(todos);&#125;)app.post('/todos', (req, res) =&gt; &#123; console.log(req.body); res.send('POST');&#125;)// 해당 앱은 3000번 포트를 이용하겠다고 명시함.app.listen(3000, () =&gt; &#123; console.log('Server listening on port 3000');&#125;); index.html 작성 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script defer src=\"js/index.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" placeholder=\"enter todo!\"&gt; &lt;ul class=\"todos\"&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; index.jsnew XMLHttpRequest(); : XMLHttpRequest 객체 생성 ( Ajax 요청을 생성하고 전송 ) xhr.open(&#39;GET&#39;, url) : 서버로의 요청을 준비. 1인수 : 요청메소드 (GET, POST…) 2인수 : url (경로) xhr.send() : 준비된 요청을 서버에 전달한다.( GET - 인수가 무시됨 , POST - 보낼데이터 인수로 줘야함(페이로드) ) xhr.readyState : 0 1 2 3 4로 각각의 상태를 나타냄. 4는 서버측이 데이터를 전부 받았음을 의미. XMLHttpRequest.DONE : 고정 값 4를 가리킨다. 요청 보내 졌을 떄 확인용 정적 프로퍼피 xhr.status : 서버에게 보낸 요청에 대한 http 에러코드가 담겨져 있다.( 200은 에러없이 전송 성공을 의미 ) xhr.response : 서버로부터 받아온 데이터가 담겨져있다. JSON.parse : 함수로 해당 JSON 문자열을 해제 시킨다. 123456789101112131415161718192021222324252627282930313233343536373839404142//DOMsconst $todos = document.querySelector('.todos');let todos = [];const get = (url, f) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.send(); // payLoad가 있다면 send에게 주고 없다면 비워둠. xhr.onreadystatechange = () =&gt; &#123; if( xhr.readyState !== XMLHttpRequest.DONE ) return; if( xhr.status === 200 ) &#123; f(JSON.parse(xhr.response)); &#125; else &#123; console.error('Error : ', xhr.status, xhr.statusText); &#125; &#125;;&#125;const getTodos = () =&gt; &#123; get('./todos', render);&#125;;const render = (data) =&gt; &#123; console.log('Render'); let html = ''; todos = data; // 디스트럭처링 todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;`; &#125;); $todos.innerHTML = html; &#125;;window.onload = () =&gt; &#123; getTodos();&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_quiz34","slug":"daily-quiz34","date":"2019-11-07T15:47:40.000Z","updated":"2019-11-30T17:11:40.922Z","comments":true,"path":"2019/11/08/daily-quiz34/","link":"","permalink":"https://hyeok999.github.io/2019/11/08/daily-quiz34/","excerpt":"","text":"문제 출처 : poiema Stop Watch 요구 사항 : 버튼을 처음 클릭하면 스톱워치가 시작하고 버튼을 다시 클릭하면 일시 정지와 시작을 반복한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Stop watch&lt;/title&gt; &lt;style&gt; @import url('https://fonts.googleapis.com/css?family=Source+Code+Pro'); .stop-watch &#123; font-family: 'Source Code Pro', monospace; text-align: center; font-size: 3em; padding: 30px; &#125; .control &#123; width: 300px; padding: 5px; margin-top: 15px; font-size: 36px; font-weight: bold; border: 2px solid #f44336; border-radius: 4px; cursor: pointer; outline: none; &#125; .control:hover &#123; background: #f44336; color: aliceblue; &#125; &lt;/style&gt; &lt;title&gt;Stop watch&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"stop-watch\"&gt; &lt;div class=\"display\"&gt;00:00:00&lt;/div&gt; &lt;button class=\"control\"&gt;Start&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 버튼을 처음 클릭하면 스톱워치가 시작하고 버튼을 다시 클릭하면 일시 정지와 시작을 반복한다. const $control = document.querySelector('.control'); const $display = document.querySelector('.display'); let timer = 0; let btn = false; let hour = '00'; let minute = '00'; let second = '00'; // const format = (num) =&gt; &#123; // num += ''; // if (num.length == 1) &#123; // num = `0$&#123;num&#125;`; // &#125; // return String(num); // &#125;; const format = (num) =&gt; ((num + '').length === 1 ? `0$&#123;num&#125;` : `$&#123;num&#125;`); $control.onclick = () =&gt; &#123; if (!btn) &#123; timer = setInterval(function () &#123; $display.textContent = `$&#123;format(hour)&#125;:$&#123;format(minute)&#125;:$&#123;format(second)&#125;`; second++; if (second &gt;= 100) &#123; minute++; second = 0; &#125; if (minute &gt;= 60) &#123; hour++; minute = 0; &#125; if (hour &gt;= 60) &#123; hour = 0; &#125; &#125;, 20); btn = true; &#125; else &#123; clearInterval(timer); btn = false; &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 주요 코드 숫자가 1자리 수 일 때는 앞에 0을 붙인 문자열 변환 해당 문제에서 제일 난해한 부분은 특정 수 일 때 문자열로 변환을 해줘야만 한다는 것이었다. 따라서 해당 시간을 화면에 보여주기 전에 먼저 문자열로 바꿔주면서 문자열 1자리 수라면 0을 앞에 붙이는 함수를 추가하였다. 123456789// const format = (num) =&gt; &#123;// num += '';// if (num.length == 1) &#123;// num = `0$&#123;num&#125;`;// &#125;// return String(num);// &#125;;const format = (num) =&gt; ((num + '').length === 1 ? `0$&#123;num&#125;` : `$&#123;num&#125;`); 정지 시작 토글 생성 정지 한 후 다시 시작하는 토글기능을 위해 변수 btn을 만들고 클릭시 btn에 false 혹은 true값을 게속 번갈아가도록 설정 하였다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"},{"name":"Quiz","slug":"Quiz","permalink":"https://hyeok999.github.io/tags/Quiz/"}]},{"title":"REST API","slug":"REST-API","date":"2019-11-07T03:58:49.000Z","updated":"2019-11-30T16:57:34.400Z","comments":true,"path":"2019/11/07/REST-API/","link":"","permalink":"https://hyeok999.github.io/2019/11/07/REST-API/","excerpt":"","text":"JavaScript REST API REST(Representational State Transfer) API REST API 중심 규칙 URI는 정보의 자원을 표현 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현 HTTP Method REST API의 구성 REST API 예 json-server GET 특정 아이디만 선택이 가능하다. POST PUT PATCH DELETE REST(Representational State Transfer) APIREST의 기본 원칙을 성실히 지킨 서비스 디자인을 “RESTful”이라고 표현한다. Method 작성 시 시멘틱하게 작성하는 것. 따르지 않더라도 에러가 나는 것은 아니지만 협업하기 위해 필요로 한다. REST API 중심 규칙 URI는 자원을 표현하는데 집중 HTTP Method는 행위에 대한 정의에 집중 1. URI는 정보의 자원을 표현 리소스명은 명사위주로 작성한다. ( 동사x , 명사o ) get같은 행위에 대한 표현이 들어가는 것은 좋지 않다. 123456# badGET /getTodos/1GET /todos/show/1# goodGET /todos/1 2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현 12345# badGET /todos/delete/1# goodDELETE /todos/1 HTTP Method 주로 5가지의 Method(GET, POST, PUT, PATCH, DELETE)를 사용하여 CRUD를 구현한다.(CRUD : Create, Read, Update, Delete) Method Action 역할 GET index/retrieve 모든/특정 리소스를 조회 POST create 리소스를 생성 PUT update all 리소스의 전체를 갱신 PATCH update 리소스의 일부를 갱신 DELETE delete 리소스를 삭제 REST API의 구성 자원(Resource), 행위(Verb), 표현(Representations)의 3가지 요소로 구성된다. REST는 자체 표현 구조(Self-descriptiveness)로 구성되어 REST API만으로 요청을 이해할 수 있다. 구성 요소 내용 표현 방법 Resource 자원 HTTP URI Verb 자원에 대한 행위 HTTP Method Representations 자원에 대한 행위의 내용 HTTP Message Pay Load REST API 예 json-server 폴더 만들고 접근 후 다음 명령을 사용하여 예습을 준비한다. 123$ mkdir rest-api-exam &amp;&amp; cd rest-api-exam$ npm init -y$ npm install json-server db.json 파일을 아래와 같이 생성한다. 1234567&#123; \"todos\": [ &#123; \"id\": 1, \"content\": \"HTML\", \"completed\": false &#125;, &#123; \"id\": 2, \"content\": \"CSS\", \"completed\": true &#125;, &#123; \"id\": 3, \"content\": \"Javascript\", \"completed\": false &#125; ]&#125; package.json 파일을 수정한다. 1234567891011&#123; \"name\": \"rest-api-exam\", \"version\": \"1.0.0\", \"description\": \"\", \"scripts\": &#123; \"start\": \"json-server --watch db.json --port 5000\" &#125;, \"dependencies\": &#123; \"json-server\": \"^0.15.0\" &#125;&#125; 실행은 $ npm start 명령을 이용하며 포트는 5000 이다. GET GET은 리소스를 조회, 검색 할 때 사용한다. todos 리소스에서 모든 todo를 조회(index)한다. GET 요청을 보낼떄마다 서버측에 로그가 뜬다. GET 요청을 RESTful 하게 하여 명사로 todos를 달라고 명시적으로 접근하였다. Script로 작성 12345678910111213const xhr = new XMLHttpRequest();xhr.open('GET', 'http://localhost:5000/todos/');xhr.send();xhr.onreadystatechange = function (e) &#123;if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; // 200: OK =&gt; https://httpstatuses.com console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; 특정 아이디만 선택이 가능하다. 123456$ curl -X GET http://localhost:5000/todos/1// &#123;// \"id\": 1,// \"content\": \"HTML\",// \"completed\": false// &#125; Script로 작성 12345678910111213const xhr = new XMLHttpRequest();xhr.open('GET', 'http://localhost:5000/todos/1');xhr.send();xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; POST POST 는 리소스를 생성할 때 사용한다. 123456$ curl -X POST http://localhost:5000/todos -H \"Content-Type: application/json\" -d '&#123;\"id\": 4, \"content\": \"Angular\", \"completed\": true&#125;'// &#123;// \"id\": 4,// \"content\": \"Angular\",// \"completed\": true// &#125; -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;id&quot;: 4, &quot;content&quot;: &quot;Angular&quot;, &quot;completed&quot;: true}&#39; 는 리소스를 생성하기 위한 명령어다. Script로 작성 1234567891011121314const xhr = new XMLHttpRequest();xhr.open('POST', 'http://localhost:5000/todos');xhr.setRequestHeader('Content-type', 'application/json');xhr.send(JSON.stringify(&#123; id: 4, content: 'Angular', completed: true &#125;));xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 201) &#123; // 201: Created console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; PUT PUT은 특정 리소스의 전체를 갱신할 때 사용한다. (Update)todos 리소스에서 id를 사용하여 todo를 특정하여 id를 제외한 리소스 전체를 갱신한다. 123456$ curl -X PUT http://localhost:5000/todos/4 -H \"Content-Type: application/json\" -d '&#123;\"id\": 4, \"content\": \"React\", \"completed\": false&#125;'// &#123;// \"content\": \"React\",// \"completed\": false,// \"id\": 4// &#125; “content”: “Angular” -&gt; “content”: “React”로 변경되었다. Script로 작성 1234567891011121314const xhr = new XMLHttpRequest();xhr.open('PUT', 'http://localhost:5000/todos/4');xhr.setRequestHeader('Content-type', 'application/json');xhr.send(JSON.stringify(&#123; id: 4, content: 'React', completed: false &#125;));xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; PATCH PATCH는 특정 리소스의 일부를 갱신할 때 사용한다.todos 리소스의 id를 사용하여 todo를 특정하여 completed만을 true로 갱신한다. 123456$ curl -X PATCH http://localhost:5000/todos/4 -H \"Content-Type: application/json\" -d '&#123;\"completed\": true&#125;'// &#123;// \"id\": 4,// \"content\": \"React\",// \"completed\": true// &#125; “completed”: false -&gt; “completed”: true 로 변경되었다. Script로 작성 1234567891011121314const xhr = new XMLHttpRequest();xhr.open('PATCH', 'http://localhost:5000/todos/4');xhr.setRequestHeader('Content-type', 'application/json');xhr.send(JSON.stringify(&#123; completed: true &#125;));xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; DELETE DELETE는 특정 리소스의 일부를 삭제할 때 사용한다.todos 리소스에서 id를 사용하여 todo를 특정하고 삭제한다. 12$ curl -X DELETE http://localhost:5000/todos/4// &#123;&#125; Script로 작성 12345678910111213const xhr = new XMLHttpRequest();xhr.open('DELETE', 'http://localhost:5000/todos/4');xhr.send();xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"REST API","slug":"REST-API","permalink":"https://hyeok999.github.io/tags/REST-API/"},{"name":"REST","slug":"REST","permalink":"https://hyeok999.github.io/tags/REST/"}]},{"title":"Ajax","slug":"Ajax","date":"2019-11-06T15:55:29.000Z","updated":"2019-11-30T17:10:06.402Z","comments":true,"path":"2019/11/07/Ajax/","link":"","permalink":"https://hyeok999.github.io/2019/11/07/Ajax/","excerpt":"","text":"JavaScript 비동기식 처리 모델과 Ajax 비동기식 처리 모델과 Ajax Ajax (Asynchronous JavaSriopt ans XML) JSON (JavaScript Object Notation) JSON.stringify JSON.parse XMLHttpRequest Ajax request XMLHttpRequest.open XMLHttpRequest.send XMLHttpRequest.setRequestHeader Content-type Accept Ajax response Web Server Ajax 예제 Load HTML Load JSON Load JSONP 동일출처원칙 우회 방법 3가지 비동기식 처리 모델과 Ajax Ajax (Asynchronous JavaSriopt ans XML)브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 갱신이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다. 서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS 나 JavaScript 파일들로 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일 혹은 서버 사이드 프로그램에서 만든 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다. Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다. 서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 하는 것이 Ajax이다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있다. JSON (JavaScript Object Notation) 클라이언트와 서버는 서로 간의 데이터 교환이 필요하다. JSON은 이러한 데이터교환을 위한 규칙 즉 데이터 포맷을 의미한다. JSON은 순수한 텍스트로 구성된 규칙이 있는 데이터 구조이다. 일반 텍스트 포맷보다는 효과적인 데이터 구조화가 가능하고 XML 포맷보다 가볍고 사용하기 간편하고 가독성도 좋다. 키는 반드시 큰따옴표(작은따옴표 사용불가)로 둘러싸야 한다. 123456&#123; \"name\": \"Lee\", \"gender\": \"male\", \"age\": 20, \"alive\": true&#125; JSON.stringify 객체를 JSON 형식의 문자열로 변환한다. 객체 -&gt; JSON 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const o = &#123; name: 'Lee', gender: 'male', age: 20 &#125;;// 객체 =&gt; JSON 형식의 문자열const strObject = JSON.stringify(o);console.log(typeof strObject, strObject);// string &#123;\"name\":\"Lee\",\"gender\":\"male\",\"age\":20&#125;// 객체 =&gt; JSON 형식의 문자열 + prettifyconst strPrettyObject = JSON.stringify(o, null, 2);console.log(typeof strPrettyObject, strPrettyObject);/*string &#123; \"name\": \"Lee\", \"gender\": \"male\", \"age\": 20&#125;*/// replacer// 값의 타입이 Number이면 필터링되어 반환되지 않는다.function filter(key, value) &#123; // undefined: 반환하지 않음 return typeof value === 'number' ? undefined : value;&#125;// 객체 =&gt; JSON 형식의 문자열 + replacer + prettifyconst strFilteredObject = JSON.stringify(o, filter, 2);console.log(typeof strFilteredObject, strFilteredObject);/*string &#123; \"name\": \"Lee\", \"gender\": \"male\"&#125;*/const arr = [1, 5, 'false'];// 배열 객체 =&gt; 문자열const strArray = JSON.stringify(arr); // \"[1, 5, 'false']\"console.log(typeof strArray, strArray); // string [1,5,\"false\"]// replacer// 모든 값을 대문자로 변환된 문자열을 반환한다function replaceToUpper(key, value) &#123; return value.toString().toUpperCase();&#125;// 배열 객체 =&gt; 문자열 + replacerconst strFilteredArray = JSON.stringify(arr, replaceToUpper);console.log(typeof strFilteredArray, strFilteredArray); // string \"1,5,FALSE\" JSON.parse JSON 데이터를 가진 문자열을 객체로 변환한다. JSON -&gt; 객체 : 역직렬화(Deserializing) 1234567891011121314151617181920const o = &#123; name: 'Lee', gender: 'male', age: 20 &#125;;// 객체 =&gt; JSON 형식의 문자열const strObject = JSON.stringify(o);console.log(typeof strObject, strObject);// string &#123;\"name\":\"Lee\",\"gender\":\"male\",\"age\":20&#125;const arr = [1, 5, 'false'];// 배열 객체 =&gt; JSON 문자열const strArray = JSON.stringify(arr);console.log(typeof strArray, strArray); // string [1,5,\"false\"]// JSON 형식의 문자열 =&gt; 객체const obj = JSON.parse(strObject);console.log(typeof obj, obj); // object &#123; name: 'Lee', gender: 'male' &#125;// JSON 문자열 =&gt; 배열 객체const objArray = JSON.parse(strArray);console.log(typeof objArray, objArray); // object [1, 5, \"false\"] 배열 내에 객체가 있는 경우 =&gt; 배열 자체를 문자열로 변환시킴 JSON 데이터를 가진 문자열을 배열로 바꿀 경우 =&gt; 배열의 요소까지 객체로 변환한다. 12345678910111213const todos = [ &#123; id: 1, content: 'HTML', completed: true &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'JavaScript', completed: false &#125;];// 배열 =&gt; JSON 형식의 문자열const str = JSON.stringify(todos);console.log(typeof str, str);// JSON 형식의 문자열 =&gt; 배열const parsed = JSON.parse(str);console.log(typeof parsed, parsed); XMLHttpRequest 브라우저는 XMLHttpRequest 객체를 이용하여 Ajax 요청을 생성하고 전송서버가 브라우저의 요청에 대해 응답을 반환하면 같은 XMLHttpRequest 객체가 그 결과를 처리한다. XMLHttpRequset 생성 : const 이름 = new XMLHttpRequest(); Ajax request Ajax 요청 처리 123456// XMLHttpRequest 객체의 생성const xhr = new XMLHttpRequest();// 비동기 방식으로 Request를 오픈한다xhr.open('GET', '/users');// Request를 전송한다xhr.send(); XMLHttpRequest.open XMLHttpRequest 객체의 인스턴스를 생성하고 서버로의 요청을 준비한다. 1XMLHttpRequest.open(method, url[, async]) 매개변수 설명 method HTTP method (“GET”, “POST”, “PUT”, “DELETE” 등) url 요청을 보낼 URL async 비동기 조작 여부. 옵션으로 default는 true이며 비동기 방식으로 동작. XMLHttpRequest.send 준비된 요청을 서버에 전달. (서버로 전송하는 데이터는 2가지 메소드에 따라 차이가 있다.) GET : URL의 일부분인 쿼리문자열(query string)로 데이터를 서버로 전송한다. POST : 데이터(페이로드)를 Request Body에 담아 전송한다. XMLHttpRequest.send 메소드에는 request body에 담아 전송할 인수를 전달할 수 있다. 12345xhr.send(null);// xhr.send('string');// xhr.send(new Blob()); // 파일 업로드와 같이 바이너리 컨텐트를 보내는 방법// xhr.send(&#123; form: 'data' &#125;);// xhr.send(document); 만약 요청 메소드가 GET인 경우, send 메소드의 인수는 무시되고 request body은 null로 설정된다. XMLHttpRequest.setRequestHeader HTTP Request Header의 값을 설정. setRequestHeader 메소드는 반드시 XMLHttpRequest.open 메소드 호출 이후에 호출한다. Content-type Content-type은 request body에 담아 전송할 데이터의 MIME-type의 정보를 표현한다. 자주 사용되는 MIME-type 타입 서브타입 text 타입 text/plain, text/html, text/css, text/javascript Application 타입 application/json, application/x-www-form-urlencode File을 업로드하기 위한 타입 multipart/formed-data 다음은 request body에 담아 서버로 전송할 데이터의 MIME-type을 지정하는 예이다. 12345678910111213141516171819202122// json으로 전송하는 경우xhr.open('POST', '/users');// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: jsonxhr.setRequestHeader('Content-type', 'application/json');const data = &#123; id: 3, title: 'JavaScript', author: 'Park', price: 5000&#125;;xhr.send(JSON.stringify(data));// x-www-form-urlencoded으로 전송하는 경우xhr2.open('POST', '/users');// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: x-www-form-urlencoded// application/x-www-form-urlencoded는 key=value&amp;key=value...의 형태로 전송xhr2.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');const data2 = &#123; title: 'JavaScript', author: 'Park', price: 5000&#125;;xhr2.send(Object.keys(data2).map(key =&gt; `$&#123;key&#125;=$&#123;data[key]&#125;`).join('&amp;'));// escaping untrusted data// xhr2.send(Object.keys(data2).map(key =&gt; `$&#123;key&#125;=$&#123;encodeURIComponent(data[key])&#125;`).join('&amp;')); Accept HTTP 클라이언트가 서버에 요청할 때 서버가 센드백할 데이터의 MIME-type을 Accept로 지정할 수 있다. 다음은 서버가 센드백할 데이터의 MIME-type을 지정하는 예 12// 서버가 센드백할 데이터의 MIME-type 지정: jsonxhr.setRequestHeader('Accept', 'application/json'); 만약 Accept 헤더를 설정하지 않으면, send 메소드가 호출될 때 Accept 헤더가 */*으로 전송됨. Ajax response 12345678910111213141516// XMLHttpRequest 객체의 생성const xhr = new XMLHttpRequest();// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 onreadystatechange 이벤트 핸들러가 호출된다.xhr.onreadystatechange = function (e) &#123; // readyStates는 XMLHttpRequest의 상태(state)를 반환 // readyState: 4 =&gt; DONE(서버 응답 완료) if (xhr.readyState !== XMLHttpRequest.DONE) return; // status는 response 상태 코드를 반환 : 200 =&gt; 정상 응답 if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('Error!'); &#125;&#125;; XMLHttpRequest.send()를 통해 서버에 Request를 전송하면 서버는 Response를 반환한다. 하지만 언제 Response가 클라이언트에 도달할 지는 알 수 없다. XMLHttpRequest.onreadystatechange는 Response가 클라이언트에 도달하여 발생된 이벤트를 감지하고 콜백 함수를 실행하여 준다. 이때 이벤트는 Request에 어떠한 변화가 발생한 경우 즉, XMLHttpRequest.readyState 프로퍼티가 변경된 경우 발생한다. XMLHttpRequest 객체는 response가 클라이언트에 도달했는지를 추적할 수 있는 프로퍼티를 제공한다. 이 프로퍼티가 XMLHttpRequest.readyState이다. 만일 XMLHttpRequest.readyState의 값이 4인 경우, 정상적으로 Response가 돌아온 경우이다. readXMLHttpRequest.readyState의 값은 아래와 같다. Value State Description 0 UNSENT XMLHttpRequest.open() 메소드 호출 이전 1 OPENED XMLHttpRequest.open() 메소드 호출 완료 2 HEADERS_RECEIVED XMLHttpRequest.send() 메소드 호출 완료 3 LOADING 서버 응답 중(XMLHttpRequest.responseText 미완성 상태) 4 DONE 서버 응답 완료 12345678910111213141516171819202122// XMLHttpRequest 객체의 생성var xhr = new XMLHttpRequest();// 비동기 방식으로 Request를 오픈한다xhr.open('GET', 'data/test.json');// Request를 전송한다xhr.send();// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 콜백함수(이벤트 핸들러)를 호출한다.xhr.onreadystatechange = function (e) &#123; // 이 함수는 Response가 클라이언트에 도달하면 호출된다. // readyStates는 XMLHttpRequest의 상태(state)를 반환 // readyState: 4 =&gt; DONE(서버 응답 완료) if (xhr.readyState !== XMLHttpRequest.DONE) return; // status는 response 상태 코드를 반환 : 200 =&gt; 정상 응답 if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('Error!'); &#125;&#125;; XMLHttpRequest의.readyState가 4인 경우, 서버 응답이 완료된 상태 이후 XMLHttpRequest.status가 200(정상 응답)임을 확인하고 정상이면, XMLHttpRequest.responseText를 취득. XMLHttpRequest.responseText에는 서버가 전송한 데이터가 담겨 있다. Web Server 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 프로그램. Ajax는 웹서버와의 통신이 필요하므로 예제를 실행하기 위해서는 웹서버가 필요하다. Ajax 예제 기본 셋팅 (Node.js - Express로 간단한 웹서버 생성) 구동 : http://localhost:3000/loadhtml.html 1234567891011## 데스크탑에 webserver-express 폴더가 생성된다.$ cd ~/Desktop$ git clone https://github.com/ungmo2/webserver-express.git$ cd webserver-express## install express$ npm install## create public folder$ mkdir public## start webserver$ npm start Load HTML Ajax를 이용하여 웹페이지에 추가하기 가장 손쉬운 데이터 형식 (HTML) 별도의 작업없이 전송받은 데이터를 DOM에 추가하면 된다. -클라이언트- 12345678910111213141516171819202122232425262728293031323334&lt;!-- 루트 폴더(webserver-express/public)/loadhtml.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 const xhr = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 xhr.open('GET', 'data/data.html'); // Request를 전송한다 xhr.send(); // Event Handler xhr.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status === 200) &#123; console.log(xhr.responseText); document.getElementById('content').innerHTML = xhr.responseText; &#125; else &#123; console.log(`[$&#123;xhr.status&#125;] : $&#123;xhr.statusText&#125;`); &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; -서버 응답 데이터- 123456789101112131415161718192021&lt;!-- 루트 폴더(webserver-express/public)/data/data.html --&gt;&lt;div id=\"tours\"&gt; &lt;h1&gt;Guided Tours&lt;/h1&gt; &lt;ul&gt; &lt;li class=\"usa tour\"&gt; &lt;h2&gt;New York, USA&lt;/h2&gt; &lt;span class=\"details\"&gt;$1,899 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;li class=\"europe tour\"&gt; &lt;h2&gt;Paris, France&lt;/h2&gt; &lt;span class=\"details\"&gt;$2,299 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;li class=\"asia tour\"&gt; &lt;h2&gt;Tokyo, Japan&lt;/h2&gt; &lt;span class=\"details\"&gt;$3,799 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; Load JSON 서버로부터 브라우저로 전송된 JSON 데이터는 문자열 문자열을 객체화하여야 하는데 이를 역직렬화(Deserializing)라 칭함. 역직렬화는 내장 객체 JSON의 static 메소드인 JSON.parse()를 사용. -클라이언트- 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 루트 폴더(webserver-express/public)/loadjson.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 var xhr = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 xhr.open('GET', 'data/data.json'); // Request를 전송한다 xhr.send(); xhr.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status === 200) &#123; console.log(xhr.responseText); // Deserializing (String → Object) responseObject = JSON.parse(xhr.responseText); // JSON → HTML String let newContent = '&lt;div id=\"tours\"&gt;&lt;h1&gt;Guided Tours&lt;/h1&gt;&lt;ul&gt;'; responseObject.tours.forEach(tour =&gt; &#123; newContent += `&lt;li class=\"$&#123;tour.region&#125; tour\"&gt; &lt;h2&gt;$&#123;tour.location&#125;&lt;/h2&gt; &lt;span class=\"details\"&gt;$&#123;tour.details&#125;&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt;`; &#125;); newContent += '&lt;/ul&gt;&lt;/div&gt;'; document.getElementById('content').innerHTML = newContent; &#125; else &#123; console.log(`[$&#123;xhr.status&#125;] : $&#123;xhr.statusText&#125;`); &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; -서버 응답 데이터- 12345678910111213141516171819&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ]&#125; Load JSONP 요청에 의해 웹페이작 전달된 서버와 동일한 도메인의 서버로부터 전달된 데이터는 이상이 없다. 하지만, 보안상의 이유로 다른 도메인(http와 https, 포트가 다르면 다른 도메인으로 간주)으로의 요청(크로스 도메인 요청)은 제한된다. 동일출처원칙(Same-origin policy)이라고 한다. 동일출처원칙 우회 방법 3가지 1. 웹서버의 프록시 파일 서버에 원격 서버로부터 데이터를 수집하는 별도의 기능을 추가하는 것이다. 이를 프록시(Proxy)라 한다. 2. JSONP script 태그의 원본 주소에 대한 제약은 존재하지 않는데 이것을 이용하여 다른 도메인의 서버에서 데이터를 수집하는 방법이다. 자신의 서버에 함수를 정의하고 다른 도메인의 서버에 얻고자 하는 데이터를 인수로 하는 함수 호출문을 로드하는 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 루트 폴더(webserver-express/public)/loadjsonp.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; function showTours(data) &#123; console.log(data); // data: object // JSON → HTML String let newContent = `&lt;div id=\"tours\"&gt; &lt;h1&gt;Guided Tours&lt;/h1&gt; &lt;ul&gt;`; data.tours.forEach(tour =&gt; &#123; newContent += `&lt;li class=\"$&#123;tour.region&#125; tour\"&gt; &lt;h2&gt;$&#123;tour.location&#125;&lt;/h2&gt; &lt;span class=\"details\"&gt;$&#123;tour.details&#125;&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt;`; &#125;); newContent += '&lt;/ul&gt;&lt;/div&gt;'; document.getElementById('content').innerHTML = newContent; &#125; &lt;/script&gt; &lt;script src='https://poiemaweb.com/assets/data/data-jsonp.js'&gt;&lt;/script&gt; &lt;!-- &lt;script&gt; showTours(&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ] &#125;); &lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122&lt;script src='https://poiemaweb.com/assets/data/data-jsonp.js'&gt;&lt;/script&gt; &lt;!-- &lt;script&gt; showTours(&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ] &#125;); &lt;/script&gt; --&gt; 서버에는 showTour()이라는 함수를 정의하고 타 도메인에서 얻고자하는 데이터를 인수로하여 호출문으로 로드했다. 3. Cross-Origin Resource Sharing HTTP 헤더에 추가적으로 정보를 추가하여 브라우저와 서버가 서로 통신해야 한다는 사실을 알게하는 방법 W3C 명세에 포함되어 있지만 최신 브라우저에서만 동작하며 서버에 HTTP 헤더를 설정해 주어야 한다. Node.js로 구현한 서버의 경우, CORS package를 사용하면 간단하게 Cross-Origin Resource Sharing을 구현가능. 12345678910111213const express = require('express')const cors = require('cors')const app = express()app.use(cors())app.get('/products/:id', function (req, res, next) &#123; res.json(&#123;msg: 'This is CORS-enabled for all origins!'&#125;)&#125;)app.listen(80, function () &#123; console.log('CORS-enabled web server listening on port 80')&#125;)","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"Ajax","slug":"Ajax","permalink":"https://hyeok999.github.io/tags/Ajax/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_quiz33","slug":"daily-quiz33","date":"2019-11-06T07:23:01.000Z","updated":"2019-11-30T17:11:46.314Z","comments":true,"path":"2019/11/06/daily-quiz33/","link":"","permalink":"https://hyeok999.github.io/2019/11/06/daily-quiz33/","excerpt":"","text":"문제 출처 : poiema Counter 요구 사항 최소값은 0이다. 즉, 0과 양수만으로 카운트한다. 클로저로 구현한다. 1. 함수 자체를 리턴하고 함수를 받아와서 출력하는 방법12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Counter&lt;/title&gt; &lt;style&gt; .container &#123; display: flex; justify-content: space-between; align-items: center; width: 130px; margin: 20px auto; font-size: 24px; color: #3f51b5; &#125; button &#123; padding: 5px 10px; font-size: 24px; border-radius: 5px; color: #3f51b5; border-color: #3f51b5; outline: none; cursor: pointer; &#125; .counter &#123; width: 50px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;div class=\"counter\"&gt;0&lt;/div&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const $increase = document.querySelector('.increase'); const $decrease = document.querySelector('.decrease'); const Counter = (function () &#123; let count = 0; return function (fr) &#123; count = fr(count); $counter.textContent = count; &#125;; &#125;()); const increase = (n) =&gt; ++n; const decrease = (n) =&gt; &#123; if (n == 0) return 0; return --n; &#125;; $increase.onclick = () =&gt; Counter(increase); $decrease.onclick = () =&gt; Counter(decrease); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 생성자 함수로 만들고 생성자함수 객체 프로토타입의 메소드를 호출하는 방법12345678910111213141516171819202122232425262728293031const $counter = document.querySelector('.counter');const $increase = document.querySelector('.increase');const $decrease = document.querySelector('.decrease');const Counter = (function () &#123; let count = 0; function Counters() &#123; &#125; Counters.prototype.increase = function () &#123; $counter.textContent = count++; &#125;; Counters.prototype.decrease = function () &#123; if (count == 0) return; $counter.textContent = --count; &#125;; return Counters;&#125;());const counts = new Counter();$increase.onclick = () =&gt; &#123; counts.increase();&#125;;$decrease.onclick = () =&gt; &#123; counts.decrease();&#125;; 객체(증가함수, 감소함수)를 리턴하는 방법123456789101112131415161718192021const $counter = document.querySelector('.counter');const $increase = document.querySelector('.increase');const $decrease = document.querySelector('.decrease');const Counter = (function () &#123; let count = 0; return &#123; increase() &#123; $counter.textContent = ++count; &#125;, decrease() &#123; if (count == 0) return; $counter.textContent = --count; &#125; &#125;;&#125;());$increase.onclick = () =&gt; Counter.increase();$decrease.onclick = () =&gt; Counter.decrease();","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"},{"name":"Quiz","slug":"Quiz","permalink":"https://hyeok999.github.io/tags/Quiz/"}]},{"title":"javascript 34강(M)~35강(M)(Ajax, Rest Api)","slug":"javascript-preview-34m35m","date":"2019-11-05T15:50:27.000Z","updated":"2019-11-30T17:03:40.631Z","comments":true,"path":"2019/11/06/javascript-preview-34m35m/","link":"","permalink":"https://hyeok999.github.io/2019/11/06/javascript-preview-34m35m/","excerpt":"","text":"JavaScript 34강m ~ 35강m 예습 34 : 비동기식 처리 모델과 Ajax Ajax (Asynchronous JavaSriopt ans XML) JSON (JavaScript Object Notation) JSON.stringify JSON.parse XMLHttpRequest Ajax request XMLHttpRequest.open XMLHttpRequest.send XMLHttpRequest.setRequestHeader Content-type Accept Ajax response Web Server Ajax 예제 Load HTML Load JSON Load JSONP 동일출처원칙 우회 방법 3가지 35 : REST(Representational State Transfer) API REST API 중심 규칙 URI는 정보의 자원을 표현 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현 HTTP Method REST API의 구성 REST API 예 json-server GET 특정 아이디만 선택이 가능하다. POST PUT PATCH DELETE 34강비동기식 처리 모델과 Ajax Ajax (Asynchronous JavaSriopt ans XML)브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 갱신이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다. 서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS 나 JavaScript 파일들로 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일 혹은 서버 사이드 프로그램에서 만든 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다. Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다. 서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 하는 것이 Ajax이다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있다. JSON (JavaScript Object Notation) 클라이언트와 서버는 서로 간의 데이터 교환이 필요하다. JSON은 이러한 데이터교환을 위한 규칙 즉 데이터 포맷을 의미한다. JSON은 순수한 텍스트로 구성된 규칙이 있는 데이터 구조이다. 일반 텍스트 포맷보다는 효과적인 데이터 구조화가 가능하고 XML 포맷보다 가볍고 사용하기 간편하고 가독성도 좋다. 키는 반드시 큰따옴표(작은따옴표 사용불가)로 둘러싸야 한다. 123456&#123; \"name\": \"Lee\", \"gender\": \"male\", \"age\": 20, \"alive\": true&#125; JSON.stringify 객체를 JSON 형식의 문자열로 변환한다. 객체 -&gt; JSON 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const o = &#123; name: 'Lee', gender: 'male', age: 20 &#125;;// 객체 =&gt; JSON 형식의 문자열const strObject = JSON.stringify(o);console.log(typeof strObject, strObject);// string &#123;\"name\":\"Lee\",\"gender\":\"male\",\"age\":20&#125;// 객체 =&gt; JSON 형식의 문자열 + prettifyconst strPrettyObject = JSON.stringify(o, null, 2);console.log(typeof strPrettyObject, strPrettyObject);/*string &#123; \"name\": \"Lee\", \"gender\": \"male\", \"age\": 20&#125;*/// replacer// 값의 타입이 Number이면 필터링되어 반환되지 않는다.function filter(key, value) &#123; // undefined: 반환하지 않음 return typeof value === 'number' ? undefined : value;&#125;// 객체 =&gt; JSON 형식의 문자열 + replacer + prettifyconst strFilteredObject = JSON.stringify(o, filter, 2);console.log(typeof strFilteredObject, strFilteredObject);/*string &#123; \"name\": \"Lee\", \"gender\": \"male\"&#125;*/const arr = [1, 5, 'false'];// 배열 객체 =&gt; 문자열const strArray = JSON.stringify(arr); // \"[1, 5, 'false']\"console.log(typeof strArray, strArray); // string [1,5,\"false\"]// replacer// 모든 값을 대문자로 변환된 문자열을 반환한다function replaceToUpper(key, value) &#123; return value.toString().toUpperCase();&#125;// 배열 객체 =&gt; 문자열 + replacerconst strFilteredArray = JSON.stringify(arr, replaceToUpper);console.log(typeof strFilteredArray, strFilteredArray); // string \"1,5,FALSE\" JSON.parse JSON 데이터를 가진 문자열을 객체로 변환한다. JSON -&gt; 객체 : 역직렬화(Deserializing) 1234567891011121314151617181920const o = &#123; name: 'Lee', gender: 'male', age: 20 &#125;;// 객체 =&gt; JSON 형식의 문자열const strObject = JSON.stringify(o);console.log(typeof strObject, strObject);// string &#123;\"name\":\"Lee\",\"gender\":\"male\",\"age\":20&#125;const arr = [1, 5, 'false'];// 배열 객체 =&gt; JSON 문자열const strArray = JSON.stringify(arr);console.log(typeof strArray, strArray); // string [1,5,\"false\"]// JSON 형식의 문자열 =&gt; 객체const obj = JSON.parse(strObject);console.log(typeof obj, obj); // object &#123; name: 'Lee', gender: 'male' &#125;// JSON 문자열 =&gt; 배열 객체const objArray = JSON.parse(strArray);console.log(typeof objArray, objArray); // object [1, 5, \"false\"] 배열 내에 객체가 있는 경우 =&gt; 배열 자체를 문자열로 변환시킴 JSON 데이터를 가진 문자열을 배열로 바꿀 경우 =&gt; 배열의 요소까지 객체로 변환한다. 12345678910111213const todos = [ &#123; id: 1, content: 'HTML', completed: true &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'JavaScript', completed: false &#125;];// 배열 =&gt; JSON 형식의 문자열const str = JSON.stringify(todos);console.log(typeof str, str);// JSON 형식의 문자열 =&gt; 배열const parsed = JSON.parse(str);console.log(typeof parsed, parsed); XMLHttpRequest 브라우저는 XMLHttpRequest 객체를 이용하여 Ajax 요청을 생성하고 전송서버가 브라우저의 요청에 대해 응답을 반환하면 같은 XMLHttpRequest 객체가 그 결과를 처리한다. XMLHttpRequset 생성 : const 이름 = new XMLHttpRequest(); Ajax request Ajax 요청 처리 123456// XMLHttpRequest 객체의 생성const xhr = new XMLHttpRequest();// 비동기 방식으로 Request를 오픈한다xhr.open('GET', '/users');// Request를 전송한다xhr.send(); XMLHttpRequest.open XMLHttpRequest 객체의 인스턴스를 생성하고 서버로의 요청을 준비한다. 1XMLHttpRequest.open(method, url[, async]) 매개변수 설명 method HTTP method (“GET”, “POST”, “PUT”, “DELETE” 등) url 요청을 보낼 URL async 비동기 조작 여부. 옵션으로 default는 true이며 비동기 방식으로 동작. XMLHttpRequest.send 준비된 요청을 서버에 전달. (서버로 전송하는 데이터는 2가지 메소드에 따라 차이가 있다.) GET : URL의 일부분인 쿼리문자열(query string)로 데이터를 서버로 전송한다. POST : 데이터(페이로드)를 Request Body에 담아 전송한다. XMLHttpRequest.send 메소드에는 request body에 담아 전송할 인수를 전달할 수 있다. 12345xhr.send(null);// xhr.send('string');// xhr.send(new Blob()); // 파일 업로드와 같이 바이너리 컨텐트를 보내는 방법// xhr.send(&#123; form: 'data' &#125;);// xhr.send(document); 만약 요청 메소드가 GET인 경우, send 메소드의 인수는 무시되고 request body은 null로 설정된다. XMLHttpRequest.setRequestHeader HTTP Request Header의 값을 설정. setRequestHeader 메소드는 반드시 XMLHttpRequest.open 메소드 호출 이후에 호출한다. Content-type Content-type은 request body에 담아 전송할 데이터의 MIME-type의 정보를 표현한다. 자주 사용되는 MIME-type 타입 서브타입 text 타입 text/plain, text/html, text/css, text/javascript Application 타입 application/json, application/x-www-form-urlencode File을 업로드하기 위한 타입 multipart/formed-data 다음은 request body에 담아 서버로 전송할 데이터의 MIME-type을 지정하는 예이다. 12345678910111213141516171819202122// json으로 전송하는 경우xhr.open('POST', '/users');// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: jsonxhr.setRequestHeader('Content-type', 'application/json');const data = &#123; id: 3, title: 'JavaScript', author: 'Park', price: 5000&#125;;xhr.send(JSON.stringify(data));// x-www-form-urlencoded으로 전송하는 경우xhr2.open('POST', '/users');// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: x-www-form-urlencoded// application/x-www-form-urlencoded는 key=value&amp;key=value...의 형태로 전송xhr2.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');const data2 = &#123; title: 'JavaScript', author: 'Park', price: 5000&#125;;xhr2.send(Object.keys(data2).map(key =&gt; `$&#123;key&#125;=$&#123;data[key]&#125;`).join('&amp;'));// escaping untrusted data// xhr2.send(Object.keys(data2).map(key =&gt; `$&#123;key&#125;=$&#123;encodeURIComponent(data[key])&#125;`).join('&amp;')); Accept HTTP 클라이언트가 서버에 요청할 때 서버가 센드백할 데이터의 MIME-type을 Accept로 지정할 수 있다. 다음은 서버가 센드백할 데이터의 MIME-type을 지정하는 예 12// 서버가 센드백할 데이터의 MIME-type 지정: jsonxhr.setRequestHeader('Accept', 'application/json'); 만약 Accept 헤더를 설정하지 않으면, send 메소드가 호출될 때 Accept 헤더가 */*으로 전송됨. Ajax response 12345678910111213141516// XMLHttpRequest 객체의 생성const xhr = new XMLHttpRequest();// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 onreadystatechange 이벤트 핸들러가 호출된다.xhr.onreadystatechange = function (e) &#123; // readyStates는 XMLHttpRequest의 상태(state)를 반환 // readyState: 4 =&gt; DONE(서버 응답 완료) if (xhr.readyState !== XMLHttpRequest.DONE) return; // status는 response 상태 코드를 반환 : 200 =&gt; 정상 응답 if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('Error!'); &#125;&#125;; XMLHttpRequest.send()를 통해 서버에 Request를 전송하면 서버는 Response를 반환한다. 하지만 언제 Response가 클라이언트에 도달할 지는 알 수 없다. XMLHttpRequest.onreadystatechange는 Response가 클라이언트에 도달하여 발생된 이벤트를 감지하고 콜백 함수를 실행하여 준다. 이때 이벤트는 Request에 어떠한 변화가 발생한 경우 즉, XMLHttpRequest.readyState 프로퍼티가 변경된 경우 발생한다. XMLHttpRequest 객체는 response가 클라이언트에 도달했는지를 추적할 수 있는 프로퍼티를 제공한다. 이 프로퍼티가 XMLHttpRequest.readyState이다. 만일 XMLHttpRequest.readyState의 값이 4인 경우, 정상적으로 Response가 돌아온 경우이다. readXMLHttpRequest.readyState의 값은 아래와 같다. Value State Description 0 UNSENT XMLHttpRequest.open() 메소드 호출 이전 1 OPENED XMLHttpRequest.open() 메소드 호출 완료 2 HEADERS_RECEIVED XMLHttpRequest.send() 메소드 호출 완료 3 LOADING 서버 응답 중(XMLHttpRequest.responseText 미완성 상태) 4 DONE 서버 응답 완료 12345678910111213141516171819202122// XMLHttpRequest 객체의 생성var xhr = new XMLHttpRequest();// 비동기 방식으로 Request를 오픈한다xhr.open('GET', 'data/test.json');// Request를 전송한다xhr.send();// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 콜백함수(이벤트 핸들러)를 호출한다.xhr.onreadystatechange = function (e) &#123; // 이 함수는 Response가 클라이언트에 도달하면 호출된다. // readyStates는 XMLHttpRequest의 상태(state)를 반환 // readyState: 4 =&gt; DONE(서버 응답 완료) if (xhr.readyState !== XMLHttpRequest.DONE) return; // status는 response 상태 코드를 반환 : 200 =&gt; 정상 응답 if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('Error!'); &#125;&#125;; XMLHttpRequest의.readyState가 4인 경우, 서버 응답이 완료된 상태 이후 XMLHttpRequest.status가 200(정상 응답)임을 확인하고 정상이면, XMLHttpRequest.responseText를 취득. XMLHttpRequest.responseText에는 서버가 전송한 데이터가 담겨 있다. Web Server 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 프로그램. Ajax는 웹서버와의 통신이 필요하므로 예제를 실행하기 위해서는 웹서버가 필요하다. Ajax 예제 기본 셋팅 (Node.js - Express로 간단한 웹서버 생성) 구동 : http://localhost:3000/loadhtml.html 1234567891011## 데스크탑에 webserver-express 폴더가 생성된다.$ cd ~/Desktop$ git clone https://github.com/ungmo2/webserver-express.git$ cd webserver-express## install express$ npm install## create public folder$ mkdir public## start webserver$ npm start Load HTML Ajax를 이용하여 웹페이지에 추가하기 가장 손쉬운 데이터 형식 (HTML) 별도의 작업없이 전송받은 데이터를 DOM에 추가하면 된다. -클라이언트- 12345678910111213141516171819202122232425262728293031323334&lt;!-- 루트 폴더(webserver-express/public)/loadhtml.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 const xhr = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 xhr.open('GET', 'data/data.html'); // Request를 전송한다 xhr.send(); // Event Handler xhr.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status === 200) &#123; console.log(xhr.responseText); document.getElementById('content').innerHTML = xhr.responseText; &#125; else &#123; console.log(`[$&#123;xhr.status&#125;] : $&#123;xhr.statusText&#125;`); &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; -서버 응답 데이터- 123456789101112131415161718192021&lt;!-- 루트 폴더(webserver-express/public)/data/data.html --&gt;&lt;div id=\"tours\"&gt; &lt;h1&gt;Guided Tours&lt;/h1&gt; &lt;ul&gt; &lt;li class=\"usa tour\"&gt; &lt;h2&gt;New York, USA&lt;/h2&gt; &lt;span class=\"details\"&gt;$1,899 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;li class=\"europe tour\"&gt; &lt;h2&gt;Paris, France&lt;/h2&gt; &lt;span class=\"details\"&gt;$2,299 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;li class=\"asia tour\"&gt; &lt;h2&gt;Tokyo, Japan&lt;/h2&gt; &lt;span class=\"details\"&gt;$3,799 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; Load JSON 서버로부터 브라우저로 전송된 JSON 데이터는 문자열 문자열을 객체화하여야 하는데 이를 역직렬화(Deserializing)라 칭함. 역직렬화는 내장 객체 JSON의 static 메소드인 JSON.parse()를 사용. -클라이언트- 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 루트 폴더(webserver-express/public)/loadjson.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 var xhr = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 xhr.open('GET', 'data/data.json'); // Request를 전송한다 xhr.send(); xhr.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status === 200) &#123; console.log(xhr.responseText); // Deserializing (String → Object) responseObject = JSON.parse(xhr.responseText); // JSON → HTML String let newContent = '&lt;div id=\"tours\"&gt;&lt;h1&gt;Guided Tours&lt;/h1&gt;&lt;ul&gt;'; responseObject.tours.forEach(tour =&gt; &#123; newContent += `&lt;li class=\"$&#123;tour.region&#125; tour\"&gt; &lt;h2&gt;$&#123;tour.location&#125;&lt;/h2&gt; &lt;span class=\"details\"&gt;$&#123;tour.details&#125;&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt;`; &#125;); newContent += '&lt;/ul&gt;&lt;/div&gt;'; document.getElementById('content').innerHTML = newContent; &#125; else &#123; console.log(`[$&#123;xhr.status&#125;] : $&#123;xhr.statusText&#125;`); &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; -서버 응답 데이터- 12345678910111213141516171819&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ]&#125; Load JSONP 요청에 의해 웹페이작 전달된 서버와 동일한 도메인의 서버로부터 전달된 데이터는 이상이 없다. 하지만, 보안상의 이유로 다른 도메인(http와 https, 포트가 다르면 다른 도메인으로 간주)으로의 요청(크로스 도메인 요청)은 제한된다. 동일출처원칙(Same-origin policy)이라고 한다. 동일출처원칙 우회 방법 3가지 1. 웹서버의 프록시 파일 서버에 원격 서버로부터 데이터를 수집하는 별도의 기능을 추가하는 것이다. 이를 프록시(Proxy)라 한다. 2. JSONP script 태그의 원본 주소에 대한 제약은 존재하지 않는데 이것을 이용하여 다른 도메인의 서버에서 데이터를 수집하는 방법이다. 자신의 서버에 함수를 정의하고 다른 도메인의 서버에 얻고자 하는 데이터를 인수로 하는 함수 호출문을 로드하는 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 루트 폴더(webserver-express/public)/loadjsonp.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; function showTours(data) &#123; console.log(data); // data: object // JSON → HTML String let newContent = `&lt;div id=\"tours\"&gt; &lt;h1&gt;Guided Tours&lt;/h1&gt; &lt;ul&gt;`; data.tours.forEach(tour =&gt; &#123; newContent += `&lt;li class=\"$&#123;tour.region&#125; tour\"&gt; &lt;h2&gt;$&#123;tour.location&#125;&lt;/h2&gt; &lt;span class=\"details\"&gt;$&#123;tour.details&#125;&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt;`; &#125;); newContent += '&lt;/ul&gt;&lt;/div&gt;'; document.getElementById('content').innerHTML = newContent; &#125; &lt;/script&gt; &lt;script src='https://poiemaweb.com/assets/data/data-jsonp.js'&gt;&lt;/script&gt; &lt;!-- &lt;script&gt; showTours(&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ] &#125;); &lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122&lt;script src='https://poiemaweb.com/assets/data/data-jsonp.js'&gt;&lt;/script&gt; &lt;!-- &lt;script&gt; showTours(&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ] &#125;); &lt;/script&gt; --&gt; 서버에는 showTour()이라는 함수를 정의하고 타 도메인에서 얻고자하는 데이터를 인수로하여 호출문으로 로드했다. 3. Cross-Origin Resource Sharing HTTP 헤더에 추가적으로 정보를 추가하여 브라우저와 서버가 서로 통신해야 한다는 사실을 알게하는 방법 W3C 명세에 포함되어 있지만 최신 브라우저에서만 동작하며 서버에 HTTP 헤더를 설정해 주어야 한다. Node.js로 구현한 서버의 경우, CORS package를 사용하면 간단하게 Cross-Origin Resource Sharing을 구현가능. 12345678910111213const express = require('express')const cors = require('cors')const app = express()app.use(cors())app.get('/products/:id', function (req, res, next) &#123; res.json(&#123;msg: 'This is CORS-enabled for all origins!'&#125;)&#125;)app.listen(80, function () &#123; console.log('CORS-enabled web server listening on port 80')&#125;) 35강REST(Representational State Transfer) APIREST의 기본 원칙을 성실히 지킨 서비스 디자인을 “RESTful”이라고 표현한다. REST API 중심 규칙 URI는 자원을 표현하는데 집중 HTTP Method는 행위에 대한 정의에 집중 1. URI는 정보의 자원을 표현 리소스명은 명사위주로 작성한다. ( 동사x , 명사o ) get같은 행위에 대한 표현이 들어가는 것은 좋지 않다. 123456# badGET /getTodos/1GET /todos/show/1# goodGET /todos/1 2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현 12345# badGET /todos/delete/1# goodDELETE /todos/1 HTTP Method 주로 5가지의 Method(GET, POST, PUT, PATCH, DELETE)를 사용하여 CRUD를 구현한다.(CRUD : Create, Read, Update, Delete) Method Action 역할 GET index/retrieve 모든/특정 리소스를 조회 POST create 리소스를 생성 PUT update all 리소스의 전체를 갱신 PATCH update 리소스의 일부를 갱신 DELETE delete 리소스를 삭제 REST API의 구성 자원(Resource), 행위(Verb), 표현(Representations)의 3가지 요소로 구성된다. REST는 자체 표현 구조(Self-descriptiveness)로 구성되어 REST API만으로 요청을 이해할 수 있다. 구성 요소 내용 표현 방법 Resource 자원 HTTP URI Verb 자원에 대한 행위 HTTP Method Representations 자원에 대한 행위의 내용 HTTP Message Pay Load REST API 예 json-server 폴더 만들고 접근 후 다음 명령을 사용하여 예습을 준비한다. 123$ mkdir rest-api-exam &amp;&amp; cd rest-api-exam$ npm init -y$ npm install json-server db.json 파일을 아래와 같이 생성한다. 1234567&#123; \"todos\": [ &#123; \"id\": 1, \"content\": \"HTML\", \"completed\": false &#125;, &#123; \"id\": 2, \"content\": \"CSS\", \"completed\": true &#125;, &#123; \"id\": 3, \"content\": \"Javascript\", \"completed\": false &#125; ]&#125; package.json 파일을 수정한다. 1234567891011&#123; \"name\": \"rest-api-exam\", \"version\": \"1.0.0\", \"description\": \"\", \"scripts\": &#123; \"start\": \"json-server --watch db.json --port 5000\" &#125;, \"dependencies\": &#123; \"json-server\": \"^0.15.0\" &#125;&#125; 실행은 $ npm start 명령을 이용하며 포트는 5000 이다. GET GET은 리소스를 조회, 검색 할 때 사용한다. todos 리소스에서 모든 todo를 조회(index)한다. GET 요청을 보낼떄마다 서버측에 로그가 뜬다. GET 요청을 RESTful 하게 하여 명사로 todos를 달라고 명시적으로 접근하였다. Script로 작성 12345678910111213const xhr = new XMLHttpRequest();xhr.open('GET', 'http://localhost:5000/todos/');xhr.send();xhr.onreadystatechange = function (e) &#123;if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; // 200: OK =&gt; https://httpstatuses.com console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; 특정 아이디만 선택이 가능하다. 123456$ curl -X GET http://localhost:5000/todos/1// &#123;// \"id\": 1,// \"content\": \"HTML\",// \"completed\": false// &#125; Script로 작성 12345678910111213const xhr = new XMLHttpRequest();xhr.open('GET', 'http://localhost:5000/todos/1');xhr.send();xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; POST POST 는 리소스를 생성할 때 사용한다. 123456$ curl -X POST http://localhost:5000/todos -H \"Content-Type: application/json\" -d '&#123;\"id\": 4, \"content\": \"Angular\", \"completed\": true&#125;'// &#123;// \"id\": 4,// \"content\": \"Angular\",// \"completed\": true// &#125; -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;id&quot;: 4, &quot;content&quot;: &quot;Angular&quot;, &quot;completed&quot;: true}&#39; 는 리소스를 생성하기 위한 명령어다. Script로 작성 1234567891011121314const xhr = new XMLHttpRequest();xhr.open('POST', 'http://localhost:5000/todos');xhr.setRequestHeader('Content-type', 'application/json');xhr.send(JSON.stringify(&#123; id: 4, content: 'Angular', completed: true &#125;));xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 201) &#123; // 201: Created console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; PUT PUT은 특정 리소스의 전체를 갱신할 때 사용한다. (Update)todos 리소스에서 id를 사용하여 todo를 특정하여 id를 제외한 리소스 전체를 갱신한다. 123456$ curl -X PUT http://localhost:5000/todos/4 -H \"Content-Type: application/json\" -d '&#123;\"id\": 4, \"content\": \"React\", \"completed\": false&#125;'// &#123;// \"content\": \"React\",// \"completed\": false,// \"id\": 4// &#125; “content”: “Angular” -&gt; “content”: “React”로 변경되었다. Script로 작성 1234567891011121314const xhr = new XMLHttpRequest();xhr.open('PUT', 'http://localhost:5000/todos/4');xhr.setRequestHeader('Content-type', 'application/json');xhr.send(JSON.stringify(&#123; id: 4, content: 'React', completed: false &#125;));xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; PATCH PATCH는 특정 리소스의 일부를 갱신할 때 사용한다.todos 리소스의 id를 사용하여 todo를 특정하여 completed만을 true로 갱신한다. 123456$ curl -X PATCH http://localhost:5000/todos/4 -H \"Content-Type: application/json\" -d '&#123;\"completed\": true&#125;'// &#123;// \"id\": 4,// \"content\": \"React\",// \"completed\": true// &#125; “completed”: false -&gt; “completed”: true 로 변경되었다. Script로 작성 1234567891011121314const xhr = new XMLHttpRequest();xhr.open('PATCH', 'http://localhost:5000/todos/4');xhr.setRequestHeader('Content-type', 'application/json');xhr.send(JSON.stringify(&#123; completed: true &#125;));xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;; DELETE DELETE는 특정 리소스의 일부를 삭제할 때 사용한다.todos 리소스에서 id를 사용하여 todo를 특정하고 삭제한다. 12$ curl -X DELETE http://localhost:5000/todos/4// &#123;&#125; Script로 작성 12345678910111213const xhr = new XMLHttpRequest();xhr.open('DELETE', 'http://localhost:5000/todos/4');xhr.send();xhr.onreadystatechange = function (e) &#123; if (xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Error!\"); &#125;&#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"Ajax","slug":"Ajax","permalink":"https://hyeok999.github.io/tags/Ajax/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"REST","slug":"REST","permalink":"https://hyeok999.github.io/tags/REST/"}]},{"title":"daily_quiz32","slug":"daily-quiz32","date":"2019-11-05T14:49:58.000Z","updated":"2019-11-30T17:11:51.551Z","comments":true,"path":"2019/11/05/daily-quiz32/","link":"","permalink":"https://hyeok999.github.io/2019/11/05/daily-quiz32/","excerpt":"","text":"문제 출처 : poiema Toggle side nav 요구 사항 자바스크립트를 사용하여 버튼이 클릭되었을 때 사이드 내비게이션이 토글되도록 구현한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Toggle side nav&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.7.2/css/all.css\"&gt; &lt;style&gt; html, body &#123; height: 100%; margin: 0; &#125; .container &#123; position: relative; overflow-x: hidden; /* 가로 scroll bar 방지 */ width: 100%; height: 100%; &#125; .main, .side-nav &#123; position: absolute; top: 0; height: 100%; transition: transform 0.8s; &#125; .main &#123; left: 0; width: 100%; background: antiquewhite; &#125; .side-nav &#123; left: -300px; width: 300px; background: rebeccapurple; &#125; .active &gt; .main, .active &gt; .side-nav &#123; transform: translate3d(300px, 0, 0); &#125; .toggle &#123; font-size: 2em; color: maroon; margin: 10px; cursor: pointer; transition: transform 0.5s; &#125; .active .toggle &#123; transform: rotate(180deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"side-nav\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt; &lt;i class=\"toggle fas fa-arrow-circle-right\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; const $toggle = document.querySelector('.toggle'); const $container = document.querySelector('.container'); $toggle.onclick = () =&gt; &#123; $container.classList.toggle('active'); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Scrolling goto top Window.pageYOffset Window.scrollTo() Window.scroll() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;scrolling-goto-top&lt;/title&gt; &lt;style&gt; @import url(https://fonts.googleapis.com/css?family=Open+Sans:300,400); @import url(https://use.fontawesome.com/releases/v5.5.0/css/all.css); body &#123; font-family: 'Open Sans'; font-weight: 300; background-color: #D6E1E5; &#125; h1 &#123; color: #DB5B33; font-weight: 300; text-align: center; &#125; .scoll-icon &#123; position: fixed; left: 50%; bottom: 20px; font-size: 36px; cursor: pointer; animation: glow 4s infinite; display: none; &#125; @keyframes glow &#123; 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 0.3; transform: translateY(10px); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;JavaScript Scrolling goto top&lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Minus, repudiandae quia. Veniam amet fuga, eveniet velit ipsa repudiandae nemo? Sit dolorem itaque laudantium dignissimos, rerum maiores nihil ad voluptates nostrum. &lt;/p&gt; &lt;div class=\"scoll-icon fa fa-angle-double-up\"&gt;&lt;/div&gt; &lt;script&gt; const $scollIcon = document.querySelector('.scoll-icon'); window.onscroll = () =&gt; &#123; $scollIcon.style.display = window.pageYOffset &gt; 200 ? 'inline' : 'none'; &#125;; $scollIcon.onclick = () =&gt; &#123; window.scroll(&#123; top: 0, left: 0, behavior: 'smooth' &#125;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"},{"name":"Quiz","slug":"Quiz","permalink":"https://hyeok999.github.io/tags/Quiz/"}]},{"title":"javascript-study-22[TodoApp 풀버전]","slug":"javascript-study-22","date":"2019-11-05T14:34:54.000Z","updated":"2019-11-30T16:59:50.660Z","comments":true,"path":"2019/11/05/javascript-study-22/","link":"","permalink":"https://hyeok999.github.io/2019/11/05/javascript-study-22/","excerpt":"","text":"JavaScript Study 22TODO-LIST Todo List V.02 풀이 버전123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142let todos = [];let navId = 'all';const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $completeAll = document.querySelector('.complete-all');const $nav = document.querySelector('.nav');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');// 데이터 받아오기function getTodos() &#123; todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ]; todos.sort((todo1, todo2) =&gt; todo2.id - todo1.id);&#125;// function separateTab() &#123;// if (navId === 'all') return;// if (navId === 'active') &#123;// todos = todos.filter((todo) =&gt; (!todo.completed));// &#125; else &#123;// todos = todos.filter((todo) =&gt; (todo.completed));// &#125;// &#125;function findMaxId() &#123; return Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;&#125;function completedCount() &#123; return todos.filter((todo) =&gt; todo.completed).length;&#125;function activeCount() &#123; return todos.filter((todo) =&gt; !todo.completed).length;&#125;// 렌더링function render() &#123; // const tempTodos = [...todos]; // separateTab(); const tempTodos = todos.filter((&#123; completed &#125;) =&gt; (navId === 'all' ? true : navId === 'active' ? !completed : completed)); let html = ''; tempTodos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;`; &#125;); $todos.innerHTML = html; $completedTodos.textContent = completedCount(); $activeTodos.textContent = activeCount(); // todos = tempTodos;&#125;// 기능function addTodo(content) &#123; todos = [&#123; id: findMaxId(), content, completed: false &#125;, ...todos]; console.log('[addTodo] : ', todos);&#125;function removeTodo(id) &#123; todos = todos.filter((todo) =&gt; todo.id !== id); console.log('[removeTodo] : ', todos);&#125;function toggleTodo(id) &#123; todos = todos.map((todo) =&gt; (todo.id === id ? &#123; ...todo, completed: !todo.completed &#125; : todo)); console.log('[toggleTodo] : ', todos);&#125;function allChangeToggle(checked) &#123; todos = todos.map((todo) =&gt; (&#123; ...todo, completed: checked &#125;)); console.log('[allChangeToggle] : ', todos);&#125;function clearCompleted() &#123; todos = todos.filter((todo) =&gt; !todo.completed); console.log('[clearCompleted] : ', todos);&#125;function changeNav(id) &#123; [...$nav.children].forEach(($navItem) =&gt; &#123; $navItem.classList.toggle('active', $navItem.id === id); navId = id; &#125;); console.log('[changeNav] : ', todos);&#125;// 이벤트window.onload = () =&gt; &#123; getTodos(); render();&#125;;$inputTodo.onkeydown = (&#123; target, keyCode &#125;) =&gt; &#123; if (target.value.trim() === '' || keyCode !== 13) return; addTodo(target.value); target.value = ''; render();&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(+target.parentNode.id); render();&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; toggleTodo(+target.parentNode.id); render();&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; allChangeToggle(target.checked); render();&#125;;$clearCompleted.onclick = () =&gt; &#123; clearCompleted(); render();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target.id); render();&#125;; 주요 코드이벤트와 기능을 분리하여 코드를 작성함 가독성을 크게 늘릴 수 있었다. 이벤트에서 처리할 내용들은 if문으로 해당 조건이 맞을 경우 이벤트가 발생하도록만 하게끔 함. 모든 이벤트는 render() 를 이용하여 웹페이지에 상태를 즉각 반영가능. 전 코드와의 다른점 임시 변수tempTodos 를 렌더링 내가 한 방법은 변수를 따로 만들고 거기에 todos 값을 임시로 저장하는 방법으로 진행하였다. 풀이 방식에서는 todos에 대한 변화는 전혀 없었다. ( todos의 데이터는 유지한다.) 임시 변수 tempTodos를 만들어서 할당하고 임시 변수 tempTodos를 그대로 렌더링 하는 방식이었다. 1234567891011121314151617181920212223function render() &#123; // const tempTodos = [...todos]; // separateTab(); const tempTodos = todos.filter((&#123; completed &#125;) =&gt; (navId === 'all' ? true : navId === 'active' ? !completed : completed)); let html = ''; tempTodos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;`; &#125;); $todos.innerHTML = html; $completedTodos.textContent = return todos.filter((todo) =&gt; todo.completed).length; $activeTodos.textContent = return todos.filter((todo) =&gt; !todo.completed).length; // todos = tempTodos;&#125; 잘못된 문제 이해. 12$completedTodos.textContent = return todos.filter((todo) =&gt; todo.completed).length;$activeTodos.textContent = return todos.filter((todo) =&gt; !todo.completed).length; 현재 nav가 아닌 All-navigation 기준으로 완료한 할 일 목록, 하지 못한 할일 목록을 나열. 기본 버전의 완료한 할 일 목록을 나타내는 $completedTodos와 완료하지 못한 할 일 목록을 나타내는 $activeTodos에 대한 값이 다르다. 우선 풀이 버전은 어느 탭을 가던지 항상 All 탭의 상태를 가리키고 있고,기본 버전은 탭에 따라 가리키는 데이터가 다르다. 문제는 풀이버전이든 기본버전이든 소스는 동일한데,이유는 기본버전에서는 1번 처럼 임시 변수를 렌더링 하는 방식이 아니라 todos자체를 렌더링 하고 렌더링 후에 todos를 다시 원래 값으로 바꿔 주는 형태의 소스 였고, 풀이버전은 todos의 값을 임시 변수에 할당하고 임시 변수를 렌더링하는 방식이기 때문에 todos의 값은 항상 그대로이며 $completedTodos와 $activeTodos 도 모두 todos 데이터를 참조하고 있기 때문이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"javascript-study-21[TodoList 만들기 (v02 추가)]","slug":"javascript-study-21","date":"2019-11-04T14:16:33.000Z","updated":"2019-11-30T16:59:58.905Z","comments":true,"path":"2019/11/04/javascript-study-21/","link":"","permalink":"https://hyeok999.github.io/2019/11/04/javascript-study-21/","excerpt":"","text":"JavaScript Study 21TODO-LIST Todo List V.02 추가 버전123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140let todos = [];let tempTodos = [];let $navId = 'all';const $todos = document.querySelector('.todos');const $inputTodo = document.querySelector('.input-todo');const $completeAll = document.querySelector('.complete-all');const $nav = document.querySelector('.nav');const $completedTodos = document.querySelector('.completed-todos');const $activeTodos = document.querySelector('.active-todos');const $clearCompleted = document.querySelector('.clear-completed &gt; .btn');// 데이터 받아오기function getTodos() &#123; todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ]; todos.sort((todo1, todo2) =&gt; todo2.id - todo1.id);&#125;function separateTab(navId) &#123; if (navId === 'all') return; if (navId === 'active') &#123; todos = todos.filter((todo) =&gt; (!todo.completed)); &#125; else &#123; todos = todos.filter((todo) =&gt; (todo.completed)); &#125;&#125;function findMaxId() &#123; return Math.max(0, ...todos.map((todo) =&gt; todo.id)) + 1;&#125;function completedCount() &#123; return todos.filter((todo) =&gt; todo.completed).length;&#125;function activeCount() &#123; return todos.filter((todo) =&gt; !todo.completed).length;&#125;// 렌더링function render() &#123; tempTodos = todos; separateTab($navId); let html = ''; todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;`; &#125;); $todos.innerHTML = html; $completedTodos.textContent = completedCount(); $activeTodos.textContent = activeCount(); todos = tempTodos;&#125;// 기능function addTodo(content) &#123; todos = [&#123; id: findMaxId(), content, completed: false &#125;, ...todos]; console.log('[addTodo] : ', todos);&#125;function removeTodo(id) &#123; todos = todos.filter((todo) =&gt; todo.id !== id); console.log('[removeTodo] : ', todos);&#125;function toggleTodo(id) &#123; todos = todos.map((todo) =&gt; (todo.id === id ? &#123; ...todo, completed: !todo.completed &#125; : todo)); console.log('[toggleTodo] : ', todos);&#125;function allChangeToggle(checked) &#123; todos = todos.map((todo) =&gt; (&#123; ...todo, completed: checked &#125;)); console.log('[allChangeToggle] : ', todos);&#125;function clearCompleted() &#123; todos = todos.filter((todo) =&gt; !todo.completed); console.log('[clearCompleted] : ', todos);&#125;function changeNav(navList) &#123; [...$nav.children].forEach(($navItem) =&gt; &#123; $navItem.classList.toggle('active', $navItem === navList); if ($navItem.classList.contains('active')) $navId = $navItem.id; &#125;); console.log('[changeNav] : ', todos);&#125;// 이벤트window.onload = () =&gt; &#123; getTodos(); render();&#125;;$inputTodo.onkeydown = (&#123; target, keyCode &#125;) =&gt; &#123; if (target.value.trim() === '' || keyCode !== 13) return; addTodo(target.value); target.value = ''; render();&#125;;$todos.onclick = (&#123; target &#125;) =&gt; &#123; if (!target.classList.contains('remove-todo')) return; removeTodo(+target.parentNode.id); render();&#125;;$todos.onchange = (&#123; target &#125;) =&gt; &#123; toggleTodo(+target.parentNode.id); render();&#125;;$completeAll.onchange = (&#123; target &#125;) =&gt; &#123; allChangeToggle(target.checked); render();&#125;;$clearCompleted.onclick = () =&gt; &#123; clearCompleted(); render();&#125;;$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target); render();&#125;; 주요 코드이벤트와 기능을 분리하여 코드를 작성함 가독성을 크게 늘릴 수 있었다. 이벤트에서 처리할 내용들은 if문으로 해당 조건이 맞을 경우 이벤트가 발생하도록만 하게끔 함. 모든 이벤트는 render() 를 이용하여 웹페이지에 상태를 즉각 반영가능. 네비게이션 바 ( 탭을 분리하여 todo 관리하기)12345&lt;ul class=\"nav\"&gt; &lt;li id=\"all\" class=\"active\"&gt;All&lt;/li&gt; &lt;li id=\"active\"&gt;Active&lt;/li&gt; &lt;li id=\"completed\"&gt;Completed&lt;/li&gt;&lt;/ul&gt; 네비게이션 3개( All, Active, Completed )탭에 따라 현재 할 일 목록을 나누고자 함. 가장 먼저 할일은 document.querySelector(&#39;.nav&#39;); 를 불러와 전역 변수를 생성하여 해당 요소에 접근하도록 함. 그리고 해당 요소를 클릭했을 시에 일어나는 이벤트를 처리하도록 함수를 작성함. 해당 함수는 각 탭마다 보여지는게 다르므로 render() 를 해야 하기에 코드를 추가 하였고 선택된 &lt;li&gt; e.target 와 &lt;ul&gt;의 자식인 &lt;li&gt; 를 비교하기 위해 함수changeNav(e.target)를 작성하였음. 12345678const $nav = document.querySelector('.nav');// 이벤트$nav.onclick = (&#123; target &#125;) =&gt; &#123; if (target.classList.contains('nav')) return; changeNav(target); render();&#125;; 해당 함수에서는 &lt;ul&gt; 안의 &lt;li&gt; 를 통채로 꺼내와야 하는데 2가지 방법이 존재한다. children : HTMLCollection 형태로 자식들이 구성되어있다. 특징은 요소만 가지고 있다. childNodes : NodeList 형태로 자식들이 구성 되어있다. 텍스트요소를 포함하여 모두 가지고 있기에 별도의 분리가 필요하다. 2번은 텍스트요소도 포함되어 있기 때문에 더 간단히 사용할 수 있는 children 을 이용한다. HOF를 사용하기 위해서 HTMLCollection을 배열로 스프레드 연산자를 이용하여 변환한다. [...$nav.children] 변환 후 forEach 함수를 이용하여 반복 한다. &lt;ul&gt; 의 각 요소 &lt;li&gt; 를 나태나는 $navItem 이 만약 인수로 넘겨 준 클릭 &lt;li&gt; 요소 navList 와 같다면 toggleMethod를 이용하여 해당 클래스에 ‘active’를 추가하고 같지 않다면 ‘active’를 제거한다. 그리고 전역 변수 $navId에 class=’active’인 &lt;li&gt;의 id값을 넘겨준다. 1234567function changeNav(navList) &#123; [...$nav.children].forEach(($navItem) =&gt; &#123; $navItem.classList.toggle('active', $navItem === navList); if ($navItem.classList.contains('active')) $navId = $navItem.id; &#125;); console.log('[changeNav] : ', todos);&#125; 2번에서 함수를 호출 하여 &lt;li&gt; 요소의 클래스를 변경 해준 뒤 render()를 실행한다. render()에서 탭이 바뀌기 전에 저장할 임시 전역 변수 tempTodos에게 todos값을 저장 하고 separateTab($navId)함수를 호출 하면서 인수로 nav의 id값을 저장하고있는 $navId를 넣는다. 123456// 렌더링function render() &#123; tempTodos = todos; separateTab($navId); ...&#125; 3번에서 호출한 separateTab(navId)는 전역변수로 받은 navigation의 id값에 따라 화면에 렌더링할 todos를 재할당한다. 12345678function separateTab(navId) &#123; if (navId === 'all') return; if (navId === 'active') &#123; todos = todos.filter((todo) =&gt; (!todo.completed)); &#125; else &#123; todos = todos.filter((todo) =&gt; (todo.completed)); &#125;&#125; 4번에 의하여 재할당된 todos를 가지고 html을 렌더링한다. 마지막 쯤 todos 에 처음에 복사한 원본 todos를 다시 할당하고 render 함수를 종료한다. 123456789101112131415161718192021// 렌더링function render() &#123; tempTodos = todos; separateTab($navId); let html = ''; todos.forEach((&#123; id, content, completed &#125;) =&gt; &#123; html += ` &lt;li id=\"$&#123;id&#125;\" class=\"todo-item\"&gt; &lt;input class=\"checkbox\" type=\"checkbox\" id=\"ck-$&#123;id&#125;\" $&#123;completed ? 'checked' : ''&#125;&gt; &lt;label for=\"ck-$&#123;id&#125;\"&gt;$&#123;content&#125;&lt;/label&gt; &lt;i class=\"remove-todo far fa-times-circle\"&gt;&lt;/i&gt; &lt;/li&gt;`; &#125;); $todos.innerHTML = html; $completedTodos.textContent = completedCount(); $activeTodos.textContent = activeCount(); todos = tempTodos;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"daily_algorithm31","slug":"daily-algorithm31","date":"2019-11-04T04:26:34.000Z","updated":"2019-11-30T17:12:09.645Z","comments":true,"path":"2019/11/04/daily-algorithm31/","link":"","permalink":"https://hyeok999.github.io/2019/11/04/daily-algorithm31/","excerpt":"","text":"문제 출처 : 프로그래머스 약수의 합문제 설명정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요. 제한 사항 n은 0 이상 3000이하인 정수입니다. 입출력 예 n return 12 28 5 6 입출력 예 설명입출력 예 #112의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다. 입출력 예 #25의 약수는 1, 5입니다. 이를 모두 더하면 6입니다. 123456789function solution(n) &#123; var answer = 0; for(let i = 1; i &lt;= n; i++) &#123; answer += n % i == 0 ? i : 0; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm30","slug":"daily-algorithm30","date":"2019-11-02T11:09:17.000Z","updated":"2019-11-30T17:12:19.486Z","comments":true,"path":"2019/11/02/daily-algorithm30/","link":"","permalink":"https://hyeok999.github.io/2019/11/02/daily-algorithm30/","excerpt":"","text":"문제 출처 : 프로그래머스 실패율문제 설명 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라. 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라. 제한사항 스테이지의 개수 N은 1 이상 500 이하의 자연수이다. stages의 길이는 1 이상 200,000 이하이다. stages에는 11 이상 1N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다. 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다. 입출력 예 N stages result 5 [2, 1, 2, 6, 2, 4, 3, 3] [3,4,2,1,5] 4 [4,4,4,4,4] [4,1,2,3] 입출력 예 설명입출력 예 #11번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다. 1 번 스테이지 실패율 : 1/8 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7 마찬가지로 나머지 스테이지의 실패율은 다음과 같다. 3 번 스테이지 실패율 : 2/4 4번 스테이지 실패율 : 1/2 5번 스테이지 실패율 : 0/1 각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다. [3,4,2,1,5] 입출력 예 #2 모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다. [4,1,2,3] 123456789101112131415161718function solution(N, stages) &#123; let answer = []; const stage = [...stages].sort((a, b) =&gt; a - b); const rate = Array(N).fill(0); let nonClearUser = []; for (let i = 1; i &lt;= N; i++) &#123; nonClearUser = stage.splice(stage.indexOf(i), stage.lastIndexOf(i) + 1); rate[i - 1] = nonClearUser.length / stage.length; if (Number.isNaN(rate[i - 1])) rate[i - 1] = 0; &#125; for (let i = 1; i &lt;= N; i++) &#123; answer[i - 1] = rate.indexOf(Math.max(...rate)) + 1; rate[rate.indexOf(Math.max(...rate))] = null; &#125; return answer;&#125; 마지막에 NaN값에 대한 처리를 안해줘서 많이 애먹었다. 각 스테이지마다 클리어하지 못한 스테이지를 담고 있는 변수 stage를 sort로 정렬시킨다. 각 실패율을 담을 변수인 rate를 N의 배열로 만들고 전부 0으로 채운다. 실패한 유저수를 세기 위해 nonClearUser라는 변수를 생성한다. 스테이지 1부터 스테이지 N까지 돌면서 각 스테이지에서 클리어하지 못한 사람을 찾아 배열에 담는다. 여기서 1번에서 만든 stage를 미리 정렬해놨으니 특정 길이만큼만 자르면 해당 스테이지를 클리어하지 못한 사람들이 모인 배열을 찾을 수 있다. 그 부분에서 indexOf, lastIndexOf를 사용한다. nonClearUser의 길이 / 잘리고 남은 스테이지 길이만큼을 나누고 그 결과 2번에 만든 rate에 쌓기 시작한다. rate는 현재 실패율(소숫점)이 들어가 있는데 여기에 있는 실패율들의 순서대로 인덱스를 반환하면 된다 주의점은 또 splice로 자르게 되면 rate의 전체적인 길이가 줄어들기 때문에 자르지말고 null값으로 채워준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm29","slug":"daily-algorithm29","date":"2019-11-02T11:09:14.000Z","updated":"2019-11-30T17:12:25.850Z","comments":true,"path":"2019/11/02/daily-algorithm29/","link":"","permalink":"https://hyeok999.github.io/2019/11/02/daily-algorithm29/","excerpt":"","text":"문제 출처 : 프로그래머스 소수 찾기문제 설명1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.(1은 소수가 아닙니다.) 제한 조건 n은 2이상 1000000이하의 자연수입니다. 입출력 예 n result 10 4 5 3 입출력 예 설명입출력 예 #11부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환 입출력 예 #21부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환 O n제곱 형태의 기본적인 풀이각 수마다 for문을 돌아가면서 소수를 찾는 방법 for문 내부에 또 for문이 돌기때문에 시간이 오래걸린다. 테스트 케이스가 커지면 커질수록 시간이 오래걸려서 테스트 10 ~13번까지 통과하지 못했다. 1234567891011121314151617function solution(n) &#123; let result = 0; let count = 0; for (let i = 2; i &lt;= n; i++) &#123; count = 0; for (let j = 1; j &lt;= i; j++) &#123; if (i % j == 0) &#123; count++; &#125; &#125; if (count == 2) &#123; result++; &#125; &#125; return result;&#125; 에라토스테네스의 체소수를 더 쉽게 찾는 방법이 존재하길래 구글 검색을 통해 알아낸 에라토스테네스의 체 공식이다. 여기서 주워진 문제는 2부터 n만큼까지의 소수를 찾는 문제이다. n은 결국 어떤 수의 제곱보다 낮은 숫자들만큼만 길이를 재면 된다. 예를들면 120은 11(121)의 제곱보다 1낮기 떄문에 11로 가정한다. 120까지 1번이라도 같은 배수해서 나온 수가 있다면 그 수는 소수가 아니기 때문에 11까지 검사하면 된다. 풀이 방법은 다음과 같다. 받아온 n을 제곱근으로 반환한다.(Math.sqrt) 그리고 소수가 나올수도 있기 때문에 올림한다.(Math.ceil) n만큼의 배열을 만들어낸다. 여기서 모두 false 혹은 true로 채워버린다. (Array(n).fill(false)) 미리 구해둔 n의 제곱근만큼 반복을 돌린다. 시작은 2이다(1은 소수가 아니기 떄문) 조건이 true라면 소수가 아니다. 따라서 해당 배열이 true일 경우 continue로 다음 반복으로 돌아가 소수인지를 찾는다. 조건이 false라면 소수다. 소수의 배수만큼 배열 내부에 접근해 반복을 사용하여 배수의 인덱스 부분들을 전부 true로 바꿔준다. 모든 반복이 끝나고 마지막에 2부터 시작해서 n까지 배열에 false값만을 찾는다. false의 갯수당 카운터를 1개씩 올리면 소수의 갯수를 판단할 수 있다. 1234567891011121314151617181920function solution(n) &#123;let rootSqrt = Math.ceil(Math.sqrt(n));let arr = Array(n).fill(false);let answer = 0; for(let i=2; i &lt;= rootSqrt; i++) &#123; if (arr[i]) &#123; continue; &#125; for(let j = i + i; j &lt;= n; j += i) &#123; arr[j] = true; &#125; &#125; for(let i=2; i &lt;= n ; i++) &#123; if(!arr[i]) answer++; &#125; return answer&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm28","slug":"daily-algorithm28","date":"2019-11-02T11:09:12.000Z","updated":"2019-11-30T17:12:31.083Z","comments":true,"path":"2019/11/02/daily-algorithm28/","link":"","permalink":"https://hyeok999.github.io/2019/11/02/daily-algorithm28/","excerpt":"","text":"문제 출처 : 프로그래머스 x만큼 간격이 있는 n개의 숫자문제 설명함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요. 제한 조건 x는 -10000000 이상, 10000000 이하인 정수입니다. n은 1000 이하인 자연수입니다. 입출력 예 x n answer 2 5 [2,4,6,8,10] 4 3 [4,8,12] -4 2 [-4, -8] 123function solution(x, n) &#123; return Array(n).fill(x).map((item, index) =&gt; item * (index + 1))&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-20[TodoList 만들기 (v01, v02)]","slug":"todo-v01-v02","date":"2019-11-01T17:14:20.000Z","updated":"2019-11-30T16:55:36.194Z","comments":true,"path":"2019/11/02/todo-v01-v02/","link":"","permalink":"https://hyeok999.github.io/2019/11/02/todo-v01-v02/","excerpt":"","text":"JavaScript Study 20TODO-LIST Todo List V.0112345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Todo List V.01&lt;/title&gt; &lt;style&gt; .cb:checked + .content &#123; text-decoration: line-through; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input class=\"input\"&gt; &lt;ul class=\"todos\"&gt;&lt;/ul&gt;&lt;/body&gt;&lt;script&gt; const $input = document.querySelector('.input'); const $todos = document.querySelector('.todos'); $input.addEventListener('keydown', function (e) &#123; if (e.keyCode !== 13 || $input.value.trim() === '') return; $todos.innerHTML += `&lt;li&gt; &lt;label&gt; &lt;input type=\"checkbox\" class=\"cb\"&gt; &lt;span class=\"content\"&gt;$&#123;$input.value&#125;&lt;/span&gt; &lt;/label&gt; &lt;button class=\"remove\"&gt;X&lt;/button&gt; &lt;/li&gt;`; $input.value = ''; &#125;); $todos.addEventListener('click', function (e) &#123; if (!e.target.classList.contains('remove')) return; this.removeChild(e.target.parentNode); &#125;);&lt;/script&gt;&lt;/html&gt; 주요 코드 document.querySelector() : css셀렉터 문법을 이용하여 해당 요소에 접근 하기 위해 사용. 12const $input = document.querySelector('.input');const $todos = document.querySelector('.todos'); $input.addEventListener( &#39;keydown&#39;, function (e) { ... }) : 키보드를 통해 입력을 받을 수 있게 ‘keydown’ 이벤트를 이용하였음. 엔터키(13번) 혹은 입력받는 문자열이 빈문자열 일 경우 해당 이벤트는 실행되지 않도록 조건함. 조건에 해당 될 경우 $todos innerHTML 프로퍼티를 이용하여 html 소스 코드를 추가함. 마지막에 input 창을 비워줘야되기 때문에 $input.value를 비워줌. 1234567891011$input.addEventListener('keydown', function (e) &#123; if (e.keyCode !== 13 || $input.value.trim() === '') return; $todos.innerHTML += `&lt;li&gt; &lt;label&gt; &lt;input type=\"checkbox\" class=\"cb\"&gt; &lt;span class=\"content\"&gt;$&#123;$input.value&#125;&lt;/span&gt; &lt;/label&gt; &lt;button class=\"remove\"&gt;X&lt;/button&gt; &lt;/li&gt;`; $input.value = ''; &#125;); 추가로 css 가로줄을 넣는다. 생성된 &lt;li&gt;들을 체크할 경우 &lt;li&gt; 내에 있는 &lt;input&gt;의 어트리뷰트로 checked 상태인지 파악한다. checked라면 &lt;input&gt;&lt;span&gt; 태그에 가로 줄을 그어넣는다. 12345&lt;style&gt; .cb:checked + .content &#123; text-decoration: line-through; &#125;&lt;/style&gt; $todos.addEventListener( &#39;keydown&#39;, function (e){ ... }) : 2번에서 만들어진 &lt;button class=&quot;remove&quot;&gt;X&lt;/button&gt;에 접근하기 위해서 상위 부모인 todos에서 부터 접근함. 이유는 코드 순서상 해당 버튼에 대한 변수를 만들어서 접근을 할 수 없기 때문임. 따라서, 실제로 이벤트를 발생한 요소를 가리키는 Event.target을 이용하여 클릭된 요소의 클래스명에 remove라는 클래스 명이 있는 지 조건한다. 해당 조건으로 &lt;ul&gt;의 자식 중 클릭된 해당 &lt;button&gt; 요소의 부모(&lt;li&gt;)를 제거한다. 1234$todos.addEventListener('click', function (e) &#123; if (!e.target.classList.contains('remove')) return; this.removeChild(e.target.parentNode); &#125;); Todo List V.021234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Todo List V02&lt;/title&gt; &lt;style&gt; .check-box:checked + span &#123; text-decoration: line-through; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input class=\"input\"&gt; &lt;ul class=\"todos\"&gt;&lt;/ul&gt;&lt;/body&gt;&lt;script&gt; let todos = []; const $input = document.querySelector('.input'); const $todos = document.querySelector('.todos'); function render() &#123; let html = ''; todos.forEach((todo) =&gt; &#123; html += ` &lt;li id=$&#123;todo.id&#125;&gt; &lt;label&gt; &lt;input type=\"checkbox\" class=\"check-box\" $&#123;todo.completed ? 'checked' : ''&#125;&gt; &lt;span&gt;$&#123;todo.content&#125;&lt;/span&gt; &lt;/label&gt; &lt;button class=\"remove\"&gt;X&lt;/button&gt; &lt;/li&gt; `; &#125;); $todos.innerHTML = html; console.log(todos); &#125; const getTodos = function () &#123; // TODO: 서버로부터 데이터를 취득. todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ]; render(); &#125;; function findMaxId() &#123; return Math.max(0, ...todos.map((todo) =&gt; todo.id)); &#125; const addTodos = function (e) &#123; if (e.keyCode !== 13 || $input.value.trim() === '') return; todos = [...todos, &#123; id: findMaxId() + 1, content: $input.value, completed: false &#125;]; $input.value = ''; render(); &#125;; const removeTodos = function (e) &#123; if (!e.target.classList.contains('remove')) return; const listId = +(e.target.parentNode.id); todos = todos.filter((todo) =&gt; todo.id !== listId); // Id 재정렬 if (todos.length !== findMaxId()) &#123; todos = todos.map((todo, index) =&gt; (&#123; ...todo, id: index + 1 &#125;)); &#125; render(); &#125;; const toggleTodos = function (e) &#123; const listId = +(e.target.parentNode.parentNode.id); todos = todos.map((todo) =&gt; ( todo.id === listId ? &#123; ...todo, completed: !todo.completed &#125; : todo)); render(); &#125;; window.onload = getTodos; $input.onkeydown = addTodos; $todos.onclick = removeTodos; $todos.onchange = toggleTodos;&lt;/script&gt;&lt;/html&gt; 주요 코드 let todos = []; const $input = document.querySelector(&#39;.input&#39;);const $todos = document.querySelector(&#39;.todos&#39;); todos는 백단으로부터 받아온 데이터를 받기 위해 만든 변수이다. 또한 각 요소들에게 접근하기 위해서 &lt;ul&gt;태그의 $todos 와 &lt;input&gt; 태그의 $input 라는 변수를 만들고 querySelector() 를 통해 접근한다. const getTodos = function () {...}; 1번에서 만든 todos의 변수에 백단으로부터 받을 변수를 담기위한 과정을 넣은 함수를 작성한다. 해당 함수는 4번에서 이벤트 핸들러로 인해 콜백 될 것이다. 123456789const getTodos = function () &#123; // TODO: 서버로부터 데이터를 취득. todos = [ &#123; id: 1, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'Javascript', completed: false &#125; ]; render();&#125;; function render() {...} 2번에서 마지막에 작성한 render()를 작성한다. render()는 직접적으로 가지고온 todos 데이터를 화면에 뿌리기 위해서 (View역할) innerHTML 프로퍼티를 이용하여 작성한다. 여기서 주의할 것은 위에서 선언한 변수 $todos를 통해 DOM요소에 직접적으로 접근하여 innertHTML을 하여서는 안된다. 이유는 그럴 경우 todos의 데이터만큼 뷰 페이지가 다시 렌더링 되는 것이므로 리소스를 많이 잡아먹는다. 123456789101112131415161718function render() &#123; let html = ''; todos.forEach((todo) =&gt; &#123; html += ` &lt;li id=$&#123;todo.id&#125;&gt; &lt;label&gt; &lt;input type=\"checkbox\" class=\"check-box\" $&#123;todo.completed ? 'checked' : ''&#125;&gt; &lt;span&gt;$&#123;todo.content&#125;&lt;/span&gt; &lt;/label&gt; &lt;button class=\"remove\"&gt;X&lt;/button&gt; &lt;/li&gt; `; &#125;); $todos.innerHTML = html; console.log(todos); &#125; window.onload = getTodos; 처음으로 .html 파일을 열었을 경우, 웹페이지의 로드가 완료되었을 때 getTodos 함수를 실행한다. getTodos함수에는 render()도 호출되므로 페이지가 렌더링 된다. $input.onkeydown = addTodos; 키보드 버튼이 눌러지고 떼졌을 때 addTodos 를 실행한다. const addTodos = function (e) {...} 엔터키(13번) 혹은 입력받는 문자열이 빈문자열 일 경우 해당 이벤트는 실행되지 않도록 조건함. 조건에 해당 될 경우 todos배열에 새로운 배열 값을 추가하는 작업을 한다. 마지막에 input 창을 비워줘야되기 때문에 $input.value를 비워줌. 12345678const addTodos = function (e) &#123; if (e.keyCode !== 13 || $input.value.trim() === '') return; todos = [...todos, &#123; id: findMaxId() + 1, content: $input.value, completed: false &#125;]; $input.value = ''; render(); &#125;; 추가 새로운 배열을 추가할 떄 아이디값을 채번 해야한다. 채번하는 과정은 새로운 함수를 만들어서 진행한다. 123function findMaxId() &#123; return Math.max(0, ...todos.map((todo) =&gt; todo.id)); &#125; $todos.onclick = removeTodos; 삭제 버튼을 눌렀을 경우 할일 목록 중 일부가 사라지기 위해서 removeTodo를 실행한다. const removeTodos = function (e) {...} 3번에서 만들어진 &lt;button class=&quot;remove&quot;&gt;X&lt;/button&gt;에 접근하기 위해서 상위 부모인 todos에서 부터 접근함. 이유는 코드 순서상 해당 버튼에 대한 변수를 만들어서 접근을 할 수 없기 때문임. 따라서, 실제로 이벤트를 발생한 요소를 가리키는 Event.target을 이용하여 클릭된 요소의 클래스명에 remove라는 클래스 명이 있는 지 조건한다. 아이디값을 비교하여 해당 아이디를 제외하고 나머지값을 새로운 배열로 추가하는 코드를 filter를 이용하여 작성한다. filter 후에 만들어진 todos를 이용하여 아이디값을 재정렬한다. 그 때 Id의 최댓값이 필요하므로 6번에서 만들어 놓은 findMaxId()를 이용한다. 123456789101112const removeTodos = function (e) &#123; if (!e.target.classList.contains('remove')) return; const listId = +(e.target.parentNode.id); todos = todos.filter((todo) =&gt; todo.id !== listId); // Id 재정렬 if (todos.length !== findMaxId()) &#123; todos = todos.map((todo, index) =&gt; (&#123; ...todo, id: index + 1 &#125;)); &#125; render(); &#125;; $todos.onchange = toggleTodos; 체크박스를 선택할 경우 todos 배열의 completed를 바꾸고 해당 값을 통해 선이 그어지도록 설정한다. 해당 함수는 toggleTodos이다. const toggleTodos = function (e) {...} todos내부의 객체에 있는 completed값을 반전 시켜야되므로 map고차함수를 이용하여 id값을 매칭해 해당 completed값만 반전시킨다. 1234567const toggleTodos = function (e) &#123; const listId = +(e.target.parentNode.parentNode.id); todos = todos.map((todo) =&gt; ( todo.id === listId ? &#123; ...todo, completed: !todo.completed &#125; : todo)); render(); &#125;;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"모의 면접 질문 정리","slug":"Interview-arrange","date":"2019-11-01T02:20:36.000Z","updated":"2019-11-30T17:06:21.645Z","comments":true,"path":"2019/11/01/Interview-arrange/","link":"","permalink":"https://hyeok999.github.io/2019/11/01/Interview-arrange/","excerpt":"","text":"면접 질문 내용 정리 ( 게속 추가 예정 )1차 모의 면접 CSS 개발 방법론 url 구조 300번대 에러 포폴내용 PWA - Service Workers 를 사용한 캐싱 덕분에 앱을 설치한 후에 로딩 시간이 줄어들어 소중한 데이터와 시간을 절약. service worker에 대해 설명하라. 클로저 얕은복사와 깊은복사 var vs let vs const 버전관리를 어떻게 하였는가? 웹브라우저 동작 원리 자신만의 개발 규칙 개발하다가 막힐 경우 어떻게 해결할 것인가? (+ 팀원이 있을 경우 어떻게 할 것 인가?) html에서 img가 에러날 경우 대체 img를 어떻게 보여줄 것 인가? ➤ javascript로 onerror 이벤트 처리한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"https://hyeok999.github.io/categories/Develop/Tips/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"interview","slug":"interview","permalink":"https://hyeok999.github.io/tags/interview/"}]},{"title":"javascript-study-19[Todo 가벼운 실습 v0]","slug":"javascript-study-19","date":"2019-10-31T14:40:54.000Z","updated":"2019-11-30T17:00:18.518Z","comments":true,"path":"2019/10/31/javascript-study-19/","link":"","permalink":"https://hyeok999.github.io/2019/10/31/javascript-study-19/","excerpt":"","text":"JavaScript Study 19TODO DOM + 이벤트 가벼운 실습 코드 ▼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Todo list&lt;/title&gt; &lt;style&gt; body&#123; background: #7ca7c7; font-size: 20px; &#125; * &#123; margin: 0; padding: 0; list-style: none; &#125; main &#123; display: flex; justify-content: center; align-items: center; flex-direction: column; height: 100vh; width: 100vw; flex:auto; &#125; .input &#123; width: 100vw; height: 40px; font-size: 20px; text-indent: 20px; border : none; &#125; div &#123; position: relative; &#125; .addList &#123; position: absolute; top: 0; right: 0; width: 80px; height: 100%; font-size: 20px; color: white; border: none; background: black; &#125; .remove &#123; width: 30px; height: 20px; color: white; border: none; border-radius: 10px 10px 10px 10px; background: red; &#125; .todos&#123; &#125; .todo &#123; width: 40vw; display: flex; justify-content: space-between; text-decoration: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;main&gt; &lt;h1&gt; Todo List &lt;/h1&gt; &lt;div&gt; &lt;input class=\"input\" type=\"text\" placeholder=\"할 일을 입력하세요.\"&gt; &lt;button class=\"addList\"&gt;추가&lt;/button&gt; &lt;/div&gt; &lt;ul class=\"todos\"&gt;&lt;/ul&gt; &lt;/main&gt;&lt;/body&gt;&lt;script&gt; const $input = document.querySelector('.input'); const $addList = document.querySelector('.addList'); const $todos = document.querySelector('.todos'); let count = 0; function addInnerHtml() &#123; $todos.innerHTML += ` &lt;li class=\"todo\"&gt; &lt;input type=\"checkbox\" id='abc$&#123;count&#125;'&gt; &lt;label for=\"abc$&#123;count&#125;\"&gt; $&#123;$input.value&#125; &lt;/label&gt; &lt;button class=\"remove\"&gt;삭제&lt;/button&gt; &lt;/li&gt;`; $input.value = ''; count++; &#125; $addList.onclick = function () &#123; if ($input.value) &#123; addInnerHtml(); $input.focus(); &#125; &#125;; $input.onkeydown = function (e) &#123; if (($input.value) &amp;&amp; e.keyCode === 13) &#123; addInnerHtml(); &#125; &#125;; // onchage는 check 박스에서만 가능하다. $todos.onchange = function (&#123; target &#125;) &#123; console.log(target); const $todo = target.parentNode; console.log($todo); $todo.style.textDecoration = target.checked ? 'line-through' : 'none'; &#125;; $todos.onclick = function (e) &#123; if (e.target.classList.value === 'remove') &#123; $todos.removeChild(e.target.parentNode); &#125; &#125;;&lt;/script&gt;&lt;/html&gt; 구현 기능 할 일 추가 기능 $addList.onclick ~~ $todos.innerHTML += 내용 할 일 삭제 기능 $todos.removeChild(e.target.parentNode); 할 일 체크박스 혹은 글자 선택 시 밑줄 그어 지는 기능target.parent.style.textDecoration = target.checked ? &#39;line-through&#39; : &#39;none&#39;; 인풋박스에 포커스 게속 유지 $input.focus(); 키보드 엔터키로 추가 가능 $input.onkeydown ~~ $todos.innerHTML += 내용 결과 ▼","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Todo","slug":"Todo","permalink":"https://hyeok999.github.io/tags/Todo/"}]},{"title":"이벤트 프로퍼티","slug":"EventProperty","date":"2019-10-31T14:24:26.000Z","updated":"2019-11-30T17:07:02.509Z","comments":true,"path":"2019/10/31/EventProperty/","link":"","permalink":"https://hyeok999.github.io/2019/10/31/EventProperty/","excerpt":"","text":"EVENT 이벤트 란? 이벤트 루프 이벤트 루프(Event Loop)와 동시성(Concurrency) addEventListener 메소드 방식 이벤트의 종류 ( 참고 : Event reference ) UI Event Keyboard Event Mouse Event Focus Event Form Event Clipboard Event 이벤트 핸들러 등록 (3가지) 인라인 이벤트 핸들러 방식 이벤트 핸들러 프로퍼티 방식 addEventListener 메소드 방식 예1 예2 이벤트 핸들러 함수 내부의 this 인라인 이벤트 핸들러 방식 이벤트 핸들러 프로퍼티 방식 addEventListener 메소드 방식 이벤트의 흐름 캡처링 표현 예제 캡처링 예제 버블링 예제 캡처링 과 버블링 혼용 Event 객체 Event Property Event.target Event.currentTarget Event.type Event.cancelabel Event.eventPhase Event.Delegation 이벤트 위임 기본 동작의 변경 Event.preventDefault Event.stopPropagation preventDefault &amp; stopPropagation 이벤트 이벤트 란? 어떤 사건을 의미. 브라우저에서의 이벤트 - 예 : 사용자가 버튼을 클릭했을 때, 웹페이지가 로드되었을 때 등등 이벤트는 발생하는 시점이나 순서를 사전에 인지할 수 없다. 일반적인 제어 흐름과는 다른 접근 방식이 필요하다. 위와 같은 조건 떄문에 이벤트가 발생하면 누군가 이를 감지할 수 있어야 하며 그에 대응하는 처리를 호출해 주어야 한다. 브라우저는 이벤트를 감지할 수 있으며 이벤트 발생 시에는 통지해 준다.이 과정을 통해 사용자와 웹페이지는 상호작용(Interaction)이 가능하게 된다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"myButton\"&gt;Click me!&lt;/button&gt; &lt;script&gt; document.querySelector('.myButton').addEventListener('click', function () &#123; alert('Clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 버튼을 클릭 했을 때, 브라우저는 이벤트를 버튼 클릭이라는 이벤트를 감지하고서 그에 대응하는 처리alert를 호출해준다. 이벤트는 일반적으로 함수에 연결되며 그 함수는 이벤트가 발생하기 전에는 실행되지 않다가 이벤트가 발생되면 실행된다.이 함수를 이벤트 핸들러라 하며 이벤트에 대응하는 처리를 기술한다. ( 위 예제에서는 &#39;addEventListenter&#39;안에 있는 함수 가 이벤트 핸들러) ###이벤트 루프(Event Loop)와 동시성(Concurrency) 브라우저는 단일 쓰레드 에서 이벤트 드리븐 방식으로 동작한다. 단일쓰레드인데도 마치 멀티 쓰레드 마냥 동시에 처리되는 것처럼 느껴지는데 그것은 JS의 동시성을 지원하는 이벤트루프 때문이다. 브라우저의 환경은 다음과 같다. 구글의 V8을 비롯한 대부분의 JS엔진은 크게 2가지 영역으로 나눌 수 있다. Call Stack (호출 스택) 함수가 호출 되면(= 작업이 요청되면) 호출된 함수는 순차적으로 Cal Stack에 쌓이게 되고 순차적으로 실행 JS는 단 하나의 Call Stack을 이용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 실행 할 수 없다. Heap 동적으로 생성된 객체 인스턴스가 할당된느 영역 비동기(이벤트 포함) 처리는 JS엔진을 구동하는 환경인 브라우저(Node.js)가 담당한다. Event Queue(Task Queue) 비동기 처리 함수의 콜백함수, 비동기식 이벤트 헨들러, Timer 함수(setTimeout(), setInterval())의 콜백 함수가 보관되는 영역. 이벤트 루프에 의해 특정 시점(Call Stack이 비어졌을 떄)에 순차적으로 Call Stack으로 이동되어 실행. Event Loop(이벤트 루프) Call Stack 내에서 현재 실행 중인 task가 있는지 Event Queue에 task가 있는지 반복하여 확인. 만약 Call Stack이 비어있다면 Event Queue 내의 Task가 Call Stack으로 이동하고 실행. 예제1 123456789101112131415161718function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; setTimeout(function () &#123; console.log('func2'); &#125;, 0); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 함수 func1은 함수 func2을 호출한다. 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 콜백함수는 즉시 실행되지 않고 지정 대기 시간만큼 기다린다. “tick” 이벤트가 발생하면 태스크(이벤트) 큐로 이동한다. Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. 예제2 - DOM 이벤트 핸들러 12345678910111213141516171819202122function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; // &lt;button class=\"foo\"&gt;foo&lt;/button&gt; const elem = document.querySelector('.foo'); elem.addEventListener('click', function () &#123; this.style.backgroundColor = 'indigo'; console.log('func2'); &#125;); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 함수 func1은 함수 func2을 호출한다. 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 즉시 실행되지 않고 이벤트를 기다린다. foo버튼의 “click” 이벤트가 발생하면 태스크(이벤트) 큐로 이동한다. Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. 이벤트의 종류 ( 참고 : Event reference ) UI Event Event Description load 웹페이지의 로드가 완료되었을 때 unload 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우) error 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우 resize 브라우저 창의 크기를 조절했을 때 scroll 사용자가 페이지를 위아래로 스크롤할 때 select 텍스트를 선택했을 때 Keyboard Event Event Description keydown 키를 누르고 있을 때 keyup 누르고 있던 키를 뗄 때 keypress 키를 누르고 뗏을 때 Mouse Event Event Description click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 마우스 버튼을 누르고 있을 때 mouseup 누르고 있던 마우스 버튼을 뗄 때 mousemove 마우스를 움직일 때 (터치스크린에서 동작하지 않는다) mouseover 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다) mouseout 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다) Focus Event Event Description focus/focusin 요소가 포커스를 얻었을 때 blur/foucusout 요소가 포커스를 잃었을 때 Form Event Event Description input input 또는 textarea 요소의 값이 변경되었을 때 contenteditable 어트리뷰트를 가진 요소의 값이 변경되었을 때 change select box, checkbox, radio button의 상태가 변경되었을 때 submit form을 submit할 때 (버튼 또는 키) reset reset 버튼을 클릭할 때 (최근에는 사용 안함) Clipboard Event Event Description cut 콘텐츠를 잘라내기할 때 copy 콘텐츠를 복사할 때 paste 콘텐츠를 붙여넣기할 때 이벤트 핸들러 등록 (3가지)인라인 이벤트 핸들러 방식 더 이상 사용되고 있지 않은 방식. on으로 시작하는 이벤트 어트리뷰트의 값으로 함수 호출을 전달한다는 것. 이벤트 어트리뷰트의 값으로 전달한 함수 호출이 즉시 호출되는 것은 아니다. 사실은 이벤트 어트리뷰트 키를 이름으로 갖는 함수를 암묵적으로 정의하고 그 함수의 몸체에 이벤트 어트리뷰트의 값으로 전달한 함수 호출을 문으로 갖는다. 아래 예제 기준 = function onclick(event) { foo(); } 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"myHandler()\"&gt;Click me&lt;/button&gt; &lt;script&gt; function myHandler() &#123; alert('Button clicked!'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 프로퍼티 방식 HTML과 Javascript가 뒤섞이는 문제는 해결할 수 있는 방식. 하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바인딩할 수 있다는 단점이 있다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Click me&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); // 이벤트 핸들러 프로퍼티 방식은 이벤트에 하나의 이벤트 핸들러만을 바인딩할 수 있다 // 첫번째 바인딩된 이벤트 핸들러 =&gt; 실행되지 않는다. btn.onclick = function () &#123; alert('① Button clicked 1'); &#125;; // 두번째 바인딩된 이벤트 핸들러 btn.onclick = function () &#123; alert('① Button clicked 2'); &#125;; // addEventListener 메소드 방식 // 첫번째 바인딩된 이벤트 핸들러 btn.addEventListener('click', function () &#123; alert('② Button clicked 1'); &#125;); // 두번째 바인딩된 이벤트 핸들러 btn.addEventListener('click', function () &#123; alert('② Button clicked 2'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addEventListener 메소드 방식 대상 DOM 요소에 이벤트를 바인딩. 해당 이벤트가 발생했을 때 실행될 콜백 함수(이벤트 핸들러)를 지정. IE 9 이상에서 동작. IE 8 이하는 attachEvent 메소드를 사용. ( 참고 : attachEvent ) addEventListener 함수 방식은 이전 방식에 비해 아래와 같이 보다 나은 장점을 갖는다. 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가할 수 있다. 캡처링과 버블링을 지원한다. HTML 요소뿐만아니라 모든 DOM 요소(HTML, XML, SVG)에 대해 동작한다. 브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱하여 DOM을 생성한다. 예112345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; addEventListener('click', function () &#123; alert('Clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM 요소를 지정 안해주면 전역객체 window(브라우저의 윈도우)에서 발생되는 click 이벤트에 이벤트 핸들러를 바인딩한다. 예21234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label&gt;User name &lt;input type='text'&gt;&lt;/label&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const input = document.querySelector('input[type=text]'); const msg = document.querySelector('.message'); input.addEventListener('blur', function () &#123; if (input.value.length &lt; 2) &#123; msg.innerHTML = '이름은 2자 이상 입력해 주세요'; &#125; else &#123; msg.innerHTML = ''; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; blur 이벤트는 포커스를 잃을 경우 생기는 이벤트다. 키보드로 input 내부에 내용을 입력 후 글자수가 모자르다면 다른 곳을 클릭, tab 하였을 때 이벤트가 호출된다. 위와 같은 코드는 좋지 못한 코드다 이유는 ‘2’라는 원시값을 통해서 어떤 이벤트가 실행될 지를 판별하는데 코드가 길어질수록 저런 식으로 원시값을 하나하나 변경하는 것은 시간낭비 와 실수를 유발한다. 해결 방법으로는 ‘2’ 라는 원시값을 상수화 하고 상수를 함수의 인수로 받는 함수를 작성한다.문제는 이럴경우 이벤트 핸들러 프로퍼티 처럼 1개의 함수만 전달할 수 있게된다.이를 해결 하기 위해 addEventListener에서 익명 함수를 작성한다면 내부에서 여러개의 함수를 받을 수 있다. 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label&gt;User name &lt;input type='text'&gt;&lt;/label&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const MIN_USER_NAME_LENGTH = 2; // 이름 최소 길이 const input = document.querySelector('input[type=text]'); const msg = document.querySelector('.message'); function checkUserNameLength(n) &#123; if (input.value.length &lt; n) &#123; msg.innerHTML = '이름은 ' + n + '자 이상이어야 합니다'; &#125; else &#123; msg.innerHTML = ''; &#125; &#125; input.addEventListener('blur', function () &#123; // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. checkUserNameLength(MIN_USER_NAME_LENGTH); &#125;); // 이벤트 핸들러 프로퍼티 방식도 동일한 방식으로 인수를 전달할 수 있다. // input.onblur = function () &#123; // // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. // checkUserNameLength(MIN_USER_NAME_LENGTH); // &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 함수 내부의 this인라인 이벤트 핸들러 방식 이벤트 핸들러는 일반 함수로서 호출되므로 이벤트 핸들러 내부의 this는 전역 객체 window를 가리킨다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"foo()\"&gt;Button&lt;/button&gt; &lt;script&gt; function foo () &#123; console.log(this); // window &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 프로퍼티 방식 이벤트 핸들러는 메소드이므로 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킨다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); btn.onclick = function (e) &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(e.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === e.currentTarget); // true &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addEventListener 메소드 방식 이벤트 핸들러는 콜백 함수이지만 이벤트 핸들러 내부의 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); btn.addEventListener('click', function (e) &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(e.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === e.currentTarget); // true &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트의 흐름HTML 요소는 계층적 구조에 포함되어 있다.이 요소에 이벤트가 발생되면 연쇄적 반응이 얼어난다.이것을 이벤트전파라 하고 전파 방향에 따라 버블링(Event Bubbling)과 캡처링(Event Capturing)으로 구분할 수 있다. 버블링 : 자식요소에서 발생한 이벤트가 부모요소로 전파 캡처링 : 부모요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달 캡처링 과 버블링은 둘 중 하나만 발생되는 개념이 아니라 캠처링부터 시작해 버블링으로 종료한다. addEventListener 메소드의 세번째 매개변수에 true를 설정하면 캡처링으로 전파되는 이벤트를 캐치하고 false 또는 미설정하면 버블링으로 전파되는 이벤트를 캐치한다. 캡처링 표현 예제1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html &#123; border:1px solid red; padding:30px; text-align: center; &#125; body &#123; border:1px solid green; padding:30px; &#125; .top &#123; width: 300px; height: 300px; background-color: red; margin: auto; &#125; .middle &#123; width: 200px; height: 200px; background-color: blue; position: relative; top: 34px; left: 50px; &#125; .bottom &#123; width: 100px; height: 100px; background-color: yellow; position: relative; top: 34px; left: 50px; line-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; body &lt;div class=\"top\"&gt;top &lt;div class=\"middle\"&gt;middle &lt;div class=\"bottom\"&gt;bottom&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // true: capturing / false: bubbling const useCature = true; const handler = function (e) &#123; const phases = ['capturing', 'target', 'bubbling']; const node = this.nodeName + (this.className ? '.' + this.className : ''); // eventPhase: 이벤트 흐름 상에서 어느 phase에 있는지를 반환한다. // 0 : 이벤트 없음 / 1 : 캡처링 단계 / 2 : 타깃 / 3 : 버블링 단계 console.log(node, phases[e.eventPhase - 1]); alert(node + ' : ' + phases[e.eventPhase - 1]); &#125;; document.querySelector('html').addEventListener('click', handler, useCature); document.querySelector('body').addEventListener('click', handler, useCature); document.querySelector('div.top').addEventListener('click', handler, useCature); document.querySelector('div.middle').addEventListener('click', handler, useCature); document.querySelector('div.bottom').addEventListener('click', handler, useCature); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 버블링 예제123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;버블링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과는 다음과 같다. 캡쳐링 이벤트 흐름에 대해서는 동작하지 않는다. 123Handler for button.Handler for paragraph.Handler for body. 캡처링 예제123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;캡처링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 캡처링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;, true); // 캡처링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;, true); // 캡처링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;, true); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과는 다음과 같다. 버블링 이벤트 흐름에 동작하지 않는다. 123Handler for body.Handler for paragraph.Handler for button. 캡처링 과 버블링 혼용123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;버블링과 캡처링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 캡처링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;, true); // 버블링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 코드는 body, button 요소는 버블링 이벤트 흐름을 캐치하고 p 요소는 캡처링 이벤트 흐름만을 캐치한다. 따라서 결과는 다음과 같다. 123Handler for paragraph.Handler for button.Handler for body. Event 객체 event 객체는 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 유용한 정보를 제공한다. 이벤트가 발생하면 event 객체는 동적으로 생성되며 이벤트를 처리할 수 있는 이벤트 핸들러에 인자로 전달된다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;클릭하세요. 클릭한 곳의 좌표가 표시됩니다.&lt;/p&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function showCoords(e) &#123; // e: event object const msg = document.querySelector('.message'); msg.innerHTML = 'clientX value: ' + e.clientX + '&lt;br&gt;' + 'clientY value: ' + e.clientY; &#125; addEventListener('click', showCoords); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위와 같이 event 객체는 이벤트 핸들러에 암묵적으로 전달된다. 이벤트 핸들러를 선언할 때, event 객체를 전달받을 첫번째 매개변수를 명시적으로 선언하는 것이 좋다. 따라서 함수로 1번더 감싸고 addEventListener를 호출 할 때 익명함수로 event객체를 넘겨준다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function showCoords(e, msg) &#123; msg.innerHTML = 'clientX value: ' + e.clientX + '&lt;br&gt;' + 'clientY value: ' + e.clientY; &#125; const msg = document.querySelector('.message'); addEventListener('click', function (e) &#123; showCoords(e, msg); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event PropertyEvent.target 실제로 이벤트를 발생시킨 요소를 가리킴 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;button id=\"btn1\"&gt;Hide me 1&lt;/button&gt; &lt;button id=\"btn2\"&gt;Hide me 2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function hide(e) &#123; e.target.style.visibility = 'hidden'; // 동일하게 동작한다. // this.style.visibility = 'hidden'; &#125; document.getElementById('btn1').addEventListener('click', hide); document.getElementById('btn2').addEventListener('click', hide); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 여기서 event객체는 btn1 과 btn2를 각각 가리키고 있기 때문에 this와 별반 차이가 없다. 하지만 아래 예제를 보자. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;button id=\"btn1\"&gt;Hide me 1&lt;/button&gt; &lt;button id=\"btn2\"&gt;Hide me 2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const container = document.querySelector('.container'); function hide(e) &#123; // e.target은 실제로 이벤트를 발생시킨 DOM 요소를 가리킨다. e.target.style.visibility = 'hidden'; // this는 이벤트에 바인딩된 DOM 요소(.container)를 가리킨다. 따라서 .container 요소를 감춘다. // this.style.visibility = 'hidden'; &#125; container.addEventListener('click', hide); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이 예제처럼 this는 자신이 불러들인 객체를 바인딩하기 때문에 DOM 요소(.container)를 가리킨다. 따라서 버튼 1개 클릭시 전부 가리게 되는데 반면에 event객체의 e.target은 실제로 인벤트를 발생시킨 DOM요소를 의미한다. 따라서 Event.target은 this와 반드시 일치하지는 않는다. Event.currentTarget 이벤트에 바인딩된 DOM 요소를 가리킴. addEventListener 앞에 기술된 객체를 가리킨다. Event.target 과 this 는 반드시 일치하지 않는다. 그러나, Event.currentTarget과 this는 언제나 일치한다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; div &#123; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button&gt;배경색 변경&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function bluify(e) &#123; // this: 이벤트에 바인딩된 DOM 요소(div 요소) console.log('this: ', this); // target: 실제로 이벤트를 발생시킨 요소(button 요소 또는 div 요소) console.log('e.target:', e.target); // currentTarget: 이벤트에 바인딩된 DOM 요소(div 요소) console.log('e.currentTarget: ', e.currentTarget); // 언제나 true console.log(this === e.currentTarget); // currentTarget과 target이 같은 객체일 때 true console.log(this === e.target); // click 이벤트가 발생하면 이벤트를 발생시킨 요소(target)과는 상관없이 this(이벤트에 바인딩된 div 요소)의 배경색이 변경된다. this.style.backgroundColor = '#A5D9F3'; &#125; // div 요소에 이벤트 핸들러가 바인딩되어 있다. // 자식 요소인 button이 발생시킨 이벤트가 버블링되어 div 요소에도 전파된다. // 따라서 div 요소에 이벤트 핸들러가 바인딩되어 있으면 자식 요소인 button이 발생시킨 이벤트를 div 요소에서도 핸들링할 수 있다. document.querySelector('div').addEventListener('click', bluify); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.type 발생한 이벤트의 종류를 나타내는 문자열을 반환한다. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;키를 입력하세요&lt;/p&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const body = document.querySelector('body'); function getEventType(e) &#123; console.log(e); document.querySelector('.message').innerHTML = `$&#123;e.type&#125; : $&#123;e.keyCode&#125;`; &#125; body.addEventListener('keydown', getEventType); body.addEventListener('keyup', getEventType); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.cancelable 요소의 기본 동작을 취소시킬 수 있는지 여부(true/false)를 나타낸다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"poiemaweb.com\"&gt;Go to poiemaweb.com&lt;/a&gt; &lt;script&gt; const elem = document.querySelector('a'); elem.addEventListener('click', function (e) &#123; console.log(e.cancelable); // 기본 동작을 중단시킨다. e.preventDefault(); // 해당 링크를 눌러도 이동되지않는다. &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.eventPhase 이벤트 흐름(event flow) 상에서 어느 단계(event phase)에 있는지를 반환한다. 반환값 의미 0 이벤트 없음 1 캡쳐링 단계 2 타깃 3 버블링 단계 Event Delegation (이벤트 위임) ​ &lt;li&gt;가 6개 있다고 가정했을 경우, 해당 태그에 모두 이벤트 반응 처리하고 싶다면 아래처럼 6개의 이벤트 핸들러를 구현해서 바인딩해야하는 비효율적인 면이 있다. 12345678910function printId() &#123; console.log(this.id);&#125;document.querySelector('#post-1').addEventListener('click', printId);document.querySelector('#post-2').addEventListener('click', printId);document.querySelector('#post-3').addEventListener('click', printId);document.querySelector('#post-4').addEventListener('click', printId);document.querySelector('#post-5').addEventListener('click', printId);document.querySelector('#post-6').addEventListener('click', printId); 6개 말고도 100개 1000개 라고 쳤을 때, 실행속도 저하 뿐만아니라 코드 작성의 불편함까지 겸비하고 있다. 동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. 이러한 경우 이벤트 위임을 사용한다. 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법 실제로 이벤트를 발생시킨 요소를 알아내기 위해서는 Event.target을 사용한다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul class=\"post-list\"&gt; &lt;li id=\"post-1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"post-2\"&gt;Item 2&lt;/li&gt; &lt;li id=\"post-3\"&gt;Item 3&lt;/li&gt; &lt;li id=\"post-4\"&gt;Item 4&lt;/li&gt; &lt;li id=\"post-5\"&gt;Item 5&lt;/li&gt; &lt;li id=\"post-6\"&gt;Item 6&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"msg\"&gt; &lt;script&gt; const msg = document.querySelector('.msg'); const list = document.querySelector('.post-list') list.addEventListener('click', function (e) &#123; // 이벤트를 발생시킨 요소 console.log('[target]: ' + e.target); // 이벤트를 발생시킨 요소의 nodeName console.log('[target.nodeName]: ' + e.target.nodeName); // li 요소 이외의 요소에서 발생한 이벤트는 대응하지 않는다. if (e.target &amp;&amp; e.target.nodeName === 'LI') &#123; msg.innerHTML = 'li#' + e.target.id + ' was clicked!'; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 기본 동작의 변경Event.preventDefault() 기본 동작을 중단 시킨다. 예를들어 폼을 submit 하거나 a태그의 링크를 클릭하면 페이지 이동이 발생하는데 이를 중단시킨다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;script&gt; document.querySelector('a').addEventListener('click', function (e) &#123; console.log(e.target, e.target.nodeName); // a 요소의 기본 동작을 중단한다. e.preventDefault(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.stopPropagation() 어느 한 요소를 이용해 이벤트를 처리한 후 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단시키기 위한 메소드. 부모 요소에 동일한 이벤트에 대한 다른 핸들러가 지정되어 있을 경우 사용된다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;버튼을 클릭하면 이벤트 전파를 중단한다. &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('click', function (event) &#123; console.log('Handler for button.'); // 이벤트 전파를 중단한다. event.stopPropagation(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1Handler for button. button 요소의 이벤트의 전파(버블링)을 중단시키기 위해 Event.stopPropagation 메소드를 이용하였다. preventDefault &amp; stopPropagation 기본 동작의 중단과 버블링 또는 캡처링의 중단을 동시에 실시하는 방법은 아래와 같다. 1return false; 단 이 방법은 jQuery를 사용할 때와 아래와 같이 사용할 때만 적용된다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\" onclick='return handleEvent()'&gt;go&lt;/a&gt; &lt;script&gt; function handleEvent() &#123; return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // within jQuery $('a').click(function (e) &#123; e.preventDefault(); // OK &#125;); $('a').click(function () &#123; return false; // OK --&gt; e.preventDefault() &amp; e.stopPropagation(). &#125;); // pure js document.querySelector('a').addEventListener('click', function(e) &#123; // e.preventDefault(); // OK return false; // NG!!!!! &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이 방법은 기본 동작의 중단과 이벤트 흐름의 중단 모두 적용되므로이 두가지 중 하나만 중단하기 원하는 경우는 preventDefault() 또는 stopPropagation() 메소드를 개별적으로 사용한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Event","slug":"Event","permalink":"https://hyeok999.github.io/tags/Event/"},{"name":"Property","slug":"Property","permalink":"https://hyeok999.github.io/tags/Property/"}]},{"title":"javascript-study-18","slug":"javascript-study-18","date":"2019-10-31T14:18:25.000Z","updated":"2019-11-30T17:00:25.395Z","comments":true,"path":"2019/10/31/javascript-study-18/","link":"","permalink":"https://hyeok999.github.io/2019/10/31/javascript-study-18/","excerpt":"","text":"JavaScript Study 18 이벤트 이벤트 란? 이벤트 루프 이벤트 루프(Event Loop)와 동시성(Concurrency) addEventListener 메소드 방식 이벤트의 종류 ( 참고 : Event reference ) UI Event Keyboard Event Mouse Event Focus Event Form Event Clipboard Event 이벤트 핸들러 등록 (3가지) 인라인 이벤트 핸들러 방식 이벤트 핸들러 프로퍼티 방식 addEventListener 메소드 방식 예1 예2 이벤트 핸들러 함수 내부의 this 인라인 이벤트 핸들러 방식 이벤트 핸들러 프로퍼티 방식 addEventListener 메소드 방식 이벤트의 흐름 캡처링 표현 예제 캡처링 예제 버블링 예제 캡처링 과 버블링 혼용 Event 객체 Event Property Event.target Event.currentTarget Event.type Event.cancelabel Event.eventPhase Event.Delegation 이벤트 위임 기본 동작의 변경 Event.preventDefault Event.stopPropagation preventDefault &amp; stopPropagation 용어 - ( 러버덕 ) 이벤트란? 이벤트 핸들러 등록 3가지 이벤트 핸들러 함수 내부의 this 버블링 캡처링 Event.tartget 이벤트 이벤트 란? 어떤 사건을 의미. 브라우저에서의 이벤트 - 예 : 사용자가 버튼을 클릭했을 때, 웹페이지가 로드되었을 때 등등 이벤트는 발생하는 시점이나 순서를 사전에 인지할 수 없다. 일반적인 제어 흐름과는 다른 접근 방식이 필요하다. 위와 같은 조건 떄문에 이벤트가 발생하면 누군가 이를 감지할 수 있어야 하며 그에 대응하는 처리를 호출해 주어야 한다. 브라우저는 이벤트를 감지할 수 있으며 이벤트 발생 시에는 통지해 준다.이 과정을 통해 사용자와 웹페이지는 상호작용(Interaction)이 가능하게 된다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"myButton\"&gt;Click me!&lt;/button&gt; &lt;script&gt; document.querySelector('.myButton').addEventListener('click', function () &#123; alert('Clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 버튼을 클릭 했을 때, 브라우저는 이벤트를 버튼 클릭이라는 이벤트를 감지하고서 그에 대응하는 처리alert를 호출해준다. 이벤트는 일반적으로 함수에 연결되며 그 함수는 이벤트가 발생하기 전에는 실행되지 않다가 이벤트가 발생되면 실행된다.이 함수를 이벤트 핸들러라 하며 이벤트에 대응하는 처리를 기술한다. ( 위 예제에서는 &#39;addEventListenter&#39;안에 있는 함수 가 이벤트 핸들러) ###이벤트 루프(Event Loop)와 동시성(Concurrency) 브라우저는 단일 쓰레드 에서 이벤트 드리븐 방식으로 동작한다. 단일쓰레드인데도 마치 멀티 쓰레드 마냥 동시에 처리되는 것처럼 느껴지는데 그것은 JS의 동시성을 지원하는 이벤트루프 때문이다. 브라우저의 환경은 다음과 같다. 구글의 V8을 비롯한 대부분의 JS엔진은 크게 2가지 영역으로 나눌 수 있다. Call Stack (호출 스택) 함수가 호출 되면(= 작업이 요청되면) 호출된 함수는 순차적으로 Cal Stack에 쌓이게 되고 순차적으로 실행 JS는 단 하나의 Call Stack을 이용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 실행 할 수 없다. Heap 동적으로 생성된 객체 인스턴스가 할당된느 영역 비동기(이벤트 포함) 처리는 JS엔진을 구동하는 환경인 브라우저(Node.js)가 담당한다. Event Queue(Task Queue) 비동기 처리 함수의 콜백함수, 비동기식 이벤트 헨들러, Timer 함수(setTimeout(), setInterval())의 콜백 함수가 보관되는 영역. 이벤트 루프에 의해 특정 시점(Call Stack이 비어졌을 떄)에 순차적으로 Call Stack으로 이동되어 실행. Event Loop(이벤트 루프) Call Stack 내에서 현재 실행 중인 task가 있는지 Event Queue에 task가 있는지 반복하여 확인. 만약 Call Stack이 비어있다면 Event Queue 내의 Task가 Call Stack으로 이동하고 실행. 예제1 123456789101112131415161718function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; setTimeout(function () &#123; console.log('func2'); &#125;, 0); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 함수 func1은 함수 func2을 호출한다. 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 콜백함수는 즉시 실행되지 않고 지정 대기 시간만큼 기다린다. “tick” 이벤트가 발생하면 태스크(이벤트) 큐로 이동한다. Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. 예제2 - DOM 이벤트 핸들러 12345678910111213141516171819202122function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; // &lt;button class=\"foo\"&gt;foo&lt;/button&gt; const elem = document.querySelector('.foo'); elem.addEventListener('click', function () &#123; this.style.backgroundColor = 'indigo'; console.log('func2'); &#125;); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 함수 func1은 함수 func2을 호출한다. 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 즉시 실행되지 않고 이벤트를 기다린다. foo버튼의 “click” 이벤트가 발생하면 태스크(이벤트) 큐로 이동한다. Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. 이벤트의 종류 ( 참고 : Event reference ) UI Event Event Description load 웹페이지의 로드가 완료되었을 때 unload 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우) error 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우 resize 브라우저 창의 크기를 조절했을 때 scroll 사용자가 페이지를 위아래로 스크롤할 때 select 텍스트를 선택했을 때 Keyboard Event Event Description keydown 키를 누르고 있을 때 keyup 누르고 있던 키를 뗄 때 keypress 키를 누르고 뗏을 때 Mouse Event Event Description click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 마우스 버튼을 누르고 있을 때 mouseup 누르고 있던 마우스 버튼을 뗄 때 mousemove 마우스를 움직일 때 (터치스크린에서 동작하지 않는다) mouseover 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다) mouseout 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다) Focus Event Event Description focus/focusin 요소가 포커스를 얻었을 때 blur/foucusout 요소가 포커스를 잃었을 때 Form Event Event Description input input 또는 textarea 요소의 값이 변경되었을 때 contenteditable 어트리뷰트를 가진 요소의 값이 변경되었을 때 change select box, checkbox, radio button의 상태가 변경되었을 때 submit form을 submit할 때 (버튼 또는 키) reset reset 버튼을 클릭할 때 (최근에는 사용 안함) Clipboard Event Event Description cut 콘텐츠를 잘라내기할 때 copy 콘텐츠를 복사할 때 paste 콘텐츠를 붙여넣기할 때 이벤트 핸들러 등록 (3가지)인라인 이벤트 핸들러 방식 더 이상 사용되고 있지 않은 방식. on으로 시작하는 이벤트 어트리뷰트의 값으로 함수 호출을 전달한다는 것. 이벤트 어트리뷰트의 값으로 전달한 함수 호출이 즉시 호출되는 것은 아니다. 사실은 이벤트 어트리뷰트 키를 이름으로 갖는 함수를 암묵적으로 정의하고 그 함수의 몸체에 이벤트 어트리뷰트의 값으로 전달한 함수 호출을 문으로 갖는다. 아래 예제 기준 = function onclick(event) { foo(); } 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"myHandler()\"&gt;Click me&lt;/button&gt; &lt;script&gt; function myHandler() &#123; alert('Button clicked!'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 프로퍼티 방식 HTML과 Javascript가 뒤섞이는 문제는 해결할 수 있는 방식. 하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바인딩할 수 있다는 단점이 있다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Click me&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); // 이벤트 핸들러 프로퍼티 방식은 이벤트에 하나의 이벤트 핸들러만을 바인딩할 수 있다 // 첫번째 바인딩된 이벤트 핸들러 =&gt; 실행되지 않는다. btn.onclick = function () &#123; alert('① Button clicked 1'); &#125;; // 두번째 바인딩된 이벤트 핸들러 btn.onclick = function () &#123; alert('① Button clicked 2'); &#125;; // addEventListener 메소드 방식 // 첫번째 바인딩된 이벤트 핸들러 btn.addEventListener('click', function () &#123; alert('② Button clicked 1'); &#125;); // 두번째 바인딩된 이벤트 핸들러 btn.addEventListener('click', function () &#123; alert('② Button clicked 2'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addEventListener 메소드 방식 대상 DOM 요소에 이벤트를 바인딩. 해당 이벤트가 발생했을 때 실행될 콜백 함수(이벤트 핸들러)를 지정. IE 9 이상에서 동작. IE 8 이하는 attachEvent 메소드를 사용. ( 참고 : attachEvent ) addEventListener 함수 방식은 이전 방식에 비해 아래와 같이 보다 나은 장점을 갖는다. 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가할 수 있다. 캡처링과 버블링을 지원한다. HTML 요소뿐만아니라 모든 DOM 요소(HTML, XML, SVG)에 대해 동작한다. 브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱하여 DOM을 생성한다. 예112345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; addEventListener('click', function () &#123; alert('Clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM 요소를 지정 안해주면 전역객체 window(브라우저의 윈도우)에서 발생되는 click 이벤트에 이벤트 핸들러를 바인딩한다. 예21234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label&gt;User name &lt;input type='text'&gt;&lt;/label&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const input = document.querySelector('input[type=text]'); const msg = document.querySelector('.message'); input.addEventListener('blur', function () &#123; if (input.value.length &lt; 2) &#123; msg.innerHTML = '이름은 2자 이상 입력해 주세요'; &#125; else &#123; msg.innerHTML = ''; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; blur 이벤트는 포커스를 잃을 경우 생기는 이벤트다. 키보드로 input 내부에 내용을 입력 후 글자수가 모자르다면 다른 곳을 클릭, tab 하였을 때 이벤트가 호출된다. 위와 같은 코드는 좋지 못한 코드다 이유는 ‘2’라는 원시값을 통해서 어떤 이벤트가 실행될 지를 판별하는데 코드가 길어질수록 저런 식으로 원시값을 하나하나 변경하는 것은 시간낭비 와 실수를 유발한다. 해결 방법으로는 ‘2’ 라는 원시값을 상수화 하고 상수를 함수의 인수로 받는 함수를 작성한다.문제는 이럴경우 이벤트 핸들러 프로퍼티 처럼 1개의 함수만 전달할 수 있게된다.이를 해결 하기 위해 addEventListener에서 익명 함수를 작성한다면 내부에서 여러개의 함수를 받을 수 있다. 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label&gt;User name &lt;input type='text'&gt;&lt;/label&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const MIN_USER_NAME_LENGTH = 2; // 이름 최소 길이 const input = document.querySelector('input[type=text]'); const msg = document.querySelector('.message'); function checkUserNameLength(n) &#123; if (input.value.length &lt; n) &#123; msg.innerHTML = '이름은 ' + n + '자 이상이어야 합니다'; &#125; else &#123; msg.innerHTML = ''; &#125; &#125; input.addEventListener('blur', function () &#123; // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. checkUserNameLength(MIN_USER_NAME_LENGTH); &#125;); // 이벤트 핸들러 프로퍼티 방식도 동일한 방식으로 인수를 전달할 수 있다. // input.onblur = function () &#123; // // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. // checkUserNameLength(MIN_USER_NAME_LENGTH); // &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 함수 내부의 this인라인 이벤트 핸들러 방식 이벤트 핸들러는 일반 함수로서 호출되므로 이벤트 핸들러 내부의 this는 전역 객체 window를 가리킨다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"foo()\"&gt;Button&lt;/button&gt; &lt;script&gt; function foo () &#123; console.log(this); // window &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 프로퍼티 방식 이벤트 핸들러는 메소드이므로 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킨다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); btn.onclick = function (e) &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(e.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === e.currentTarget); // true &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addEventListener 메소드 방식 이벤트 핸들러는 콜백 함수이지만 이벤트 핸들러 내부의 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); btn.addEventListener('click', function (e) &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(e.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === e.currentTarget); // true &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트의 흐름HTML 요소는 계층적 구조에 포함되어 있다.이 요소에 이벤트가 발생되면 연쇄적 반응이 얼어난다.이것을 이벤트전파라 하고 전파 방향에 따라 버블링(Event Bubbling)과 캡처링(Event Capturing)으로 구분할 수 있다. 버블링 : 자식요소에서 발생한 이벤트가 부모요소로 전파 캡처링 : 부모요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달 캡처링 과 버블링은 둘 중 하나만 발생되는 개념이 아니라 캠처링부터 시작해 버블링으로 종료한다. addEventListener 메소드의 세번째 매개변수에 true를 설정하면 캡처링으로 전파되는 이벤트를 캐치하고 false 또는 미설정하면 버블링으로 전파되는 이벤트를 캐치한다. 캡처링 표현 예제1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html &#123; border:1px solid red; padding:30px; text-align: center; &#125; body &#123; border:1px solid green; padding:30px; &#125; .top &#123; width: 300px; height: 300px; background-color: red; margin: auto; &#125; .middle &#123; width: 200px; height: 200px; background-color: blue; position: relative; top: 34px; left: 50px; &#125; .bottom &#123; width: 100px; height: 100px; background-color: yellow; position: relative; top: 34px; left: 50px; line-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; body &lt;div class=\"top\"&gt;top &lt;div class=\"middle\"&gt;middle &lt;div class=\"bottom\"&gt;bottom&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // true: capturing / false: bubbling const useCature = true; const handler = function (e) &#123; const phases = ['capturing', 'target', 'bubbling']; const node = this.nodeName + (this.className ? '.' + this.className : ''); // eventPhase: 이벤트 흐름 상에서 어느 phase에 있는지를 반환한다. // 0 : 이벤트 없음 / 1 : 캡처링 단계 / 2 : 타깃 / 3 : 버블링 단계 console.log(node, phases[e.eventPhase - 1]); alert(node + ' : ' + phases[e.eventPhase - 1]); &#125;; document.querySelector('html').addEventListener('click', handler, useCature); document.querySelector('body').addEventListener('click', handler, useCature); document.querySelector('div.top').addEventListener('click', handler, useCature); document.querySelector('div.middle').addEventListener('click', handler, useCature); document.querySelector('div.bottom').addEventListener('click', handler, useCature); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 버블링 예제123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;버블링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과는 다음과 같다. 캡쳐링 이벤트 흐름에 대해서는 동작하지 않는다. 123Handler for button.Handler for paragraph.Handler for body. 캡처링 예제123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;캡처링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 캡처링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;, true); // 캡처링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;, true); // 캡처링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;, true); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과는 다음과 같다. 버블링 이벤트 흐름에 동작하지 않는다. 123Handler for body.Handler for paragraph.Handler for button. 캡처링 과 버블링 혼용123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;버블링과 캡처링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 캡처링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;, true); // 버블링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 코드는 body, button 요소는 버블링 이벤트 흐름을 캐치하고 p 요소는 캡처링 이벤트 흐름만을 캐치한다. 따라서 결과는 다음과 같다. 123Handler for paragraph.Handler for button.Handler for body. Event 객체 event 객체는 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 유용한 정보를 제공한다. 이벤트가 발생하면 event 객체는 동적으로 생성되며 이벤트를 처리할 수 있는 이벤트 핸들러에 인자로 전달된다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;클릭하세요. 클릭한 곳의 좌표가 표시됩니다.&lt;/p&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function showCoords(e) &#123; // e: event object const msg = document.querySelector('.message'); msg.innerHTML = 'clientX value: ' + e.clientX + '&lt;br&gt;' + 'clientY value: ' + e.clientY; &#125; addEventListener('click', showCoords); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위와 같이 event 객체는 이벤트 핸들러에 암묵적으로 전달된다. 이벤트 핸들러를 선언할 때, event 객체를 전달받을 첫번째 매개변수를 명시적으로 선언하는 것이 좋다. 따라서 함수로 1번더 감싸고 addEventListener를 호출 할 때 익명함수로 event객체를 넘겨준다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function showCoords(e, msg) &#123; msg.innerHTML = 'clientX value: ' + e.clientX + '&lt;br&gt;' + 'clientY value: ' + e.clientY; &#125; const msg = document.querySelector('.message'); addEventListener('click', function (e) &#123; showCoords(e, msg); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event PropertyEvent.target 실제로 이벤트를 발생시킨 요소를 가리킴 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;button id=\"btn1\"&gt;Hide me 1&lt;/button&gt; &lt;button id=\"btn2\"&gt;Hide me 2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function hide(e) &#123; e.target.style.visibility = 'hidden'; // 동일하게 동작한다. // this.style.visibility = 'hidden'; &#125; document.getElementById('btn1').addEventListener('click', hide); document.getElementById('btn2').addEventListener('click', hide); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 여기서 event객체는 btn1 과 btn2를 각각 가리키고 있기 때문에 this와 별반 차이가 없다. 하지만 아래 예제를 보자. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;button id=\"btn1\"&gt;Hide me 1&lt;/button&gt; &lt;button id=\"btn2\"&gt;Hide me 2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const container = document.querySelector('.container'); function hide(e) &#123; // e.target은 실제로 이벤트를 발생시킨 DOM 요소를 가리킨다. e.target.style.visibility = 'hidden'; // this는 이벤트에 바인딩된 DOM 요소(.container)를 가리킨다. 따라서 .container 요소를 감춘다. // this.style.visibility = 'hidden'; &#125; container.addEventListener('click', hide); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이 예제처럼 this는 자신이 불러들인 객체를 바인딩하기 때문에 DOM 요소(.container)를 가리킨다. 따라서 버튼 1개 클릭시 전부 가리게 되는데 반면에 event객체의 e.target은 실제로 인벤트를 발생시킨 DOM요소를 의미한다. 따라서 Event.target은 this와 반드시 일치하지는 않는다. Event.currentTarget 이벤트에 바인딩된 DOM 요소를 가리킴. addEventListener 앞에 기술된 객체를 가리킨다. Event.target 과 this 는 반드시 일치하지 않는다. 그러나, Event.currentTarget과 this는 언제나 일치한다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; div &#123; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button&gt;배경색 변경&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function bluify(e) &#123; // this: 이벤트에 바인딩된 DOM 요소(div 요소) console.log('this: ', this); // target: 실제로 이벤트를 발생시킨 요소(button 요소 또는 div 요소) console.log('e.target:', e.target); // currentTarget: 이벤트에 바인딩된 DOM 요소(div 요소) console.log('e.currentTarget: ', e.currentTarget); // 언제나 true console.log(this === e.currentTarget); // currentTarget과 target이 같은 객체일 때 true console.log(this === e.target); // click 이벤트가 발생하면 이벤트를 발생시킨 요소(target)과는 상관없이 this(이벤트에 바인딩된 div 요소)의 배경색이 변경된다. this.style.backgroundColor = '#A5D9F3'; &#125; // div 요소에 이벤트 핸들러가 바인딩되어 있다. // 자식 요소인 button이 발생시킨 이벤트가 버블링되어 div 요소에도 전파된다. // 따라서 div 요소에 이벤트 핸들러가 바인딩되어 있으면 자식 요소인 button이 발생시킨 이벤트를 div 요소에서도 핸들링할 수 있다. document.querySelector('div').addEventListener('click', bluify); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.type 발생한 이벤트의 종류를 나타내는 문자열을 반환한다. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;키를 입력하세요&lt;/p&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const body = document.querySelector('body'); function getEventType(e) &#123; console.log(e); document.querySelector('.message').innerHTML = `$&#123;e.type&#125; : $&#123;e.keyCode&#125;`; &#125; body.addEventListener('keydown', getEventType); body.addEventListener('keyup', getEventType); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.cancelable 요소의 기본 동작을 취소시킬 수 있는지 여부(true/false)를 나타낸다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"poiemaweb.com\"&gt;Go to poiemaweb.com&lt;/a&gt; &lt;script&gt; const elem = document.querySelector('a'); elem.addEventListener('click', function (e) &#123; console.log(e.cancelable); // 기본 동작을 중단시킨다. e.preventDefault(); // 해당 링크를 눌러도 이동되지않는다. &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.eventPhase 이벤트 흐름(event flow) 상에서 어느 단계(event phase)에 있는지를 반환한다. 반환값 의미 0 이벤트 없음 1 캡쳐링 단계 2 타깃 3 버블링 단계 Event Delegation (이벤트 위임) ​ &lt;li&gt;가 6개 있다고 가정했을 경우, 해당 태그에 모두 이벤트 반응 처리하고 싶다면 아래처럼 6개의 이벤트 핸들러를 구현해서 바인딩해야하는 비효율적인 면이 있다. 12345678910function printId() &#123; console.log(this.id);&#125;document.querySelector('#post-1').addEventListener('click', printId);document.querySelector('#post-2').addEventListener('click', printId);document.querySelector('#post-3').addEventListener('click', printId);document.querySelector('#post-4').addEventListener('click', printId);document.querySelector('#post-5').addEventListener('click', printId);document.querySelector('#post-6').addEventListener('click', printId); 6개 말고도 100개 1000개 라고 쳤을 때, 실행속도 저하 뿐만아니라 코드 작성의 불편함까지 겸비하고 있다. 동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. 이러한 경우 이벤트 위임을 사용한다. 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법 실제로 이벤트를 발생시킨 요소를 알아내기 위해서는 Event.target을 사용한다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul class=\"post-list\"&gt; &lt;li id=\"post-1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"post-2\"&gt;Item 2&lt;/li&gt; &lt;li id=\"post-3\"&gt;Item 3&lt;/li&gt; &lt;li id=\"post-4\"&gt;Item 4&lt;/li&gt; &lt;li id=\"post-5\"&gt;Item 5&lt;/li&gt; &lt;li id=\"post-6\"&gt;Item 6&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"msg\"&gt; &lt;script&gt; const msg = document.querySelector('.msg'); const list = document.querySelector('.post-list') list.addEventListener('click', function (e) &#123; // 이벤트를 발생시킨 요소 console.log('[target]: ' + e.target); // 이벤트를 발생시킨 요소의 nodeName console.log('[target.nodeName]: ' + e.target.nodeName); // li 요소 이외의 요소에서 발생한 이벤트는 대응하지 않는다. if (e.target &amp;&amp; e.target.nodeName === 'LI') &#123; msg.innerHTML = 'li#' + e.target.id + ' was clicked!'; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 기본 동작의 변경Event.preventDefault() 기본 동작을 중단 시킨다. 예를들어 폼을 submit 하거나 a태그의 링크를 클릭하면 페이지 이동이 발생하는데 이를 중단시킨다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;script&gt; document.querySelector('a').addEventListener('click', function (e) &#123; console.log(e.target, e.target.nodeName); // a 요소의 기본 동작을 중단한다. e.preventDefault(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.stopPropagation() 어느 한 요소를 이용해 이벤트를 처리한 후 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단시키기 위한 메소드. 부모 요소에 동일한 이벤트에 대한 다른 핸들러가 지정되어 있을 경우 사용된다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;버튼을 클릭하면 이벤트 전파를 중단한다. &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('click', function (event) &#123; console.log('Handler for button.'); // 이벤트 전파를 중단한다. event.stopPropagation(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1Handler for button. button 요소의 이벤트의 전파(버블링)을 중단시키기 위해 Event.stopPropagation 메소드를 이용하였다. preventDefault &amp; stopPropagation 기본 동작의 중단과 버블링 또는 캡처링의 중단을 동시에 실시하는 방법은 아래와 같다. 1return false; 단 이 방법은 jQuery를 사용할 때와 아래와 같이 사용할 때만 적용된다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\" onclick='return handleEvent()'&gt;go&lt;/a&gt; &lt;script&gt; function handleEvent() &#123; return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // within jQuery $('a').click(function (e) &#123; e.preventDefault(); // OK &#125;); $('a').click(function () &#123; return false; // OK --&gt; e.preventDefault() &amp; e.stopPropagation(). &#125;); // pure js document.querySelector('a').addEventListener('click', function(e) &#123; // e.preventDefault(); // OK return false; // NG!!!!! &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이 방법은 기본 동작의 중단과 이벤트 흐름의 중단 모두 적용되므로이 두가지 중 하나만 중단하기 원하는 경우는 preventDefault() 또는 stopPropagation() 메소드를 개별적으로 사용한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 31강(M)~32강(M) (비동기식모델 vs 동기식모델 , Event)","slug":"javascript-preview-31m32m","date":"2019-10-31T01:53:00.000Z","updated":"2019-11-30T17:04:47.195Z","comments":true,"path":"2019/10/31/javascript-preview-31m32m/","link":"","permalink":"https://hyeok999.github.io/2019/10/31/javascript-preview-31m32m/","excerpt":"","text":"JavaScript 31강m ~ 32강m 예습 31강 : 동기식 처리 모델 vs 비동기식 처리 모델 동기식 처리 모델 동기식 처리 모델 코드 비동기식 처리 모델 비동기식 처리 모델 코드 32강 : 이벤트 이벤트 란? 이벤트 루프 이벤트 루프(Event Loop)와 동시성(Concurrency) addEventListener 메소드 방식 이벤트의 종류 ( 참고 : Event reference ) UI Event Keyboard Event Mouse Event Focus Event Form Event Clipboard Event 이벤트 핸들러 등록 (3가지) 인라인 이벤트 핸들러 방식 이벤트 핸들러 프로퍼티 방식 addEventListener 메소드 방식 예1 예2 이벤트 핸들러 함수 내부의 this 인라인 이벤트 핸들러 방식 이벤트 핸들러 프로퍼티 방식 addEventListener 메소드 방식 이벤트의 흐름 캡처링 표현 예제 캡처링 예제 버블링 예제 캡처링 과 버블링 혼용 Event 객체 Event Property Event.target Event.cancelabel Event.eventPhase Event.Delegation 기본 동작의 변경 Event.preventDefault Event.stopPropagation preventDefault &amp; stopPropagation 31강m동기식 처리 모델 vs 비동기식 처리 모델 동기식 처리 모델 직렬적으로 태스크(task)를 수행한다. 태스크(task)는 순차적이다. 어떤 작업이 진행 중이면 다음 작업은 대기해야한다. 자바스크립트는 동기식 처리 모델이다.서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때,서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 태스크들은 블로킹(blocking, 작업 중단)된다. 동기식 처리 모델 코드123456789101112131415function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; console.log('func2'); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 비동기식 처리 모델 병렬적으로 태스크를 수행한다. 즉, 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다. 자바스크립트는 비동기식 처리 모델이다.서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때,서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고 즉시 다음 태스크를 수행한다.이후, 서버로부터 데이터가 응답되면 이벤트가 발생하고 이벤트 핸들러가 데이터를 가지고 수행할 테스크를 게속해 수행한다. 비동기식 처리 모델 코드123456789101112131415161718function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; setTimeout(function() &#123; console.log('func2'); &#125;, 0); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 위 예제의 setTimeout 메소드는 비동기 함수이다.따라서 setTimeout의 인터벌을 0초로 설정해도 콘솔에 func1 func2 func3 의 순서로 로그가 출력되지 않는다. 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 함수 func1은 함수 func2을 호출한다. 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 콜백함수는 즉시 실행되지 않고 지정 대기 시간만큼 기다린다. “tick” 이벤트가 발생하면 태스크(이벤트) 큐로 이동한다. Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. 32강m이벤트 이벤트 란? 어떤 사건을 의미. 브라우저에서의 이벤트 - 예 : 사용자가 버튼을 클릭했을 때, 웹페이지가 로드되었을 때 등등 이벤트는 발생하는 시점이나 순서를 사전에 인지할 수 없다. 일반적인 제어 흐름과는 다른 접근 방식이 필요하다. 위와 같은 조건 떄문에 이벤트가 발생하면 누군가 이를 감지할 수 있어야 하며 그에 대응하는 처리를 호출해 주어야 한다. 브라우저는 이벤트를 감지할 수 있으며 이벤트 발생 시에는 통지해 준다.이 과정을 통해 사용자와 웹페이지는 상호작용(Interaction)이 가능하게 된다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"myButton\"&gt;Click me!&lt;/button&gt; &lt;script&gt; document.querySelector('.myButton').addEventListener('click', function () &#123; alert('Clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 버튼을 클릭 했을 때, 브라우저는 이벤트를 버튼 클릭이라는 이벤트를 감지하고서 그에 대응하는 처리alert를 호출해준다. 이벤트는 일반적으로 함수에 연결되며 그 함수는 이벤트가 발생하기 전에는 실행되지 않다가 이벤트가 발생되면 실행된다.이 함수를 이벤트 핸들러라 하며 이벤트에 대응하는 처리를 기술한다. ( 위 예제에서는 &#39;addEventListenter&#39;안에 있는 함수 가 이벤트 핸들러) ###이벤트 루프(Event Loop)와 동시성(Concurrency) 브라우저는 단일 쓰레드 에서 이벤트 드리븐 방식으로 동작한다. 단일쓰레드인데도 마치 멀티 쓰레드 마냥 동시에 처리되는 것처럼 느껴지는데 그것은 JS의 동시성을 지원하는 이벤트루프 때문이다. 브라우저의 환경은 다음과 같다. 구글의 V8을 비롯한 대부분의 JS엔진은 크게 2가지 영역으로 나눌 수 있다. Call Stack (호출 스택) 함수가 호출 되면(= 작업이 요청되면) 호출된 함수는 순차적으로 Cal Stack에 쌓이게 되고 순차적으로 실행 JS는 단 하나의 Call Stack을 이용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 실행 할 수 없다. Heap 동적으로 생성된 객체 인스턴스가 할당된느 영역 비동기(이벤트 포함) 처리는 JS엔진을 구동하는 환경인 브라우저(Node.js)가 담당한다. Event Queue(Task Queue) 비동기 처리 함수의 콜백함수, 비동기식 이벤트 헨들러, Timer 함수(setTimeout(), setInterval())의 콜백 함수가 보관되는 영역. 이벤트 루프에 의해 특정 시점(Call Stack이 비어졌을 떄)에 순차적으로 Call Stack으로 이동되어 실행. Event Loop(이벤트 루프) Call Stack 내에서 현재 실행 중인 task가 있는지 Event Queue에 task가 있는지 반복하여 확인. 만약 Call Stack이 비어있다면 Event Queue 내의 Task가 Call Stack으로 이동하고 실행. 예제1 123456789101112131415161718function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; setTimeout(function () &#123; console.log('func2'); &#125;, 0); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 함수 func1은 함수 func2을 호출한다. 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 콜백함수는 즉시 실행되지 않고 지정 대기 시간만큼 기다린다. “tick” 이벤트가 발생하면 태스크(이벤트) 큐로 이동한다. Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. 예제2 - DOM 이벤트 핸들러 12345678910111213141516171819202122function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; // &lt;button class=\"foo\"&gt;foo&lt;/button&gt; const elem = document.querySelector('.foo'); elem.addEventListener('click', function () &#123; this.style.backgroundColor = 'indigo'; console.log('func2'); &#125;); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 함수 func1은 함수 func2을 호출한다. 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 즉시 실행되지 않고 이벤트를 기다린다. foo버튼의 “click” 이벤트가 발생하면 태스크(이벤트) 큐로 이동한다. Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. 이벤트의 종류 ( 참고 : Event reference ) UI Event Event Description load 웹페이지의 로드가 완료되었을 때 unload 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우) error 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우 resize 브라우저 창의 크기를 조절했을 때 scroll 사용자가 페이지를 위아래로 스크롤할 때 select 텍스트를 선택했을 때 Keyboard Event Event Description keydown 키를 누르고 있을 때 keyup 누르고 있던 키를 뗄 때 keypress 키를 누르고 뗏을 때 Mouse Event Event Description click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 마우스 버튼을 누르고 있을 때 mouseup 누르고 있던 마우스 버튼을 뗄 때 mousemove 마우스를 움직일 때 (터치스크린에서 동작하지 않는다) mouseover 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다) mouseout 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다) Focus Event Event Description focus/focusin 요소가 포커스를 얻었을 때 blur/foucusout 요소가 포커스를 잃었을 때 Form Event Event Description input input 또는 textarea 요소의 값이 변경되었을 때 contenteditable 어트리뷰트를 가진 요소의 값이 변경되었을 때 change select box, checkbox, radio button의 상태가 변경되었을 때 submit form을 submit할 때 (버튼 또는 키) reset reset 버튼을 클릭할 때 (최근에는 사용 안함) Clipboard Event Event Description cut 콘텐츠를 잘라내기할 때 copy 콘텐츠를 복사할 때 paste 콘텐츠를 붙여넣기할 때 이벤트 핸들러 등록 (3가지)인라인 이벤트 핸들러 방식 더 이상 사용되고 있지 않은 방식. on으로 시작하는 이벤트 어트리뷰트의 값으로 함수 호출을 전달한다는 것. 이벤트 어트리뷰트의 값으로 전달한 함수 호출이 즉시 호출되는 것은 아니다. 사실은 이벤트 어트리뷰트 키를 이름으로 갖는 함수를 암묵적으로 정의하고 그 함수의 몸체에 이벤트 어트리뷰트의 값으로 전달한 함수 호출을 문으로 갖는다. 아래 예제 기준 = function onclick(event) { foo(); } 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"myHandler()\"&gt;Click me&lt;/button&gt; &lt;script&gt; function myHandler() &#123; alert('Button clicked!'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 프로퍼티 방식 HTML과 Javascript가 뒤섞이는 문제는 해결할 수 있는 방식. 하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바인딩할 수 있다는 단점이 있다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Click me&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); // 이벤트 핸들러 프로퍼티 방식은 이벤트에 하나의 이벤트 핸들러만을 바인딩할 수 있다 // 첫번째 바인딩된 이벤트 핸들러 =&gt; 실행되지 않는다. btn.onclick = function () &#123; alert('① Button clicked 1'); &#125;; // 두번째 바인딩된 이벤트 핸들러 btn.onclick = function () &#123; alert('① Button clicked 2'); &#125;; // addEventListener 메소드 방식 // 첫번째 바인딩된 이벤트 핸들러 btn.addEventListener('click', function () &#123; alert('② Button clicked 1'); &#125;); // 두번째 바인딩된 이벤트 핸들러 btn.addEventListener('click', function () &#123; alert('② Button clicked 2'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addEventListener 메소드 방식 대상 DOM 요소에 이벤트를 바인딩. 해당 이벤트가 발생했을 때 실행될 콜백 함수(이벤트 핸들러)를 지정. IE 9 이상에서 동작. IE 8 이하는 attachEvent 메소드를 사용. ( 참고 : attachEvent ) addEventListener 함수 방식은 이전 방식에 비해 아래와 같이 보다 나은 장점을 갖는다. 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가할 수 있다. 캡처링과 버블링을 지원한다. HTML 요소뿐만아니라 모든 DOM 요소(HTML, XML, SVG)에 대해 동작한다. 브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱하여 DOM을 생성한다. 예112345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; addEventListener('click', function () &#123; alert('Clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM 요소를 지정 안해주면 전역객체 window(브라우저의 윈도우)에서 발생되는 click 이벤트에 이벤트 핸들러를 바인딩한다. 예21234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label&gt;User name &lt;input type='text'&gt;&lt;/label&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const input = document.querySelector('input[type=text]'); const msg = document.querySelector('.message'); input.addEventListener('blur', function () &#123; if (input.value.length &lt; 2) &#123; msg.innerHTML = '이름은 2자 이상 입력해 주세요'; &#125; else &#123; msg.innerHTML = ''; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; blur 이벤트는 포커스를 잃을 경우 생기는 이벤트다. 키보드로 input 내부에 내용을 입력 후 글자수가 모자르다면 다른 곳을 클릭, tab 하였을 때 이벤트가 호출된다. 위와 같은 코드는 좋지 못한 코드다 이유는 ‘2’라는 원시값을 통해서 어떤 이벤트가 실행될 지를 판별하는데 코드가 길어질수록 저런 식으로 원시값을 하나하나 변경하는 것은 시간낭비 와 실수를 유발한다. 해결 방법으로는 ‘2’ 라는 원시값을 상수화 하고 상수를 함수의 인수로 받는 함수를 작성한다.문제는 이럴경우 이벤트 핸들러 프로퍼티 처럼 1개의 함수만 전달할 수 있게된다.이를 해결 하기 위해 addEventListener에서 익명 함수를 작성한다면 내부에서 여러개의 함수를 받을 수 있다. 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label&gt;User name &lt;input type='text'&gt;&lt;/label&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const MIN_USER_NAME_LENGTH = 2; // 이름 최소 길이 const input = document.querySelector('input[type=text]'); const msg = document.querySelector('.message'); function checkUserNameLength(n) &#123; if (input.value.length &lt; n) &#123; msg.innerHTML = '이름은 ' + n + '자 이상이어야 합니다'; &#125; else &#123; msg.innerHTML = ''; &#125; &#125; input.addEventListener('blur', function () &#123; // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. checkUserNameLength(MIN_USER_NAME_LENGTH); &#125;); // 이벤트 핸들러 프로퍼티 방식도 동일한 방식으로 인수를 전달할 수 있다. // input.onblur = function () &#123; // // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. // checkUserNameLength(MIN_USER_NAME_LENGTH); // &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 함수 내부의 this인라인 이벤트 핸들러 방식 이벤트 핸들러는 일반 함수로서 호출되므로 이벤트 핸들러 내부의 this는 전역 객체 window를 가리킨다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"foo()\"&gt;Button&lt;/button&gt; &lt;script&gt; function foo () &#123; console.log(this); // window &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트 핸들러 프로퍼티 방식 이벤트 핸들러는 메소드이므로 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킨다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); btn.onclick = function (e) &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(e.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === e.currentTarget); // true &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addEventListener 메소드 방식 이벤트 핸들러는 콜백 함수이지만 이벤트 핸들러 내부의 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; const btn = document.querySelector('.btn'); btn.addEventListener('click', function (e) &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(e.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === e.currentTarget); // true &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트의 흐름HTML 요소는 계층적 구조에 포함되어 있다.이 요소에 이벤트가 발생되면 연쇄적 반응이 얼어난다.이것을 이벤트전파라 하고 전파 방향에 따라 버블링(Event Bubbling)과 캡처링(Event Capturing)으로 구분할 수 있다. 버블링 : 자식요소에서 발생한 이벤트가 부모요소로 전파 캡처링 : 부모요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달 캡처링 과 버블링은 둘 중 하나만 발생되는 개념이 아니라 캠처링부터 시작해 버블링으로 종료한다. addEventListener 메소드의 세번째 매개변수에 true를 설정하면 캡처링으로 전파되는 이벤트를 캐치하고 false 또는 미설정하면 버블링으로 전파되는 이벤트를 캐치한다. 캡처링 표현 예제1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html &#123; border:1px solid red; padding:30px; text-align: center; &#125; body &#123; border:1px solid green; padding:30px; &#125; .top &#123; width: 300px; height: 300px; background-color: red; margin: auto; &#125; .middle &#123; width: 200px; height: 200px; background-color: blue; position: relative; top: 34px; left: 50px; &#125; .bottom &#123; width: 100px; height: 100px; background-color: yellow; position: relative; top: 34px; left: 50px; line-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; body &lt;div class=\"top\"&gt;top &lt;div class=\"middle\"&gt;middle &lt;div class=\"bottom\"&gt;bottom&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // true: capturing / false: bubbling const useCature = true; const handler = function (e) &#123; const phases = ['capturing', 'target', 'bubbling']; const node = this.nodeName + (this.className ? '.' + this.className : ''); // eventPhase: 이벤트 흐름 상에서 어느 phase에 있는지를 반환한다. // 0 : 이벤트 없음 / 1 : 캡처링 단계 / 2 : 타깃 / 3 : 버블링 단계 console.log(node, phases[e.eventPhase - 1]); alert(node + ' : ' + phases[e.eventPhase - 1]); &#125;; document.querySelector('html').addEventListener('click', handler, useCature); document.querySelector('body').addEventListener('click', handler, useCature); document.querySelector('div.top').addEventListener('click', handler, useCature); document.querySelector('div.middle').addEventListener('click', handler, useCature); document.querySelector('div.bottom').addEventListener('click', handler, useCature); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 버블링 예제123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;버블링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과는 다음과 같다. 캡쳐링 이벤트 흐름에 대해서는 동작하지 않는다. 123Handler for button.Handler for paragraph.Handler for body. 캡처링 예제123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;캡처링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 캡처링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;, true); // 캡처링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;, true); // 캡처링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;, true); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과는 다음과 같다. 버블링 이벤트 흐름에 동작하지 않는다. 123Handler for body.Handler for paragraph.Handler for button. 캡처링 과 버블링 혼용123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;버블링과 캡처링 이벤트 &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 캡처링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;, true); // 버블링 button.addEventListener('click', function () &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 코드는 body, button 요소는 버블링 이벤트 흐름을 캐치하고 p 요소는 캡처링 이벤트 흐름만을 캐치한다. 따라서 결과는 다음과 같다. 123Handler for paragraph.Handler for button.Handler for body. Event 객체 event 객체는 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 유용한 정보를 제공한다. 이벤트가 발생하면 event 객체는 동적으로 생성되며 이벤트를 처리할 수 있는 이벤트 핸들러에 인자로 전달된다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;클릭하세요. 클릭한 곳의 좌표가 표시됩니다.&lt;/p&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function showCoords(e) &#123; // e: event object const msg = document.querySelector('.message'); msg.innerHTML = 'clientX value: ' + e.clientX + '&lt;br&gt;' + 'clientY value: ' + e.clientY; &#125; addEventListener('click', showCoords); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위와 같이 event 객체는 이벤트 핸들러에 암묵적으로 전달된다. 이벤트 핸들러를 선언할 때, event 객체를 전달받을 첫번째 매개변수를 명시적으로 선언하는 것이 좋다. 따라서 함수로 1번더 감싸고 addEventListener를 호출 할 때 익명함수로 event객체를 넘겨준다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function showCoords(e, msg) &#123; msg.innerHTML = 'clientX value: ' + e.clientX + '&lt;br&gt;' + 'clientY value: ' + e.clientY; &#125; const msg = document.querySelector('.message'); addEventListener('click', function (e) &#123; showCoords(e, msg); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event PropertyEvent.target 실제로 이벤트를 발생시킨 요소를 가리킴 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;button id=\"btn1\"&gt;Hide me 1&lt;/button&gt; &lt;button id=\"btn2\"&gt;Hide me 2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function hide(e) &#123; e.target.style.visibility = 'hidden'; // 동일하게 동작한다. // this.style.visibility = 'hidden'; &#125; document.getElementById('btn1').addEventListener('click', hide); document.getElementById('btn2').addEventListener('click', hide); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 여기서 event객체는 btn1 과 btn2를 각각 가리키고 있기 때문에 this와 별반 차이가 없다. 하지만 아래 예제를 보자. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;button id=\"btn1\"&gt;Hide me 1&lt;/button&gt; &lt;button id=\"btn2\"&gt;Hide me 2&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const container = document.querySelector('.container'); function hide(e) &#123; // e.target은 실제로 이벤트를 발생시킨 DOM 요소를 가리킨다. e.target.style.visibility = 'hidden'; // this는 이벤트에 바인딩된 DOM 요소(.container)를 가리킨다. 따라서 .container 요소를 감춘다. // this.style.visibility = 'hidden'; &#125; container.addEventListener('click', hide); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이 예제처럼 this는 자신이 불러들인 객체를 바인딩하기 때문에 DOM 요소(.container)를 가리킨다. 따라서 버튼 1개 클릭시 전부 가리게 되는데 반면에 event객체의 e.target은 실제로 인벤트를 발생시킨 DOM요소를 의미한다. 따라서 Event.target은 this와 반드시 일치하지는 않는다. Event.currentTarget 이벤트에 바인딩된 DOM 요소를 가리킴. addEventListener 앞에 기술된 객체를 가리킨다. Event.target 과 this 는 반드시 일치하지 않는다. 그러나, Event.currentTarget과 this는 언제나 일치한다. Event.type 발생한 이벤트의 종류를 나타내는 문자열을 반환한다. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;키를 입력하세요&lt;/p&gt; &lt;em class=\"message\"&gt;&lt;/em&gt; &lt;script&gt; const body = document.querySelector('body'); function getEventType(e) &#123; console.log(e); document.querySelector('.message').innerHTML = `$&#123;e.type&#125; : $&#123;e.keyCode&#125;`; &#125; body.addEventListener('keydown', getEventType); body.addEventListener('keyup', getEventType); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.cancelable 요소의 기본 동작을 취소시킬 수 있는지 여부(true/false)를 나타낸다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"poiemaweb.com\"&gt;Go to poiemaweb.com&lt;/a&gt; &lt;script&gt; const elem = document.querySelector('a'); elem.addEventListener('click', function (e) &#123; console.log(e.cancelable); // 기본 동작을 중단시킨다. e.preventDefault(); // 해당 링크를 눌러도 이동되지않는다. &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.eventPhase 이벤트 흐름(event flow) 상에서 어느 단계(event phase)에 있는지를 반환한다. 반환값 의미 0 이벤트 없음 1 캡쳐링 단계 2 타깃 3 버블링 단계 Event Delegation (이벤트 위임)​ &lt;li&gt;가 6개 있다고 가정했을 경우, 해당 태그에 모두 이벤트 반응 처리하고 싶다면 아래처럼 6개의 이벤트 핸들러를 구현해서 바인딩해야하는 비효율적인 면이 있다. 12345678910function printId() &#123; console.log(this.id);&#125;document.querySelector('#post-1').addEventListener('click', printId);document.querySelector('#post-2').addEventListener('click', printId);document.querySelector('#post-3').addEventListener('click', printId);document.querySelector('#post-4').addEventListener('click', printId);document.querySelector('#post-5').addEventListener('click', printId);document.querySelector('#post-6').addEventListener('click', printId); 6개 말고도 100개 1000개 라고 쳤을 때, 실행속도 저하 뿐만아니라 코드 작성의 불편함까지 겸비하고 있다. 동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. 이러한 경우 이벤트 위임을 사용한다. 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법 실제로 이벤트를 발생시킨 요소를 알아내기 위해서는 Event.target을 사용한다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul class=\"post-list\"&gt; &lt;li id=\"post-1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"post-2\"&gt;Item 2&lt;/li&gt; &lt;li id=\"post-3\"&gt;Item 3&lt;/li&gt; &lt;li id=\"post-4\"&gt;Item 4&lt;/li&gt; &lt;li id=\"post-5\"&gt;Item 5&lt;/li&gt; &lt;li id=\"post-6\"&gt;Item 6&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"msg\"&gt; &lt;script&gt; const msg = document.querySelector('.msg'); const list = document.querySelector('.post-list') list.addEventListener('click', function (e) &#123; // 이벤트를 발생시킨 요소 console.log('[target]: ' + e.target); // 이벤트를 발생시킨 요소의 nodeName console.log('[target.nodeName]: ' + e.target.nodeName); // li 요소 이외의 요소에서 발생한 이벤트는 대응하지 않는다. if (e.target &amp;&amp; e.target.nodeName === 'LI') &#123; msg.innerHTML = 'li#' + e.target.id + ' was clicked!'; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 기본 동작의 변경Event.preventDefault() 기본 동작을 중단 시킨다. 예를들어 폼을 submit 하거나 a태그의 링크를 클릭하면 페이지 이동이 발생하는데 이를 중단시킨다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;script&gt; document.querySelector('a').addEventListener('click', function (e) &#123; console.log(e.target, e.target.nodeName); // a 요소의 기본 동작을 중단한다. e.preventDefault(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.stopPropagation() 어느 한 요소를 이용해 이벤트를 처리한 후 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단시키기 위한 메소드. 부모 요소에 동일한 이벤트에 대한 다른 핸들러가 지정되어 있을 경우 사용된다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;버튼을 클릭하면 이벤트 전파를 중단한다. &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // 버블링 body.addEventListener('click', function () &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('click', function () &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('click', function (event) &#123; console.log('Handler for button.'); // 이벤트 전파를 중단한다. event.stopPropagation(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1Handler for button. button 요소의 이벤트의 전파(버블링)을 중단시키기 위해 Event.stopPropagation 메소드를 이용하였다. preventDefault &amp; stopPropagation기본 동작의 중단과 버블링 또는 캡처링의 중단을 동시에 실시하는 방법은 아래와 같다. 1return false; 단 이 방법은 jQuery를 사용할 때와 아래와 같이 사용할 때만 적용된다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\" onclick='return handleEvent()'&gt;go&lt;/a&gt; &lt;script&gt; function handleEvent() &#123; return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // within jQuery $('a').click(function (e) &#123; e.preventDefault(); // OK &#125;); $('a').click(function () &#123; return false; // OK --&gt; e.preventDefault() &amp; e.stopPropagation(). &#125;); // pure js document.querySelector('a').addEventListener('click', function(e) &#123; // e.preventDefault(); // OK return false; // NG!!!!! &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이 방법은 기본 동작의 중단과 이벤트 흐름의 중단 모두 적용되므로이 두가지 중 하나만 중단하기 원하는 경우는 preventDefault() 또는 stopPropagation() 메소드를 개별적으로 사용한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Event","slug":"Event","permalink":"https://hyeok999.github.io/tags/Event/"},{"name":"Async","slug":"Async","permalink":"https://hyeok999.github.io/tags/Async/"}]},{"title":"daily_algorithm27","slug":"daily-algorithm27","date":"2019-10-30T11:41:46.000Z","updated":"2019-11-30T17:12:38.908Z","comments":true,"path":"2019/10/30/daily-algorithm27/","link":"","permalink":"https://hyeok999.github.io/2019/10/30/daily-algorithm27/","excerpt":"","text":"문제 출처 : 프로그래머스 콜라츠 추측문제 설명1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다. 1231-1. 입력된 수가 짝수라면 2로 나눕니다.1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요. 제한 사항 입력된 수, num은 1 이상 8000000 미만인 정수입니다. 입출력 예 n result 6 8 16 4 626331 -1 입출력 예 설명입출력 예 #1문제의 설명과 같습니다. 입출력 예 #216 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 이되어 총 4번만에 1이 됩니다. 입출력 예 #3626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다. 12345678910111213141516171819202122232425function solution(num) &#123; let answer = 0; if (num == 1) return 0; function reapeatFn(x) &#123; if (!(x % 2)) &#123; answer++; x /= 2; &#125; else &#123; answer++; x = (x * 3) + 1; &#125; if (x == 1) return answer; if (answer &gt;= 500) &#123; answer = -1; return answer; &#125; return reapeatFn(x); &#125; return reapeatFn(num);&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"문자열 객체","slug":"StringObject","date":"2019-10-30T10:54:20.000Z","updated":"2019-11-30T16:57:20.962Z","comments":true,"path":"2019/10/30/StringObject/","link":"","permalink":"https://hyeok999.github.io/2019/10/30/StringObject/","excerpt":"","text":"JavaScript String String 생성자 함수 문자열은 유사배열 객체 + 이터러블 문자열 명시적 타입 변환 (new 없이 사용했을 때) length 프로퍼티 String 메서드 indexOf includes charAt replace split substring || slice trim repeat String.prototype.toUpperCase || String.prototype.toLowerCase String.prototype.startsWith || String.prototype.endsWith String 생성자 함수 표준 빌트인 객체인 String 객체는 생성자 함수 객체이다. 따라서 new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다. String 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다. 1234const strObj = new String('Lee');console.log(strObj);// String &#123;0: \"L\", 1: \"e\", 2: \"e\", length: 3, [[PrimitiveValue]]: \"Lee\"&#125;strObj.valueOf(); //'Lee' 위 예제를 크롬 브라우저의 개발자 도구에서 실행해보면 [[PrimitiveValue]]라는 프로퍼티가 보인다.이는 [[StringData]] 내부 슬롯을 가리킨다. ES5에서는 [[StringData]]을 [[PrimitiveValue]]이라 불렸다. String 생성자 함수에 문자열을 인수로 전달 ( 문자열이 아니라면 문자열로 강제 변환한다. ) [[StringData]] 내부 슬롯에 인수로 전달받은 문자열을 할당 String 래퍼 객체를 생성 문자열은 유사배열 객체 + 이터러블배열과 유사하게 인덱스를 사용하여 각 문자에 접근이 가능하다. 1console.log(strObj[0]); // L 문자열 명시적 타입 변환 (new 없이 사용했을 때)명시적 타입 변환 : new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 String 인스턴스가 아닌 문자열을 반환한다. 12345678// 숫자 타입 =&gt; 문자열 타입String(1); // -&gt; \"1\"String(NaN); // -&gt; \"NaN\"String(Infinity); // -&gt; \"Infinity\"// 불리언 타입 =&gt; 문자열 타입String(true); // -&gt; \"true\"String(false); // -&gt; \"false\" length 프로퍼티length 프로퍼티는 문자열의 문자 개수를 반환한다.문자열 레퍼 객체는 배열과 마찬가지로 length 프로퍼티를 갖는다. 12'Hello'.length; // -&gt; 5'안녕하세요!'.length; // -&gt; 6 그리고 인덱스를 나타내는 숫자를 프로퍼티 키로, 각 문자를 프로퍼티 값으로 가지므로 문자열 레퍼 객체는 유사 배열 객체이다. String 메서드String 객체의 모든 메소드는 언제나 새로운 문자열을 반환한다. 즉, 원본 문자열에 영향을 주지 않는다.문자열은 변경 불가능한 원시 값이다. indexOf 첫번쨰 인수로 전달한 문자열을 검색해 첫번쨰 인덱스를 반환. 검색 실패시 -1을 반환 두번째 인수는 생략가능. 시작할 인덱스를 전달 가능하다. 123456789101112131415161718const str = 'Hello World';// 문자열 str에서 'l'을 검색하여 첫번째 인덱스를 반환한다.let index = str.indexOf('l');console.log(index); // 2// 문자열 str에서 'or'을 검색하여 첫번째 인덱스를 반환한다.index = str.indexOf('or');console.log(index); // 7// 문자열 str에서 'x'를 검색하여 첫번째 인덱스를 반환한다.// 검색에 실패하면 -1을 반환한다.index = str.indexOf('x');console.log(index); // -1// 문자열 str의 인덱스 3부터 'l'을 검색하여 첫번째 인덱스를 반환한다.index = str.indexOf('l', 3);console.log(index); // 3 includes 첫번쨰 인수로 전달한 문자열이 포함되어 있는지 확인하여 그 결과를 true 또는 false로 반환한다. 두번째 인수는 생략가능. 시작할 인덱스를 전달 가능하다. 12345678910111213141516const str = 'Hello world';str.includes('Hello'); // -&gt; truestr.includes(''); // -&gt; truestr.includes('x'); // -&gt; falsestr.includes(); // -&gt; false// String.prototype.indexOf 메소드로 대체할 수 있다.console.log(str.indexOf('hello')); // 0// 문자열 str의 인덱스 3부터 'l'이 포함되어 있는지 확인let index = str.includes('l', 3);console.log(index); // trueindex = str.includes('H', 3);console.log(index); // false charAt charAt 메소드는 인수로 전달한 인덱스에 위치한 문자를 반환한다. 인덱스는 문자열의 범위, 즉 0 ~ (문자열 길이 - 1) 사이의 정수이어야 한다. 인덱스가 문자열의 범위를 벗어난 정수인 경우, 빈문자열을 반환한다. 12345const str = 'Hello';for (let i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i)); // H e l l o&#125; replace 원본 문자열을 변경한다. 첫번째 인수 - 문자열 또는 정규 표현식 : 검색할 문자열 , 여러개인 경우 1개만 반환 두번째 인수 - 문자열 또는 치환 함수 : 바꿀 문자열 , 특수패턴 : $&amp;는 검색된 문자열을 의미 정규표현식을 인수로 받을 수 있다. 1234const str = 'Hello world';// 첫번째로 검색된 문자열만 대체하여 새로운 문자열을 반환한다.console.log(str.replace('world', 'Lee')); // Hello Lee 문자열.match(정규표현식)은 해당 정규표현식 조건에 해당되는 문자열을 찾아서 반환한다. 12345678910111213141516171819202122232425// camelCase =&gt; snake_casefunction camelToSnake(camelCase) &#123; // /.[A-Z]/g =&gt; 문자와 대문자로 이루어진 문자열 검색 // 두번째 인수로 치환 함수를 전달할 수 있다. return camelCase.replace(/.[A-Z]/g, match =&gt; &#123; console.log(match); // 'oW' return match[0] + '_' + match[1].toLowerCase(); &#125;);&#125;const camelCase = 'helloWorld';camelToSnake(camelCase); // -&gt; 'hello_world'// snake_case =&gt; camelCasefunction snakeToCamel(snakeCase) &#123; // /_[a-z]/g =&gt; _와 소문자로 이루어진 문자열 검색 // 두번째 인수로 치환 함수를 전달할 수 있다. return snakeCase.replace(/_[a-z]]/g, match =&gt; &#123; console.log(match); // '_w' return match[1].toUpperCase(); &#125;); // helloWorld&#125;const snakeCase = 'hello_world';snakeToCamel(snakeCase); // -&gt; 'helloWorld' split 원본 문자열은 변경되지 않는다. 첫번째 인수로 전달한 문자열 또는 정규표현식을 대상 문자열에서 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다. 123456/** * @param &#123;string | RegExp&#125; [separator] - 구분 대상 문자열 또는 정규표현식 * @param &#123;number&#125; [limit] - 구분 대상수의 한계를 나타내는 정수 * @return &#123;string[]&#125; */str.split([separator[, limit]]) 12345678910111213141516171819const str = 'How are you doing?';// 공백으로 구분(단어로 구분)하여 배열로 반환한다console.log(str.split(' ')); // [ 'How', 'are', 'you', 'doing?' ]// 정규 표현식console.log(str.split(/\\s/)); // [ 'How', 'are', 'you', 'doing?' ]// 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.console.log(str.split()); // [ 'How are you doing?' ]// 각 문자를 모두 분리한다console.log(str.split('')); // [ 'H','o','w',' ','a','r','e',' ','y','o','u',' ','d','o','i','n','g','?' ]// 공백으로 구분하여 배열로 반환한다. 단 요소수는 3개까지만 허용한다console.log(str.split(' ', 3)); // [ 'How', 'are', 'you' ]// 'o'으로 구분하여 배열로 반환한다.console.log(str.split('o')); // [ 'H', 'w are y', 'u d', 'ing?' ] substring || slice 첫번째 인수의 값 부터 두번째 인수의 바로 전(두번쨰 인수는 미포함)까지 위치한 부분 문자열을 반환한다. 두번쨰 인수는 생략이 가능하다. 첫번쨰 인수의 값부터 끝까지 반환한다. 원본 배별은 변하지 않는다. 인수가 0보다 작거나 NaN 일경우, 강제로 0 취급 인수가 문자열의 길이보다 클 경우 그 인수는 문자열의 길이로 취급. slice와 거의 동일하게 동작하나 slice는 음수일 경우 뒤부터 음수만큼 복사해서 반환한다. 123456789const str = 'Hello World';// 인덱스 1부터 인덱스 4 이전까지의 부분 문자열을 반환한다.str.substring(1, 4); // -&gt; ellstr.substring(1); // -&gt; 'ello World'str.substring(-5); // -&gt; 'hello world'// 뒤에서 5자리를 잘라내어 반환한다.str.slice(-5); // ⟶ 'world' trim 대상 문자열 양쪽 끝에 있는 공백 문자를 제거한 문자열을 반환한다. 123456789101112const str = ' foo ';console.log(str.trim()); // 'foo'// String.prototype.replaceconsole.log(str.replace(/\\s/g, '')); // 'foo'console.log(str.replace(/^\\s+/g, '')); // 'foo 'console.log(str.replace(/\\s+$/g, '')); // ' foo'// String.prototype.&#123;trimStart,trimEnd&#125; : Proposal stage 3console.log(str.trimStart()); // 'foo 'console.log(str.trimEnd()); // ' foo' repeat 인수로 전달한 정수만큼 반복해 연결한 새로운 문자열을 반환한다. 인수로 전달한 정수가 0이면 빈 문자열을 반환 , 음수면 RangeError 발생 1234567const str = 'abc';str.repeat(0); // -&gt; ''str.repeat(1); // -&gt; 'abc'str.repeat(2); // -&gt; 'abcabc'str.repeat(2.5); // -&gt; 'abcabc' (2.5 → 2)str.repeat(-1); // -&gt; RangeError: Invalid count value String.prototype.toUpperCase || String.prototype.toLowerCase toUpperCase 메소드는 문자열의 모든 문자를 대문자로 변경하여 반환. toLowerCase 메소드는 문자열의 모든 문자를 대문자로 변경하여 반환. 1234const str = 'hello world!';str.toUpperCase(); // -&gt; 'HELLO WORLD!'str.toLowerCase(); // -&gt; 'hello world!' String.prototype.startsWith || String.prototype.endsWith ES6에서 새롭게 도입된 startsWith / endsWith 메소드는 문자열이 인수로 전달한 문자열로 시작 / 끝 을 확인하여 그 결과를 true 또는 false로 반환한다. startsWith 메소드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다. endsWith 메소드의 2번째 인수로 검색할 문자열의 길이를 전달할 수 있다. 123456789const str = 'Hello world';// 문자열 str이 'He'로 시작하는지 확인str.startsWith('He'); // -&gt; true// 문자열 str이 'x'로 시작하는지 확인str.startsWith('x'); // -&gt; false// 문자열 str의 인덱스 5부터 시작하는 문자열이 ' '로 시작하는지 확인str.startsWith(' ', 5); // -&gt; true 123456789const str = 'Hello world';// 문자열 str이 'ld'로 끝나는지 확인str.endsWith('ld'); // -&gt; true// 문자열 str이 'x'로 끝나는지 확인str.endsWith('x'); // -&gt; false// 문자열 str의 처음부터 5자리까지('Hello')가 'lo'로 끝나는지 확인str.endsWith('lo', 5); // -&gt; true","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Object","slug":"Object","permalink":"https://hyeok999.github.io/tags/Object/"},{"name":"String","slug":"String","permalink":"https://hyeok999.github.io/tags/String/"}]},{"title":"깃 브랜치 및 협업","slug":"git-branch-collabo","date":"2019-10-30T10:39:50.000Z","updated":"2019-11-30T17:06:44.672Z","comments":true,"path":"2019/10/30/git-branch-collabo/","link":"","permalink":"https://hyeok999.github.io/2019/10/30/git-branch-collabo/","excerpt":"","text":"git branch branch 확인 branch 새로 만들기 branch 이동 (반드시 커밋 다 하고 넘어가야됨) 타 브랜치 내용 병합 git checkout 브랜치명 -&gt; 해당 브랜치에서 푸쉬하기 master 브랜치에서 최신상태를 땡겨오기 브랜치 지우기 실제 개발환경에서 브랜치 설정 예 협업 git-flow 란? git flow 지원 확인 실습 git flow init 기능 feature 브랜치 생성 - git flow feature start 브랜치명 기능 feature 브랜치 개발 완료 후 -&gt; 종료 -&gt; devleop에 병합하기 - git flow feature finish 브랜치명 feature 브랜치 에서 develop 브랜치 병합치기. - (feature 브랜치에서) git merge develop feature 브랜치 에서 develop 브랜치 병합치기. - (feature 브랜치에서) git merge develop feature branch 지우기 배포 release start release finish git 파일 이동 시 주의점 협업 예시 일반적 (팀원 기준) 시나리오 git branchbranch 확인1gir branch branch 새로 만들기1git branch 브랜치명 branch 이동 (반드시 커밋 다 하고 넘어가야됨)1git checkout 브랜치명 타 브랜치 내용 병합1git merge 브랜치명 ( 만약 , 충돌이 난다면 ➤ 충돌 수정 후 ➤ git add ➤ git commit 재실행 ) github 페이지 ➤ insight ➤ Network에 보면 현재 git의 상태가 어디쯤인지 파악할수 있다. git checkout 브랜치명 -&gt; 해당 브랜치에서 푸쉬하기12git checkout 브랜치명git push -u origin 브랜치명 master 브랜치에서 최신상태를 땡겨오기1git pull origin master 브랜치 지우기1git branch -D 브랜치명 실제 개발환경에서 브랜치 설정 예master - develop을 머지 ⌙ develop - layout을 머지 ​ ⌙ layout -&gt; 차후 develop에 커밋 이 과정을 Git-flow로 한다. 협업Git-Flow란? git-flow는 전략적으로 관리하는 Git을 쉽고 편하게 도와주는 도구. :) git flow 지원 확인1git flow 실습 git push -u origin master: 새로운 브랜치에 대한 존재를 remote에게 알리기 위해 사용. (처음에만 알리면 됨.) git branch : 현재 만들어져있는 브랜치 확인. git checkout 브랜치명 : 해당 브랜치로 이동. (어디서나 가능, 개념이기 때문) 1. git flow init git flow init을 한 순간 develop 브랜치를 만들고 develop으로 checkout까지 함. 123git flow init&gt; 기본 [master]&gt; 전부 엔터 2. 기능 feature 브랜치 생성 - git flow feature start 브랜치명 feature는 develop에서 따야만 하므로 현재 위치가 develop인지 확인을 먼저 한다. feature브랜치 이름은 브랜치 이름만 들어도 알 수 있게금 이름 디테일을 확실히 해야 한다. 자동으로 만든 브랜치로 이동한다. 12// git flow feature start 브랜치명git flow feature start markup-init 3. 기능 feature 브랜치 개발 완료 후 -&gt; 종료 -&gt; devleop에 병합하기 - git flow feature finish 브랜치명 자동으로 develop 브랜치로 이동한다. 해당 기능 feature 브랜치에서 작성했던 내용은 상위 브랜치로 병합된다. 123// git flow feature finish 브랜치명git flow feature finish markup-init// 자동으로 develop 브랜치로 이동하게 됩니다. 4. feature 브랜치 에서 develop 브랜치 병합치기. - (feature 브랜치에서) git merge develop 새로운 feature 가 만들어 져 있다고 가정 ( 이미 다 하고나서 생성하면 자동 병합된다. ) 12// git flow feature start 브랜치명git flow feature start style-init develop 브랜치의 내용을 해당 feature 브랜치로 가져오기 현재 위치는 feature 브랜치 12// git flow feature start 브랜치명git merge develop feature branch 지우기 만들고 개발중이던 기능이 아예 무산됬다고 가정 상위 브랜치(develop)으로 올라간다. -&gt; git checkout 브랜치명 해당 기능 브랜치를 제거 해버리면된다. -&gt; git branch -D feature/브랜치명 해당 기능 브랜치는 commit이 되어있어야 한다. 12345678910git flow feature start wrong-feature// ~~~ 내용 추가 (html 파일 생성 내용 추가등등)// html 내용 git add -&gt; git commit // 해당 기능이 무산됨. 해당 wrong-feature가 존재해서는 안됨.// 1. 상위 브랜치로 이동(develop)git checkout develop// 2. 해당 브랜치에서 잘못된 기능 브랜치를 제거한다.git branch -D feature/wrong-feature 배포 release start 배포 버전 브랜치를 생성한다. 맨뒤에 버전 명을 적어주어야 한다. 1git flow release start v0.0.1.001910300002 release finish release finish 명령이 되면 자동으로 모든 내용이 master와 병합이된다. finish 후 branch 위치는 develop develop push , master push 전부 해야한다. 1git flow release finish v0.0.1.001910300002 git 파일 이동 시 주의점 git이 관리하는 폴더 중에 파일을 강제로 이동,잘라내기를 해서 다른곳으로 이동시키면 git은 해당 파일이 삭제되고 다른 쪽에 새로 생긴걸로 착가한다. ( mv 파일명 이동위치명 ) 따라서 이것을 방지하기 위해 앞에 git mv 파일명 이동위치명을 적어준다. 협업 예시일반적 ( 팀원 기준 )팀장의 깃 폴더를 fork 뜬다. ➢ 로컬에서 내 레포(fork한) git clone을 한다. ➢ clone한 폴더로 이동한다. ➢git flow init을 한다. ➢ git flow feature start 브랜치명 ➢ (현재 위치:feature 브랜치) 해당 브랜치에서 내용 수정 ➢add / commit ➢ git flow feature finish 브랜치명 ➢ (현재 위치:develop) 자신의 레포에 푸쉬 ➢내용 변경 확인 후 ➢ git 페이지에서 pull request 버튼 클릭 ➢ 내 develop : 팀장의 devleop ➢ 메시지 작성 ➢ 전송 ➢팀장 레포에서 풀리퀘스트를 받아주면 팀장의 develop에 작업내용 반영. 시나리오팀장 레포 생성 ➢ git clone ➢ git flow init (자동 develop 브랜치 이동) ➢ touch index.html 생성 ➢ git add, commit ➢ git push 팀원 A 팀장 깃을 fork를 한다. ➢ fork 한 자신의 레포를 clone ➢ git flow init ➢ (현재 develop) git pull origin develop ➢ git feature start ➢ git feature finish ➢ push ➢ 자신의 git 페이지에서 Create pull request(github.com) 팀장 Merge pull request(github.com) 팀원 B (2번에서 팀원 A와 fork만 같이 한 상황) git rmote add pmorigin [팀장깃주소] ➢ git pull pmrorigin develop 팀장에서 issue를 남긴다 . 팀장 issue 확인 하고 역할 분배 - Assignees : 담당자 , Labels : 업무 팀원들 git rmote add pmorigin [팀장깃주소] (리모트 연결했다면 생략가능) ➢ git pull pmorigin develop ➢ git feature start ➢ 내용작성 ➢ git add/commit ➢ git feature finish ➢ push ➢ 자신의 git 페이지에서 Create pull request(github.com) 팀장 Merge pull request(github.com) ➢ git pull ➢ git flow release start v0.0.1.001910300001 ➢ git flow release finish v0.0.1.001910300001 ➢ (현재 위치 develop) ➢ git push ➢ git checkout master ➢ (현재 위치 master) ➢ git push 모든 팀원은 merge 발생 시 pm-origin의 develop을 자신의 develop 으로 pull 하여 업데이트 한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"https://hyeok999.github.io/categories/Develop/GIT/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"branch","slug":"branch","permalink":"https://hyeok999.github.io/tags/branch/"},{"name":"flow","slug":"flow","permalink":"https://hyeok999.github.io/tags/flow/"}]},{"title":"daily_algorithm26","slug":"daily-algorithm26","date":"2019-10-30T10:39:37.000Z","updated":"2019-11-30T17:12:45.350Z","comments":true,"path":"2019/10/30/daily-algorithm26/","link":"","permalink":"https://hyeok999.github.io/2019/10/30/daily-algorithm26/","excerpt":"","text":"문제 출처 : 프로그래머스 두 정수 사이의 합문제 설명두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다. 제한 조건 a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요. a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다. a와 b의 대소관계는 정해져있지 않습니다. 입출력 예 a b return 3 5 12 3 3 3 5 3 12 123456789101112131415function solution(a, b) &#123; var answer = 0; if(a &gt; b)&#123; let temp = a; a = b; b = temp; &#125; for(let i = a; i &lt;= b ; i++)&#123; answer += i; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"Date 객체","slug":"DateObject","date":"2019-10-29T17:46:13.000Z","updated":"2019-11-30T17:07:32.278Z","comments":true,"path":"2019/10/30/DateObject/","link":"","permalink":"https://hyeok999.github.io/2019/10/30/DateObject/","excerpt":"","text":"JavaScript Date 객체 Date 객체 Date 객체 생성 법 new Date() new Date(milliseconds) new Date(dateString) new Date(year, month[, day, hour, minute, second, millisecond]) Date 생성자 함수를 new 연산자없이 호출 Date Method Date.now Date.prototype.getFullYear Date.prototype.getMonth Date.prototype.getDate Date.prototype.getDay Date.prototype.getHours Date.prototype.getMinutes Date.prototype.getSeconds Date.prototype.toDateString 참고 자료 Date 객체 날짜 시간 요일 까지 제공하는 빌트인 객체이면서 생성자 함수. Date 생성자 함수로 생성한 Date 객체는 내부적으로 숫자값을 갖는다. 이 값은 1970년 1월 1일 00:00(UTC)을 기점으로 현재 시간까지의 밀리초를 나타낸다. 한국시간(KST) 는 UTC보다 9시간이 빠르다. Date 객체 생성 법new Date() 인수를 전달하지 않으면 현재 날짜와 시간을 가지는 인스턴스를 반환한다. 12const date = new Date();console.log(date); // Thu May 16 2019 17:16:13 GMT+0900 (한국 표준시) new Date(milliseconds) 인수로 숫자 타입의 밀리초를 전달하면 1970년 1월 1일 00:00(UTC)을 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다. new Date(dateString) 인수로 날짜와 시간을 나타내는 문자열을 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 인수로 전달한 문자열은 Date.parse 메소드에 의해 해석 가능한 형식이어야 한다. 12345let date = new Date('May 16, 2019 17:22:10');console.log(date); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시)date = new Date('2019/05/16/17:22:10');console.log(date); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시) new Date(year, month[, day, hour, minute, second, millisecond]) 인수로 년, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 이때 년, 월은 반드시 지정하여야 한다. 지정하지 않은 옵션 정보는 0 또는 1으로 초기화된다. 인수는 다음과 같다. 인수 내용 year 1900년 이후의 년 month 월을 나타내는 0 ~ 11까지의 정수 (주의: 0부터 시작, 0 = 1월) day 일을 나타내는 1 ~ 31까지의 정수 hour 시를 나타내는 0 ~ 23까지의 정수 minute 분을 나타내는 0 ~ 59까지의 정수 second 초를 나타내는 0 ~ 59까지의 정수 millisecond 밀리초를 나타내는 0 ~ 999까지의 정수 년, 월을 지정하지 않은 경우 1970년 1월 1일 00:00(UTC)을 가지는 인스턴스를 반환한다. 12345678910111213// 월을 나타내는 4는 5월을 의미한다.// 2019/5/1/00:00:00:00let date = new Date(2019, 4);console.log(date); // Wed May 01 2019 00:00:00 GMT+0900 (한국 표준시)// 월을 나타내는 4는 5월을 의미한다.// 2019/5/16/17:24:30:00date = new Date(2019, 4, 16, 17, 24, 30, 0);console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시)// 가독성이 훨씬 좋다.date = new Date('2019/5/16/17:24:30:10');console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시) Date 생성자 함수를 new 연산자없이 호출 Date 생성자 함수를 new 연산자없이 호출하면 인스턴스를 반환하지 않고 결과값을 문자열로 반환한다. 12let date = Date();console.log(typeof date, date); // string Thu May 16 2019 17:33:03 GMT+0900 (한국 표준시) Date MethodDate.now 1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다. 12const now = Date.now();console.log(now); Date.prototype.getFullYear 년도를 나타내는 4자리 숫자를 반환한다. 12345const today = new Date();const year = today.getFullYear();console.log(today); // Thu May 16 2019 17:39:30 GMT+0900 (한국 표준시)console.log(year); // 2019 Date.prototype.getMonth 월을 나타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다. 12345const today = new Date();const month = today.getMonth();console.log(today); // Thu May 16 2019 17:44:03 GMT+0900 (한국 표준시)console.log(month); // 4 Date.prototype.getDate 날짜(1 ~ 31)를 나타내는 정수를 반환한다. 12345const today = new Date();const date = today.getDate();console.log(today); // Thu May 16 2019 17:46:42 GMT+0900 (한국 표준시)console.log(date); // 16 Date.prototype.getDay 요일(0 ~ 6)를 나타내는 정수를 반환한다. 반환값은 아래와 같다. 요일 반환값 일요일 0 월요일 1 화요일 2 수요일 3 목요일 4 금요일 5 토요일 6 12345const today = new Date();const day = today.getDay();console.log(today); // Thu May 16 2019 17:47:31 GMT+0900 (한국 표준시)console.log(day); // 4 Date.prototype.getHours 시간(0 ~ 23)를 나타내는 정수를 반환한다. 12345const today = new Date();const hours = today.getHours();console.log(today); // Thu May 16 2019 17:48:03 GMT+0900 (한국 표준시)console.log(hours); // 17 Date.prototype.getMinutes 분(0 ~ 59)를 나타내는 정수를 반환한다. 12345const today = new Date();const minutes = today.getMinutes();console.log(today); // Thu May 16 2019 17:50:29 GMT+0900 (한국 표준시)console.log(minutes); // 50 Date.prototype.getSeconds 초(0 ~ 59)를 나타내는 정수를 반환한다. 12345const today = new Date();const seconds = today.getSeconds();console.log(today); // Thu May 16 2019 17:53:17 GMT+0900 (한국 표준시)console.log(seconds); // 17 Date.prototype.toDateString 사람이 읽을 수 있는 형식의 문자열로 날짜를 반환한다. 1234const d = new Date('2019/5/16/18:30');console.log(d.toString()); // Thu May 16 2019 18:30:00 GMT+0900 (한국 표준시)console.log(d.toDateString()); // Thu May 16 2019 참고 자료 Date 객체 자체를 자주 사용하지 않기 때문에 그나마 필요한 것 위주로 정리했다. 추가 적인 필요 프로퍼티 나 메서드(시간조작하는 set등등)은 MDN-Date을 참조한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Object","slug":"Object","permalink":"https://hyeok999.github.io/tags/Object/"},{"name":"Date","slug":"Date","permalink":"https://hyeok999.github.io/tags/Date/"}]},{"title":"javascript-study-17","slug":"javascript-study-17","date":"2019-10-29T04:05:08.000Z","updated":"2019-11-30T17:00:32.366Z","comments":true,"path":"2019/10/29/javascript-study-17/","link":"","permalink":"https://hyeok999.github.io/2019/10/29/javascript-study-17/","excerpt":"","text":"JavaScript Study 17 용어 String 생성자 함수 문자열은 유사배열 객체 + 이터러블 문자열 명시적 타입 변환 (new 없이 사용했을 때) length 프로퍼티 String 메서드 indexOf includes charat replace split substring trim repeat include Date 객체 new Date() new Date(milliseconds) new Date(dateString) new Date(year, month[, day, hour, minute, second, millisecond]) Date 생성자 함수를 new 연산자없이 호출 DOM DOM 트리 DOM 검색 하나의 요소 노드 선택 여러개의 요소 노드 선택 DOM 탐색 DOM Manipulation (조작) 텍스트 노드에의 접근/수정 어트리뷰트 노드에의 접근/수정 HTML 콘텐츠 조작(Manipulation) 용어 - ( 러버덕 ) String 생성자 String 메서드 lenght 프로퍼티 DOM 객체 DOM 트리 DOM 검색 ,탐색 ,조작 String 생성자 함수 표준 빌트인 객체인 String 객체는 생성자 함수 객체이다. 따라서 new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다. String 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다. 1234const strObj = new String('Lee');console.log(strObj);// String &#123;0: \"L\", 1: \"e\", 2: \"e\", length: 3, [[PrimitiveValue]]: \"Lee\"&#125;strObj.valueOf(); //'Lee' 위 예제를 크롬 브라우저의 개발자 도구에서 실행해보면 [[PrimitiveValue]]라는 프로퍼티가 보인다.이는 [[StringData]] 내부 슬롯을 가리킨다. ES5에서는 [[StringData]]을 [[PrimitiveValue]]이라 불렸다. String 생성자 함수에 문자열을 인수로 전달 ( 문자열이 아니라면 문자열로 강제 변환한다. ) [[StringData]] 내부 슬롯에 인수로 전달받은 문자열을 할당 String 래퍼 객체를 생성한다. 문자열은 유사배열 객체 + 이터러블1console.log(strObj[0]); // L 문자열 명시적 타입 변환 (new 없이 사용했을 때)명시적 타입 변환 : new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 String 인스턴스가 아닌 문자열을 반환한다. 12345678// 숫자 타입 =&gt; 문자열 타입String(1); // -&gt; \"1\"String(NaN); // -&gt; \"NaN\"String(Infinity); // -&gt; \"Infinity\"// 불리언 타입 =&gt; 문자열 타입String(true); // -&gt; \"true\"String(false); // -&gt; \"false\" length 프로퍼티length 프로퍼티는 문자열의 문자 개수를 반환한다. 12'Hello'.length; // -&gt; 5'안녕하세요!'.length; // -&gt; 6 문자열 레퍼 객체는 배열과 마찬가지로 length 프로퍼티를 갖는다.그리고 인덱스를 나타내는 숫자를 프로퍼티 키로, 각 문자를 프로퍼티 값으로 가지므로 문자열 레퍼 객체는 유사 배열 객체이다. String 메서드indexOf 첫번쨰 인수로 전달한 문자열을 검색해 첫번쨰 인덱스를 반환. 검색 실패시 -1을 반환 두번째 인수는 생략가능. 시작할 인덱스를 전달 가능하다. 123456789101112131415161718const str = 'Hello World';// 문자열 str에서 'l'을 검색하여 첫번째 인덱스를 반환한다.let index = str.indexOf('l');console.log(index); // 2// 문자열 str에서 'or'을 검색하여 첫번째 인덱스를 반환한다.index = str.indexOf('or');console.log(index); // 7// 문자열 str에서 'x'를 검색하여 첫번째 인덱스를 반환한다.// 검색에 실패하면 -1을 반환한다.index = str.indexOf('x');console.log(index); // -1// 문자열 str의 인덱스 3부터 'l'을 검색하여 첫번째 인덱스를 반환한다.index = str.indexOf('l', 3);console.log(index); // 3 includes 첫번쨰 인수로 전달한 문자열이 포함되어 있는지 확인하여 그 결과를 true 또는 false로 반환한다. 두번째 인수는 생략가능. 시작할 인덱스를 전달 가능하다. 123456789const str = 'Hello world';str.includes('Hello'); // -&gt; truestr.includes(''); // -&gt; truestr.includes('x'); // -&gt; falsestr.includes(); // -&gt; false// String.prototype.indexOf 메소드로 대체할 수 있다.console.log(str.indexOf('hello')); // 0 charat charAt 메소드는 인수로 전달한 인덱스에 위치한 문자를 반환한다. 인덱스는 문자열의 범위, 즉 0 ~ (문자열 길이 - 1) 사이의 정수이어야 한다. 인덱스가 문자열의 범위를 벗어난 정수인 경우, 빈문자열을 반환한다. 12345const str = 'Hello';for (let i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i)); // H e l l o&#125; replace 원본 문자열을 변경한다. 첫번째 인수 - 문자열 또는 정규 표현식 : 검색할 문자열 , 여러개인 경우 1개만 반환 두번째 인수 - 문자열 또는 치환 함수 : 바꿀 문자열 , 특수패턴 : $&amp;는 검색된 문자열을 의미 1234const str = 'Hello world';// 첫번째로 검색된 문자열만 대체하여 새로운 문자열을 반환한다.console.log(str.replace('world', 'Lee')); // Hello Lee 문자열.match(정규표현식)은 해당 정규표현식 조건에 해당되는 문자열을 찾아서 반환한다. 12345678910111213141516171819202122232425// camelCase =&gt; snake_casefunction camelToSnake(camelCase) &#123; // /.[A-Z]/g =&gt; 문자와 대문자로 이루어진 문자열 검색 // 두번째 인수로 치환 함수를 전달할 수 있다. return camelCase.replace(/.[A-Z]/g, match =&gt; &#123; console.log(match); // 'oW' return match[0] + '_' + match[1].toLowerCase(); &#125;);&#125;const camelCase = 'helloWorld';camelToSnake(camelCase); // -&gt; 'hello_world'// snake_case =&gt; camelCasefunction snakeToCamel(snakeCase) &#123; // /_[a-z]/g =&gt; _와 소문자로 이루어진 문자열 검색 // 두번째 인수로 치환 함수를 전달할 수 있다. return snakeCase.replace(/_[a-z]]/g, match =&gt; &#123; console.log(match); // '_w' return match[1].toUpperCase(); &#125;); // helloWorld&#125;const snakeCase = 'hello_world';snakeToCamel(snakeCase); // -&gt; 'helloWorld' split 원본 문자열은 변경되지 않는다. 첫번째 인수로 전달한 문자열 또는 정규표현식을 대상 문자열에서 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다. 123456/** * @param &#123;string | RegExp&#125; [separator] - 구분 대상 문자열 또는 정규표현식 * @param &#123;number&#125; [limit] - 구분 대상수의 한계를 나타내는 정수 * @return &#123;string[]&#125; */str.split([separator[, limit]]) 12345678910111213141516171819const str = 'How are you doing?';// 공백으로 구분(단어로 구분)하여 배열로 반환한다console.log(str.split(' ')); // [ 'How', 'are', 'you', 'doing?' ]// 정규 표현식console.log(str.split(/\\s/)); // [ 'How', 'are', 'you', 'doing?' ]// 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.console.log(str.split()); // [ 'How are you doing?' ]// 각 문자를 모두 분리한다console.log(str.split('')); // [ 'H','o','w',' ','a','r','e',' ','y','o','u',' ','d','o','i','n','g','?' ]// 공백으로 구분하여 배열로 반환한다. 단 요소수는 3개까지만 허용한다console.log(str.split(' ', 3)); // [ 'How', 'are', 'you' ]// 'o'으로 구분하여 배열로 반환한다.console.log(str.split('o')); // [ 'H', 'w are y', 'u d', 'ing?' ] substring 첫번째 인수의 값 부터 두번째 인수의 바로 전(두번쨰 인수는 미포함)까지 위치한 부분 문자열을 반환한다. 두번쨰 인수는 생략이 가능하다. 첫번쨰 인수의 값부터 끝까지 반환한다. 원본 배별은 변하지 않는다. 인수가 0보다 작거나 NaN 일경우, 강제로 0 취급 인수가 문자열의 길이보다 클 경우 그 인수는 문자열의 길이로 취급. slice와 거의 동일하게 동작하나 slice는 음수일 경우 뒤부터 음수만큼 복사해서 반환한다. 12345const str = 'Hello World';// 인덱스 1부터 인덱스 4 이전까지의 부분 문자열을 반환한다.str.substring(1, 4); // -&gt; ellstr.substring(1); // -&gt; 'ello World' trim 대상 문자열 양쪽 끝에 있는 공백 문자를 제거한 문자열을 반환한다. 123456789101112const str = ' foo ';console.log(str.trim()); // 'foo'// String.prototype.replaceconsole.log(str.replace(/\\s/g, '')); // 'foo'console.log(str.replace(/^\\s+/g, '')); // 'foo 'console.log(str.replace(/\\s+$/g, '')); // ' foo'// String.prototype.&#123;trimStart,trimEnd&#125; : Proposal stage 3console.log(str.trimStart()); // 'foo 'console.log(str.trimEnd()); // ' foo' repeat 인수로 전달한 정수만큼 반복해 연결한 새로운 문자열을 반환한다. 인수로 전달한 정수가 0이면 빈 문자열을 반환 , 음수면 RangeError 발생 1234567const str = 'abc';str.repeat(0); // -&gt; ''str.repeat(1); // -&gt; 'abc'str.repeat(2); // -&gt; 'abcabc'str.repeat(2.5); // -&gt; 'abcabc' (2.5 → 2)str.repeat(-1); // -&gt; RangeError: Invalid count value Date 객체날짜 시간 요일 까지 제공하는 빌트인 객체이면서 생성자 함수. Date 생성자 함수로 생성한 Date 객체는 내부적으로 숫자값을 갖는다. 이 값은 1970년 1월 1일 00:00(UTC)을 기점으로 현재 시간까지의 밀리초를 나타낸다. 한국시간(KST) 는 UTC보다 9시간이 빠르다. new Date()인수를 전달하지 않으면 현재 날짜와 시간을 가지는 인스턴스를 반환한다. 12const date = new Date();console.log(date); // Thu May 16 2019 17:16:13 GMT+0900 (한국 표준시) new Date(milliseconds)인수로 숫자 타입의 밀리초를 전달하면 1970년 1월 1일 00:00(UTC)을 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다. new Date(dateString) 인수로 날짜와 시간을 나타내는 문자열을 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 인수로 전달한 문자열은 Date.parse 메소드에 의해 해석 가능한 형식이어야 한다. 12345let date = new Date('May 16, 2019 17:22:10');console.log(date); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시)date = new Date('2019/05/16/17:22:10');console.log(date); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시) new Date(year, month[, day, hour, minute, second, millisecond]) 인수로 년, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 이때 년, 월은 반드시 지정하여야 한다. 지정하지 않은 옵션 정보는 0 또는 1으로 초기화된다. 인수는 다음과 같다. 인수 내용 year 1900년 이후의 년 month 월을 나타내는 0 ~ 11까지의 정수 (주의: 0부터 시작, 0 = 1월) day 일을 나타내는 1 ~ 31까지의 정수 hour 시를 나타내는 0 ~ 23까지의 정수 minute 분을 나타내는 0 ~ 59까지의 정수 second 초를 나타내는 0 ~ 59까지의 정수 millisecond 밀리초를 나타내는 0 ~ 999까지의 정수 년, 월을 지정하지 않은 경우 1970년 1월 1일 00:00(UTC)을 가지는 인스턴스를 반환한다. 12345678910111213// 월을 나타내는 4는 5월을 의미한다.// 2019/5/1/00:00:00:00let date = new Date(2019, 4);console.log(date); // Wed May 01 2019 00:00:00 GMT+0900 (한국 표준시)// 월을 나타내는 4는 5월을 의미한다.// 2019/5/16/17:24:30:00date = new Date(2019, 4, 16, 17, 24, 30, 0);console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시)// 가독성이 훨씬 좋다.date = new Date('2019/5/16/17:24:30:10');console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시) Date 생성자 함수를 new 연산자없이 호출Date 생성자 함수를 new 연산자없이 호출하면 인스턴스를 반환하지 않고 결과값을 문자열로 반환한다. 12let date = Date();console.log(typeof date, date); // string Thu May 16 2019 17:33:03 GMT+0900 (한국 표준시) DOM HTML 파서가 HTML을 분석해서 결과물을 만들어내는 것이 DOM tree. HTML 문법은 중첩관계 표현 가능하다. 태그들 사이에 다른 요소가 올 수 있다. 요소 안에 요소가 중첩되는 관계를 통해 트리를 만들 수 있음 (부자-자식 관계) CSS는 부자-자식 관계가 없고 룰셋이 중첩되거나 하지는 않는다. CSS는 HTML 없으면 무용지물. CSSOM tree 는 DOM tree에 종속적이다. &lt;head&gt; 태그 안의 내용은 브라우저를 위한 정보를 적어준다. &lt;script&gt;태그도 &lt;head&gt;에게 적어주는 것이 맞으나, 이럴경우 &lt;script&gt;가 블락당할 수 있으니 body아래에 적어준다. DOM은 콘솔창 ➤ Properties 에 들어가야 확인 할 수 있다. 어트리뷰트와 DOM 요소는 항상 1대1 매칭되지 않는다. (예를들어 class, cal, span는 프로퍼티가 없다.) html 의 id, class 어트리뷰트의 값의 네이밍은 케밥케이스 , 카멜케이스가 통상적이다. class는 예전 버전에는 className에 문자열 형태로 추가되는 식이었기 때문에 split()를 이용해 하나하나 잘라내서 접근해야됬지만, 현재는 classList라는 객체를 통해서 관리되기 떄문에 더욱 간편해졌다. 태그 요소의 특정 속성들의 하위 자식들에게 상속될 수 있다. ( ul ➤ li : &lt;style = &quot;color:red&quot;&gt; ) 어트리뷰트는 프로퍼티와 구조가 다르다. (어트리뷰트 != 프로퍼티) 어트리뷰트 class != className , classList DOM 객체는 전부 window에 들어있다. DOM 트리 DOM 객체는 전부 window에 들어있다. DOM트리의 진입점은 항상 document다. 각각의 가지들을 ‘노드’ 라 한다. DOM tree에 접근하기 위한 시작점인 노드를 ‘문서노드’라 한다. html 태그 내의 요소와 1:1 맵핑하는 노드를 ‘요소노드’라 한다. html 태그 내의 요소의 어트리뷰트와 1:1 맵핑하는 노드를 ‘어트리뷰트 노드’라 한다. 어트리뷰트노드는 형제 노드다. html 태그 내의 요소 안의 텍스트들과 1:1 맵핑하는 노드를 ‘텍스트 노드’라 한다. 텍스트노드는 자식 노드다. 아래는 DOM tree의 객체 구조다. DOM 검색특정 요소에 접근하는 것을 의미. 하나의 요소 노드 선택document.getElementById(id) id 어트리뷰트 값으로 요소 노드를 한 개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작 id는 전역으로 만들어지기 때문에 이 방법은 추천하지 않는다. document.querySelector(cssSelector) CSS 셀렉터를 사용하여 요소 노드를 한 개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다. Return: HTMLElement를 상속받은 객체 IE8 이상의 브라우저에서 동작 배열메소드들이 더 다양하기 떄문에 배열로 변경하여 사용하면 좋다. 여러 개의 요소 노드 선택document.getElementsByClassName(class) class 어트리뷰트 값으로 요소 노드를 모두 선택한다. 공백으로 구분하여 여러 개의 class를 지정할 수 있다. Return: HTMLCollection (live) ➤ 매우 큰 혼란을 준다. IE9 이상의 브라우저에서 동작 사용 금지 document.querySelectorAll(selector) 지정된 CSS 선택자를 사용하여 요소 노드를 모두 선택한다. Return: NodeList (non-live) IE8 이상의 브라우저에서 동작 배열메소드들이 더 다양하기 떄문에 배열로 변경하여 사용하면 좋다. 12345// querySelectorAll는 Nodelist(non-live)를 반환한다. IE8+const elems = document.querySelectorAll('.red');// 배열메소드들이 더 다양하기 떄문에 배열로 변경하여 사용하면 좋다.[...elems].forEach(elem =&gt; elem.className = 'blue'); DOM 탐색​ DOM 검색 하여 특정 요소에 접근하여 그 요소에 대한 부모 형제 자식 등을 찾아가는 것을 의미. parentNode - 부모 부모 노드를 탐색한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작 firstChild, lastChild - 자식 텍스트노드를 포함한 자식 노드를 탐색한다. Return: HTMLElement를 상속받은 객체 IE9 이상의 브라우저에서 동작 위 두개의 프로퍼티는 각각 텍스트노드를 못건너뛰기 때문에 firstElementChild, lastElementChild를 사용한다. hasChildNodes() - 자식 자식 노드가 있는지 확인하고 Boolean 값을 반환한다. Return: Boolean 값 모든 브라우저에서 동작 childNodes - 자식 자식 노드의 컬렉션을 반환한다. 텍스트 요소를 포함한 모든 자식 요소를 반환한다. Return: NodeList (non-live) 모든 브라우저에서 동작 children - 자식 자식 노드의 컬렉션을 반환한다. 자식 요소 중에서 Element type 요소만을 반환한다. Return: HTMLCollection (live) IE9 이상의 브라우저에서 동작 previousSibling, nextSibling - 형제 형제 노드를 탐색한다. text node를 포함한 모든 형제 노드를 탐색한다. Return: HTMLElement를 상속받은 객체모든 브라우저에서 동작 previousElementSibling, nextElementSibling - 형제 형제 노드를 탐색한다. 형제 노드 중에서 Element type 요소만을 탐색한다. Return: HTMLElement를 상속받은 객체IE9 이상의 브라우저에서 동작 1234const elem = document.querySelector('ul');elem.firstElementChild.nextElementSibling.className = 'blue';elem.firstElementChild.nextElementSibling.previousElementSibling.className = 'blue'; DOM Manipulation (조작) 텍스트 노드에의 접근/수정 nodeValue , nodeType , nodeName 노드의 값을 반환한다. Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 반환 IE6 이상의 브라우저에서 동작한다. 1234567891011121314151617181920// 해당 텍스트 노드의 부모 요소 노드를 선택한다.const one = document.getElementById('one');console.dir(one); // HTMLLIElement: li#one.red// nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.console.log(one.nodeName); // LIconsole.log(one.nodeType); // 1: Element node// firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.const textNode = one.firstChild;// nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.console.log(textNode.nodeName); // #textconsole.log(textNode.nodeType); // 3: Text node// nodeValue 프로퍼티를 사용하여 노드의 값을 취득한다.console.log(textNode.nodeValue); // Seoul// nodeValue 프로퍼티를 이용하여 텍스트를 수정한다.textNode.nodeValue = 'Pusan'; 어트리뷰트 노드에의 접근/수정 어트리뷰트 노드을 조작할 때 다음 프로퍼티 또는 메소드를 사용할 수 있다. className class 어트리뷰트의 값을 취득 또는 변경한다. className 프로퍼티에 값을 할당하는 경우, class 어트리뷰트가 존재하지 않으면 class 어트리뷰트를 생성하고 지정된 값을 설정한다. class 어트리뷰트의 값이 여러 개일 경우, 공백으로 구분된 문자열이 반환되므로 String 메소드 split(&#39; &#39;)를 사용하여 배열로 변경하여 사용한다. 모든 브라우저에서 동작한다. classList add, remove, item, toggle, contains, replace 메소드를 제공한다. IE10 이상의 브라우저에서 동작한다. 추천한다. 12345678910111213141516171819const elems = document.querySelectorAll('li');// className[...elems].forEach(elem =&gt; &#123; // class 어트리뷰트 값을 취득하여 확인 if (elem.className === 'red') &#123; // class 어트리뷰트 값을 변경한다. elem.className = 'blue'; &#125;&#125;);// classList[...elems].forEach(elem =&gt; &#123; // class 어트리뷰트 값 확인 if (elem.classList.contains('blue')) &#123; // class 어트리뷰트 값 변경한다. elem.classList.replace('blue', 'red'); &#125;&#125;); id id 어트리뷰트의 값을 취득 또는 변경한다. id 프로퍼티에 값을 할당하는 경우, id 어트리뷰트가 존재하지 않으면 id 어트리뷰트를 생성하고 지정된 값을 설정한다.모든 브라우저에서 동작한다. 12345678910// h1 태그 요소 중 첫번째 요소를 취득const heading = document.querySelector('h1');console.dir(heading); // HTMLHeadingElement: h1console.log(heading.firstChild.nodeValue); // Cities// id 어트리뷰트의 값을 변경.// id 어트리뷰트가 존재하지 않으면 id 어트리뷰트를 생성하고 지정된 값을 설정heading.id = 'heading';console.log(heading.id); // heading 이외의 어트리뷰트 hasAttribute(attribute) 지정한 어트리뷰트를 가지고 있는지 검사한다. Return : Boolean IE8 이상의 브라우저에서 동작한다. getAttribute(attribute) 어트리뷰트의 값을 취득한다. Return : 문자열 모든 브라우저에서 동작한다. setAttribute(attribute, value) 어트리뷰트와 어트리뷰트 값을 설정한다. Return : undefined 모든 브라우저에서 동작한다. removeAttribute(attribute) 지정한 어트리뷰트를 제거한다. Return : undefined 모든 브라우저에서 동작한다. attribute는 고정값 이고 DOM객체의 프로퍼티는 동적으로 변한다. Attributes는 key : value 형태로 관리한다. 1&lt;input type=\"text\" value=\"100\"&gt; 위 input태그의 value어트리뷰트의 값 100은 고정(초기값)이다. 이 값을 직접 변경을 하고 싶다면 input태그 안의 Attributes 프로퍼티 내의 value를 변경해야한다. input 요소의 value프로퍼티를 변경해도 초기값은 그대로 100이다. 즉, 어트리뷰트 와 프로퍼티는 다른것이며 따로 관리된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"my-id\" style=\"color: red\"&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;Java Script&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"myId\" style=\"color: green\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;input type=\"text\" value=\"100\"&gt; &lt;script&gt; // 요소 1개 선택 const $ul = document.querySelector('#my-id'); console.log($ul); console.log($ul.style.color = 'blue'); console.log([...$ul.classList].forEach((item) =&gt; console.log(item))); console.log($ul.classList.add('class3')); console.log($ul.classList.contains('class3')); console.log($ul.classList.remove('class3')); $ul.firstElementChild.style.color = 'red'; // 다중 요소 선택 const $lis = document.querySelectorAll('li'); console.log($lis); [...$lis].forEach((item, index) =&gt; item.classList.add(`class$&#123;index + 1&#125;`)); console.log($lis); // ul.#myId 안에 있는 요소들을 문자열로 반환한다. console.log(document.querySelector('#myId').innerHTML); document.querySelector('#myId').innerHTML = '&lt;h1&gt;Hi&lt;/h1&gt;'; document.querySelector('#myId').innerHTML += '&lt;h2&gt;Hi&lt;/h2&gt;'; // 어트리뷰트 접근 const $input = document.querySelector('input'); console.dir($input); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML 콘텐츠 조작(Manipulation) textContent 요소의 텍스트 콘텐츠를 취득 또는 변경한다. 이때 마크업은 무시된다. textContent를 통해 요소에 새로운 텍스트를 할당하면 텍스트를 변경할 수 있다. 이때 순수한 텍스트만 지정해야 하며 마크업을 포함시키면 문자열로 인식되어 그대로 출력된다. IE9 이상의 브라우저에서 동작한다. innerText innerText 프로퍼티를 사용하여도 요소의 텍스트 콘텐츠에만 접근할 수 있다. 하지만 아래의 이유로 사용하지 않는 것이 좋다. 비표준이다. CSS에 순종적이다. 예를 들어 CSS에 의해 비표시(visibility: hidden;)로 지정되어 있다면 텍스트가 반환되지 않는다. CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다 innerHTML 해당 요소의 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다. 이 문자열은 마크업을 포함한다. 마크업이 포함된 새로운 콘텐츠를 지정하면 새로운 요소를 DOM에 추가할 수 있다. 크로스 스크립팅 공격에 취약하다. 12345678910const one = document.getElementById('one');// 마크업이 포함된 콘텐츠 취득console.log(one.innerHTML); // Seoul// 마크업이 포함된 콘텐츠 변경one.innerHTML += '&lt;em class=\"blue\"&gt;, Korea&lt;/em&gt;';// 마크업이 포함된 콘텐츠 취득console.log(one.innerHTML); // Seoul &lt;em class=\"blue\"&gt;, Korea&lt;/em&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 30강(DOM)","slug":"javascript-preview-30","date":"2019-10-29T02:53:28.000Z","updated":"2019-11-30T17:05:16.642Z","comments":true,"path":"2019/10/29/javascript-preview-30/","link":"","permalink":"https://hyeok999.github.io/2019/10/29/javascript-preview-30/","excerpt":"","text":"JavaScript 30강 예습 30강 : 문서 객체 모델 (Document Object Model) DOM 30강문서 객체 모델 (Document Object Model)DOM 바로가기","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://hyeok999.github.io/tags/DOM/"},{"name":"Document Object Model","slug":"Document-Object-Model","permalink":"https://hyeok999.github.io/tags/Document-Object-Model/"}]},{"title":"3주차 시험 개념정리","slug":"test-arrange03","date":"2019-10-29T02:45:12.000Z","updated":"2019-11-30T16:56:45.108Z","comments":true,"path":"2019/10/29/test-arrange03/","link":"","permalink":"https://hyeok999.github.io/2019/10/29/test-arrange03/","excerpt":"","text":"짧은 개념 정리글 실행 컨텍스트식별자, 스코프, 호이스팅, 클로저 등의 동작원리를 담고 있는 자바스크립트의 핵심개념.실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역. 실행 컨텍스트 등록 과정코드의 평가 과정에서 실행 컨텍스트가 생성되고 변수, 함수, 클래스 등의 선언문이 평가되어 그 결과가 실행 컨텍스트에 등록 -&gt; 코드 평가 과정 끝 -&gt; 선언문을 제외한 코드 순차적으로 실행 실행 컨텍스트 스택코드의 실행 순서를 스택형태의 자료구조로 관리. ( = 콜스택) 렉시컬 환경스코프와 식별자를 관리. 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 한다. 렉시컬 환경의 3가지 콤퍼넌트 환경레코드 외부렉시컬환경참조 ThisBinding 실행 컨텍스트의 생성과 식별자 검색 과정 전역 객체 생성 (코드가 평가 되기 이전에 생성된다.) 전역 코드 평가 전역 실행 컨텍스트 생성 전역 렉시컬 환경 생성 객체 환경 레코드 생성 선언적 환경 레코드 생성 외부 렉시컬 환경에 대한 참조 할당 this 바인딩 함수 호출 함수 실행 컨텍스트 생성 함수 렉시컬 환경 생성 함수 환경 레코드 생성 외부 렉시컬 환경에 대한 참조 할당 this 바인딩 식별자를 검색할 때는 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색한다. 클로저​ 함수와 그 함수가 선언된 렉시컬 환경(Lexical environment)과의 조합이다. 함수 객체의 내부 슬롯 [[Environment]]​ 함수는 자신의 내부 슬롯[[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다. 클로저의 역할 상태를 안전하게 유지하기 위해 사용. 의도치 않게 변경되지 않도록 안전하게 은닉. 상태가 변경되면 최신 상태(state)를 유지. 아래는 왜 클로저가 아닌가? 함수 makeCounter를 호출해 함수를 반환할 때 반환된 함수는 자신만의 독립된 렉시컬 환경을 갖는다 문제는 2개의 makeCounter를 호출 했으므로 각각의 렉시컬환경에 counter라는 변수를 전부 가지고 있으므로 counter는 증감 되지 않는다. 12345678910111213141516171819202122232425262728293031323334// 함수를 인수로 전달받고 함수를 반환하는 고차 함수// 이 함수가 반환하는 함수는 카운트 상태를 유지하기 위한 자유 변수 counter을 기억하는 클로저다.function makeCounter(predicate) &#123; // 카운트 상태를 유지하기 위한 자유 변수 let counter = 0; // 클로저를 반환 return function () &#123; // 인수로 전달 받은 보조 함수에 상태 변경을 위임한다. counter = predicate(counter); return counter; &#125;;&#125;// 보조 함수function increase(n) &#123; return ++n;&#125;// 보조 함수function decrease(n) &#123; return --n;&#125;// 함수로 함수를 생성한다.// makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환한다const increaser = makeCounter(increase); // ①console.log(increaser()); // 1console.log(increaser()); // 2// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.const decreaser = makeCounter(decrease); // ②console.log(decreaser()); // -1console.log(decreaser()); // -2 클로저를 사용시 나타나는 실수1234567891011var arr = [];for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; // ① return i; &#125;;&#125;for (var j = 0; j &lt; arr.length; j++) &#123; console.log(arr[j]()); // ②&#125; 출력시 i가 게속 5로만 출력된다. i를 var키워드로 선언했고 따라서 i는 전역 렉시컬 환경의 window의 소유이기 때문이다. arr함수 호출이 2번째 for문 때 일어나기 때문에 그 때 실행컨텍스트가 쌓이고 i를 반환한다. 그 때의 i는 값이 5다. 따라서 5를 5번 출력한다. 해결법 1 - 즉시 실행 함수12345678910111213var arr = [];for (var i = 0; i &lt; 5; i++)&#123; arr[i] = (function (id) &#123; // ① return function () &#123; return id; &#125;; &#125;(i));&#125;for (var j = 0; j &lt; arr.length; j++) &#123; console.log(arr[j]());&#125; 즉시 실행 함수의 매개변수 id는 반환한 함수의 상위 스코프(즉시 실행 함수)에 존재하기 때문에 자유변수가 된다. 즉시 실행 함수가 반환한 함수에 의해 그 값이 유지된다. 해결법 2 - let 키워드 사용123456789const arr = [];for (let i = 0; i &lt; 3; i++) &#123; arr[i] = () =&gt; i;&#125;for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]()); // 0 1 2&#125; for 문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다. 자바스크립트의 클래스함수. 객체를 만드는 용도. 클래스 vs 생성자함수 클래스는 new 연산자 없이 호출 시 에러를 발생한다. 상속을 지원하는 extends 키워드 와 super키워드 제공 클래스는 호이스팅이 발생하지 않는 것처럼 동작함( 마치 let, const ) 암묵적으로 strict모드로 실행됨(해지 불가) 클래스의 메소드들은 모두 열거되지 않는다. 클래스는 문법적 설탕이 아닌 이유​ 생성자 함수를 기반으로 한 객체 생성방식보다 견고하면서 명료하기 때문에 새로운 객체 생성 메카니즘이다. 클래스의 메소드 3가지 정적 메소드 ( static sayHello( ) { } ) 프로토타입 메소드 ( sayHello( ) { } ) constructor 메소드 ( constructor( ) { } ) 클래스에서 정의한 메소드의 특징 메소드 축약 표현을 이용 콤마가 필요없다. 암묵적인 strict모드 열거 불가능 new연산자와 함께 호출이 불가능. 클래스 인스턴스 생성 과정 인스턴스 생성 (빈 객체) 해당 인스턴스의 prototype 객체가 설정됨. 인스턴스를 this에 암묵적으로 바인딩 ( constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킴. ) 인스턴스 초기화 (프로퍼티 추가) 프로토 타입 / 정적 메소드 추가 인스턴스 반환 클래스 private 필드123456class Person &#123; // private 필드 정의 #_name = '';&#125;const person = new Person(); person.#_name을 참조하면 private 관련 에러를 발생하고, person._name을 참조하면 undefined를 반환한다. extends 부모 클래스를 자식 클래스에 상속하는 키워드 super수퍼클래스의 constructor를 호출. super를 참조하여 수퍼클래스의 메소드를 호출. constructor를 기재시 반드시 counstructor 내부 최상단에 작성해야됨. constructor를 기재하고 super를 안적거나 최상단에 미기재시 에러 발생. (constructor를 미기재했다면 암묵적으로 전달함) 서브 클래스의 constructor 에서만 호출. 상속 클래스의 인스턴스 생성과정 서브클래스의 super 호출 - 내부 슬롯 [[ConstructorKind]] (‘base’, ‘derived’) = ‘derived’ 인스턴스 생성(빈객체)을 수퍼클래스에게 위임. 수퍼클래스 인스턴스 생성 및 this 바인딩 수퍼클래스의 인스턴스 초기화 수퍼클래스의 프로토타입 / 정적 메소드 추가 서브 클래스 constructor로의 복귀 및 this 바인딩 서브 클래스 인스턴스 초기화 인스턴스 반환","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"daily test","slug":"daily-test","permalink":"https://hyeok999.github.io/tags/daily-test/"}]},{"title":"DOM","slug":"DOM","date":"2019-10-29T02:33:55.000Z","updated":"2019-11-30T17:07:17.537Z","comments":true,"path":"2019/10/29/DOM/","link":"","permalink":"https://hyeok999.github.io/2019/10/29/DOM/","excerpt":"","text":"JavaScript 30강(M) 30강 : 문서 객체 모델 (Document Object Model) DOM (Document Object Model) DOM tree DOM tree의 종류 DOM 조작 순서 DOM Query (요소 접근) html 예제 하나의 요소 노드 선택 document.getElementById(id) document.querySelector(cssSelector) 여러개의 요소 노드 선택 document.getElementsByClassName (class) HTMLCollection 회피 방법 document.getElementsByTagName(tagName) document.querySelectorAll(selector) DOM Traversing (탐색) html 예제 parentNode firstChild, lastChild firstElementChild, lastElementChild ( firstChild, lastChild 대체 ) hasChildNodes() childNodes children previousSibling, nextSibling previousElementSibling, nextElementSibling DOM Manipulation (조작) 텍스트 노드의 접근 / 수정 nodeValue 어트리뷰트 노드의 접근 / 수정 className classList id hasAttribute(attribute) getAttribute(attribute) setAttribute(attribute, value) removeAttribute(attribute) HTML 콘텐츠 조작(Manipulation) textContent innerText innerHTML DOM 조작 방식 createElement(tagName) createTextNode(text) appendChild(Node) removeChild(Node) insertAdjacentHTML( ) insertAdjacentHTML(position, string) innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML() style style 프로퍼티 window.getComputedStyle( element[, pseudoElt] ) CssStyle.getPropertyValue( StyleProperty ) 30강문서 객체 모델 (Document Object Model) 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다. 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다. 이 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다. DOM은 HTML, ECMAScript에서 정의한 표준이 아닌 별개의 W3C의 공식 표준이며 플랫폼/프로그래밍 언어 중립적이다.DOM은 다음 두 가지 기능을 담당한다. HTML 문서에 대한 모델 구성 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다. 이때 모델은 객체의 트리로 구성되는데 이것을 DOM tree라 한다. HTML 문서 내의 각 요소에 접근 / 수정 DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다. DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다. DOM tree DOM tree는 브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 모델을 의미한다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red &#123; color: #ff0000; &#125; .blue &#123; color: #0000ff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; DOM tree의 종류 문서 노드(Document Node) 트리의 최상위에 존재하며 각각 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다. 즉, DOM tree에 접근하기 위한 시작점(entry point)이다. 요소 노드(Element Node) 요소 노드는 HTML 요소를 표현한다. HTML 요소는 중첩에 의해 부자 관계를 가지며 이 부자 관계를 통해 정보를 구조화한다. 따라서 요소 노드는 문서의 구조를 서술한다고 말 할 수 있다. 어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다. 모든 요소 노드는 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성된다. 어트리뷰트 노드(Attribute Node) 어트리뷰트 노드는 HTML 요소의 어트리뷰트를 표현한다. 어트리뷰트 노드는 해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현된다. 따라서 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조, 수정할 수 있다. 텍스트 노드(Text Node) 텍스트 노드는 HTML 요소의 텍스트를 표현한다. 텍스트 노드는 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없다. 즉, 텍스트 노드는 DOM tree의 최종단이다. DOM 조작 순서 조작하고자하는 요소를 선택 또는 탐색한다. 선택된 요소의 콘텐츠 또는 어트리뷰트를 조작한다. DOM Query (요소 접근)html 예제 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red &#123; color: #ff0000; &#125; .blue &#123; color: #0000ff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 하나의 요소 노드 선택 document.getElementById(id) id 어트리뷰트 값으로 요소 노드를 한 개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작 1234567891011// id로 하나의 요소를 선택한다.const elem = document.getElementById('one');// 클래스 어트리뷰트의 값을 변경한다.elem.className = 'blue';// 그림: DOM tree의 객체 구성 참고console.log(elem); // &lt;li id=\"one\" class=\"blue\"&gt;Seoul&lt;/li&gt;console.log(elem.__proto__); // HTMLLIElementconsole.log(elem.__proto__.__proto__); // HTMLElementconsole.log(elem.__proto__.__proto__.__proto__); // Elementconsole.log(elem.__proto__.__proto__.__proto__.__proto__); // Node document.querySelector(cssSelector) CSS 셀렉터를 사용하여 요소 노드를 한 개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다.Return: HTMLElement를 상속받은 객체IE8 이상의 브라우저에서 동작 1234// CSS 셀렉터를 이용해 요소를 선택한다const elem = document.querySelector('li.red');// 클래스 어트리뷰트의 값을 변경한다.elem.className = 'blue'; 여러 개의 요소 노드 선택 (DOM Query) document.getElementsByClassName (class) class 어트리뷰트 값으로 요소 노드를 모두 선택한다. 공백으로 구분하여 여러 개의 class를 지정할 수 있다. Return: HTMLCollection (live) IE9 이상의 브라우저에서 동작 1234567// HTMLCollection을 반환한다. HTMLCollection은 live하다.const elems = document.getElementsByClassName('red');for (let i = 0; i &lt; elems.length; i++) &#123; // 클래스 어트리뷰트의 값을 변경한다. elems[i].className = 'blue';&#125; 위 예제는 제대로 작동하지 않는다. 이유 : getElementsByClassName 메소드의 반환값은 [HTMLCollection]이다. 실시간으로 Node의 상태 변경을 반영한다. [HTMLCollection]는 실시간으로 Node의 상태 변경을 반영하기 때문에 loop가 필요한 경우 주의가 필요하다. i가 0일 때, elems 의 첫 요소의 어트리브뷰트 값(red)를 블루로 바꾼다. (li#one.red ➤ li#one.blue) 문제는 실시간으로 Node의 상태가 변경되어 elems.length가 3이 아닌 2가 된다. 실제로 elems[0] 번째는 배열에 배제된것인다. 따라서 i가 1일 때, 실제로 elems[2]번째 li#three.red 를 가리키게 된 것이나 다름이 없다. 이런식으로 게속가면 elems[1]번째는 건너띄었으므로 elems[1]는 li#two.red를 유지하고 있다. HTMLCollection 회피 방법 반복문을 역으로 돌린다. 12345const elems = document.getElementsByClassName('red');for (let i = elems.length - 1; i &gt;= 0; i--) &#123; elems[i].className = 'blue';&#125; while 반복문을 쓰고 elems요소가 남아있지 않을 때 까지 돌리기 위해 index를 0으로 고정시킨다. 1234567const elems = document.getElementsByClassName('red');let i = 0;while (elems.length &gt; i) &#123; // elems에 요소가 남아 있지 않을 때까지 무한반복 elems[i].className = 'blue'; // i++;&#125; HTMLCollection을 배열로 변경한다. ( 제일 추천! ) 12345678const elems = document.getElementsByClassName('red');// 유사 배열 객체인 HTMLCollection을 배열로 변환한다.// 배열로 변환된 HTMLCollection은 더 이상 live하지 않다.console.log([...elems]); // [li#one.red, li#two.red, li#three.red]//Array.prototype.slice.apply(elems).forEach(elem =&gt; elem.className = 'blue');[...elems].forEach(elem =&gt; elem.className = 'blue'); querySelectorAll 메소드를 사용하여 HTMLCollection(live)이 아닌 NodeList(non-live)를 반환하게 한다. 1234// querySelectorAll는 Nodelist(non-live)를 반환한다. IE8+const elems = document.querySelectorAll('.red');[...elems].forEach(elem =&gt; elem.className = 'blue'); document.getElementsByTagName(tagName) 태그명으로 요소 노드를 모두 선택한다. Return: HTMLCollection (live) 모든 브라우저에서 동작 1234// HTMLCollection을 반환한다.const elems = document.getElementsByTagName('li');[...elems].forEach(elem =&gt; elem.className = 'blue'); document.querySelectorAll(selector) 지정된 CSS 선택자를 사용하여 요소 노드를 모두 선택한다. Return: NodeList (non-live) IE8 이상의 브라우저에서 동작 1234// Nodelist를 반환한다.const elems = document.querySelectorAll('li.red');[...elems].forEach(elem =&gt; elem.className = 'blue'); DOM Traversing (탐색) parentNode 부모 노드를 탐색한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작 123const elem = document.querySelector('#two');elem.parentNode.className = 'blue'; firstChild, lastChild 자식 노드를 탐색한다. Return: HTMLElement를 상속받은 객체 IE9 이상의 브라우저에서 동작 123456const elem = document.querySelector('ul');// first Childelem.firstChild.className = 'blue';// last Childelem.lastChild.className = 'blue'; 위 예제를 실행해 보면 예상대로 동작하지 않는다. 이유 : IE를 제외한 대부분의 브라우저들은 요소 사이의 공백 또는 줄바꿈 문자를 텍스트 노드로 취급하기 때문이다. 이것을 회피하기 위해서는 아래와 같이 HTML의 공백을 제거하거나 jQuery: .prev()와 jQuery: .next()를 사용한다. 12345&lt;ul&gt;&lt;li id='one' class='red'&gt;Seoul&lt;/li&gt;&lt;li id='two' class='red'&gt;London&lt;/li&gt;&lt;li id='three' class='red'&gt;Newyork&lt;/li&gt;&lt;li id='four'&gt;Tokyo&lt;/li&gt;&lt;/ul&gt; 위와 같이 공백을 모두 제거 해주어야만 한다. firstElementChild, lastElementChild ( firstChild, lastChild 대체 ) 모든 IE9 이상에서 정상 동작한다. firstChild, lastChild 대체 123456const elem = document.querySelector('ul');// first Childelem.firstElementChild.className = 'blue';// last Childelem.lastElementChild.className = 'blue'; hasChildNodes() 자식 노드가 있는지 확인하고 Boolean 값을 반환한다. Return: Boolean 값 모든 브라우저에서 동작 childNodes 자식 노드의 컬렉션을 반환한다. 텍스트 요소를 포함한 모든 자식 요소를 반환한다. Return: NodeList (non-live) 모든 브라우저에서 동작 children 자식 노드의 컬렉션을 반환한다. 자식 요소 중에서 Element type 요소만을 반환한다. Return: HTMLCollection (live) IE9 이상의 브라우저에서 동작 123456789101112const elem = document.querySelector('ul');if (elem.hasChildNodes()) &#123; console.log(elem.childNodes); // 텍스트 요소를 포함한 모든 자식 요소를 반환한다. // NodeList(9) [text, li#one.red, text, li#two.red, text, li#three.red, text, li#four, text] console.log(elem.children); // 자식 요소 중에서 Element type 요소만을 반환한다. // HTMLCollection(4) [li#one.red, li#two.red, li#three.red, li#four, one: li#one.red, two: li#two.red, three: li#three.red, four: li#four] [...elem.children].forEach(el =&gt; console.log(el.nodeType)); // 1 (=&gt; Element node)&#125; previousSibling, nextSibling 형제 노드를 탐색한다. text node를 포함한 모든 형제 노드를 탐색한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작 previousElementSibling, nextElementSibling 형제 노드를 탐색한다. 형제 노드 중에서 Element type 요소만을 탐색한다. Return: HTMLElement를 상속받은 객체 IE9 이상의 브라우저에서 동작 1234const elem = document.querySelector('ul');elem.firstElementChild.nextElementSibling.className = 'blue';elem.firstElementChild.nextElementSibling.previousElementSibling.className = 'blue'; DOM Manipulation (조작)텍스트 노드의 접근 / 수정 요소의 텍스트는 텍스트 노드에 저장되어 있다. 텍스트 노드의 접근은 다음과 같은 절차를 이용한다. 해당 텍스트 노드의 부모 노드를 선택한다. 텍스트 노드는 요소 노드의 자식이다. firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다. 텍스트 노드의 유일한 프로퍼티(nodeValue)를 이용하여 텍스트를 취득한다. nodeValue를 이용하여 텍스트를 수정한다. nodeValue 노드의 값을 반환한다. Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 반환 IE6 이상의 브라우저에서 동작한다. nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.nodeValue 프로퍼티를 사용하여 노드의 값을 취득 및 수정한다. 1234567891011121314151617181920// 해당 텍스트 노드의 부모 요소 노드를 선택한다.const one = document.getElementById('one');console.dir(one); // HTMLLIElement: li#one.red// nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.console.log(one.nodeName); // LIconsole.log(one.nodeType); // 1: Element node// firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.const textNode = one.firstChild;// nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.console.log(textNode.nodeName); // #textconsole.log(textNode.nodeType); // 3: Text node// nodeValue 프로퍼티를 사용하여 노드의 값을 취득한다.console.log(textNode.nodeValue); // Seoul// nodeValue 프로퍼티를 이용하여 텍스트를 수정한다.textNode.nodeValue = 'Pusan'; 어트리뷰트 노드의 접근 / 수정 어트리뷰트 노드을 조작 프로퍼티 및 메소드 className class 어트리뷰트의 값을 취득 또는 변경한다. className 프로퍼티에 값을 할당하는 경우, class 어트리뷰트가 존재하지 않으면 class 어트리뷰트를 생성하고 지정된 값을 설정한다. class 어트리뷰트의 값이 여러 개일 경우, 공백으로 구분된 문자열이 반환되므로 String 메소드 split(&#39; &#39;)를 사용하여 배열로 변경하여 사용한다. 모든 브라우저에서 동작한다. classList add, remove, item, toggle, contains, replace 메소드를 제공한다.IE10 이상의 브라우저에서 동작한다. 12345678910111213141516171819const elems = document.querySelectorAll('li');// className[...elems].forEach(elem =&gt; &#123; // class 어트리뷰트 값을 취득하여 확인 if (elem.className === 'red') &#123; // class 어트리뷰트 값을 변경한다. elem.className = 'blue'; &#125;&#125;);// classList[...elems].forEach(elem =&gt; &#123; // class 어트리뷰트 값 확인 if (elem.classList.contains('blue')) &#123; // class 어트리뷰트 값 변경한다. elem.classList.replace('blue', 'red'); &#125;&#125;); id id 어트리뷰트의 값을 취득 또는 변경한다. id 프로퍼티에 값을 할당하는 경우, id 어트리뷰트가 존재하지 않으면 id 어트리뷰트를 생성하고 지정된 값을 설정한다. 모든 브라우저에서 동작한다. 12345678910// h1 태그 요소 중 첫번째 요소를 취득const heading = document.querySelector('h1');console.dir(heading); // HTMLHeadingElement: h1console.log(heading.firstChild.nodeValue); // Cities// id 어트리뷰트의 값을 변경.// id 어트리뷰트가 존재하지 않으면 id 어트리뷰트를 생성하고 지정된 값을 설정heading.id = 'heading';console.log(heading.id); // heading hasAttribute(attribute) 지정한 어트리뷰트를 가지고 있는지 검사한다. Return : Boolean IE8 이상의 브라우저에서 동작한다. getAttribute(attribute) 어트리뷰트의 값을 취득한다. Return : 문자열 모든 브라우저에서 동작한다. setAttribute(attribute, value) 어트리뷰트와 어트리뷰트 값을 설정한다. Return : undefined 모든 브라우저에서 동작한다. removeAttribute(attribute) 지정한 어트리뷰트를 제거한다. Return : undefined 모든 브라우저에서 동작한다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;input type=\"text\"&gt; &lt;script&gt; const input = document.querySelector('input[type=text]'); console.log(input); // value 어트리뷰트가 존재하지 않으면 if (!input.hasAttribute('value')) &#123; // value 어트리뷰트를 추가하고 값으로 'hello!'를 설정 input.setAttribute('value', 'hello!'); &#125; // value 어트리뷰트 값을 취득 console.log(input.getAttribute('value')); // hello! // value 어트리뷰트를 제거 input.removeAttribute('value'); // value 어트리뷰트의 존재를 확인 console.log(input.hasAttribute('value')); // false &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;input class=\"password\" type=\"password\" value=\"123\"&gt; &lt;button class=\"show\"&gt;show&lt;/button&gt; &lt;script&gt; const $password = document.querySelector('.password'); const $show = document.querySelector('.show'); function makeClickHandler() &#123; let isShow = false; return function () &#123; $password.setAttribute('type', isShow ? 'password' : 'text'); isShow = !isShow; $show.innerHTML = isShow ? 'hide' : 'show'; &#125;; &#125; $show.onclick = makeClickHandler(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; HTML 콘텐츠 조작(Manipulation) HTML 콘텐츠를 조작(Manipulation)하기 위해 아래의 프로퍼티 또는 메소드를 사용할 수 있다. textContent 요소의 텍스트 콘텐츠를 취득 또는 변경한다. 이때 마크업은 무시된다. textContent를 통해 요소에 새로운 텍스트를 할당하면 텍스트를 변경할 수 있다. 이때 순수한 텍스트만 지정해야 하며 마크업을 포함시키면 문자열로 인식되어 그대로 출력된다. IE9 이상의 브라우저에서 동작한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red &#123; color: #ff0000; &#125; .blue &#123; color: #0000ff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; const ul = document.querySelector('ul'); // 요소의 텍스트 취득 console.log(ul.textContent); /* Seoul London Newyork Tokyo */ const one = document.getElementById('one'); // 요소의 텍스트 취득 console.log(one.textContent); // Seoul // 요소의 텍스트 변경 one.textContent += ', Korea'; console.log(one.textContent); // Seoul, Korea // 요소의 마크업이 포함된 콘텐츠 변경. - 마크업을 포함시키면 안된다. one.textContent = '&lt;h1&gt;Heading&lt;/h1&gt;'; // 마크업이 문자열로 표시된다. console.log(one.textContent); // &lt;h1&gt;Heading&lt;/h1&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; innerText innerText 프로퍼티를 사용하여도 요소의 텍스트 콘텐츠에만 접근할 수 있다. 하지만 아래의 이유로 사용하지 않는 것이 좋다. 비표준이다. CSS에 순종적이다. 예를 들어 CSS에 의해 비표시(visibility: hidden;)로 지정되어 있다면 텍스트가 반환되지 않는다. CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다. innerHTML 해당 요소의 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다. 이 문자열은 마크업을 포함한다. 1234567891011const ul = document.querySelector('ul');// innerHTML 프로퍼티는 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다. 이 문자열은 마크업을 포함한다.console.log(ul.innerHTML);// IE를 제외한 대부분의 브라우저들은 요소 사이의 공백 또는 줄바꿈 문자를 텍스트 노드로 취급한다/* &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt;*/ innerHTML 프로퍼티를 사용하여 마크업이 포함된 새로운 콘텐츠를 지정하면 새로운 요소를 DOM에 추가할 수 있다. 12345678910const one = document.getElementById('one');// 마크업이 포함된 콘텐츠 취득console.log(one.innerHTML); // Seoul// 마크업이 포함된 콘텐츠 변경one.innerHTML += '&lt;em class=\"blue\"&gt;, Korea&lt;/em&gt;';// 마크업이 포함된 콘텐츠 취득console.log(one.innerHTML); // Seoul &lt;em class=\"blue\"&gt;, Korea&lt;/em&gt; 마크업이 포함된 콘텐츠를 추가하는 것은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. 12345678910// 크로스 스크립팅 공격 사례// 스크립트 태그를 추가하여 자바스크립트가 실행되도록 한다.// HTML5에서 innerHTML로 삽입된 &lt;script&gt; 코드는 실행되지 않는다.// 크롬, 파이어폭스 등의 브라우저나 최신 브라우저 환경에서는 작동하지 않을 수도 있다.elem.innerHTML = '&lt;script&gt;alert(\"XSS!\")&lt;/script&gt;';// 에러 이벤트를 발생시켜 스크립트가 실행되도록 한다.// 크롬에서도 실행된다!elem.innerHTML = '&lt;img src=\"#\" onerror=\"alert(\\'XSS\\')\"&gt;'; DOM 조작 방식innerHTML 프로퍼티를 사용하지 않고 새로운 콘텐츠를 추가할 수 있는 방법은 DOM을 직접 조작하는 것이다.한 개의 요소를 추가하는 경우 사용한다. 요소 노드 생성 createElement() 메소드를 사용하여 새로운 요소 노드를 생성한다. createElement() 메소드의 인자로 태그 이름을 전달한다. 텍스트 노드 생성 createTextNode() 메소드를 사용하여 새로운 텍스트 노드를 생성한다. 경우에 따라 생략될 수 있지만 생략하는 경우, 콘텐츠가 비어 있는 요소가 된다. 생성된 요소를 DOM에 추가 appendChild() 메소드를 사용하여 생성된 노드를 DOM tree에 추가한다. 또는 removeChild() 메소드를 사용하여 DOM tree에서 노드를 삭제할 수도 있다. createElement(tagName) 태그이름을 인자로 전달하여 요소를 생성한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작한다. createTextNode(text) 텍스트를 인자로 전달하여 텍스트 노드를 생성한다. Return: Text 객체 모든 브라우저에서 동작한다. appendChild(Node) 인자로 전달한 노드를 마지막 자식 요소로 DOM 트리에 추가한다. Return: 추가한 노드 모든 브라우저에서 동작한다. removeChild(Node) 인자로 전달한 노드를 DOM 트리에 제거한다. Return: 추가한 노드 모든 브라우저에서 동작한다. 1234567891011121314151617181920// 태그이름을 인자로 전달하여 요소를 생성const newElem = document.createElement('li');// const newElem = document.createElement('&lt;li&gt;test&lt;/li&gt;');// Uncaught DOMException: Failed to execute 'createElement' on 'Document': The tag name provided ('&lt;li&gt;test&lt;/li&gt;') is not a valid name.// 텍스트 노드를 생성const newText = document.createTextNode('Beijing');// 텍스트 노드를 newElem 자식으로 DOM 트리에 추가newElem.appendChild(newText);const container = document.querySelector('ul');// newElem을 container의 자식으로 DOM 트리에 추가. 마지막 요소로 추가된다.container.appendChild(newElem);const removeElem = document.getElementById('one');// container의 자식인 removeElem 요소를 DOM 트리에 제거한다.container.removeChild(removeElem); insertAdjacentHTML() insertAdjacentHTML(position, string) 인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입한다. 첫번째 인자는 삽입 위치 두번째 인자는 삽입할 요소를 표현한 문자열이다. 첫번째 인자로 올 수 있는 값은 아래와 같다. ‘beforebegin’ ‘afterbegin’ ‘beforeend’ ‘afterend’ 모든 브라우저에서 동작한다. 1234jconst one = document.getElementById('one');// 마크업이 포함된 요소 추가one.insertAdjacentHTML('beforeend', '&lt;em class=\"blue\"&gt;, Korea&lt;/em&gt;'); innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML() innerHTML 장점 단점 DOM 조작 방식에 비해 빠르고 간편하다. XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의하여야 한다. 간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있다. 해당 요소의 내용을 덮어 쓴다. 즉, HTML을 다시 파싱한다. 이것은 비효율적이다. 콘텐츠를 취득할 수 있다. DOM 조작 방식 ➤createElement(tagName) , createTextNode(text), appendChild(Node) removeChild(Node) 장점 단점 특정 노드 한 개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합하다. innerHTML보다 느리고 더 많은 코드가 필요하다. insertAdjacentHTML() 장점 단점 간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다. XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의하여야 한다. 삽입되는 위치를 선정할 수 있다. 결론 innerHTML과 insertAdjacentHTML()은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. 따라서 untrusted data의 경우, 주의하여야 한다. 텍스트를 추가 또는 변경시에는 textContent, 새로운 요소의 추가 또는 삭제시에는 DOM 조작 방식을 사용하도록 한다. stylestyle 프로퍼티 inline 스타일 선언을 생성한다. 특정 요소에 inline 스타일을 지정하는 경우 사용한다. -으로 구분되는 프로퍼티는 카멜케이스로 변환하여 사용한다. 1234567const four = document.getElementById('four');// inline 스타일 선언을 생성four.style.color = 'blue';// font-size와 같이 '-'으로 구분되는 프로퍼티는 카멜케이스로 변환하여 사용한다.four.style.fontSize = '2em'; window.getComputedStyle(element[, pseudoElt]) style 프로퍼티의 값을 취득할 때 사용한다. 인자로 주어진 요소의 모든 CSS 프로퍼티 값을 반환한다. 2번쨰 인자는 옵션이며, 의사 요소를 지정하는 문자열을 입력한다. (보통의 요소들은 생략 혹은 null을 적는다.) 의사요소 : ::after , ::before , ::marker , ::line-marker 등등 CssStyle.getPropertyValue( StyleProperty ) 특정 CSS 속성 값을 반환한다. 인자로 스타일 객체의 프로퍼티 키를 받는다, 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;style 프로퍼티 값 취득&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 50px; background-color: red; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;script&gt; const box = document.querySelector('.box'); const width = getStyle(box, 'width'); const height = getStyle(box, 'height'); const backgroundColor = getStyle(box, 'background-color'); const border = getStyle(box, 'border'); console.log('width: ' + width); console.log('height: ' + height); console.log('backgroundColor: ' + backgroundColor); console.log('border: ' + border); /** * 요소에 적용된 CSS 프로퍼티를 반환한다. * @param &#123;HTTPElement&#125; elem - 대상 요소 노드. * @param &#123;string&#125; prop - 대상 CSS 프로퍼티. * @returns &#123;string&#125; CSS 프로퍼티의 값. */ function getStyle(elem, prop) &#123; return window.getComputedStyle(elem, null).getPropertyValue(prop); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://hyeok999.github.io/tags/DOM/"},{"name":"Document Object Model","slug":"Document-Object-Model","permalink":"https://hyeok999.github.io/tags/Document-Object-Model/"}]},{"title":"daily_algorithm25","slug":"daily-algorithm25","date":"2019-10-28T07:28:11.000Z","updated":"2019-11-30T17:12:49.423Z","comments":true,"path":"2019/10/28/daily-algorithm25/","link":"","permalink":"https://hyeok999.github.io/2019/10/28/daily-algorithm25/","excerpt":"","text":"문제 출처 : 프로그래머스 나누어 떨어지는 숫자 배열 문제 설명array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요. 제한사항 arr은 자연수를 담은 배열입니다. 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다. divisor는 자연수입니다. array는 길이 1 이상인 배열입니다. 입출력 예 arr divisor return [5, 9, 7, 10] 5 [5, 10] [2, 36, 1, 3] 1 [1, 2, 3, 36] [3,2,6] 10 [-1] 입출력 예 설명입출력 예#1arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다. 입출력 예#2arr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다. 입출력 예#33, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다. 123456function solution(arr, divisor) &#123; var answer = []; answer = arr.filter((todo) =&gt; !(todo % divisor)).sort((a,b) =&gt; a - b ); if(answer == '') return answer = [-1]; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-16","slug":"javascript-study-16","date":"2019-10-28T04:05:46.000Z","updated":"2019-11-30T17:00:57.875Z","comments":true,"path":"2019/10/28/javascript-study-16/","link":"","permalink":"https://hyeok999.github.io/2019/10/28/javascript-study-16/","excerpt":"","text":"JavaScript Study 16 용어 클래스 상속 관계 instanceof 스프레드 문법 함수 호출문의 인수 목록 배열 리터럴 내부 배열 병합 배열 복사 유사 배열 객체 배열 변환 객체 리터럴 내부 객체 병합 디스트럭처링 배열 디스트럭처링 배열 디스트럭처링의 조건 Rest 요소 예제 - Date 객체에서 년 , 월 , 일 객체 디스트럭처링 객체 디스트럭처링의 조건 값만 추출 배열 디스터럭처링과 혼용이 가능하다 Rest 프로퍼티 예제 - 고차함수의 매개변수로 이용 표준 빌트인 객체와 래퍼 객체자바스크립트 3가지 객체 분류 원시값과 래퍼 객체 용어 - ( 러버덕 ) 스프레드 문법 함수 호출문 배열 리터럴 시 스프레드 객체 리터럴 시 스프레드 디스트럭처링 원시값과 래퍼 객체 클래스 상속 관계 instanceof123456789101112131415class Base &#123; constructor() &#123; console.log(new.target); // class Dreived~ , class Base~ console.log(this instanceof Derived); // true , false console.log(this instanceof Base); // true , true console.log(this instanceof Object); // true , true &#125;&#125;class Derived extends Base &#123; constructor() &#123; super(); &#125;&#125;const derived = new Derived(); const base = new Base(); 스프레드 문법 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서(전개, 분산하여, spread) 개별적인 값들의 목록으로 만든다. 대상 : iterable 가능한 존재들 ( for…of 문으로 순회할 수 있는 이터러블 ) Array, String, Map, Set, DOM data structure(NodeList, HTMLCollection), Arguments 스프레드는 연산자가 아니다. 결과물만 단독으로 사용 불가능. (예 : 스프레드를 사용해서 변수에 사용해보면 담을 수 없다.) 함수 호출문의 인수 목록 ( 함수의 매개변수는 Rest 파라미터 ) 배열 리터럴의 요소 목록 객체 리터럴의 프로퍼티 목록 12345678910111213// ...[1, 2, 3]는 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3)console.log(...[1, 2, 3]) // 1 2 3// 문자열은 이터러블이다.console.log(...'Hello'); // H e l l o// Map과 Set은 이터러블이다.console.log(...new Map([['a', '1'], ['b', '2']])); // [ 'a', '1' ] [ 'b', '2' ]console.log(...new Set([1, 2, 3])); // 1 2 3// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.console.log(...&#123; a: 1, b: 2 &#125;);// TypeError: Found non-callable @@iterator 함수 호출문의 인수 목록123456const arr = [1, 2, 3];// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.const maxValue = Math.max(arr);console.log(maxValue); // NaN Math.max(); 는 가변인자 함수이기 때문에 갯수가 정해진 배열은 들어갈 수 없다. 따라서 엣날에는 apply 를 이용했다. apply 는 2번째 인수로 배열을 받는다. Math.max()를 호출 시apply에 2번쨰 인수(배열형태)가 배열이 풀어져Math.max()` 로 넘어간다. 123// apply 함수의 2번째 인수(배열)는 apply 함수가 호출하는 함수의 인수 목록이다.// 따라서 배열이 펼쳐져서 인수로 전달되는 효과가 있다.var maxValue = Math.max.apply(null, arr); 위 복잡한 구문을 스프레드로 사용 시 간결하고 편리하다. 1234567const arr = [1, 2, 3];// 스프레드 문법을 사용하여 배열 arr을 1, 2, 3으로 펼쳐서 Math.max에 전달한다.// Math.max(...[1, 2, 3])는 Math.max(1, 2, 3)과 같다.const maxValue = Math.max(...arr);console.log(maxValue); // 3 Rest 파라미터와는 정반대 개념이다. Rest파라미터는 풀어진것을 모은다. 123456789// Rest 파라미터는 인수들의 목록을 배열로 전달받는다.function foo(param, ...rest) &#123; console.log(param); // 1 console.log(rest); // [ 2, 3 ]&#125;// 스프레드 문법은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.// [1, 2, 3] -&gt; 1, 2, 3foo(...[1, 2, 3]); 배열 리터럴 내부배열 병합기존 배열 병합 방법들 ( concat, push ) 1234567891011// ES5var arr = [1, 2].concat([3, 4]);console.log(arr); // [1, 2, 3, 4]// ES5var arr1 = [1, 2];var arr2 = [3, 4];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4] spread 사용 시 12345678910// ES6 concat 대체const arr = [...[1, 2], 3, 4];console.log(arr); // [1, 2, 3, 4]// ES6 push 대체const arr1 = [1, 2];const arr2 = [3, 4];arr1.push(...arr2); // arr1.push(3, 4)와 같다.console.log(arr1); // [1, 2, 3, 4] 배열 복사기존의 배열에 다른 배열의 요소들을 삽입 ( splice 메소드 ) - splie는 배열을 직접고친다. (원본배열 변경) 1234567891011// ES5var arr1 = [1, 4];var arr2 = [2, 3];// apply 메소드의 2번째 인수는 배열이다. 이것은 인수 목록으로 splice 메소드에 전달된다.// [1, 0].concat(arr2) → [1, 0, 2, 3]// arr1.splice(1, 0, 2, 3) → arr1[1]부터 0개의 요소를 제거하고// 그자리(arr1[1])에 새로운 요소(2, 3)를 삽입한다.Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));console.log(arr1); // [1, 2, 3, 4] 스프레드 문법 - 얕은 복사 1234567// ES6const arr1 = [1, 4];const arr2 = [2, 3];arr1.splice(1, 0, ...arr2);console.log(arr1); // [1, 2, 3, 4] 유사 배열 객체 배열 변환기존 방법 1234567891011// ES5function sum() &#123; // 유사 배열 객체인 arguments를 배열로 변환 var args = Array.prototype.slice.apply(arguments); return args.reduce(function (pre, cur) &#123; return pre + cur; &#125;, 0);&#125;console.log(sum(1, 2, 3)); // 6 스프레드 문법 1234567891011// ES5function sum() &#123; // 유사 배열 객체인 arguments를 배열로 변환 var args = [...arguments]; return args.reduce(function (pre, cur) &#123; return pre + cur; &#125;, 0);&#125;console.log(sum(1, 2, 3)); // 6 객체 리터럴 내부 객체에서도 spread를 사용할 수 있는 경우가 딱 1가지 존재한다. 바로 객체 리터럴에서 사용하는 것이다. 주로, Object.assign()을 대체하기 위해 사용한다. 객체 병합기존에서 객체 병합 Object.assign의 병합은 뒷 인자에서 앞 인자 순으로 이동한다. 제일 앞에 {}을 해준 이유는 새로운 객체를 할당하기 위함이다. 123456789101112// 객체의 병합// 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.const merged = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, &#123; y: 10, z: 3 &#125;);console.log(merged); // &#123; x: 1, y: 10, z: 3 &#125;// 특정 프로퍼티 변경const changed = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, &#123; y: 100 &#125;);console.log(changed); // &#123; x: 1, y: 100 &#125;// 프로퍼티 추가const added = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, &#123; z: 0 &#125;);console.log(added); // &#123; x: 1, y: 2, z: 0 &#125; 스프레드 문법 1234567891011121314// 객체의 병합 - 스프레드// 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.const merged = &#123; ...&#123; x: 1, y: 2 &#125;, ...&#123; y: 10, z: 3 &#125; &#125;;console.log(merged); // &#123; x: 1, y: 10, z: 3 &#125;// 특정 프로퍼티 변경const changed = &#123; ...&#123; x: 1, y: 2 &#125;, y: 100 &#125;;// changed = &#123; ...&#123; x: 1, y: 2 &#125;, ...&#123; y: 100 &#125; &#125;console.log(changed); // &#123; x: 1, y: 100 &#125;// 프로퍼티 추가const added = &#123; ...&#123; x: 1, y: 2 &#125;, z: 0 &#125;;// added = &#123; ...&#123; x: 1, y: 2 &#125;, ...&#123; z: 0 &#125; &#125;console.log(added); // &#123; x: 1, y: 2, z: 0 &#125; 디스트럭처링배열 디스트럭처링예전에는 각 배열의 값을 변수에 담기 위해서는 다음과 같이 하나하나 넣어줘야만 했다. 12345678// ES5var arr = [1, 2, 3];var one = arr[0];var two = arr[1];var three = arr[2];console.log(one, two, three); // 1 2 3 디스트럭처링을 사용한다면 코드 수를 많이 줄일 수 있다. 12345678// ES6 배열 디스트럭처링 할당const arr = [1, 2, 3];// 변수 one, two, three를 선언하고 배열 arr을 디스트럭처링하여 할당한다.// 이때 할당 기준은 배열의 인덱스이다.const [one, two, three] = arr;console.log(one, two, three); // 1 2 3 여기서 [one, two, three]는 배열이 아니다. 디스트럭처링 할당이다. 12345let x, y;[x, y] = [1, 2];// 위의 문과 아래의 문은 동치이다.const [x, y] = [1, 2]; 배열 디스트럭처링의 조건 선언과 초기화가 무조건 동시에 진행되어야한다. (만약, 선언만 한다면 에러 유발) 반드시 배열이 와야한다. 순서대로 할당한다. 받고자하는 배열의 수가 더 작을 경우 undefined가 할당된다. 받고자하는 배열의 수가 더 많을 경우 무시한다. Rest 요소123// Rest 요소const [x, ...y] = [1, 2, 3];console.log(x, y); // 1 [ 2, 3 ] 예제 - Date 객체에서 년 , 월 , 일123456const today = new Date(); // Mon Sep 16 2019 02:03:42 GMT+0900 (한국 표준시)const formattedDate = today.toISOString().substring(0, 10); // \"2019-09-15\"// 문자열을 분리하여 배열로 변환한 후, 배열 디스트럭처링 할당을 통해 필요한 요소를 취득한다.const [year, month, day] = formattedDate.split('-');console.log([year, month, day]); // ['2019', '09', '15'] 객체 디스트럭처링 할당객체에서도 디스트럭처링을 할당할 수 있다. 기존에는 다음과 같이 해야했다. 1234567// ES5var user = &#123; firstName: 'Ungmo', lastName: 'Lee' &#125;;var firstName = user.firstName;var lastName = user.lastName;console.log(firstName, lastName); // Ungmo Lee ES6 에서의 디스트럭처링을 할당. 12345678// ES6 객체 디스트럭처링 할당const user = &#123; firstName: 'Ungmo', lastName: 'Lee' &#125;;// 변수 lastName, firstName을 선언하고 객체 user를 디스트럭처링하여 할당한다.// 이때 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.const &#123; lastName, firstName &#125; = user;console.log(firstName, lastName); // Ungmo Lee 123const &#123; lastName, firstName &#125; = user;// 위와 아래는 동치이다.const &#123; lastName: lastName, firstName: firstName &#125; = user; 객체 디스트럭처링의 조건 선언과 초기화가 무조건 동시에 진행되어야한다. (만약, 선언만 한다면 에러 유발) 반드시 객체가 와야한다. (혹은 객체인 변수) 프로퍼티 키에 맞춰서 할당한다. 값만 추출12345const todo = &#123; id: 1, content: 'HTML', completed: true &#125;;// todo 객체로부터 id 프로퍼티만을 추출한다.const &#123; id &#125; = todo;console.log(id); // 1 배열 디스터럭처링과 혼용이 가능하다123456789const todos = [ &#123; id: 1, content: 'HTML', completed: true &#125;, &#123; id: 2, content: 'CSS', completed: false &#125;, &#123; id: 3, content: 'JS', completed: false &#125;];// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만을 추출한다.const [, &#123; id &#125;] = todos;console.log(id); // 2 Rest 프로퍼티12const &#123; x, ...rest &#125; = &#123; x: 1, y: 2, z: 3 &#125;;console.log(x, rest); // 1 &#123; y: 2, z: 3 &#125; 예제 - 고차함수의 매개변수로 이용12345678910111213141516171819const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function render() &#123; let html = ''; todos.forEach((&#123;id, content, completed&#125;) =&gt; &#123; html += (`&lt;li id=\"$&#123;id&#125;\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" $&#123;completed ? 'checked' : '' &#125; &gt; $&#123;content&#125;&lt;/label&gt; &lt;/li&gt;`); &#125;); return html;&#125;console.log(render()); 표준 빌트인 객체와 래퍼 객체자바스크립트 3가지 객체 분류 구분 설명 표준 빌트인 객체(standard built-in object) Object, Sting, Number, Array, Function과 같이 ECMAScript 사양에 정의된 객체 / 애플리케이션 전역의 공통 기능을 제공. 호스트 객체(host object) 브라우저 환경에서 제공하는 window, XmlHttpRequest, HTMLElement 등의 DOM 노드 객체와 같이 호스트 환경에 정의된 객체. 예를 들어 브라우저에서 동작하는 환경과 브라우저 외부에서 동작하는 환경의 자바스크립트(Node.js)는 다른 호스트 객체를 사용할 수 있다. 사용자 정의 객체(user-defined object) 표준 빌트인 객체와 호스트 객체처럼 외부에서 제공되는 객체가 아닌 사용자가 직접 정의한 객체. 표준 빌트인 객체 ECMAScript 사양에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다. Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Generator, Promise, Reflect, Proxy, JSON, Error 등등 표준 빌트인 객체는 전역 객체의 프로퍼티이다. 따라서 언제나 참조가 가능하다 자바스크립트의 실행환경에 구애받지 않고 사용할 수 있다. 원시값과 래퍼 객체12345const str = 'hello';// 원시 타입인 문자열이 프로퍼티와 메소드를 갖고 있다.console.log(str.length); // 5console.log(str.toUpperCase()); // HELLO 원시값은 객체가 아니므로 프로퍼티나 메소드를 가질 수 없음에도 불구하고 원시값인 문자열이 마치 객체처럼 동작한다. 이유 : 원시값인 문자열, 숫자, 불리언 값의 경우, 마치 객체처럼 이들 원시값에 대해 마침표 표기법(또는 대괄호 표기법)으로 접근하면 자바스크립트 엔진은 일시적으로 원시값을 연관된 객체로 변환한다. 즉 , 원시값(문자열 숫자 불리언) ► 객체로 임시 변환(래퍼 객체) ► 원시값 이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 레퍼 객체(wrapper object)라 한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascrip 27강~29강(Spread, 디스트럭처링, 빌트인 과 래퍼객체)","slug":"javascript-preview-272829","date":"2019-10-27T17:10:20.000Z","updated":"2019-11-30T17:02:43.230Z","comments":true,"path":"2019/10/28/javascript-preview-272829/","link":"","permalink":"https://hyeok999.github.io/2019/10/28/javascript-preview-272829/","excerpt":"","text":"JavaScript 27강 ~ 29강 예습 27강 : Spread 문법 함수 호출문의 인수 목록에서 사용하는 경우 배열 리터럴 내부에서 사용하는 경우 concat push - 뒤에 추가 splice - 중간 추가 배열 복사 (slice) 유사 배열 객체를 배열로 변환 객체 리터럴 내부에서 사용하는 경우 Rest 파라미터 28강 : 디스트럭처링 할당 배열 디스트럭처링 할당 객체 디스트럭처링 할당 29강 : 표준 빌트인 객체와 래퍼 객체 객체의 분류 3가지 ( 표준 빌트인 객체, 사용자 정의 객체, 호스트 객체(환경에 따른 객체) ) 표준 빌트인 객체 표준 빌트인 객체 = 생성자 함수 원시값과 래퍼 객체 결론 27강Spread 문법 ES6에서 도입된 Spread 문법은 ... 은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. Spread문법은 for…of로 순회할 수 있는 이터러블에 한정된다. 매개변수에 사용할 경우 Spread가 아닌 Rest파라미터(인수들의 목록을 배열로 바꿔준다)이므로 착각하지 말 것. 12345678910111213// ...[1, 2, 3]는 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3)console.log(...[1, 2, 3]) // 1 2 3// 문자열은 이터러블이다.console.log(...'Hello'); // H e l l o// Map과 Set은 이터러블이다.console.log(...new Map([['a', '1'], ['b', '2']])); // [ 'a', '1' ] [ 'b', '2' ]console.log(...new Set([1, 2, 3])); // 1 2 3// 이터러블이 아닌 일반 객체는 Spread 문법의 대상이 될 수 없다.console.log(...&#123; a: 1, b: 2 &#125;);// TypeError: Found non-callable @@iterator Spread 문법의 결과물은 단독으로 사용할 수 없고, 아래와 같이 쉼표로 구분한 값의 목록을 사용하는 문에서 사용한다. 함수 호출문의 인수 목록 (매개변수로 주면 Rest파라미터) 배열 리터럴의 요소 목록 객체 리터럴의 프로퍼티 목록 (2019년 11월 - Stage 4 제안) 함수 호출문의 인수 목록에서 사용하는 경우12345678const arr = [1, 2, 3];// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.// apply 함수의 2번째 인수(배열)는 apply 함수가 호출하는 함수의 인수 목록이다.// 따라서 배열이 펼쳐져서 인수로 전달되는 효과가 있다.var maxValue = Math.max.apply(null, arr);console.log(maxValue); // NaN Spread 문법이 제공되기 이전에는 배열을 펼쳐서 요소값의 목록을 함수의 인수로 전달하고 싶은 경우, Function.prototype.apply를 사용하였다. Spread 문법을 사용하면 보다 간결하고 가독성이 좋다. 1234567const arr = [1, 2, 3];// Spread 문법을 사용하여 배열 arr을 1, 2, 3으로 펼쳐서 Math.max에 전달한다.// Math.max(...[1, 2, 3])는 Math.max(1, 2, 3)과 같다.const maxValue = Math.max(...arr);console.log(maxValue); // 3 배열 리터럴 내부에서 사용하는 경우concat ES5 123// ES5var arr = [1, 2].concat([3, 4]);console.log(arr); // [1, 2, 3, 4] Spread 문법 123// ES6const arr = [...[1, 2], 3, 4];console.log(arr); // [1, 2, 3, 4] push - 뒤에 추가 ES5 1234567// ES5var arr1 = [1, 2];var arr2 = [3, 4];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4] Spread 문법 12345678// ES6const arr1 = [1, 2];const arr2 = [3, 4];// arr1.push(3, 4)와 같다.arr1.push(...arr2);console.log(arr1); // [1, 2, 3, 4] splice - 중간 추가 ES5 1234567891011// ES5var arr1 = [1, 4];var arr2 = [2, 3];// apply 메소드의 2번째 인수는 배열이다. 이것은 인수 목록으로 splice 메소드에 전달된다.// [1, 0].concat(arr2) → [1, 0, 2, 3]// arr1.splice(1, 0, 2, 3) → arr1[1]부터 0개의 요소를 제거하고// 그자리(arr1[1])에 새로운 요소(2, 3)를 삽입한다.Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));console.log(arr1); // [1, 2, 3, 4] Spread 문법 1234567// ES6const arr1 = [1, 4];const arr2 = [2, 3];arr1.splice(1, 0, ...arr2);console.log(arr1); // [1, 2, 3, 4] 배열 복사 (slice) ES5 123456// ES5var origin = [1, 2];var copy = origin.slice();console.log(copy); // [1, 2]console.log(copy === origin); // false Spread 문법 123456// ES6const origin = [1, 2];const copy = [...origin];console.log(copy); // [1, 2]console.log(copy === origin); // false 원본 배열의 각 요소를 얕은 복사(shallow copy)하여 새로운 복사본을 생성. 유사 배열 객체를 배열로 변환 일반적인 방법 : slice 메소드를 apply 함수로 호출. 123456789// ES5function sum() &#123; const args = Array.prototype.slice.apply(arguments); return args.reduce((pre, cur) =&gt; pre + cur, 0); &#125;console.log(sum(1, 2, 3)); // 6 Spread 문법 123456789// ES6function sum() &#123; // 유사 배열 객체인 arguments를 배열로 변환 const args = [...arguments]; return args.reduce((pre, cur) =&gt; pre + cur, 0);&#125;console.log(sum(1, 2, 3)); // 6 객체 리터럴 내부에서 사용하는 경우​ Spread 프로퍼티는 Rest 프로퍼티와 함께 2019년 11월 TC39 프로세스의 stage 4(Finished) 단계에 제안. Spread 문법의 대상은 이터러블이어야 하지만 Spread 프로퍼티는 객체 리터럴 내부에서 Spread 문법의 사용을 허용 Spread 이전 ▶︎ Object.assign( ) 이용. 123456789101112// 객체의 병합// 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.const merged = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, &#123; y: 10, z: 3 &#125;);console.log(merged); // &#123; x: 1, y: 10, z: 3 &#125;// 특정 프로퍼티 변경const changed = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, &#123; y: 100 &#125;);console.log(changed); // &#123; x: 1, y: 100 &#125;// 프로퍼티 추가const added = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, &#123; z: 0 &#125;);console.log(added); // &#123; x: 1, y: 2, z: 0 &#125; Spread 사용 1234567891011121314// 객체의 병합// 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.const merged = &#123; ...&#123; x: 1, y: 2 &#125;, ...&#123; y: 10, z: 3 &#125; &#125;;console.log(merged); // &#123; x: 1, y: 10, z: 3 &#125;// 특정 프로퍼티 변경const changed = &#123; ...&#123; x: 1, y: 2 &#125;, y: 100 &#125;;// changed = &#123; ...&#123; x: 1, y: 2 &#125;, ...&#123; y: 100 &#125; &#125;console.log(changed); // &#123; x: 1, y: 100 &#125;// 프로퍼티 추가const added = &#123; ...&#123; x: 1, y: 2 &#125;, z: 0 &#125;;// added = &#123; ...&#123; x: 1, y: 2 &#125;, ...&#123; z: 0 &#125; &#125;console.log(added); // &#123; x: 1, y: 2, z: 0 &#125; Rest 파리미터ES6에서는 rest 파라미터를 사용하여 가변 인자의 목록을 배열로 직접 전달받을 수 있다. 123456789101112131415161718// ES5의 call함수를 이용하여 가변인자 배열을 받는다.function sum_es5() &#123; // 유사 배열 객체인 arguments 객체를 배열로 변환한다. var array = Array.prototype.slice.call(arguments); return array.reduce(function (pre, cur) &#123; return pre + cur; &#125;);&#125;console.log(sum_es5(1, 2, 3, 4, 5)); // 15// Rest 파라미터 사용시function sum(...args) &#123; // Rest 파라미터 args에는 배열 [1, 2, 3, 4, 5]이 할당된다. return args.reduce((pre, cur) =&gt; pre + cur);&#125;console.log(sum(1, 2, 3, 4, 5)); // 15 28강디스트럭처링 할당 구조화된 배열 또는 객체를 Destructuring(비구조화, 구조파괴) 하여 1개 이상의 변수에 개별적으로 할당 하는 것. 배열 또는 객체 리터럴에서 필요한 값만을 추출하여 변수 할당 시 유용하다. 배열 디스트럭처링 할당 ES5 에서 배열을 디스트럭처링하여 각 변수에 할당하는 방법. 12345678// ES5var arr = [1, 2, 3];var one = arr[0];var two = arr[1];var three = arr[2];console.log(one, two, three); // 1 2 3 ES6의 배열 디스트럭처링 할당은 배열의 각 요소를 배열로부터 추출하여 변수의 할당한다. 12345678// ES6 배열 디스트럭처링 할당const arr = [1, 2, 3];// 변수 one, two, three를 선언하고 배열 arr을 디스트럭처링하여 할당한다.// 이때 할당 기준은 배열의 인덱스이다.const [one, two, three] = arr;console.log(one, two, three); // 1 2 3 배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉, 순서대로 할당된다. 이때 변수의 개수와 배열 요소의 개수가 반드시 일치할 필요는 없다. 12345678910111213let x, y, z;[x, y] = [1, 2];console.log(x, y); // 1 2[x, y] = [1];console.log(x, y); // 1 undefined[x, y] = [1, 2, 3];console.log(x, y); // 1 2[x, , z] = [1, 2, 3];console.log(x, z); // 1 3 기본값을 설정할 수 있다. 1234567891011배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다.let x, y, z;// 기본값[x, y, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3// 기본값보다 할당된 값이 우선한다.[x, y = 10, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3 예제) Date 객체에서 년도, 월, 일 추출 123456const today = new Date(); // Mon Sep 16 2019 02:03:42 GMT+0900 (한국 표준시)const formattedDate = today.toISOString().substring(0, 10); // \"2019-09-15\"// 문자열을 분리하여 배열로 변환한 후, 배열 디스트럭처링 할당을 통해 필요한 요소를 취득한다.const [year, month, day] = formattedDate.split('-');console.log([year, month, day]); // ['2019', '09', '15'] Rest 파라미터 사용 가능 Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다. 123// Rest 요소const [x, ...y] = [1, 2, 3];console.log(x, y); // 1 [ 2, 3 ] 객체 디스트럭처링 할당 ES5 1234567// ES5var user = &#123; firstName: 'JunHyeok', lastName: 'Kim' &#125;;var firstName = user.firstName;var lastName = user.lastName;console.log(firstName, lastName); // JunHyeok Kim ES6 (순서 의미 없다. 프로퍼티 키를 기준으로 한다.) 12345678// ES6 객체 디스트럭처링 할당const user = &#123; firstName: 'JunHyeok', lastName: 'Kim' &#125;;// 변수 lastName, firstName을 선언하고 객체 user를 디스트럭처링하여 할당한다.// 이때 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.const &#123; lastName, firstName &#125; = user;console.log(firstName, lastName); // JunHyeok Kim 객체 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 12345const &#123; firstName = 'JunHyeok', lastName &#125; = &#123; lastName: 'Kim' &#125;;console.log(firstName, lastName); // Ungmo Leeconst &#123; firstName: fn = 'JunHyeok', lastName: ln &#125; = &#123; lastName: 'Kim' &#125;;console.log(fn, ln); // Ungmo Lee 객체 디스트럭처링 할당은 프로퍼티 키로 객체에서 필요한 프로퍼티 값만을 추출할 수 있다. 12345const todo = &#123; id: 1, content: 'HTML', completed: true &#125;;// todo 객체로부터 id 프로퍼티만을 추출한다.const &#123; id &#125; = todo;console.log(id); // 1 배열의 요소가 객체인 경우, 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다. ,콤마로 몇 번쨰 배열 요소인지 구별해서 사용한다. 123456789const todos = [ &#123; id: 1, content: 'HTML', completed: true &#125;, &#123; id: 2, content: 'CSS', completed: false &#125;, &#123; id: 3, content: 'JS', completed: false &#125;];// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만을 추출한다.const [, &#123; id &#125;] = todos;console.log(id); // 2 중첩 객체의 경우는 아래와 같이 사용한다. 12345678910const user = &#123; name: 'Lee', address: &#123; zipCode: '03068', city: 'Seoul' &#125;&#125;;const &#123; address: &#123; city &#125; &#125; = user;console.log(city); // 'Seoul' 객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 Rest 프로퍼티 …을 사용할 수 있다. Rest 프로퍼티는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다. 123// Rest 프로퍼티const &#123; x, ...rest &#125; = &#123; x: 1, y: 2, z: 3 &#125;;console.log(x, rest); // 1 &#123; y: 2, z: 3 &#125; 29강표준 빌트인 객체와 래퍼 객체객체의 분류 3가지 구분 설명 표준 빌트인 객체(standard built-in object) Object, Sting, Number, Array, Function과 같이 ECMAScript 사양에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다. 호스트 객체(host object) 브라우저 환경에서 제공하는 window, XmlHttpRequest, HTMLElement 등의 DOM 노드 객체와 같이 호스트 환경에 정의된 객체를 말한다. 예를 들어 브라우저에서 동작하는 환경과 브라우저 외부에서 동작하는 환경의 자바스크립트(Node.js)는 다른 호스트 객체를 사용할 수 있다. 사용자 정의 객체(user-defined object) 표준 빌트인 객체와 호스트 객체처럼 외부에서 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다. 표준 빌트인 객체 ECMAScript 사양에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공. 표준 빌트인 객체는 40개가 넘는다. 대표적인 표준 빌트인 객체 Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Generator, Promise, Reflect, Proxy, JSON, Error 등등 표준 빌트인 객체의 특징 ECMAScript에 정의된 객체이므로 Node.js, 브라우저 등의 실행환경과 관계앖이 사용 가능하다. 전역 객체의 프로퍼티다. 언제나 참조가 가능하다. 표준 빌트인 객체 = 생성자 함수Math 를 제외한 표준 빌트인 객체는 모두 생성자 함수다. 12345678910111213141516171819202122232425262728293031323334// String 생성자 함수에 의한 String 객체 생성const strObj = new String('Lee');console.log(typeof strObj); // objectconsole.log(strObj); // String &#123;\"Lee\"&#125;// Number 생성자 함수에 의한 Number 객체 생성const numObj = new Number(123);console.log(typeof numObj); // objectconsole.log(numObj); // Number &#123;123&#125;// Boolean 생성자 함수에 의한 Boolean 객체 생성const boolObj= new Boolean(true);console.log(typeof boolObj); // objectconsole.log(boolObj); // Boolean &#123;true&#125;// Function 생성자 함수에 의한 Function 객체(함수) 생성const func = new Function('x', 'return x * x');console.log(typeof func); // functionconsole.dir(func); // ƒ anonymous(x )// Array 생성자 함수에 의한 Array 객체(배열) 생성const arr = new Array(1, 2, 3);console.log(typeof arr); // objectconsole.log(arr); // (3) [1, 2, 3]// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성const regExp = new RegExp(/ab+c/i);console.log(typeof regExp); // objectconsole.log(regExp); // /ab+c/i// Date 생성자 함수에 의한 Date 객체 생성const date = new Date();console.log(typeof date); // objectconsole.log(date); // Tue Mar 19 2019 02:38:26 GMT+0900 (한국 표준시) ✸ 참고 : new 키워드를 안붙인다면 해당 타입을 반환한다. 예를들어 var a = Number(‘5’); 의 a는 number타입이다. 표준 빌트인 객체가 생성자 함수(new 키워드와 함께)로서 호출되어 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다. 123456// String 생성자 함수에 의한 String 객체 생성const strObj = new String('Lee');console.log(typeof strObj); // objectconsole.log(strObj); // String &#123;\"Lee\"&#125;console.log(Object.getPrototypeOf(strObj) === String.prototype); // true 표준 빌트인 객체가 제공하는 다양한 기능의 메소드는 프로토타입의 객체에 프로토타입 메소드로 존재한다. 또는 표준 빌트인 객체의 메소드로 존재하여 인스턴스 없이 정적으로 호출이 가능하다. 123456789101112// Number 생성자 함수에 의한 Number 객체 생성const numObj = new Number(1.5);console.log(typeof numObj); // objectconsole.log(numObj); // Number &#123;1.5&#125;// toFixed는 프로토타입 메소드이다.// 소숫점자리를 반올림하여 문자열로 반환한다.console.log(numObj.toFixed()); // 2// isInteger는 정적 메소드이다.// 정수(Integer)인지 검사하여 그 결과를 Boolean으로 반환한다.console.log(Number.isInteger(0.5)); // false 원시값과 래퍼 객체 위에서 표준빌트인 객체가 존재하는 이유에 대해 알아보자. 표준 빌트인 객체가 제공하는 프로토타입 메소드를 사용하려면 반드시 인스턴스를 생성하고 인스턴스로 프로토타입 메소드를 호출해야 한다. 그런데 숫자, 문자열, 불리언 원시값은 객체가 아니지만 마치 객체처럼 작동할 때가 있다. (정확히 마침표 표기법으로 접근시) 12345678const str = 'hello';// 원시 타입인 문자열이 객체처럼 프로퍼티와 메소드를 갖고 있다.console.log(str.length); // 5console.log(str.toUpperCase()); // HELLO// 레퍼 객체로 프로퍼티 접근이나 메소드 호출한 후, 다시 원시값으로 되돌린다.console.log(typeof str); // string ​ 이는 원시값인 문자열, 숫자, 불리언 값의 경우, 마치 객체처럼 이들 원시값에 대해 마침표 표기법(또는 대괄호 표기법)으로 접근하면 자바스크립트 엔진은 일시적으로 원시값을 연관된 객체로 변환한다. ▿ 이 때 생성된 객체로 프로퍼티에 접근하거나 메소드를 호출하고 다시 원시값으로 되돌린다. ▿ 이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 레퍼 객체(wrapper object)라 한다. ​ 래퍼 객체의 처리가 종료하면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 되돌리고 래퍼객체는 가비지 컬렉션의 대상이 된다. 숫자(Number)의 경우도 같다. 숫자에 대해 마침표 표기법으로 접근하면 그 순간 레퍼 객체인 Number 생성자 함수의 인스턴스가 생성된다. 숫자는 레퍼 객체의 [[NumberData]] 내부 슬롯에 할당된다. 레퍼 객체인 Number 객체는 Number.prototype의 메소드를 상속받아 사용할 수 있다. 레퍼 객체의 처리가 종료하면 레퍼 객체의 [[NumberData]] 내부 슬롯에 할당된 원시값을 되돌리고 레퍼 객체는 가비지 컬렉션의 대상이 된다. 문자열, 숫자, 불리언 값 이외의 원시값은 레퍼 객체를 생성하지 않는다. 즉, 원시값 null과 undefined 값의 래퍼 객체가 없다. 따라서 null과 undefined 값을 객체처럼 사용하면 에러가 발생한다. 결론 따라서 String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 문자열, 숫자, 불리언 인스턴스를 생성할 필요가 없으며 권장하지도 않는다. ##","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Object","slug":"Object","permalink":"https://hyeok999.github.io/tags/Object/"},{"name":"Rapper","slug":"Rapper","permalink":"https://hyeok999.github.io/tags/Rapper/"},{"name":"Spread","slug":"Spread","permalink":"https://hyeok999.github.io/tags/Spread/"}]},{"title":"2주차 시험 개념정리","slug":"test-arrange02","date":"2019-10-26T19:04:24.000Z","updated":"2019-11-30T16:56:50.215Z","comments":true,"path":"2019/10/27/test-arrange02/","link":"","permalink":"https://hyeok999.github.io/2019/10/27/test-arrange02/","excerpt":"","text":"짧은 개념 정리글함수란?여러가지 실행문들을 코드 블럭으로 묶은 하나의 실행단위. 함수 사용 이유코드의 재사용 , 유지보수의 편의성, 코드의 신뢰성 함수객체vs일반객체함수객체는 호출할 수 있고 일반객체는 호출할 수 없다. 함수 정의 방법 함수표현문 함수선언문 Function 생성자 함수 화살표 함수 메소드 종류 인스턴스 메소드 프로토타입 메소드 정적 메소드 매개변수 vs. 인수 (parameter vs. argument)할당해주는 값이 인수고 그 값을 전달 받는게 매개변수이다. 함수정의시 동작 모든 함수 객체는 일반 객체가 가지고 있는 메소드를 가지고, 추가적으로 [[Call]] 내부 메소드와 생성자 함수인 경우 [[Constructor]]를 가지고 있다. [[Constructor]]는 생성자 함수로서 호출이 가능한지를 알려주는 내부 메소드로, 해당 메소드를 가지고 있다면 constructor, 없다면 non-constructor이다. 이는 함수 정의 방식에 따라 결정된다. 일반 함수로서의 호출 , 생성자 함수로서의 호출일반 함수는 호출시 함수 객체의 내부 메소드 [[Call]]가 호출 되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다. 다양한 함수의 형태 재귀함수 중첩함수 즉시실행함수 콜백함수 스코프JS엔진이 식별자를 찾는 규칙 , 식별자가 유효한 범위 스코프 체인지역 스코프부터 시작하여 자신의 상위 스코프 방향으로 올라가면서 찾고자하는 식별자를 찾을 때까지 올라간다. 순수 함수 vs 비순수순수함수는 함수내부를 돌았을때 외부값을 변경시키지 않으며 비순수함수는 함수내부를 돌았을때 함수 외부값을 변경시키면 비순수함수이다. 전역변수의 단점스코프의 종점에 존재하여 검색속도가 느리다. 유효범위가 넓어서 의도치않게 값을 변경시킬 수 있다 네임스페이스 오염 긴 생명주기 렉시컬 스코프함수 호출 위치가 아닌 정의 위치에 따라 상위 스코프를 결정한다. 함수 레벨 스코프var키워드로 선언된 변수는 함수의 코드블록만을 지역스코프로 인정한다var 키워드가 함수 레벨 스코프.let , const 블록 레벨 스코프. var 키워드 문제점 3개 함수 레벨 스코프 변수 중복 선언 허용 변수 호이스팅 let 키워드 특징 3개 동일 스코프 내에서 변수 중복 선언 금지 블록레벨 스코프 변수 호이스팅이 마치 발생 안한것처럼 동작 스코프 시작지점부터 초기화 시작 지점까지의 구간을 일시적 사각지대(TDZ)라고 부른다. 생성자 함수 로직 함수를 new연산자와 생성자를 호출하면 빈 객체를 생성한다. this에 빈객체를 할당한다. this의 빈객체 내부에서 프로퍼티 추가, 메서드 추가 등등 을 한다. 생성자 함수는 마지막에 return = this;를 암묵적으로 실행한다. (마지막에 return을 안적어줘도 되는 이유임) (생성자 함수는 return을 사용하지 말아야한다.) 내부슬롯 / 내부메소드자바스크립트엔진이 동작하기 위한 내부코드를 설명하기 위한 의사코드를 내부슬롯과 내부메소드 라고 한다. get 키워드가 해석되면 [[GET]] 내부메서드에 들어가서 동작을 수행한다. set 키워드가 해석되면 [[SET]] 내부메서드에 들어가서 동작을 수행한다. 프로퍼티 정의프로퍼티 어트리뷰트 값을 정의하여 프로퍼티의 상태를 관리하는 것. const 키워드 특징 재할당 금지 선언과 동시에 할당이 이루어져야한다. 상수는 가독성과 유지보수의 편의가 좋다. 전역 변수 사용 억제 방법 즉시실행함수 네임스페이스 객체 모듈패턴 ES6문법 전역 변수의 단점 스코프 체인상 종점에 존재 네임스페이스 오렴 긴 생명 주기 암묵적 결합 함수 객체 VS 객체일반 객체는 호출할 수 없지만, 함수 객체는 호출할 수 있다. 데이터 프로퍼티 vs 접근자 프로퍼티데이터프로퍼티는 키와 값으로 구성된 일반적인 프로퍼티다. 접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 사용하는 접근자함수로 구성된 프로퍼티다. 접근자 함수는 getter/setter함수라고도 부른다. 데이터 프로퍼티 어트리뷰트[[Value]] , [[Writable]] , [[Enumerable]] , [[Configurable]] 접근자 프로퍼티 어트리뷰트[[Get]] , [[Set]] , [[Enumerable]] , [[Configurable]] 일급 함수 객체의 특징 4가지 무명의 객체를 만들 수 있다. 즉 런타임에 생성 가능하다. 변수나 자료구조에 저장 할 수 있다. 함수의 매개변수에 전달할 수 있다. 함수의 결과값으로 반환할 수 있다. 함수형 프로그래밍 순수함수 와 보조함수를 이용해 부수효과를 최소한으로 하는 프로그래밍. JS는 함수형 프로그래밍을 가능하게 한다. 인스턴스객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어. 함수 객체에만 있는 프로퍼티일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다. 객체를 만드는 5가지 방법Object생성자함수(+Object.create() ) , 객체리터럴 , new생성자함수 , class 객체 지향 프로그래밍객체 : 데이터와 동작을 집합으로 표현한 것. 이러한 객체를 프로그래밍으로 표현하려는 패러다임. 캡슐화정보은닉. 외부에서 내부상태를 변경할 수 없다. 추상화필요한 속성 만을 간추려서 표현 하는 것. 상속어떤 객체의 프로퍼티나 메소드를 다른 객체가 물려 받아 그대로 사용하는 것. 프로토타입어떤 객체의 상위 역할을 하는 객체. 다른 객체에게 공유프로퍼티를 제공한다. 모든 객체는 하나의 프로토타입을 갖는다. 프로토타입은 객체 생성 방식에 의해 결정된다. 프로토타입 체인객체의 프로퍼티에 접근하려고 할때 해당 객체에 접근하려는 프로퍼티가 없다면 접근자 프로퍼티가 가리키는 링크에 따라 자신의 부모 역할을 하는 프로토타입에 프로퍼티를 순차적으로 검색한다. 리터럴 방식 과 생성자 함수 리터럴 표기법 생성자 함수 프로토타입 객체 리터럴 [new] Object() Object.protptype 함수 리터럴 new Function() Function.prototype 배열 리터럴 new Array() Array.prototype 정규 표현식 리터럴 new RegExp() RegExp.protptype 즉, 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다. 사용자 정의 생성자 함수와 프로토타입 생성 시점함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. 생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor는 프로토타입이 생성되지 않는다. 빌트인 생성자 함수와 프로토타입 생성 시점모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 객체의 프로토타입을 찾는 방법Object.getPrototypeOf(객체명) , 객체명.__Proto__ 프로토타입이 생성자함수에 접근하는법constructor 프로퍼티 생성자함수가 프로토타입에 접근하는 법생성자함수명.prototype __Proto__ 접근자 프로퍼티를 코드내에서 직접사용을 비추천하는 이유ES5에서는 비표준이었기 때문이다. 모든 객체가 __Proto__를 사용할 수 없기 때문이다. 메소드의 종류3개정적메소드 , 프로토타입메소드 , 인스턴스메소드 정적 프로퍼티/메소드정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다. 함수호출방식에 따른 this가 가리키는 값 함수호출방식 this가 가리키는 값 일반 함수로서 호출 전역객체 메소드로서 호출 메소드를 호출한 객체 생성자함수로서 호출 생성자함수가 생성할 인스턴스 this의 binding 확정시간 함수가 호출 되었을 때, this의 binding이 확정 된다. 바인딩(binding) : 바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다. 함수 호출 방식 this 바인딩 일반 함수 호출 전역 객체 메소드 호출 메소드를 호출한 객체 생성자 함수 호출 생성자 함수가 (미래에) 생성할 인스턴스 Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"daily test","slug":"daily-test","permalink":"https://hyeok999.github.io/tags/daily-test/"}]},{"title":"daily_algorithm24","slug":"daily-algorithm24","date":"2019-10-26T14:30:57.000Z","updated":"2019-11-30T17:12:58.863Z","comments":true,"path":"2019/10/26/daily-algorithm24/","link":"","permalink":"https://hyeok999.github.io/2019/10/26/daily-algorithm24/","excerpt":"","text":"문제 출처 : 프로그래머스 기능 개발문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93,30,55] [1,30,5] [2,1] 입출력 예 설명첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 12345678910111213141516171819202122232425function solution(progresses, speeds) &#123; let answer = []; let count = 0; while (progresses[0]) &#123; count = 0; for (let i = 0; i &lt; progresses.length; i++) &#123; progresses[i] = progresses[i] + speeds[i]; &#125; while (progresses[0] &gt;= 100) &#123; count++; console.log(progresses); progresses.shift(); speeds.shift(); console.log(progresses); &#125; if (count &gt; 0) &#123; answer.push(count); &#125; &#125; return answer;&#125; 재도전, 성공 - 마지막에 0값이 많이 들어가서 0초과할 경우만 push하게끔 설정하였다.해당 문제는 배열을 맨 앞부터 잘라내는 방식 큐 ( FIFO )으로 해결한다. 변수 기능치가 100이 될 경우 올라갈 배포 count count값이 들어갔는지 체크할 booleanValue 현재 기능 정도와 스피드를 각각 더한다. 동시에 기능 배열의 길이가 0이 아니고 0번쨰 기능이 100이 되어야만 다음 기능들도 배포가 가능하므로 0번째 기능이 100이상 인지 체크한다. 100이상이라면 count수를 올리고 count값이 올라갔으므로 booleanValue를 바꿔준다. 기능과 스피드 정도의 배열을 각각 앞부터 잘라낸다. 만약 booleanValue가 참일경우 answer에 해당 카운드값을 넣는다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm23","slug":"daily-algorithm23","date":"2019-10-26T12:35:42.000Z","updated":"2019-11-30T17:13:06.418Z","comments":true,"path":"2019/10/26/daily-algorithm23/","link":"","permalink":"https://hyeok999.github.io/2019/10/26/daily-algorithm23/","excerpt":"","text":"문제 출처 : 프로그래머스 문자열 내 마음대로 정렬하기문제 설명문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [sun, bed, car]이고 n이 1이면 각 단어의 인덱스 1의 문자 u, e, a로 strings를 정렬합니다. 제한 조건 strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다. 입출력 예 strings n return [sun, bed, car] 1 [car, bed, sun] [abce, abcd, cdx] 2 [abcd, abce, cdx] 입출력 예 설명입출력 예 1sun, bed, car의 1번째 인덱스 값은 각각 u, e, a 입니다. 이를 기준으로 strings를 정렬하면 [car, bed, sun] 입니다. 입출력 예 2abce와 abcd, cdx의 2번째 인덱스 값은 c, c, x입니다. 따라서 정렬 후에는 cdx가 가장 뒤에 위치합니다. abce와 abcd는 사전순으로 정렬하면 abcd가 우선하므로, 답은 [abcd, abce, cdx] 입니다. 1234function solution(strings, n) &#123; var answer = []; return strings.sort((a, b) =&gt; (a[n] &gt; b[n] ? 1 : (a[n] &lt; b[n] ? -1 : (a &gt; b ? 1 : -1))));&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm22","slug":"daily-algorithm22","date":"2019-10-26T12:35:38.000Z","updated":"2019-11-30T17:13:13.640Z","comments":true,"path":"2019/10/26/daily-algorithm22/","link":"","permalink":"https://hyeok999.github.io/2019/10/26/daily-algorithm22/","excerpt":"","text":"문제 출처 : 프로그래머스 문자열 내림차순으로 배치하기문제 설명문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요.s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다. 제한 사항 str은 길이 1 이상인 문자열입니다. 입출력 예 s return “Zbcdefg” “gfedcbZ” 123456function solution(s) &#123; let answer = ''; return answer = s.split('').sort().reverse().join('');&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-15","slug":"javascript-study-15","date":"2019-10-25T04:30:47.000Z","updated":"2019-11-30T17:01:05.738Z","comments":true,"path":"2019/10/25/javascript-study-15/","link":"","permalink":"https://hyeok999.github.io/2019/10/25/javascript-study-15/","excerpt":"","text":"JavaScript Study 15 용어 클래스 클래스 기본적인 구조 클래스 vs 생성자 함수 클래스 호이스팅 인스턴스 생성 클래스 필드 메소드 constructor 프로토타입 메소드 정적 메소드 정적 메소드와 프로토타입 메소드의 차이 클래스에서 정의한 메소드의 특징 클래스의 인스턴스 생성 과정 프로퍼티 인스턴스 프로퍼티 접근 프로퍼티 클래스 필드 정의 제한 private 필드 정의 제한 static 필드 정의 제한 상속 클래스 상속과 생성자 함수 상속 서브 클래스의 constructor super 키워드 super 참조 ES6 함수의 추가 기능 생성자 함수와 생성자가 아닌 함수 화살표 함수 화살표 함수와 일반 함수의 차이 화살표 함수 - this 화살표 함수 - super 화살표 함수 - arguments Rest 파라미터 기본 문법 Rest 파라미터 주의사항 매개변수 기본값 용어 - ( 러버덕 ) 클래스 클래스 내부 메소드 3가지 super extends ES6 함수의 추가 기능 화살표 함수 매개변수 기본값 클래스 객체를 만드는 용도로 사용. 클래스는 함수다. 클래스 기본적인 구조1234567891011class 클래스명 &#123;//함수 본체 - 메서드 3개만 올 수 있음. constructor()&#123; // 생성자, 인스턴스의 프로퍼티를 정의한다. &#125; 함수명()&#123; // 프로토 타입 메소드 &#125; static 함수명()&#123; // 정적 메소드 &#125;&#125; 클래스 vs 생성자 함수클래스는 생성자 함수와 매우 유사하게 동작하지만 아래와 같이 몇가지 차이가 있다. 클래스는 new 연산자를 사용하지 않고 호출하면 에러가 발행한다. 하지만 생성자 함수는 new 연산자를 사용하지 않고 호출하면 일반 함수로서 호출된다. 클래스는 상속을 지원하는 extentds와 super 키워드를 제공한다. 하지만 생성자 함수는 extentds와 super 키워드를 지원하지 않는다. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 생성자 함수는 함수 호이스팅이 발생한다. 클래스의 모든 코드는 암묵적으로 strict 모드가 지정되어 실행되며 strict 모드를 해지할 수 없다. 하지만 생성자 함수는 암묵적으로 strict 모드가 지정되지 않는다. 클래스의 constructor, 프로토타입 메소드, 정적 메소드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 다시 말해, 열거되지 않는다. 클래스는 생성자 함수보다 엄격하다. 12345678910111213141516171819202122232425262728// 클래스 선언문class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; // name 프로퍼티는 public하다. &#125; // 프로토타입 메소드 sayHi() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; // 정적 메소드 static sayHello() &#123; console.log('Hello!'); &#125;&#125;// 인스턴스 생성const me = new Person('Lee');// 인스턴스의 프로퍼티 참조console.log(me.name); // Lee// 프로토타입 메소드 호출me.sayHi(); // Hi! My name is Lee// 정적 메소드 호출Person.sayHello(); // Hello! 클래스 호이스팅​ 클래스 선언문 이전에 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다. 즉, let이나 const와 동일하다. 인스턴스 생성 클래스는 인스턴스를 생성하는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다. 클래스는 new없이 호출시 에러를 유발한다. 123456class Person &#123;&#125;// 인스턴스 생성const me = new Person();console.log(me); // Person &#123;&#125; 클래스 필드 정식 사양은 아니다. 클래스 내에 필드형태로 문을 넣는 것을 말한다. 클래시 필드에서는 this를 빼야한다. 1234567891011121314// 클래스class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; &#125;&#125;// 생성자 함수function Person(name) &#123; // 인스턴스 생성 및 초기화 this.name = name;&#125; 메소드constructorconstructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메소드이다. constructor는 이름을 변경할 수 없다. 1234567class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; &#125;&#125; 1234567891011class Person &#123; constructor(name, address) &#123; // 인스턴스 초기화 this.name = name; this.address = address; &#125;&#125;// 초기값을 전달한다. 초기값은 constructor에 전달된다.const me = new Person('Lee', 'Seoul');console.log(me); // Person &#123;name: \"Lee\", address: \"Seoul\"&#125; 이처럼 constructor 내에서는 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스의 초기화를 실행한다. 따라서 인스턴스를 초기화하려면 constructor를 생략해서는 안된다. 프로토타입 메소드생성자 함수를 사용하여 인스턴스를 생성하는 경우, 프로토타입 메소드를 생성하기 위해서는 아래와 같이 명시적으로 프로토타입에 메소드를 추가해야 한다. 123456789101112// 생성자 함수function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHi = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;const me = new Person('Lee');me.sayHi(); // Hi! My name is Lee 12345678910111213141516// 클래스class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; &#125; // 프로토타입 메소드 sayHi() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;&#125;const me = new Person('Lee');me.sayHi(); // Hi! My name is Lee 정적 메소드 정적(static) 메소드는 인스턴스를 생성하지 않아도 호출할 수 있는 메소드를 말한다. 생성자 함수의 경우, 정적 메소드를 생성하기 위해서는 아래와 같이 명시적으로 생성자 함수에 메소드를 추가해야 한다. 123456789101112// 생성자 함수function Person(name) &#123; this.name = name;&#125;// 정적 메소드Person.sayHi = function () &#123; console.log('Hi!');&#125;;// 정적 메소드 호출Person.sayHi(); // Hi! 클래스 몸체에서 정의한 메소드에 static 키워드를 붙이면 정적 메소드(클래스 메소드)가 된다. 123456789101112class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; &#125; // 정적 메소드 static sayHi() &#123; console.log('Hi!'); &#125;&#125; 위 예제의 Person 클래스는 아래와 같이 프로토타입 체인을 생성한다. 정적 메소드와 프로토타입 메소드의 차이정적 메소드와 프로토타입 메소드는 무엇이 다르며 무엇을 기준으로 구분하여 정의하여야 할 지 생각해 보자. 정적 메소드와 프로토타입 메소드의 차이는 아래와 같다. 정적 메소드와 프로토타입 메소드가 속해 있는 프로토타입 체인이 다르다. 정적 메소드는 클래스로 호출하고 프로토타입 메소드는 인스턴스로 호출한다. 정적 메소드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메소드는 인스턴스 프로퍼티를 참조할 수 있다. 메소드 내부에서 인스턴스 프로퍼티를 참조해야 할 필요가 있다면 this를 사용해야 하며 이러한 경우, 프로토타입 메소드로 정의해야 한다. 하지만 메소드 내부에서 인스턴스 프로퍼티를 참조해야 할 필요가 없다면 this를 사용하지 않게 된다. 클래스에서 정의한 메소드의 특징클래스에서 정의한 메소드는 아래와 같은 특징을 갖는다. function 키워드를 생략한 메소드 축약 표현을 사용한다. 객체 리터럴과는 다르게 클래스에 메소드를 정의할 때는 콤마가 필요 없다. 암묵적으로 strict 모드로 실행된다. for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 내부 메소드 [[Construct]]를 갖지 않는 non-constructor이다. 따라서 new 연산자와 함께 호출할 수 없다. 클래스의 인스턴스 생성 과정1. 인스턴스 생성과 this 바인딩 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 (아직 완성되진 않았지만) 클래스가 생성한 인스턴스이다. 이때 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다. 따라서 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다. 2. 인스턴스 초기화 constructor에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다. 3. 프로토타입 / 정적 메소드 추가 클래스 몸체에 프로토타입 메소드가 존재하면 클래스의 prototype 프로퍼티가 가리키는 객체에 메소드로 추가된다. 클래스 몸체에 정적 메소드가 존재하면 클래스에 메소드로 추가된다. 4. 인스턴스 반환 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 1234567891011121314151617181920212223class Person &#123; // 생성자 constructor(name) &#123; // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.console.log(this); // Person &#123;&#125; console.log(Object.getPrototypeOf(this) === Person.prototype); // true // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.name = name; // 4. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. &#125; // 3. 프로토타입 메소드는 클래스의 prototype에 메소드로 추가된다. sayHi() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; // 3. 정적 메소드는 클래스에 메소드로 추가된다. static sayHello() &#123; console.log('Hello!'); &#125;&#125; 프로퍼티인스턴스 프로퍼티인스턴스 프로퍼티는 construnctor 내부에서 정의해야 한다. 123456789class Person &#123; constructor(name) &#123; // 인스턴스 프로퍼티 this.name = name; &#125;&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: \"Lee\"&#125; 접근 프로퍼티접근자 프로퍼티(Accessor property)는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다. 123456789101112131415161718192021222324252627282930313233343536class Person &#123; constructor(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; // fullName은 접근자 함수로 구성된 접근자 프로퍼티이다. // getter 함수 get fullName() &#123; return this.firstName + ' ' + this.lastName; &#125; // setter 함수 set fullName(name) &#123; [this.firstName, this.lastName] = name.split(' '); &#125;&#125;const me = new Person('Ungmo', 'Lee');// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.console.log(`$&#123;me.firstName&#125; $&#123;me.lastName&#125;`); // Ungmo Lee// 접근자 프로퍼티를 통한 프로퍼티 값의 저장// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.me.fullName = 'Heegun Lee';console.log(me); // &#123;firstName: \"Heegun\", lastName: \"Lee\"&#125;// 접근자 프로퍼티를 통한 프로퍼티 값의 참조// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.console.log(me.fullName); // Heegun Lee// fullName는 접근자 프로퍼티이다.// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.console.log(Object.getOwnPropertyDescriptor(Person.prototype, 'fullName'));// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125; 클래스 필드 정의 제안​ 클래스 몸체에서 클래스 필드를 정의할 수 있는 클래스 필드 정의(Class field definitions) 제안은 아직 ECMAScript의 정식 표준 사양으로 승급 되지 않았다. 하지만 최신 브라우저(Chrome 72 이상)와 최신 Node.js(버전 12 이상)는 표준 사양으로 승급이 확실시되는 이 제안을 미리 구현해 놓았다. 따라서 최신 브라우저와 최신 Node.js에서는 아래 예제와 같이 클래스 필드를 클래스 몸체에 정의할 수 있다. 1234567class Person &#123; // 클래스 필드 정의 name = 'Lee';&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: \"Lee\"&#125; 클래스 필드는 고정값을 가지고 있는 경우에 사용하도록 한다. 왜냐하면 값을 넘겨받았다면 클래스필드로 받을 수 없기에 결국 함수를 만들게되는데 그럴바에는 차라리 constructor를 만드는게 차라리 낫다. 1234567891011class Person &#123; name; // 의미 없는 코드 constructor(name) &#123; // 클래스 필드 초기화. this.name = name; &#125;&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: \"Lee\"&#125; 함수는 일급 객체이므로 클래스 필드에 할당할 수 있으므로 클래스 필드를 통해 메소드를 정의할 수도 있다. 123456789101112131415class Person &#123; // 클래스 필드에 문자열을 할당 name = 'Lee'; // 클래스 필드에 함수를 할당 getName = function () &#123; return this.name; &#125; // 화살표 함수로 정의할 수도 있다. // getName = () =&gt; this.name;&#125;const me = new Person();console.log(me); // Person &#123;name: \"Lee\", getName: ƒ&#125;console.log(me.getName()); // Lee private 필드 정의 제안constructor 내부에서 this를 통해 정의한 인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 언제나 public이다. ES6의 클래스는 다른 객체지향 언어처럼 private, public, protected 키워드와 같은 접근 제한자(access modifier)를 지원하지 않는다. 생성자 함수에서는 클로저를 사용하여 private한 프로퍼티를 흉내낼 수 있었다. 단 private한 프로퍼티를 흉내낸 자유 변수에 접근하면 에러가 발생하지 않고 undefined를 반환하므로 아쉬움이 남는다. 12345678910111213141516171819202122// ES5var Person = (function () &#123; // 자유 변수이며 private하다 var _name = ''; // 생성자 함수 function Person(name) &#123; _name = name; &#125; // 프로토타입 메소드. 이 메소드는 클로저이다. Person.prototype.sayHi = function () &#123; console.log('Hi! My name is ' + _name); &#125;; // 생성자 함수를 반환 return Person;&#125;());// 인스턴스 생성var me = new Person('Lee');// _name에 접근할 수 없다.console.log(me); // Person &#123;&#125; 123456789101112131415161718class Person &#123; // private 필드 정의 #_name = ''; constructor(name) &#123; this.#_name = name; &#125; // sayHi는 접근자 프로퍼티이다. get sayHi() &#123; // sayHi() &#123; // private 필드를 참조하여 trim한 다음 반환한다. return this.#_name.trim(); &#125;&#125;const me = new Person(' Lee ');console.log(me.sayHi); // \"Hi! My name is Lee\" private 필드는 반드시 클래스 몸체에 정의해야 한다. private 필드를 직접 constructor에 정의하면 에러가 발생한다. 1234567class Person &#123; constructor(name) &#123; // private 필드는 클래스 몸체에서 정의해야 한다. this.#name = name; // SyntaxError: Private field '#name' must be declared in an enclosing class &#125;&#125; static 필드 정의 제안static public 필드, static private 필드, static private 메소드를 정의할 수 있는 새로운 표준 사양인 “Static class features”이 2019년 11월 현재, TC39 프로세스의 stage 3(candidate)에 제안되어 있다. 이 제안 중에 static public/private 필드는 2019년 11월 현재, 최신 브라우저(Chrome 72 이상)과 최신 Node.js(버전 12 이상)에 이미 구현되어 있다. 123456789101112131415class MyMath &#123; // static public 필드 정의 static PI = 22 / 7; // static private 필드 정의 static #num = 10; // static 메소드 static increment() &#123; return ++MyMath.#num; &#125;&#125;console.log(MyMath.PI); // 3.142857142857143console.log(MyMath.increment()); // 11 상속클래스 상속과 생성자 함수 상속 1234567891011121314151617181920212223242526272829303132class Animal &#123; constructor(age, weight) &#123; this.age = age; this.weight = weight; &#125; eat() &#123; return 'eat'; &#125; move() &#123; return 'move'; &#125;&#125;class Bird extends Animal &#123; /* // countructor가 생략되어있으므로 다음과 같이 진행한다. constructor(age, weight) &#123; super(age, weight); this.age; this.weight; &#125; */ fly() &#123; return 'fly'; &#125;&#125;const crow = new Bird(1, 5);console.log(crow); // Bird &#123;age: 1, weight: 5&#125;console.log(crow instanceof Bird); // trueconsole.log(crow instanceof Animal); // trueconsole.log(crow.eat()); // eatconsole.log(crow.move()); // moveconsole.log(crow.fly()); // fly 서브 클래스의 constructor 클래스에 constructor를 생략하면 클래스에 아래와 같이 디폴트 constructor가 암묵적으로 정의된다. 1constructor() &#123;&#125; super()는 수퍼 클래스의 constructor(super-constructor)를 호출하여 인스턴스를 생성한다. 1constructor(...args) &#123; super(...args); &#125; 위 ...은 스프레드가 아니라 Rest 파라미터 이다. 매개변수에 …을 붙이면 Rest 파라미터가 된다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. 즉, 푸는게 아니라 배열로 묶는다. 수퍼 클래스와 서브 클래스 모두 constructor를 생략되었다. 12345// 수퍼 클래스class Base &#123;&#125;// 서브 클래스class Derived extends Base &#123;&#125; 위 예제는 아래와 같이 암묵적으로 디폴트 constructor가 정의된다. 123456789101112// 수퍼 클래스class Base &#123; constructor() &#123;&#125;&#125;// 서브 클래스class Derived extends Base &#123; constructor() &#123; super(); &#125;&#125;const derived = new Derived();console.log(derived); // Derived &#123;&#125; 위 예제와 같이 수퍼 클래스와 서브 클래스 모두 constructor를 생략하면 빈객체가 생성된다. 프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다. super 키워드123456789101112131415161718// 수퍼 클래스class Base &#123; constructor(a, b) &#123; // ④ this.a = a; this.b = b; &#125;&#125;// 서브 클래스class Derived extends Base &#123; constructor(a, b, c) &#123; // ② super(a, b); // ③ this.c = c; &#125;&#125;const derived = new Derived(1, 2, 3); // ①console.log(derived); // Derived &#123;a: 1, b: 2, c: 3&#125; 서브 클래스에서 constructor를 생략하지 않는 경우, 서브 클래스의 constructor에서는 반드시 super를 호출해야 한다. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다. super는 반드시 서브 클래스의 constructor에서만 호출한다. 서브 클래스가 아닌 클래스 또는 함수에서 호출하면 에러를 발생시킨다. super 참조메소드 내에서 super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다. 12345678910111213141516// 수퍼 클래스class Base &#123; static sayHi() &#123; return 'Hi!'; &#125;&#125;// 서브 클래스class Derived extends Base &#123; static sayHi() &#123; // super.sayHi는 수퍼 클래스의 정적 메소드를 가리킨다. return `$&#123;super.sayHi()&#125; how are you doing?`; &#125;&#125;console.log(Derived.sayHi()); // Hi! how are you doing? ES6 함수의 추가 기능생성자 함수와 생성자가 아닌 함수 (constructor || non-constructor)ES6 이전의 함수는 모두 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 다시 말해, ES6 이전의 모든 함수는 callable이며 constructor이다. 따라서 모든 함수가 프로타입을 만들고 arguments를 가지고 있는 등등 성능상으로 비효율적인 상황이 생기게 된다. 따라서 ES6부터 함수를 체계적으로 구분하여 다음과 같이 사용하도록 하였다. ES6 함수의 구분 constructor prototype super arguments 일반 함수(Normal) ○ ○ ✗ ○ 메소드(Method) ✗ ✗ ○ ○ 화살표 함수(Arrow) ✗ ✗ ✗ ✗ 일반 함수는 함수 선언문이 함수 표현식으로 정의한 함수를 말하며 ES6 이전의 함수와 차이가 없다. 하지만 ES6의 메소드와 화살표 함수는 ES6 이전의 함수와 명확한 차이가 있다. 일반 함수는 constructor이지만 ES6의 메소드와 화살표 함수는 non-constructor이다. 화살표 함수 화살표 함수는 주로 콜백에서 사용한다. 인수가 1개일 때만 ()을 생략할 수 있다. 한줄 일때만 {}또는 return을 생략이 가능하다. 빈객체 리터럴로 반환하고 싶을 떄 12const arrow = () =&gt; &#123;&#125;; // XXX &#123;&#125;을 함수을 괄호로 이해한다.const arrow = () =&gt; (&#123;&#125;); // O 화살표 함수와 일반 함수의 차이화살표 함수와 일반 함수의 차이는 아래와 같다. 1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor이다. 따라서 화살표 함수는 생성자 함수로서 호출할 수 없다. 2. 중복된 매개 변수 이름을 선언할 수 없다. 일반 함수는 중복된 매개 변수 이름을 선언해도 에러가 발생하지 않는다. 3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다. ​ 화살표 함수 내부에서 this, arguments, super, new.target를 참조하면 스코프 체인을 통해 상위 컨텍스트의 this, arguments, super, new.target를 참조한다. 화살표함수 - this화살표 함수가 일반 함수와 구별되는 가장 큰 특징은 바로 this이다. 그리고 화살표 함수는 다른 함수의 인수로 전달되어 중첩 함수(콜백 함수)로 사용되는 경우가 많다. 화살표 함수의 this는 일반 함수의 this와 다르게 동작한다. 이는 “중첩 함수 내부의 this 문제”, 즉 중첩 함수 내부의 this가 외부 함수의 this와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것이다. 12345// 화살표 함수는 상위 컨텍스트의 this를 참조한다.() =&gt; this.x;// 익명 함수에 this를 주입한다. 위 화살표 함수와 동일하게 동작한다.(function () &#123; return this.x; &#125;).bind(this); ​ 만약 화살표 함수가 화살표 함수의 중첩 함수인 경우, 부모 화살표 함수가 참조하는 상위 컨텍스트의 this를 참조한다. 즉, 화살표 함수가 중첩 함수인 경우, 상위 스코프에 존재하는 가장 가까운 함수 중에서 화살표 함수가 아닌 부모 함수의 this를 참조한다. 만약 화살표 함수가 전역 함수라면 화살표 함수의 this는 전역 객체를 가리킨다. 12345678910111213141516171819202122232425262728// 화살표 함수는 함수 자체의 this 바인딩이 없다.// 전역 함수 foo의 상위 컨텍스트는 전역이다.// 화살표 함수 foo의 this는 전역 객체를 가리킨다.const foo = () =&gt; console.log(this);foo(); // window// 중첩 함수 foo의 상위 컨텍스트는 즉시 실행 함수이다.// 화살표 함수 foo의 this는 즉시 실행 함수의 this를 가리킨다.(function () &#123; const foo = () =&gt; console.log(this); foo();&#125;).call(&#123; a: 1 &#125;); // &#123; a: 1 &#125;// 함수 foo는 화살표 함수를 반환한다.// 반환된 화살표 함수의 this는 즉시 실행 함수의 this를 가리킨다.(function () &#123; const foo = () =&gt; () =&gt; console.log(this); foo()();&#125;).call(&#123; a: 1 &#125;); // &#123; a: 1 &#125;// increase 프로퍼티에 할당한 화살표 함수의 상위 컨텍스트는 전역이다.// increase 프로퍼티에 할당한 화살표 함수의 this는 전역 객체를 가리킨다.const counter = &#123; num: 1, increase: () =&gt; ++this.num&#125;;console.log(counter.increase()); // NaN 화살표 함수의 this는 정적으로 결정이 나버린다. (자신의 상위 스코프를 가리킨다.) 1234567window.x = 1;const normal = function () &#123; return this.x; &#125;;const arrow = () =&gt; this.x;console.log(normal.call(&#123; x: 10 &#125;)); // 10console.log(arrow.call(&#123; x: 10 &#125;)); // 1 위처럼 call로 this를 보내도 arrow의 this는 전역을 가리킨다. 화살표 함수가 call, applay, bind 메소드를 사용할 수 없다는 의미는 아니다. 단지 화살표 함수의 this는 일단 결정된 이후 변경할 수 없고 언제나 유지된다. 12345const add = (a, b) =&gt; a + b;console.log(add.call(null, 1, 2)); // 3console.log(add.apply(null, [1, 2])); // 3console.log(add.bind(null, 1, 2)()); // 3 메소드를 화살표 함수로 정의하는 것은 피해야 한다. 클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있다. 123456789// Badclass Person &#123; // 클래스 필드 정의 제안 name = 'Lee'; sayHi = () =&gt; console.log(`Hi $&#123;this.name&#125;`);&#125;const person = new Person();person.sayHi(); // Hi Lee 이때 sayHi 클래스 필드에 할당한 화살표 함수 내부에서 this를 참조하면 상위 컨텍스트의 this를 그대로 가리킨다. 그렇다면 sayHi 클래스 필드에 할당한 화살표 함수의 상위 컨텍스트는 무엇일까? sayHi 클래스 필드는 인스턴스 프로퍼티이므로 아래와 같은 의미이다. 12345678class Person &#123; constructor() &#123; this.name = 'Lee'; // 클래스가 생성한 인스턴스(this)의 sayHi 프로퍼티에 화살표 함수를 할당한다. // sayHi 프로퍼티는 인스턴스 프로퍼티이다. this.sayHi = () =&gt; console.log(`Hi $&#123;this.name&#125;`); &#125;&#125; 화살표함수 - super화살표 함수는 함수 자체의 super 바인딩이 없다. 따라서 화살표 함수 내부에서 super를 참조하면 상위 컨텍스트의 super를 참조한다. 123456789101112131415161718192021class Base &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `Hi! $&#123;this.name&#125;`; &#125;&#125;class Derived extends Base &#123; // super 키워드는 ES6 메소드 내에서만 사용 가능하다. // 화살표 함수는 함수 자체의 super 바인딩이 없다. // 화살표 함수 foo의 상위 컨텍스트는 constructor이다. // 화살표 함수 foo의 super는 constructor의 super를 가리킨다. // 클래스 필드 정의 제안으로 클래스 필드에 화살표 함수를 할당한다. sayHi = () =&gt; `$&#123;super.sayHi()&#125; how are you doing?`;&#125;const derived = new Derived('Lee');console.log(derived.sayHi()); // Hi! Lee how are you doing? 화살표함수 - arguments화살표 함수는 함수 자체의 arguments 바인딩이 없다. 따라서 화살표 함수 내부에서 arguments를 참조하면 상위 컨텍스트의 arguments를 참조한다. 123456789101112(function () &#123; // 화살표 함수는 함수 자체의 arguments 바인딩이 없다. // 중첩 함수 foo의 상위 컨텍스트는 즉시 실행 함수이다. // 화살표 함수 foo의 arguments는 실행 함수의 arguments를 가리킨다. const foo = () =&gt; console.log(arguments); // [Arguments] &#123; '0': 1, '1': 2 &#125; foo(3, 4);&#125;(1, 2));// 전역 함수 foo의 상위 컨텍스트는 전역이다.// 전역에는 arguments 객체가 없다. arguments 객체는 함수 내부에서만 유효하다.const foo = () =&gt; console.log(arguments);foo(1, 2); // ReferenceError: arguments is not defined Rest 파라미터기본 문법 Rest 파라미터(Rest Parameter, 나머지 매개변수)는 매개변수 이름 앞에 세개의 점 …을 붙여서 정의한 매개변수를 의미한다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. 12345678function foo(...rest) &#123; // 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터이다. console.log(rest); // [ 1, 2, 3, 4, 5 ] // 매개변수 rest에는 배열이 할당된다. console.log(Array.isArray(rest)); // true&#125;foo(1, 2, 3, 4, 5); argurments는 유사배열 객체이기 때문에 완전한 배열로 변환하기 위해서는 slice.call등을 써야하는데 Rest 파라미터는 정말 쉽게 배열로 바꿀수 있다. 함수에 전달된 인수들은 순차적으로 파라미터와 Rest 파라미터에 할당된다. 1234567891011121314function foo(param, ...rest) &#123; console.log(param); // 1 console.log(rest); // [ 2, 3, 4, 5 ]&#125;foo(1, 2, 3, 4, 5);function bar(param1, param2, ...rest) &#123; console.log(param1); // 1 console.log(param2); // 2 console.log(rest); // [ 3, 4, 5 ]&#125;bar(1, 2, 3, 4, 5); Rest파라미터 주의사항 Rest파라미터는 항상 마지막에 위치해야만 한다. Rest파라미터는 단 하나만 선언할 수 있다. Rest파라미터는 함수 정의 시 선언한 매개변수의 개수를 나타내는 length프로퍼티에 영향을 주지 않는다. 1234567891011121314151617181920function foo( ...rest, param1, param2) &#123; &#125;foo(1, 2, 3, 4, 5);// SyntaxError: Rest parameter must be last formal parameter// Rest 파라미터는 단 하나만 선언할 수 있다.function foo(...rest1, ...rest2) &#123; &#125;foo(1, 2, 3, 4, 5);// SyntaxError: Rest parameter must be last formal parameter// Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.function foo(...rest) &#123;&#125;console.log(foo.length); // 0function bar(x, ...rest) &#123;&#125;console.log(bar.length); // 1function baz(x, y, ...rest) &#123;&#125;console.log(baz.length); // 2 매개변수 기본값​ 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지는 않는다. 함수는 매개변수의 개수와 인수의 개수를 체크하지 않는다. 인수가 부족한 경우, 매개변수의 값은 undefined이다. 12345function sum(x, y) &#123; return x + y;&#125;console.log(sum(1)); // NaN 따라서 매개변수에 적절한 인수가 전달되었는지 함수 내부에서 확인할 필요가 있다. 12345678910function sum(x, y) &#123; // 매개변수의 값이 falsy value인 경우, 기본값을 할당한다. x = x || 0; y = y || 0; return x + y;&#125;console.log(sum(1)); // 1console.log(sum(1, 2)); // 3 ES6에서는 매개변수 기본값을 사용하여 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다. 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우에만 유효하다. 123456function sum(x = 0, y = 0) &#123; return x + y;&#125;console.log(sum(1)); // 1console.log(sum(1, 2)); // 3 매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티와 arguments 객체에 영향을 주지 않는다. 12345678function foo(x, y = 0) &#123; console.log(arguments);&#125;console.log(foo.length); // 1sum(1); // Arguments &#123; '0': 1 &#125;sum(1, 2); // Arguments &#123; '0': 1, '1': 2 &#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 24강(Class)","slug":"javascript-preview-24","date":"2019-10-25T01:43:59.000Z","updated":"2019-11-30T17:05:34.477Z","comments":true,"path":"2019/10/25/javascript-preview-24/","link":"","permalink":"https://hyeok999.github.io/2019/10/25/javascript-preview-24/","excerpt":"","text":"JavaScript 24강 예습 24강 : 클래스 클래스 vs 생성자 함수 클래스 정의 클래스 호이스팅 인스턴스 생성 메소드 constructor 프로토타입 메소드 정적 메소드 정적 메소드와 프로토타입 메소드의 차이 클래스에서 정의한 메소드의 특징 클래스의 인스턴스 생성 과정 프로퍼티 인스턴스 프로퍼티 접근자 프로퍼티 클래스 필드 정의 제안 private 필드 정의 제안 static 필드 정의 제안 상속 클래스 상속과 생성자 함수 상속 extends 키워드 동적 상속 서브 클래스의 constructor super 키워드 super 참조 상속 클래스의 인스턴스 생성 과정 24강클래스 ES5에서는 클래스 없이 생성자함수와 프로토타입 체인, 클로저를 이용하여 객체 지향 언어의 상속, 캡슐화(정보은닉) 등의 개념을 구현할 수 있다. 123456789101112131415161718192021222324// ES5 생성자 함수var Person = (function () &#123; // 자유 변수이며 private하다 var _name = ''; // 생성자 함수 function Person(name) &#123; _name = name; &#125; // 프로토타입 메소드. 이 메소드는 클로저이다. Person.prototype.sayHi = function () &#123; console.log('Hi! My name is ' + _name); &#125;; // 생성자 함수 반환 return Person;&#125;());// 인스턴스 생성var me = new Person('Lee');// _name은 지역 변수이므로 외부에서 접근하여 변경할 수 없다. 즉, private하다.// me 객체에는 _name 프로퍼티가 존재하지 않기 때문에 me._name 프로퍼티를 동적 추가뿐이다.me._name = 'Kim';me.sayHi(); // Hi! My name is Lee ES6에서 새롭게 도입된 클래스는 기존 프로토타입 기반 객체지향 프로그래밍보다 Java나 C#과 같은 클래스 기반 객체지향 프로그래밍에 익숙한 프로그래머가 보다 빠르게 학습할 수 있도록 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 새로운 객체 생성 매카니즘을 제시하고 있다. 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 한다. 클래스 vs 생성자 함수클래스는 생성자 함수와 매우 유사하게 동작하지만 아래와 같이 몇가지 차이가 있다. 클래스는 new 연산자를 사용하지 않고 호출하면 에러가 발행한다. 하지만 생성자 함수는 new 연산자를 사용하지 않고 호출하면 일반 함수로서 호출된다. 클래스는 상속을 지원하는 extentds와 super 키워드를 제공한다. 하지만 생성자 함수는 extentds와 super 키워드를 지원하지 않는다. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 생성자 함수는 함수 호이스팅이 발생한다. 클래스의 모든 코드는 암묵적으로 strict 모드가 지정되어 실행되며 strict 모드를 해지할 수 없다. 하지만 생성자 함수는 암묵적으로 strict 모드가 지정되지 않는다. 클래스의 constructor, 프로토타입 메소드, 정적 메소드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 다시 말해, 열거되지 않는다. 클래스 정의​ 클래스는 class 키워드를 사용하여 정의한다. 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적이다. 파스칼 케이스를 사용하지 않아도 에러가 발생하지는 않는다. 123456789// 클래스 선언문class Person &#123;&#125;일반적이지는 않지만, 함수와 마찬가지로 표현식으로 클래스를 정의할 수도 있다. 이때 클래스는 함수와 마찬가지로 이름을 가질 수도 있고, 갖지 않을 수도 있다.// 익명 클래스 표현식const Person = class &#123;&#125;;// 기명 클래스 표현식const Person = class MyClass &#123;&#125;; 클래스는 일급 객체이다. 따라서 다음과 같은 특징을 지니고 있다. 무명 리터럴로 생성할 수 있다. 런타임에 생성이 가능하다. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다. 함수의 매개변수에 값으로서 전달이 가능하다. 함수의 반환값으로 사용이 가능하다. 클래스 몸체에는 0개 이상의 메소드만을 선언할 수 있다. 클래스 몸체에서 정의할 수 있는 메소드는 construnctor(생성자), 프로토타입 메소드, 정적 메소드 3가지가 있다. 12345678910111213141516171819202122232425262728// 클래스 선언문class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; // name 프로퍼티는 public하다. &#125; // 프로토타입 메소드 sayHi() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; // 정적 메소드 static sayHello() &#123; console.log('Hello!'); &#125;&#125;// 인스턴스 생성const me = new Person('Lee');// 인스턴스의 프로퍼티 참조console.log(me.name); // Lee// 프로토타입 메소드 호출me.sayHi(); // Hi! My name is Lee// 정적 메소드 호출Person.sayHello(); // Hello! 클래스 호이스팅 클래스는 클래스 정의 이전에 참조할 수 없다. 클래스도 호이스팅이 된다. (단, let , const 처럼 일시적 사각지대에 빠지게 된다.) 인스턴스 생성 클래스의 정의는 함수다. (typeof시 함수로 찍힌다.) 클래스는 인스턴스를 생성하는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다. 생성자 함수는 new키워드 없이 호출하게 될 경우, 일반함수로서 호출이 되지만, 클래스는 에러를 일으킨다. 12345class Person &#123;&#125;// new 연산자 없이 호출하면 타입 에러가 발생한다.const me = Person();// TypeError: Class constructor Foo cannot be invoked without 'new' 메소드클래스의 몸체에는 메소드만을 정의할 수 있으며 constructor(생성자) : 인스턴스를 만들경우 해당 인스턴스의 프로퍼티들을 정의한다. 프로토타입 메소드 : 프로토타입 메소드를 정의한다. 정적 메소드 : 해당 클래스만의 메소드를 정의한다. 123456789101112class Person &#123; constructor(name) &#123; // 생성자 // 인스턴스 생성 및 초기화 this.name = name; // name 프로퍼티는 public하다. &#125; sayHi() &#123; // 프로토타입 메소드 console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; static sayHello() &#123; // 정적 메소드 console.log('Hello!'); &#125;&#125; 클래스 정의에 대한 새로운 제안 사양 ​ 2019년 8월 현재, 클래스 몸체에 메소드 뿐만이 아니라 프로퍼티를 직접 정의할 수 있는 새로운 표준 사양이 제안되어 있다. 현재 ECMAScript 사양에 따르면 인스턴스 프로퍼티는 반드시 constructor 내부에서 정의해야 한다. 하지만 제안된 새로운 표준 사양에 의해 머지않아 클래스 몸체에 프로퍼티도 정의할 수 있게 될 것으로 보인다.(현재 크롬과 같은 모던 브라우저는 사용 가능하다.) 이에 대해서는 “24.7.3 클래스 필드 정의 제안”에서 살펴볼 것이다. constructor constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메소드이다. constructor는 이름을 변경할 수 없다. 1234567class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; &#125;&#125; 모든 함수 객체가 가지고 있는 prototype 프로퍼티가 가리키는 객체의 constructor 프로퍼티는 클래스 자신을 가리키고 있다. constructor 내부에서 this에 추가한 name 프로퍼티가 클래스가 생성한 인스턴스의 프로퍼터로 추가된 것을 확인할 수 있다. 즉, 생성자 함수와 마찬가지로 constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다. constructor 내부의 this는 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킨다. constructor는 메소드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. 다시 말해, 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다. constructor는 생성자 함수와 유사하지만 몇가지 차이가 있다. constructor는 클래스 내에 최대 한 개만 존재할 수 있다. 만약 클래스가 2개 이상의 constructor를 포함하면 문법 에러(SyntaxError)가 발생한다. 12345class Person &#123; constructor() &#123;&#125; constructor() &#123;&#125;&#125;// SyntaxError: A class may only have one constructor constructor는 생략할 수 있다. 1class Person &#123;&#125; constructor를 생략하면 클래스에 아래와 같이 디폴트 constructor가 암묵적으로 정의된다. 12345678class Person &#123;// constructor는 생략하면 암묵적으로 디폴트 constructor가 정의된다. constructor() &#123;&#125;&#125;// 빈 객체가 생성된다.const me = new Person();console.log(me); // Person &#123;&#125; constructor를 생략한 클래스는 빈 객체를 생성한다. 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다. 1234567891011class Person &#123; constructor() &#123; // 인스턴스 초기화 this.name = 'Lee'; this.address = 'Seoul'; &#125;&#125;// 인스턴스 프로퍼티가 추가된다.const me = new Person();console.log(me); // Person &#123;name: \"Lee\", address: \"Seoul\"&#125; 인스턴스를 생성할 때, 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 아래와 같이 constructor에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달한다. 이때 초기값은 constructor의 매개변수로 전달된다. 1234567891011class Person &#123; constructor(name, address) &#123; // 인스턴스 초기화 this.name = name; this.address = address; &#125;&#125;// 초기값을 전달한다. 초기값은 constructor에 전달된다.const me = new Person('Lee', 'Seoul');console.log(me); // Person &#123;name: \"Lee\", address: \"Seoul\"&#125; constructor 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손한다. 따라서 constructor 내부에서 return 문을 반드시 생략해야 한다.(생성자 함수와 동일하다.) 프로토타입 메소드생성자 함수를 사용하여 인스턴스를 생성하는 경우, 프로토타입 메소드를 생성하기 위해서는 아래와 같이 명시적으로 프로토타입에 메소드를 추가해야 한다. 123456789101112// 생성자 함수function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHi = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;const me = new Person('Lee');me.sayHi(); // Hi! My name is Lee 123456789101112131415class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; &#125; // 프로토타입 메소드 sayHi() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;&#125;const me = new Person('Lee');me.sayHi(); // Hi! My name is Lee 클래스 몸체에서 정의한 메소드는 생성자 함수에 의한 객체 생성 방식과는 다르게 클래스의 prototype 프로퍼티에 메소드를 추가하지 않아도 기본적으로 프로토타입 메소드가 된다. 정적 메소드123456789101112// 생성자 함수function Person(name) &#123; this.name = name;&#125;// 정적 메소드Person.sayHi = function () &#123; console.log('Hi!');&#125;;// 정적 메소드 호출Person.sayHi(); // Hi! 123456789101112class Person &#123; // 생성자 constructor(name) &#123; // 인스턴스 생성 및 초기화 this.name = name; &#125; // 정적 메소드 static sayHi() &#123; console.log('Hi!'); &#125;&#125; 정적 메소드는 인스턴스 없이 클래스만 가지고 호출이 가능하다.( Person.sayHi() ) 반대로, 인스턴스로는 정적메소드를 호출할 수 없다. ( me.sayHi() 불가능 ) 정적 메소드와 프로토타입 메소드의 차이정적 메소드와 프로토타입 메소드는 무엇이 다르며 무엇을 기준으로 구분하여 정의하여야 할 지 생각해 보자. 정적 메소드와 프로토타입 메소드의 차이는 아래와 같다. 정적 메소드와 프로토타입 메소드가 속해 있는 프로토타입 체인이 다르다. 정적 메소드는 클래스로 호출하고 프로토타입 메소드는 인스턴스로 호출한다. 정적 메소드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메소드는 인스턴스 프로퍼티를 참조할 수 있다. 클래스에서 정의한 메소드의 특징 function 키워드를 생략한 메소드 축약 표현을 사용한다. 객체 리터럴과는 다르게 클래스에 메소드를 정의할 때는 콤마가 필요 없다. 암묵적으로 strict 모드로 실행된다. for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 내부 메소드 [[Construct]]를 갖지 않는 non-constructor이다. 따라서 new 연산자와 함께 호출할 수 없다. 클래스의 인스턴스 생성 과정클래스는 new 연산자 없이 호출할 수 없다. new연산자와 함꼐 클래스를 호출 시 인스턴스를 생성하면 클래스의 내부 메소드 [[Construnct]]가 호출된다. 1. 인스턴스 생성과 this 바인딩 암묵적으로 빈객체가 생성된다. 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다. 인스턴스는 빈객체(this)에 바인딩 된다. 2. 인스턴스 초기화 constructor에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가한다. constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다. 3. 프로토타입 / 정적 메소드 추가 클래스 몸체에 프로토타입 메소드가 존재하면 클래스의 prototype 프로퍼티가 가리키는 객체에 메소드로 추가된다. 클래스 몸체에 정적 메소드가 존재하면 클래스에 메소드로 추가된다. 4. 인스턴스 반환 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 1234567891011121314151617181920212223class Person &#123; // 생성자 constructor(name) &#123; // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.console.log(this); // Person &#123;&#125; console.log(Object.getPrototypeOf(this) === Person.prototype); // true // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.name = name; // 4. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. &#125; // 3. 프로토타입 메소드는 클래스의 prototype에 메소드로 추가된다. sayHi() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; // 3. 정적 메소드는 클래스에 메소드로 추가된다. static sayHello() &#123; console.log('Hello!'); &#125;&#125; 프로퍼티인스턴스 프로퍼티123456789class Person &#123; constructor(name) &#123; // 인스턴스 프로퍼티 this.name = name; &#125;&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: \"Lee\"&#125; constructor 내부에서 this에 추가한 프로퍼티는 언제나 클래스가 생성한 인스턴스의 프로퍼티가 된다. 인스턴스 프로퍼티는 언제나 public하다. 다행히도 private한 프로퍼티를 정의할 수 있는 사양이 현재 제안 중에 있다. 접근자 프로퍼티접근자 프로퍼티(Accessor property)는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다. 접근자 프로퍼티는 클래스에서도 사용할 수 있다. 위 예제의 객체 리터럴을 클래스로 표현하면 아래와 같다. 123456789101112131415161718192021222324252627282930313233343536class Person &#123; constructor(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; // fullName은 접근자 함수로 구성된 접근자 프로퍼티이다. // getter 함수 get fullName() &#123; return this.firstName + ' ' + this.lastName; &#125; // setter 함수 set fullName(name) &#123; [this.firstName, this.lastName] = name.split(' '); &#125;&#125;const me = new Person('Ungmo', 'Lee');// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.console.log(`$&#123;me.firstName&#125; $&#123;me.lastName&#125;`); // Ungmo Lee// 접근자 프로퍼티를 통한 프로퍼티 값의 저장// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.me.fullName = 'Heegun Lee';console.log(me); // &#123;firstName: \"Heegun\", lastName: \"Lee\"&#125;// 접근자 프로퍼티를 통한 프로퍼티 값의 참조// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.console.log(me.fullName); // Heegun Lee// fullName는 접근자 프로퍼티이다.// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.console.log(Object.getOwnPropertyDescriptor(Person.prototype, 'fullName'));// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125; 클래스의 메소드는 기본적으로 프로토타입 메소드가 되므로 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다. 클래스의 접근자 프로퍼티는 프로토타입 프로퍼티이다. 클래스 필드 정의 제안 클래스 필드(필드 또는 멤버)는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어 전까지는 분명 클래스 몸체에는 3종류의 메서드(생성자, 정적, 프로토타입)만이 들어올수 있다고 하였다. 하지만 새로운표준상양이 추가되어(19년 8월) 클래스필드를 선언할 수 있게 되었다. 클래스 몸체에서 클래스 필드를 정의할 수 있는 클래스 필드 정의(Class field definitions) 제안은 아직 ECMAScript의 정식 표준 사양으로 승급 되지 않았다. 하지만 최신 브라우저(Chrome 72 이상)와 최신 Node.js(버전 12 이상)는 표준 사양으로 승급이 확실시되는 이 제안을 미리 구현해 놓았다. 따라서 최신 브라우저와 최신 Node.js에서는 아래 예제와 같이 클래스 필드를 클래스 몸체에 정의할 수 있다. 1234567class Person &#123; // 클래스 필드 정의 name = 'Lee';&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: \"Lee\"&#125; 클래스 몸체에서 클래스 필드를 정의하는 경우, this에 클래스 필드를 바인딩해서는 안된다. this는 클래스의 메소드 내에서만 유효하다. 1234class Person &#123; // this에 클래스 필드를 바인딩해서는 안된다. this.name = ''; // SyntaxError: Unexpected token .&#125; 클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다. 1234567class Person &#123; // 클래스 필드를 초기화하지 않으면 undefined를 갖는다. name;&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: undefined&#125; 인스턴스를 생성할 때, 외부의 초기값으로 클래스 필드를 초기화해야 할 필요가 있다면 constructor에서 클래스 필드를 초기화해야 한다. 1234567891011class Person &#123; name; constructor(name) &#123; // 클래스 필드 초기화. this.name = name; &#125;&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: \"Lee\"&#125; 이처럼 인스턴스를 생성할 때, 클래스 필드를 초기화할 필요가 있다면 constructor 밖에서 클래스 필드를 정의할 필요가 없다. 클래스 필드를 초기화할 필요가 있다면 어차피 constructor 내부에서 클래스 필드를 참조하여 초기값을 할당해야 한다. 이때 this, 즉 클래스가 생성한 인스턴스에 클래스 필드에 해당하는 프로퍼티가 없다면 자동 추가되기 때문이다. 12345678class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;const me = new Person('Lee');console.log(me); // Person &#123;name: \"Lee\"&#125; 함수는 일급 객체이므로 클래스 필드에 할당할 수 있으므로 클래스 필드를 통해 메소드를 정의할 수도 있다. 123456789101112131415class Person &#123; // 클래스 필드에 문자열을 할당 name = 'Lee'; // 클래스 필드에 함수를 할당 getName = function () &#123; return this.name; &#125; // 화살표 함수로 정의할 수도 있다. // getName = () =&gt; this.name;&#125;const me = new Person();console.log(me); // Person &#123;name: \"Lee\", getName: ƒ&#125;console.log(me.getName()); // Lee 클래스 필드에 함수는 프로퍼티 메소드가 아닌 인스턴스의 메소드가 된다. private 필드 정의 제안constructor 내부에서 this를 통해 정의한 인스턴스 프로퍼티는 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 언제나 public이다. 클로저를 사용하여 private한 프로퍼티를 흉내낼 수 있었다. 단 private한 프로퍼티를 흉내낸 자유 변수에 접근하면 에러가 발생하지 않고 undefined를 반환하므로 아쉬움이 남는다. private 필드의 선두에는 #을 붙여준다. private 필드를 참조할 때도 #을 붙어주어야 한다. 123456789101112131415class Person &#123; // private 필드 정의 #name = ''; constructor(name) &#123;// private 필드 참조 this.#name = name; &#125;&#125;const me = new Person('Lee');// private 필드 #name은 클래스 외부에서 참조할 수 없다.console.log(me.#name);// SyntaxError: Private field '#name' must be declared in an enclosing class 접근 프로퍼티를 이용하여 간접적으로 접근할 수 있다. 123456789101112131415161718class Person &#123; // private 필드 정의 #_name = ''; constructor(name) &#123; this.#_name = name; &#125; // name은 접근자 프로퍼티이다. get name() &#123; // private 필드를 참조하여 trim한 다음 반환한다. return this.#_name.trim(); &#125;&#125;const me = new Person(' Lee ');console.log(me.name); // \"Lee\" private 필드는 반드시 클래스 몸체에 정의해야 한다. private 필드를 직접 constructor에 정의하면 에러가 발생한다. 1234567class Person &#123; constructor(name) &#123; // private 필드는 클래스 몸체에서 정의해야 한다. this.#name = name; // SyntaxError: Private field '#name' must be declared in an enclosing class &#125;&#125; static 필드 정의 제안지금까지 static메소드를 정의는 되었지만, static 필드는 불가능했다. 하지만 최근 버전에 static 필드 또한 제한이 되었다. 123456789101112131415class MyMath &#123; // static public 필드 정의 static PI = 22 / 7; // static private 필드 정의 static #num = 10; // static 메소드 static increment() &#123; return ++MyMath.#num; &#125;&#125;console.log(MyMath.PI); // 3.142857142857143console.log(MyMath.increment()); // 11 상속클래스 상속과 생성자 함수 상속프로토타입 기반 상속은 프로토타입 체인에 의해 객체의 리소스를 상속받는 개념이. 상속에 의한 클래스 확장은 기존의 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다. 동물이라는 클래스를 새라는 클래스에 상속하는 예제이다. 123456789101112131415161718192021222324class Animal &#123; constructor(age, weight) &#123; this.age = age; this.weight = weight; &#125; eat() &#123; return 'eat'; &#125; move() &#123; return 'move'; &#125;&#125;class Bird extends Animal &#123; fly() &#123; return 'fly'; &#125;&#125;const bird = new Bird(1, 5);console.log(bird); // Bird &#123;age: 1, weight: 5&#125;console.log(bird instanceof Bird); // trueconsole.log(bird instanceof Animal); // trueconsole.log(bird.eat()); // eatconsole.log(bird.move()); // moveconsole.log(bird.fly()); // fly 클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends 키워드가 기본적으로 제공된다. 이를 통해 상속에 의한 클래스 확장이 간편하고 직관적이다. 하지만 생성자 함수는 클래와 같이 상속을 통해 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않는다. extends 키워드상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정의한다. 12345// 수퍼(파생/부모) 클래스class Base &#123;&#125;// 서브(파생/자식) 클래스class Derived extends Base &#123;&#125; extends 키워드의 역할은 수퍼 클래스와 서브 클래스 간의 상속 관계를 설정하는 것이다. 클래스도 프로토타입을 통해 상속 관계를 구현한다. 수퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인 뿐만이 아니라, 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메소드, 정적 메소드 모두 상속이 가능하다. 동적 상속extends키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메소드를 갖는 함수 객체를 반환하는 모든 표현식을 사용할 수 있다. 이를 통해 동적으로 상속받을 대상을 결정할 수 있다. 1234567891011121314function Base1() &#123;&#125;class Base2 &#123;&#125;let condition = true;// 조건에 따라 동적으로 상속 대상을 결정하는 서브 클래스class Derived extends (condition ? Base1 : Base2) &#123;&#125;const derived = new Derived();console.log(derived); // Derived &#123;&#125;console.log(derived instanceof Base1); // trueconsole.log(derived instanceof Base2); // false 서브 클래스의 constructor서브 클래스에 constructor를 생략하면 클래스에 아래와 같이 디폴트 constructor가 암묵적으로 정의된다. args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트이다. super()는 수퍼 클래스의 constructor(super-constructor)를 호출하여 인스턴스를 생성한다. 1constructor(...args) &#123; super(...args); &#125; 123456789101112// 수퍼 클래스class Base &#123; constructor() &#123;&#125;&#125;// 서브 클래스class Derived extends Base &#123; constructor() &#123; super(); &#125;&#125;const derived = new Derived();console.log(derived); // Derived &#123;&#125; 위 예제와 같이 수퍼 클래스와 서브 클래스 모두 constructor를 생략하면 빈객체가 생성된다. 프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다. super 키워드super 키워드는 함수처럼 호출할 수도 있고 this와 같은 식별자처럼 참조할 수 있는 특수한 키워드이다. super는 아래와 같이 동작한다. super를 호출하면 수퍼 클래스의 constructor(super-constructor)를 호출한다. super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다. 12345678910111213141516// 수퍼 클래스class Base &#123; constructor(a, b) &#123; this.a = a; this.b = b; &#125;&#125;// 서브 클래스class Derived extends Base &#123; // 아래와 같이 암묵적으로 디폴트 constructor가 정의된다. // constructor(a, b) &#123; super(a, b); &#125;&#125;const derived = new Derived(1, 2);console.log(derived); // Derived &#123;a: 1, b: 2&#125; 123456789101112131415161718// 수퍼 클래스class Base &#123; constructor(a, b) &#123; // ④ this.a = a; this.b = b; &#125;&#125;// 서브 클래스class Derived extends Base &#123; constructor(a, b, c) &#123; // ② super(a, b); // ③ this.c = c; &#125;&#125;const derived = new Derived(1, 2, 3); // ①console.log(derived); // Derived &#123;a: 1, b: 2, c: 3&#125; new 연산자와 함께 Derived 클래스를 호출하면서 전달한 인수(①)는 Derived 클래스의 constructor(②)에게 전달되고 super 호출(③)을 통해 Base클래스의 constructor(④)에게 전달된다. super 호출 주의사항 1. 서브 클래스의 constructor에서는 반드시 super를 호출해야 한다. 12345678910class Base &#123;&#125;class Derived extends Base &#123; constructor() &#123; // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor console.log('constructor call'); &#125;&#125;const derived = new Derived(); 2. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다. 1234567891011class Base &#123;&#125;class Derived extends Base &#123; constructor() &#123; // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor this.a = 1; super(); &#125;&#125;const derived = new Derived(1); 3. super는 반드시 서브 클래스의 constructor에서만 호출한다. 서브 클래스가 아닌 클래스 또는 함수에서 호출하면 에러를 발생시킨다. 123456789class Base &#123; constructor() &#123; super(); // SyntaxError: 'super' keyword unexpected here &#125;&#125;function Foo() &#123; super(); // SyntaxError: 'super' keyword unexpected here&#125; super 참조메소드 내에서 super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다. 1. 서브 클래스의 프로토타입 메소드 내에서 super.prop는 수퍼 클래스의 프로토타입 메소드 prop를 가리킨다. 123456789101112131415161718192021// 수퍼 클래스class Base &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `Hi! $&#123;this.name&#125;`; &#125;&#125;// 서브 클래스class Derived extends Base &#123; sayHi() &#123; // super.getName은 수퍼 클래스의 프로토타입 메소드를 가리킨다. return `$&#123;super.sayHi()&#125;. how are you doing?`; &#125;&#125;const derived = new Derived('Lee');console.log(derived.sayHi()); // Hi! Lee. how are you doing? 위 예제는 이 예제와 동일하다. 12345678910111213141516171819// 수퍼 클래스class Base &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `Hi! $&#123;this.name&#125;`; &#125;&#125;class Derived extends Base &#123; sayHi() &#123; // __super는 Derived의 sayHi가 바인딩된 객체의 프로토타입을 가리킨다. // sayHi는 Derived.prototype에 바인딩되었으므로 __super는 Base.prototype을 가리킨다. const __super = Object.getPrototypeOf(Derived.prototype); return `$&#123;__super.sayHi.call(this)&#125; how are you doing?`; &#125;&#125; super는 자신이 바인딩되어 있는 객체의 프로토타입을 가리킨다. 위 예제에서 Derived 클래스의 sayHi는 Derived.prototype에 바인딩되어 있고 super는 Derived.prototype의 프로토타입인 Base.prototype을 가리킨다. 따라서 super.sayHi는 Base.prototype.sayHi를 가리킨다. 단, super.sayHi, 즉 Base.prototype.sayHi를 호출할 때 call 메소드를 사용해 this를 전달하여야 한다. Base.prototype.sayHi에는 name 프로퍼티가 존재하지 않기 때문이다. 이처럼 super 참조가 동작하기 위해서는 메소드는 자신이 바인딩되어 있는 객체의 프로토타입을 기억해야 한다. 이를 위해 메소드는 내부 슬롯 [[HomeObject]]를 갖으며 자신이 바인딩된 객체를 가리킨다. super 참조를 의사 코드로 표현하면 아래와 같다. 1super = Object.getPrototypeOf([[HomeObject]]) 주의할 것은 ES6 사양에서 새롭게 정의한 메소드, 즉 ES6의 메소드 축약 표현으로 정의된 함수만이 [[HomeObject]]를 갖는다는 것이다. 123456const obj = &#123; // ES6 사양에서 정의한 메소드이다. [[HomeObject]]를 갖는다. foo() &#123;&#125;, // ES6 사양에서 정의한 메소드가 아니라 일반 함수이다. [[HomeObject]]를 갖지 않는다. bar: function () &#123;&#125;&#125;; super 참조는 클래스의 전유물은 아니다. 객체 리터럴에서도 super 참조를 사용할 수 있다. 단, ES6의 메소드 축약 표현으로 정의된 함수만 가능하다. 12345678910111213141516const base = &#123; name: 'Lee', sayHi() &#123; return `Hi! $&#123;this.name&#125;`; &#125;&#125;;const derived = &#123; __proto__: base, // ES6 사양에서 정의한 메소드이다. [[HomeObject]]를 갖는다. sayHi() &#123; return `$&#123;super.sayHi()&#125;. how are you doing?`; &#125;&#125;;console.log(derived.sayHi()); // Hi! Lee. how are you doing? 2. 서브 클래스의 정적 메소드 내에서 super.prop는 수퍼 클래스의 정적 메소드 prop를 가리킨다. 12345678910111213141516// 수퍼 클래스class Base &#123; static sayHi() &#123; return 'Hi!'; &#125;&#125;// 서브 클래스class Derived extends Base &#123; static sayHi() &#123; // super.sayHi는 수퍼 클래스의 정적 메소드를 가리킨다. return `$&#123;super.sayHi()&#125; how are you doing?`; &#125;&#125;console.log(Derived.sayHi()); // Hi! how are you doing? 상속 클래스의 인스턴스 생성 과정123456789101112131415161718192021222324252627282930313233343536// 수퍼 클래스class Rectangle &#123; constructor(width, height) &#123; this.width = width; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125; toString() &#123; return `width = $&#123;this.width&#125;, height = $&#123;this.height&#125;`; &#125;&#125;// 서브 클래스class ColorRectangle extends Rectangle &#123; constructor(width, height, color) &#123; super(width, height); this.color = color; &#125; // 메소드 오버라이딩 toString() &#123; return super.toString() + `, color = $&#123;this.color&#125;`; &#125;&#125;const colorRectangle = new ColorRectangle(2, 4, 'red');console.log(colorRectangle); // Rectangle &#123; width: 2, height: 4, color: 'red' &#125;// 상속을 통해 getArea 메소드를 호출console.log(colorRectangle.getArea()); // 8// 오버라이딩된 toString 메소드를 호출console.log(colorRectangle.toString()); // width = 2, height = 4, color = red ColorRectangle 클래스에 의해 생성된 인스턴스의 프로토타입 체인은 아래와 같다. 서브 클래스(ColorRectangle)가 new 연산자와 함께 호출되면 아래의 과정을 통해 인스턴스를 생성한다. 1. 서브 클래스의 super 호출 자바스크립트 엔진은 클래스를 평가할 때, 수퍼 클래스와 서브 클래스를 구분하기 위해 내부 슬롯 [[ConstructorKind]]를 갖는다. 다른 클래스를 상속받지 않는 클래스(그리고 생성자 함수)는 내부 슬롯 [[ConstructorKind]]의 값이 “base”로 설정되지만 다른 클래스를 상속받는 서브 클래스는 내부 슬롯 [[ConstructorKind]]의 값이 “derived”로 설정된다. 이를 통해 수퍼 클래스와 서브 클래스는 new 연산자와 함께 호출되었을 때의 동작이 구분된다. 다른 클래스를 상속받지 않는 클래스(그리고 생성자 함수)는 new 연산자와 함께 호출되었을 때 암묵적으로 빈 객체, 즉 인스턴스를 생성하고 이를 this에 바인딩한다. 하지만 서브 클래스는 암묵적으로 빈 객체, 즉 인스턴스를 생성하지 않고 인스턴스 생성을 수퍼 클래스에게 위임한다. 이것이 바로 서브 클래스의 constructor에서 반드시 super를 호출해야하는 이유이다. 서브 클래스(ColorRectangle)가 new 연산자와 함께 호출되면 서브 클래스 constructor 내부의 super 키워드가 함수처럼 호출된다. super를 호출하면 수퍼 클래스의 constructor(super-constructor)가 호출된다. 좀 더 정확히 말하자면 수퍼 클래스가 평가되어 생성된 함수 객체의 코드가 실행되기 시작한다. 만약 서브 클래스 constructor 내부에 super 호출이 없으면 에러가 발생한다. 실제로 인스턴스를 생성하는 주체는 수퍼 클래스이므로 수퍼 클래스의 constructor를 호출하는 super가 호출되지 않으면 인스턴스를 생성할 수 없기 때문이다. 2. 수퍼 클래스의 인스턴스 생성과 this 바인딩 수퍼 클래스가 실행되기 시작하여 암묵적으로 빈 객체를 생성한다. 이 빈 객체가 바로 (아직 완성되진 않았지만) 클래스가 생성한 인스턴스이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다. 따라서 수퍼 클래스의 constructor 내부의 this는 생성된 인스턴스를 가리킨다. 12345678// 수퍼 클래스class Rectangle &#123; constructor(width, height) &#123; // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다. console.log(this); // ColorRectangle &#123;&#125; // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다. console.log(new.target); // ColorRectangle... 이때 인스턴스는 수퍼 클래스가 생성한 것이다. 하지만 new 연산자와 함께 호출된 클래스가 서브 클래스라는 것이 중요하다. 즉, new 연산자와 함께 호출된 함수를 가리키는 new.target은 서브클래스를 가리킨다. 따라서 인스턴스는 new.target이 가리키는 서브 클래스가 생성한 것으로 처리된다. 따라서 생성된 인스턴스의 프로토타입은 수퍼 클래스의 prototype 프로퍼티가 가리키는 객체(Rectangle.prototype)가 아니라 new.target, 즉 서브 클래스의 prototype 프로퍼티가 가리키는 객체(ColorRectangle.prototype)이다. 12345678910111213// 수퍼 클래스class Rectangle &#123; constructor(width, height) &#123; // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다. console.log(this); // ColorRectangle &#123;&#125; // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다. console.log(new.target); // ColorRectangle // 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype가 설정된다. console.log(Object.getPrototypeOf(this) === ColorRectangle.prototype); // true console.log(this instanceof ColorRectangle); // true console.log(this instanceof Rectangle); // true... 3. 수퍼 클래스의 인스턴스 초기화 수퍼 클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다. 1234567891011121314151617181920// 수퍼 클래스class Rectangle &#123; constructor(width, height) &#123; // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다. console.log(this); // ColorRectangle &#123;&#125; // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다. console.log(new.target); // ColorRectangle // 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype가 설정된다. console.log(Object.getPrototypeOf(this) === ColorRectangle.prototype); // true console.log(this instanceof ColorRectangle); // true console.log(this instanceof Rectangle); // true // 인스턴스 초기화 this.width = width; this.height = height; console.log(this); // ColorRectangle &#123;width: 2, height: 4&#125; &#125;... 4. 수퍼 클래스의 프로토타입 / 정적 메소드 추가 수퍼 클래스 몸체에 프로토타입 메소드가 존재하면 수퍼 클래스의 prototype 프로퍼티가 가리키는 객체에 메소드로 추가된다. 수퍼 클래스 몸체에 정적 메소드가 존재하면 클래스에 메소드로 추가된다. 5. 서브 클래스 constructor로의 복귀와 this 바인딩 super의 호출이 종료되고 컨트롤이 서브 클래스 constructor로의 복귀한다. 이때 super가 반환한 인스턴스가 this에 바인딩된다. super 호출이 종료하기 전에는 this를 참조할 수 없다. 서브 클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용한다. 12345678// 서브 클래스class ColorRectangle extends Rectangle &#123; constructor(width, height, color) &#123; super(width, height); // super가 반환한 인스턴스가 this에 바인딩된다. console.log(this); // ColorRectangle &#123;width: 2, height: 4&#125;... 이처럼 super가 호출되지 않으면 인스턴스가 생성되지 않는다. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없는 이유는 바로 이 때문이다. 따라서 서브 클래스 constructor 내부의 인스턴스 초기화는 반드시 super 호출 이후에 처리되어야 한다. 6. 서브 클래스의 인스턴스 초기화 super 호출 이후, 서브 클래스의 constructor에 기술되어 있는 인스턴스 초기화가 실행된다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다. 7. 인스턴스 반환 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 123456789101112131415// 서브 클래스class ColorRectangle extends Rectangle &#123; constructor(width, height, color) &#123; super(width, height); // super가 반환한 인스턴스가 this에 바인딩된다. console.log(this); // ColorRectangle &#123;width: 2, height: 4&#125; // 인스턴스 초기화 this.color = color; // 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. console.log(this); // ColorRectangle &#123;width: 2, height: 4, color: \"red\"&#125; &#125;...","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Class","slug":"Class","permalink":"https://hyeok999.github.io/tags/Class/"}]},{"title":"javascript-study-14","slug":"javascript-study-14","date":"2019-10-24T01:52:51.000Z","updated":"2019-11-30T17:01:25.836Z","comments":true,"path":"2019/10/24/javascript-study-14/","link":"","permalink":"https://hyeok999.github.io/2019/10/24/javascript-study-14/","excerpt":"","text":"JavaScript Study 14 용어 클로저 함수 객체의 내부 슬롯 [[Environment]] 클로저와 렉시컬 환경 클로저의 활용 생성자를 이용 함수형 프로그래밍 자주 발생하는 실수 정규 표현식 플래그 패턴 자주 사용하는 정규표현식 용어 - ( 러버덕 ) 고차함수 클로저 정규표현식 플래그 패턴 클로저 JS에는 private, protect, public과 같은 접근 제한자가 없다. 따라서 클로저를 이용하여 접근제한자를 구현하여 캡슐화에 이용한다. 즉, 클로저는 상태를 안전하게 유지하기 위함이다. MDN : 클로저는 함수와 그 함수가 선언된 렉시컬 환경(Lexical environment)과의 조합이다. 함수 정의된 위치(환경)에 따라서 상위스코프가 정적으로 결정된다. ▹ 렉시컬 환경 함수 객체의 내부 슬롯 [[Environment]] 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다. 123451. 함수 실행 컨텍스트 생성2. 함수 렉시컬 환경 생성 2.1. 함수 환경 레코드 생성 2.2. 외부 렉시컬 환경에 대한 참조 할당 2.3. this 바인딩 함수 렉시컬 환경의 구성 요소인 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다. 1234567891011121314151617const x = 1;function foo() &#123; const x = 10; // 상위 스코프는 함수 정의 환경(위치)에 따라 결정된다. // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다. bar();&#125;// 함수 bar는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 기억한다.function bar() &#123; console.log(x);&#125;foo(); // ?bar(); // ? 클로저와 렉시컬 환경 지금까지 배운 내용으로는 이론적으로 모든 함수가 클로저라 할수 있다. 그러나 실제로는 모두 클로저라 하지 않고 다음 조건을 가지는 것을 클로저라한다. 중첩함수가 상위 함수가 만든 상위 스코프의 식별자를 참조하고 있다. 상위 함수보다 중첩 함수가 더 오래 살아야 한다. 이 경우의 중첩함수를 클로저라 칭한다. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; function foo() &#123; const x = 1; const y = 2; // 클로저 function bar() &#123; // 상위 스코프의 식별자 x만을 참조한다. console.log(x); &#125; return bar; &#125; const bar = foo(); bar(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 클로저에 의해 참조되는 상위 스코프의 변수(위 예제의 경우, foo 함수의 변수 x)를 자유 변수(Free variable)라고 부른다. 위에 선언된 x는 결국 ‘자유변수’ 다. y는 기억을 안한다. 따라서, 즉, 자유변수와 묶여있는 함수는 클로저다. 클로저의 활용클로저는 상태를 안전하게 유지하기 위해 사용한다. 즉, 상태가 의도치 않게 변경되지 않도록 안전하게 은닉(Information hiding)한다. 그리고 이전 상태를 기억하다가 상태가 변경되면 최신 상태(state)를 유지한다. 클로저의 사용 목적 상태를 안전하게 유지. (아무나 바꾸지 못하게 한다.) 위 내용을 보고 정보은닉만을 떠오르는데 클로저는 단지 정보은닉만을 위해서 사용하는 것이 아니라,상태를 안전하게 유지하게 하고자 클로저를 사용하다보니 정보은닉을 하게 된 것. 버튼이 클릭될 때마다 클릭한 횟수를 누적하여 화면에 표시되는 카운터를 만들어보자. 이 예제의 클릭된 횟수(변수 num)가 바로 유지해야할 상태이다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const counter = (function () &#123; // 카운트 상태를 유지하기 위한 자유 변수 let num = 0; // 클로저를 메소드로 갖는 객체를 반환한다. // 객체 리터럴은 스코프를 만들지 않는다. // 따라서 아래 메소드들의 상위 스코프는 즉시 실행 함수의 스코프이다. return &#123; // num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다. increase() &#123; $counter.textContent = ++num; // 상태 변경 &#125;, decrease() &#123; if (num &lt;= 0) return; $counter.textContent = --num; // 상태 변경 &#125; &#125;; &#125;()); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제에서 즉시 실행 함수가 반환하는 객체 리터럴은 함수 실행 단계에서 평가되어 객체가 된다. 이때 객체의 메소드인 함수도 함수 객체로 생성된다. 객체 리터럴의 중괄호는 코드 블록이 아니므로 별도의 스코프를 생성하지 않는다. 따라서 위 예제의 increase, decrease 메소드의 상위 스코프는 increase, decrease 메소드가 평가되는 시점에 실행 중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경이다. 다시 말해, increase, decrease 메소드의 상위 스코프는 즉시 실행 함수의 스코프이다. 따라서 increase, decrease 메소드가 언제 어디서 호출되던지 상관없이 increase, decrease 함수는 즉시 실행 함수의 스코프의 식별자를 참조할 수 있다. 생성자를 이용12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const Counter = (function () &#123; // ① 카운트 상태를 유지하기 위한 자유 변수 let num = 0; function Counter() &#123; // this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다. &#125; Counter.prototype.increase = function () &#123; $counter.textContent = ++num; &#125;; Counter.prototype.decrease = function () &#123; if (num &lt;= 0) return; $counter.textContent = --num; &#125;; return Counter; &#125;()); const counter = new Counter(); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 즉시 실행 함수로 감싸고 생성자로 호출하여 인스턴스화한다. 따라서 Counter.prototype.increase \\ decrease는 결국에는 상위스코프인 즉시 실행함수를 가리키기 때문에 num을 기억하게 된다. 함수형 프로그래밍12345678910111213141516171819202122232425262728293031323334// 함수를 인수로 전달받고 함수를 반환하는 고차 함수// 이 함수가 반환하는 함수는 카운트 상태를 유지하기 위한 자유 변수 counter을 기억하는 클로저다.function makeCounter(predicate) &#123; // 카운트 상태를 유지하기 위한 자유 변수 let counter = 0; // 클로저를 반환 return function () &#123; // 인수로 전달 받은 보조 함수에 상태 변경을 위임한다. counter = predicate(counter); return counter; &#125;;&#125;// 보조 함수function increase(n) &#123; return ++n;&#125;// 보조 함수function decrease(n) &#123; return --n;&#125;// 함수로 함수를 생성한다.// makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환한다const increaser = makeCounter(increase); // ①console.log(increaser()); // 1console.log(increaser()); // 2// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.const decreaser = makeCounter(decrease); // ②console.log(decreaser()); // -1console.log(decreaser()); // -2 함수 makeCounter는 보조 함수를 인자로 전달받고 함수를 반환하는 고차 함수이다. 함수 makeCounter가 반환하는 함수는 자신이 생성됐을 때의 렉시컬 환경인 함수 makeCounter의 스코프에 속한 변수 counter을 기억하는 클로저다. 함수 makeCounter를 호출해 함수를 반환할 때 반환된 함수는 자신만의 독립된 렉시컬 환경을 갖는다 변수 increaser와 변수 decreaser에 할당된 함수는 각각 자신만의 독립된 렉시컬 환경을 갖기 때문에 카운트를 유지하기 위한 자유 변수 counter를 공유하지 않아 카운터의 증감이 연동하지 않는다. 따라서 독립된 카운터가 아니라 연동하여 증감이 가능한 카운터를 만들려면 렉시컬 환경을 공유하는 클로저를 만들어야 한다. 이를 위해서는 makeCounter 함수를 두번 호출하지 말아야 한다. 자주 발생하는 실수12345678910var arr = []; for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; // ① return i; &#125;; &#125; for (var j = 0; j &lt; arr.length; j++) &#123; console.log(arr[j]()); // ② &#125; for 문의 초기화 문에서 var 키워드로 선언한 변수 i는 블록 레벨이 아닌 함수 레벨 스코프를 갖기 때문에 전역 변수가 되며 변수 i에는 0, 1, 2, 3, 4, 5가 순차적으로 할당된다. 따라서 배열 funcs에 요소로 추가된 함수를 호출하면 전역 변수 i를 참조하여 i의 값 5가 출력된다. 12345678910111213 var arr = [];for (var i = 0; i &lt; 5; i++)&#123; arr[i] = (function (id) &#123; // ① return function () &#123; return id; &#125;; &#125;(i));&#125;for (var j = 0; j &lt; arr.length; j++) &#123; console.log(arr[j]());&#125; ①에서 즉시 실행 함수는 전역 변수 i에 현재 할당되어 있는 값을 인수로 전달받아 매개 변수 id에 할당한 후 중첩 함수를 반환하고 종료된다. 즉시 실행 함수가 반환한 함수는 배열 funcs에 순차적으로 저장된다. 이때 즉시 실행 함수의 매개 변수 id는 즉시 실행 함수가 반환한 함수의 상위 스코프에 존재하며 즉시 실행 함수가 반환한 함수에 의해 참조되므로 자유 변수가 되어 즉시 실행 함수가 반환한 함수에 의해 그 값이 유지된다. 위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 문의 초기화 문에서 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 번거로움이 깔끔하게 해결된다. 123456789const arr = [];for (let i = 0; i &lt; 3; i++) &#123; arr[i] = () =&gt; i;&#125;for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]()); // 0 1 2&#125; 초기화 문에서 let 키워드로 선언한 변수를 사용하면 for 문이 반복될 때마다 for 문 코드 블록의 새로운 렉시컬 환경이 생성된다. 만약 for 문 내에서 정의된 함수가 있다면 이 함수의 상위 스코프는 for 문이 반복될 때마다 생성된 for 문 코드 블록의 새로운 렉시컬 환경이다. 이때 함수의 상위 스코프는 for 문이 반복될 때 마다 식별자(초기화 변수 및 for 문 내 지역 변수 등)의 값을 유지해야 한다. 이를 위해 for 문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다. 정규 표현식 정규 표현식은 문자열에서 특정 내용을 찾거나 대체 또는 발췌하는데 사용한다. 정규표현식은 기호들로 이루어졌길래 난해한 문법으로 유명하다. 정규표현식을 공부하거나 사용할 때는 인터넷을 통해서 그 때 즉시 알아보고 써야한다. 다만, 인터넷마다 정규표현식의 내용이 다를수도 있기 때문에 충분히 테스트를 해보고 사용해야만 한다. 플래그플래그는 아래와 같은 종류가 있다. Flag Meaning Description i Ignore Case 대소문자를 구별하지 않고 검색한다. g Global 문자열 내의 모든 패턴을 검색한다. m Multi Line 문자열의 행이 바뀌더라도 검색을 계속한다. 패턴패턴에는 검색하고 싶은 문자열을 지정한다. 이때 문자열의 따옴표는 생략한다. .를 3개 연속하여 패턴을 생성하면 3자리 문자를 추출한다. 모든 문자를 선택하려면 .와 g를 동시에 지정한다. + : 앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 +를 붙인다. |를 사용하면 or의 의미를 가지게 된다. []내의 문자는 or로 동작한다. 그 뒤에 +를 사용하여 앞선 패턴을 한번 이상 반복하게 한다. 범위를 지정하려면 []내에 -를 사용한다. // ex) /[A-Z]+/g; - ‘A’ ~ ‘Z’가 한번 이상 반복되는 문자열을 반복 검색 /[A-Za-z]+/g; // ‘A’ ~ ‘Z’ 또는 ‘a’ ~ ‘z’가 한번 이상 반복되는 문자열을 반복 검색 /[0-9]+/g; // ‘0’ ~ ‘9’가 한번 이상 반복되는 문자열을 반복 검색 /[0-9,]+/g; // ‘0’ ~ ‘9’ 또는 ‘,’가 한번 이상 반복되는 문자열을 반복 검색 \\d는 숫자를 의미한다. \\D는 \\d와 반대로 동작한다. \\w는 알파벳과 숫자를 의미한다. \\W는 \\w와 반대로 동작한다. 자주 사용하는 정규표현식특정 단어로 시작하는지 검사한다. ‘http’로 시작하는지 검사 ^ : 문자열의 처음을 의미한다. 123const url = 'http://example.com';const regexr = /^http/;console.log(regexr.test(url)); // true 특정 단어로 끝나는지 검사한다. ‘html’로 끝나는지 검사 $ : 문자열의 끝을 의미한다. 123const fileName = 'index.html';const regexr = /html$/;console.log(regexr.test(fileName)); // true 숫자인지 검사한다. 모두 숫자인지 검사 ^숫자로 시작 , &amp;숫자로 끝, + 반복 [^]: 부정(not)을 의미한다. 예를 들어 [^a-z]는 알파벳 소문자로 시작하지 않는 모든 문자를 의미한다. [] 바깥의 ^는 문자열의 처음을 의미한다. 123const targetStr = '12345';const regexr = /^\\d+$/;console.log(regexr.test(targetStr)); // true 하나 이상의 공백으로 시작하는지 검사한다. 1개 이상의 공백으로 시작하는지 검사 \\s : 여러 가지 공백 문자 (스페이스, 탭 등) =&gt; [\\t\\r\\n\\v\\f] 123const targetStr = ' Hi!';const regexr = /^[\\s]+/;console.log(regexr.test(targetStr)); // true 아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리) 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사 {4,10}: 4 ~ 10자리 123const id = 'abc123';const regexr = /^[A-Za-z0-9]&#123;4,10&#125;$/;console.log(regexr.test(id)); // true 메일 주소 형식에 맞는지 검사한다. 12345const email = 'ungmo2@gmail.com';const regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]&#123;2,3&#125;$/;console.log(regexr.test(email)); // true 핸드폰 번호 형식에 맞는지 검사한다. 12345const cellphone = '010-1234-5678';const regexr = /^\\d&#123;3&#125;-\\d&#123;3,4&#125;-\\d&#123;4&#125;$/;console.log(regexr.test(cellphone)); // true 특수 문자 포함 여부를 검사한다. 1234567891011121314const targetStr = 'abc#123';// A-Za-z0-9 이외의 문자가 있는지 검사let regexr = /[^A-Za-z0-9]/gi;console.log(regexr.test(targetStr)); // true// 아래 방식도 동작한다. 이 방식의 장점은 특수 문자를 선택적으로 검사할 수 있다.regexr = /[\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"]/gi;console.log(regexr.test(targetStr)); // true// 특수 문자 제거console.log(targetStr.replace(regexr, '')); // abc123","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 23강(클로저)","slug":"javascript-preview-23","date":"2019-10-24T01:47:29.000Z","updated":"2019-11-30T17:05:59.881Z","comments":true,"path":"2019/10/24/javascript-preview-23/","link":"","permalink":"https://hyeok999.github.io/2019/10/24/javascript-preview-23/","excerpt":"","text":"JavaScript 23강 예습 23강 : 클로저 렉시컬 스코프 함수 객체의 내부 슬롯 [[Environment]] 함수 코드 평가 순서 클로저와 렉시컬 환경 클로저의 활용 함수형 프로그래밍에서의 클로저 자주 발생하는 실수 23강클로저 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(Functional Programming language: 하스켈(Haskell), 리스프(Lisp), 얼랭(Erlnag), 스칼라(Scala) …)에서 사용되는 중요한 특성이다. ECMAScript 사양에서의 클로저 정의 ▿ 클로저는 함수와 그 함수가 선언된 렉시컬 환경(Lexical environment)과의 조합이다. ###렉시컬 스코프 자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다. 스코프의 실체는 실행 컨텍스트의 렉시컬 환경(Lexical environment)이다. 이 렉시컬 환경은 자신의 “외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)”를 통해 상위 렉시컬 환경과 연결된다. ( = 스코프체인) “함수의 상위 스코프를 결정한다” = “렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다” 함수 객체의 내부 슬롯 [[Environment]]함수가 정의된 환경과 호출되는 환경은 다를 수 있다. 즉, 렉시컬 스코프가 가능하려면 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경, 렉시컬 스코프를 기억해야한다. 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 렉시컬 스코프의 참조를 저장한다. 함수 정의가 평가되어 객체를 생성. 생성된 객체는 자신이 정의된 환경(위치)에 의해 결정된 상위 스코프의 참조를 자신의 내부 슬롯[[Environment]]에 저장. 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킴. *함수 객체의 내부 슬롯 [[Environment]]에 저장한 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다. * *또한 자신이 호출되었을 때 생성될 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이다. * 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다. 1234567891011121314151617const x = 1;function foo() &#123; const x = 10; // 상위 스코프는 함수 정의 환경(위치)에 따라 결정된다. // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다. bar();&#125;// 함수 bar는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 기억한다.function bar() &#123; console.log(x);&#125;foo(); // 1bar(); // 1 함수 코드 평가 순서123451. 함수 실행 컨텍스트 생성2. 함수 렉시컬 환경 생성 2.1. 함수 환경 레코드 생성 2.2. 외부 렉시컬 환경에 대한 참조 할당 2.3. this 바인딩 클로저와 렉시컬 환경 자신을 포함하고 있는 외부 함수(outer)보다 중첩 함수(inner)가 더 오래 유지되는 경우, 외부 함수(outer) 밖에서 중첩 함수(inner)를 호출하더라도 외부 함수(outer)의 지역 변수(outer의 x)에 접근할 수 있는데 이러한 함수를 클로저(closure)라고 부른다. (예제 기준 ▿) 12345678910111213const x = 1;// ①function outer() &#123; const x = 10; const inner = function () &#123; console.log(x); &#125;; // ② return inner;&#125;// 함수 outer를 호출하면 중첩 함수 inner를 반환한다.// 그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다.const innerFunc = outer(); // ③innerFunc(); // ④ 10 예제로 돌아가 보자. 위 예제에서 outer 함수가 평가되어 함수 객체를 생성할 때(①) 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 전역 렉시컬 환경을 outer 함수 객체의 [[Environment]] 내부 슬롯에 상위 스코프로서 저장한다. 전역 함수 객체의 상위 스코프 결정 outer 함수를 호출하면 outer 함수의 렉시컬 환경이 생성되고 앞서 outer 함수 객체의 [[Environment]] 내부 슬롯에 저장된 전역 렉시컬 환경을 outer 함수 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 할당한다. 그리고 중첩 함수 inner가 평가된다.(② inner 함수는 함수 표현식으로 정의하였기 때문에 런타임에 평가된다.) 이때 중첩 함수 inner은 자신의 [[Environment]] 내부 슬롯에 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 outer 함수의 렉시컬 환경을 상위 스코프로서 저장한다. 중첩 함수 객체의 상위 스코프 결정 outer 함수의 실행이 종료하면 inner 함수를 반환하면서 outer 함수의 생명 주기는 종료한다.(③) 즉, outer 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거된다. 이때 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다. outer 함수의 렉시컬 환경은 inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있으므로 가비지 켈렉션의 대상이 되지 않기 때문이다. 실행 컨텍스트가 제거되어도 렉시컬 환경은 유지된다. outer 함수가 반환한 inner 함수를 호출(④)하면 inner 함수의 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 push된다. 그리고 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에는 inner 함수 객체의 [[Environment]] 내부 슬롯에 저장되어 있는 참조값이 할당된다. 외부 함수가 소멸하여도 반환된 중첩 함수는 외부 함수의 변수를 참조할 수 있다. 중첩 함수 inner는 외부 함수 outer보다 더 오래 생존하였다. 이때 함수는 외부 함수의 생존 여부(실행 컨텍스트의 생존 여부)와 상관없이 자신이 정의된 위치에 의해 결정된 상위 스코프를 기억한다. 이처럼 중첩 함수 inner의 내부에서는 상위 스코프를 참조할 수 있으므로 상위 스코프의 식별자를 참조할 수 있고 식별자의 값을 변경할 수도 있다. 이론적으로 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 모든 함수는 클로저이다. 하지만 일반적으로 모든 함수를 클로저라고 하지는 않는다. ​ 클로저에 의해 참조되는 상위 스코프의 변수(위 예제의 경우, foo 함수의 변수 x)를 자유 변수(Free variable)라고 부른다. 클로저(closure)란 “함수가 자유 변수에 대해 닫혀있다(closed)”라는 의미이다. 이를 좀 더 알기 쉽게 의역하자면 “자유 변수와 묶여있는 함수”라고 할 수 있다. 클로저의 활용 클로저는 상태를 안전하게 유지하기 위해 사용한다. [은닉(Information hiding)] 이전 상태를 기억하다가 상태가 변경되면 최신 상태(state)를 유지 다음의 코드들의 문제를 살펴보면서 왜 클로저를 사용해야하는지 깨달아보자. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;script&gt; // 카운트 상태를 유지하기 위한 전역 변수 let num = 0; const $counter = document.querySelector('.counter'); const increase = function () &#123; $counter.textContent = ++num; // 상태 변화 &#125;; document.querySelector('.increase').onclick = increase; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ▵ 위 코드의 문제점 : 전역 변수 num의 값, 즉 카운트 상태는 반드시 이벤트 핸들러 increase만이 변경할 수 있어야 한다. 허나, num은 누구나 접근이 가능하고 변경이 가능하다. 따라서 의도치 않게 변경이 가능하다. 따라서 num을 increase안으로 넘는다면 num은 누구도 건들 수 없게된다. ▽ num을 넣은 후 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const increase = function () &#123; // 카운트 상태를 유지하기 위한 지역 변수 let num = 0; $counter.textContent = ++num; // 상태 변경 &#125;; document.querySelector('.increase').onclick = increase; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ▵ 위 코드의 문제점 : 위 코드에서 num은 오직 increase만 사용할 수 있게 되었다. 허나 increase가 호출 되면 num은 매번 0으로 초기화된다. 즉 num은 1을 넘을 수 없다. 따라서 increase함수를 즉시 실행함수로 변경시키고 상태 변경 문만 반환하면 어떻게 될까? 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const increase = (function () &#123; // 카운트 상태를 유지하기 위한 자유 변수 let num = 0; return function () &#123; $counter.textContent = ++num; // 상태 변경 &#125;; &#125;()); document.querySelector('.increase').onclick = increase; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ▵ 위 코드는 정답 : 따라서 이 코드는 정답이 된다. 즉시 실행 함수로 설정을 해두었기에 누구도 num을 건드릴수 없다. 렉시컬환경상 오직 increase함수 내부에서 외부함수만으로 num값을 조작할 수 있게 되었다. decrease함수도 만들어서 count를 구성한다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const counter = (function () &#123; // 카운트 상태를 유지하기 위한 자유 변수 let num = 0; // 클로저를 메소드로 갖는 객체를 반환한다. // 객체 리터럴은 스코프를 만들지 않는다. // 따라서 아래 메소드들의 상위 스코프는 즉시 실행 함수의 스코프이다. return &#123; // num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다. increase() &#123; $counter.textContent = ++num; // 상태 변경 &#125;, decrease() &#123; if (num &lt;= 0) return; //num이 0보다 작으면 그냥 리턴 $counter.textContent = --num; // 상태 변경 &#125; &#125;; &#125;()); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제에서 즉시 실행 함수가 반환하는 객체 리터럴은 함수 실행 단계에서 평가되어 객체가 된다. 이때 객체의 메소드인 함수도 함수 객체로 생성된다. 객체 리터럴의 중괄호는 코드 블록이 아니므로 별도의 스코프를 생성하지 않는다. ▵ 위 코드의 문제점 : 위 코드에서 클로저를 통하여 num을 보호하기에 충분하다. 하지만 반환되는 메소드가 정해져있기 때문에 만약 생성자를 수백개 만든다고 모든 생성자 내부에는 increase decrease메소드가 담기게 될 것이다. 따라서 이와같은 현상을 방지 하기 위해서 prototype을 이용하도록 한다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const Counter = (function () &#123; // ① 카운트 상태를 유지하기 위한 자유 변수 let num = 0; function Counter() &#123; // this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다. &#125; Counter.prototype.increase = function () &#123; $counter.textContent = ++num; &#125;; Counter.prototype.decrease = function () &#123; if (num &lt;= 0) return; $counter.textContent = --num; &#125;; return Counter; &#125;()); const counter = new Counter(); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제의 num(①)은 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티가 아니라 즉시 실행 함수 내에서 선언된 변수다. 만약 num이 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티라면(②) 인스턴스를 통해 외부에서 접근이 가능한 public 프로퍼티가 된다. 하지만 즉시 실행 함수 내에서 선언된 변수 num은 인스턴스를 통해 접근할 수 없으며 즉시 실행 함수 외부에서도 접근할 수 없는 은닉된 변수이다. 생성자 함수 Counter는 increase, decrease 메소드를 프로토타입을 통해 상속받는 인스턴스를 생성한다. 이 메소드들은 모두 자신의 함수 정의가 평가되어 함수 객체가 될 때, 실행 중인 실행 컨텍스트, 즉 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경을 기억하는 클로저이다. 따라서 프로토타입을 통해 상속되는 프로토타입 메소드일지라도 즉시 실행 함수의 자유 변수 num을 참조할 수 있다. 다시 말해, 변수 num의 값은 increase, decrease 메소드만이 변경할 수 있다. 이러한 클로저의 특징을 사용해 클래스 기반 언어의 private 키워드를 흉내낼 수 있다. 변수 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 함수형 프로그래밍에서 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다. 함수형 프로그래밍에서의 클로저12345678910111213141516171819202122232425262728293031323334// 함수를 인자로 전달받고 함수를 반환하는 고차 함수// 이 함수가 반환하는 함수는 클로저로서 카운트 상태를 유지하기 위한 자유 변수 counter을 기억한다.function makeCounter(predicate) &#123; // 카운트 상태를 유지하기 위한 자유 변수 let counter = 0; // 클로저를 반환 return function () &#123; // 인자로 전달 받은 보조 함수에 상태 변경을 위임한다. counter = predicate(counter); return counter; &#125;;&#125;// 보조 함수function increase(n) &#123; return ++n;&#125;// 보조 함수function decrease(n) &#123; return --n;&#125;// 함수로 함수를 생성한다.// makeCounter 함수는 보조 함수를 인자로 전달받아 함수를 반환한다const increaser = makeCounter(increase); // ①console.log(increaser()); // 1console.log(increaser()); // 2// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.const decreaser = makeCounter(decrease); // ②console.log(decreaser()); // -1console.log(decreaser()); // -2 ▵ 위 코드의 문제점 : 함수 makeCounter를 호출해 함수를 반환할 때 반환된 함수는 자신만의 독립된 렉시컬 환경을 갖는다. 위 예제에서는 총 2번의 makeCounter를 호출 했으므로 반환된 함수가 2개이고 또한 각 독립된 렉시컬 환경을 갖게된다. 즉, 변수 increaser와 변수 decreaser에 할당된 함수는 각각 자신만의 독립된 렉시컬 환경을 갖기 때문에 카운트를 유지하기 위한 자유 변수 counter를 공유하지 않아 카운터의 증감이 연동하지 않는다. 따라서 독립된 카운터가 아니라 연동하여 증감이 가능한 카운터를 만들려면 렉시컬 환경을 공유하는 클로저를 만들어야 한다. 이를 위해서는 makeCounter 함수를 두번 호출하지 말아야 한다. 1234567891011121314151617181920212223242526272829303132333435// 함수를 반환하는 고차 함수// 이 함수가 반환하는 함수는 클로저로서 카운트 상태를 유지하기 위한 자유 변수 counter을 기억한다.function makeCounter() &#123; // 카운트 상태를 유지하기 위한 자유 변수 let counter = 0; // 클로저를 반환 return function (predicate) &#123; // 인자로 전달 받은 보조 함수에 상태 변경을 위임한다. counter = predicate(counter); return counter; &#125;;&#125;// 보조 함수function increase(n) &#123; return ++n;&#125;// 보조 함수function decrease(n) &#123; return --n;&#125;// 함수로 함수를 생성한다.// makeCounter 함수는 보조 함수를 인자로 전달받아 함수를 반환한다const counter = makeCounter(); // ①// 보조 함수를 전달하여 호출console.log(counter(increase)); // 1console.log(counter(increase)); // 2// 자유 변수를 공유한다.console.log(counter(decrease)); // 1console.log(counter(decrease)); // 0 자주 발생하는 실수1234567891011var arr = [];for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; // ① return i; &#125;;&#125;for (var j = 0; j &lt; arr.length; j++) &#123; console.log(arr[j]()); // ②&#125; ▵ 위 코드의 문제점 : ②에서 결과가 0, 1, 2, 3, 4를 출력할 거 라고 생각했다면 완전히 틀렸다. 정답은 5만 5번출력한다. 이유는 ①에서 코드가 멈춘것이나 다름이없다. ②에서 arr을 호출 했을 떄, return으로 순회를 다 돌고 5가 되버린 i를 리턴하는 것이다. 따라서 다음과 같이 즉시 실행 함수를 감싸서 사용한다. 12345678910111213var arr = [];for (var i = 0; i &lt; 5; i++) &#123; arr[i] = (function (id) &#123; // ① return function()&#123; return id; &#125;; &#125;(i));&#125;for (var j = 0; j &lt; arr.length; j++) &#123; console.log(arr[j]()); // ②&#125; ①에서 즉시 실행 함수는 전역 변수 i에 현재 할당되어 있는 값을 인수로 전달받아 매개 변수 id에 할당한 후 중첩 함수를 반환하고 종료된다. 즉시 실행 함수가 반환한 함수는 배열 funcs에 순차적으로 저장된다. 이때 즉시 실행 함수의 매개 변수 id는 즉시 실행 함수가 반환한 함수의 상위 스코프에 존재하며 즉시 실행 함수가 반환한 함수에 의해 참조되므로 자유 변수가 되어 즉시 실행 함수가 반환한 함수에 의해 그 값이 유지된다. 위 예제는 var키워들 사용했기에 일어나는 번거로움이다. 따라서 ES6의 let키워드를 사용하면 이러한 문제를 해결할 수있다. 123456789const arr = [];for (let i = 0; i &lt; 3; i++) &#123; arr[i] = () =&gt; i;&#125;for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]()); // 0 1 2&#125; 초기화 문에서 let 키워드로 선언한 변수를 사용하면 for 문이 반복될 때마다 for 문 코드 블록의 새로운 렉시컬 환경이 생성된다. 만약 for 문 내에서 정의된 함수가 있다면 이 함수의 상위 스코프는 for 문이 반복될 때마다 생성된 for 문 코드 블록의 새로운 렉시컬 환경이다. 함수의 상위 스코프는 for 문이 반복될 때 마다 식별자(초기화 변수 및 for 문 내 지역 변수 등)의 값을 유지해야 한다. 이를 위해 for 문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다. ① 초기화 문에 let 키워드로 선언한 변수를 사용한 for 문이 평가되면 먼저 새로운 렉시컬 환경(LOOP Lexical Environment)을 생성하고 초기화 문의 식별자와 값을 등록한다. 그리고 새롭게 생성된 렉시컬 환경을 현재 실행 중인 실행 컨텍스트의 렉시컬 환경으로 교체한다. ②, ③, ④ for 문의 반복이 시작되면 새로운 렉시컬 환경(PER-ITERATION Lexical Environment)을 생성하고 반복 시의 for 문 코드 블록 내의 식별자와 값(증감문 반영 이전)을 등록한다. 그리고 새롭게 생성된 렉시컬 환경을 현재 실행 중인 실행 컨텍스트의 렉시컬 환경으로 교체한다. ⑤ for 문의 반복이 모두 종료되면 for 문이 실행되기 이전의 렉시컬 환경을 실행 중인 실행 컨텍스트의 렉시컬 환경으로 되돌린다. 이처럼 var 키워드로 사용하지 않은 ES6의 반복문(for…in 문, for…of 문, while 문 등)은 반복할 때마다 새로운 렉시컬을 생성하여 반복할 당시의 상태를 마치 스냅샷을 찍는 것처럼 저장한다. 단, 이는 반복문 내부에서 함수 정의가 존재할 때 의미가 있다. 반복문 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다. 함수형 프로그래밍 기법인 고차 함수를 사용하는 방법 12345const arr = new Array(5).fill();arr.forEach((v, i, self) =&gt; self[i] = () =&gt; i);arr.forEach(f =&gt; console.log(f()));","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Closer","slug":"Closer","permalink":"https://hyeok999.github.io/tags/Closer/"}]},{"title":"Math 객체 및 메소드","slug":"math-method","date":"2019-10-23T07:00:25.000Z","updated":"2019-11-30T16:27:24.282Z","comments":true,"path":"2019/10/23/math-method/","link":"","permalink":"https://hyeok999.github.io/2019/10/23/math-method/","excerpt":"","text":"JavaScript Math 객체 Math Property Math.PI Math Method Math.abs Math.round Math.ceil Math.floor Math.sqrt Math.random Math.pow Math.max Math.min Math 객체 Math 객체는 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다. Math 객체는 생성자 함수가 아니다. Math 객체는 정적(static) 프로퍼티와 메소드만을 제공한다. Math PropertyMath.PI PI 값(π ≈ 3.141592653589793)을 반환한다. 1Math.PI; // 3.141592653589793 Math MethodMath.abs 인수의 절댓값(absolute value)을 반환한다. 절댓값은 반드시 0 또는 양수이어야 한다. 123456789Math.abs(-1); // 1Math.abs('-1'); // 1Math.abs(''); // 0Math.abs([]); // 0Math.abs(null); // 0Math.abs(undefined);// NaNMath.abs(&#123;&#125;); // NaNMath.abs('string'); // NaNMath.abs(); // NaN Math.round(x: number) 반올림 인수의 소수점 이하를 반올림한 정수를 반환한다. 123456Math.round(1.4); // 1Math.round(1.6); // 2Math.round(-1.4); // -1Math.round(-1.6); // -2Math.round(1); // 1Math.round(); // NaN Math.ceil(x: number) 올림 인수의 소수점 이하를 올림한 정수를 반환한다. 123456Math.ceil(1.4); // 2Math.ceil(1.6); // 2Math.ceil(-1.4); // -1Math.ceil(-1.6); // -1Math.ceil(1); // 1Math.ceil(); // NaN Math.floor(x: number) 내림 인수의 소수점 이하를 내림한 정수를 반환한다. Math.ceil의 반대 개념이다. 양수인 경우, 소수점 이하를 떼어 버린 다음 정수를 반환한다. 음수인 경우, 소수점 이하를 떼어 버린 다음 -1을 한 정수를 반환한다. 123456Math.floor(1.9); // 1Math.floor(9.1); // 9Math.floor(-1.9); // -2Math.floor(-9.1); // -10Math.floor(1); // 1Math.floor(); // NaN Math.sqrt(x: number): number 인수의 제곱근을 반환한다. 123456Math.sqrt(9); // 3Math.sqrt(-9); // NaNMath.sqrt(2); // 1.414213562373095Math.sqrt(1); // 1Math.sqrt(0); // 0Math.sqrt(); // NaN Math.random(): number ES1 임의의 부동 소수점을 반환한다. 반환된 부동 소수점은 0부터 1 미만이다. 즉, 0은 포함되지만 1은 포함되지 않는다. 12345678Math.random(); // 0 ~ 1 미만의 부동 소수점 (0.8208720231391746)// 1 ~ 10의 랜덤 정수 취득// 1) Math.random로 0 ~ 1 미만의 부동 소수점을 구한 다음, 10을 곱해 0 ~ 10 미만의 부동 소수점을 구한다.// 2) 0 ~ 10 미만의 부동 소수점에 1을 더해 1 ~ 10까지의 부동 소수점을 구한다.// 3) Math.floor으로 1 ~ 10까지의 부동 소수점의 소수점 이하를 떼어 버린 다음 정수를 반환한다.const random = Math.floor((Math.random() * 10) + 1);console.log(random); // 1 ~ 10까지의 정수 Math.pow(x: number, y: number): number 첫번째 인수를 밑(base), 두번째 인수를 지수(exponent)로하여 거듭제곱을 반환한다. 123456Math.pow(2, 8); // 256Math.pow(2, -1); // 0.5Math.pow(2); // NaN// ES7(ECMAScript 2016) Exponentiation operator(거듭 제곱 연산자)2 ** 8; // 256 Math.max(…values: number[]): number 인수 중에서 가장 큰 수를 반환한다. 인수를 가변인자로 받을 수 있다. 12345678Math.max(1, 2, 3); // 3// 배열 요소 중에서 최대값 취득const arr = [1, 2, 3];const max = Math.max.apply(null, arr); // 3// ES6 Spread operatorMath.max(...arr); // 3 Math.min(…values: number[]): number 인수 중에서 가장 작은 수를 반환한다. 12345678Math.min(1, 2, 3); // 1// 배열 요소 중에서 최소값 취득const arr = [1, 2, 3];const min = Math.min.apply(null, arr); // 1// ES6 Spread operatorMath.min(...arr); // 1","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Object","slug":"Object","permalink":"https://hyeok999.github.io/tags/Object/"},{"name":"Method","slug":"Method","permalink":"https://hyeok999.github.io/tags/Method/"},{"name":"Math","slug":"Math","permalink":"https://hyeok999.github.io/tags/Math/"}]},{"title":"고차함수 연습하기 05-08","slug":"HOF-05-08","date":"2019-10-23T05:12:01.000Z","updated":"2019-11-30T16:45:33.038Z","comments":true,"path":"2019/10/23/HOF-05-08/","link":"","permalink":"https://hyeok999.github.io/2019/10/23/HOF-05-08/","excerpt":"","text":"문제 출처 : Poiema - HOF 특정 요소 삭제todos에서 삭제할 요소의 id를 인수로 전달하면 해당 요소를 삭제하는 함수를 작성하라. 1234567891011121314151617181920// 5. 특정 요소 삭제let todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function removeTodo(id) &#123; todos = todos.filter((todo) =&gt; (todo.id == id));&#125;removeTodo(2);console.log(todos);/*[ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;]*/ 특정 요소의 프로퍼티 값 반전todos에서 대상 요소의 id를 인수로 전달하면 해당 요소의 completed 프로퍼티 값을 반전하는 함수를 작성하라. 단, Object.assign를 사용하도록 한다. 1234567891011121314151617181920212223242526// 6. 특정 요소의 프로퍼티 값 반전const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function toggleCompletedById(id) &#123; const result = todos.map((todo) =&gt; &#123; if (todo.id == id) todo.completed = !todo.completed; return todo; &#125;); Object.assign(todos, result);&#125;toggleCompletedById(2);console.log(todos);/*[ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: false &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;]*/ 모든 요소의 completed 프로퍼티 값을 true로 설정todos의 모든 요소의 completed 프로퍼티 값을 true로 설정하는 함수를 작성하라. 단, Object.assign를 사용하도록 한다. 123456789101112131415161718192021222324// 7. 모든 요소의 completed 프로퍼티 값을 true로 설정let todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function toggleCompletedAll() &#123; todos = todos.map((todo) =&gt; &#123; if (!todo.completed) todo.completed = !todo.completed; return todo; &#125;);&#125;toggleCompletedAll();console.log(todos);/*[ &#123; id: 3, content: 'HTML', completed: true &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: true &#125;]*/ completed 프로퍼티의 값이 true인 요소의 갯수 구하기todos에서 완료(completed: true)한 할일의 갯수를 구하는 함수를 작성하라. 단, for 문, Array#forEach는 사용하지 않도록 하자. 123456789101112131415// 8. completed 프로퍼티의 값이 true인 요소의 갯수 구하기const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function countCompletedTodos() &#123; return todos.reduce((pre, todo) =&gt; &#123; if (todo.completed === true) pre++; return pre; &#125;, 0);&#125;console.log(countCompletedTodos()); // 1","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"HOF","slug":"HOF","permalink":"https://hyeok999.github.io/tags/HOF/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"고차함수 연습하기 01-04","slug":"HOF-01-04","date":"2019-10-23T05:10:05.000Z","updated":"2019-11-30T16:45:40.566Z","comments":true,"path":"2019/10/23/HOF-01-04/","link":"","permalink":"https://hyeok999.github.io/2019/10/23/HOF-01-04/","excerpt":"","text":"문제 출처 : Poiema - HOF html 생성아래 배열을 사용하여 html을 생성하는 함수를 작성하라. 123456789101112131415161718192021222324252627282930313233// #1번 - html 생성const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function render() &#123; let html = ''; todos.forEach((todo) =&gt; &#123; html += (` &lt;li id=\"$&#123;todo.id&#125;\"&gt; &lt;label&gt;&lt;input type=\"checkbox\"$&#123;todo.completed ? ' checked=\"true\"' : ''&#125;&gt;$&#123;todo.content&#125;&lt;/label&gt; &lt;/li&gt; `); &#125;); return html;&#125;console.log(render());/*&lt;li id=\"3\"&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;HTML&lt;/label&gt;&lt;/li&gt;&lt;li id=\"2\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" checked&gt;CSS&lt;/label&gt;&lt;/li&gt;&lt;li id=\"1\"&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;Javascript&lt;/label&gt;&lt;/li&gt;*/ 특정 프로퍼티 값 추출요소의 프로퍼티(id, content, completed)를 문자열 인수로 전달하면 todos의 각 요소 중, 해당 프로퍼티의 값만을 추출한 배열을 반환하는 함수를 작성하라. 단, for 문이나 Array#forEach는 사용하지 않도록 하자. 12345678910111213141516// #2번 - 특정 프로퍼티 값 추출const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function getValues(key) &#123; const arr = todos.map((todo) =&gt; todo[key]); return arr;&#125;console.log(getValues('id')); // [3, 2, 1]console.log(getValues('content')); // [ 'HTML', 'CSS', 'Javascript' ]console.log(getValues('completed')); // [ false, true, false ] 프로퍼티 정렬요소의 프로퍼티(id, content, completed)를 문자열 인수로 전달하면 todos의 요소를 정렬하는 함수를 작성하라. 단, todos는 변경되지 않도록 하자. 1234567891011121314151617181920212223242526272829303132333435363738// 3. 프로퍼티 정렬const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];function sortBy(key) &#123; return todos.slice(0, todos.length).sort( (a, b) =&gt; (a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0)) );&#125;console.log(sortBy('id'));/*[ &#123; id: 1, content: 'Javascript', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'HTML', completed: false &#125;]*/console.log(sortBy('content'));/*[ &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;]*/console.log(sortBy('completed'));/*[ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;]*/ 새로운 요소 추가새로운 요소(예를 들어 { id: 4, content: &#39;Test&#39;, completed: false })를 인수로 전달하면 todos의 선두에 새로운 요소를 추가하는 함수를 작성하라. 단, Array#push는 사용하지 않도록 하자. 1234567891011121314151617181920212223242526// 4. 새로운 요소 추가const todos = [ &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;];// function addTodo(newTodo) &#123;// todos = [newTodo].concat(todos);// &#125;function addTodo(newTodo) &#123; todos.unshift(newTodo);&#125;addTodo(&#123; id: 4, content: 'Test', completed: false &#125;);console.log(todos);/*[ &#123; id: 4, content: 'Test', completed: false &#125;, &#123; id: 3, content: 'HTML', completed: false &#125;, &#123; id: 2, content: 'CSS', completed: true &#125;, &#123; id: 1, content: 'Javascript', completed: false &#125;]*/","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"HOF","slug":"HOF","permalink":"https://hyeok999.github.io/tags/HOF/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"daily_algorithm21","slug":"daily-algorithm21","date":"2019-10-23T05:08:15.000Z","updated":"2019-11-30T16:47:08.412Z","comments":true,"path":"2019/10/23/daily-algorithm21/","link":"","permalink":"https://hyeok999.github.io/2019/10/23/daily-algorithm21/","excerpt":"","text":"문제 출처 : 프로그래머스 124 나라의 숫자문제 설명124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 n은 500,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 123456789101112131415161718192021function solution(n) &#123; const answer = ''; let temp; while(n &gt; 0) &#123; temp = n % 3; n = Math.floor(n / 3); if(temp === 0) &#123; answer += 4; n--; &#125; else &#123; answer += temp; &#125; &#125; answer = answer.split('').reverse().join(''); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-13","slug":"javascript-study-13","date":"2019-10-22T12:14:50.000Z","updated":"2019-11-30T16:28:24.200Z","comments":true,"path":"2019/10/22/javascript-study-13/","link":"","permalink":"https://hyeok999.github.io/2019/10/22/javascript-study-13/","excerpt":"","text":"JavaScript Study 13 용어 고차함수 실행 컨텍스트 실행 가능한 코드의 평가와 실행 실행 컨텍스트의 역할 실행 컨텍스트 스택 동기식 처리 모델과 비동기식 처리 모델 렉시컬 환경 전역 코드 평가 함수 코드 평가 예제 전체 구상도 용어 - ( 러버덕 ) 고차함수 실행 컨텍스트 실행 컨텍스트 이해 코드 평가 코드 실행 렉시컬 환경 동기식 vs 비동기식 실행 컨텍스트 스택 고차함수 고차함수 실행 컨텍스트 (Execution Context) 실행 컨텍스트는 식별자, 스코프, 호이스팅, 클로저 등의 동작 원리를 담고 있는 자바스크립트의 핵심 개념이다. 실행 컨텍스트를 바르게 이해하면 자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩된 값을 관리하는 방식,호이스팅이 발생하는 이유, 그리고 클로저의 동작 방식에 대해 이해할 수 있다. 실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. ECMAScript 사양은 실행 가능한 코드(Executable Code)를 4가지 유형으로 구분한다. 실행 가능한 코드 설명 전역 코드(Global code) 전역에 존재하는 텍스트 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. 함수 코드(Function code) 함수 내부에 존재하는 텍스트 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. eval 코드(Eval code) 빌트인 전역 함수인 eval 함수에 인수로 전달된 텍스트 코드를 말한다. 모듈 코드(Module code) 모듈 내부에 존재하는 텍스트 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. 실행 가능한 코드를 4가지 유형으로 구분하는 이유는 각 유형마다 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다. 전역 코드: 전역 코드는 전역 스코프를 생성해야 하며 전역 객체와 연결되어야 한다. 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다. 함수 코드: 함수 코드는 지역 스코프를 생성해야 하며 생성된 지역 스코프는 스코프 체인의 최상위인 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결되어야 한다. 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다. eval 코드: eval 코드는 엄격 모드(strict mode)에서 자신만의 독자적인 스코프를 생성한다. 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다. 모듈 코드: 모듈 코드는 모듈 별로 독립적인 스코프를 생성한다. 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다. 이 중 제일 중요한 전역코드 , 함수코드만 학습한다. 실행 가능한 코드의 평가와 실행 모든 실행 가능한 코드는 실행에 앞서 평가 과정을 거치면서 코드 실행을 위한 준비를 한다. 코드의 평가 과정에서 실행 컨텍스트가 생성되고 변수, 함수, 클래스 등의 선언문이 평가되어 그 결과(=식별자)가 생성된 실행 컨텍스트에 등록된다. 코드의 평가 과정이 끝나면 비로소 선언문을 제외한 코드가 순차적으로 실행된다. 코드 실행에 필요한 정보를 실행 컨텍스트에서 취득한다. 그리고 코드의 실행 결과는 실행 컨텍스트에서 관리된다. 실행 컨텍스트의 역할아래 예제는 전역 코드와 함수 코드로 구성되어 있다. 자바스크립트 엔진이 아래 예제를 어떻게 실행할지 생각해보자. 12345678910111213141516171819// 전역 변수 선언const x = 1;const y = 2;// 함수 정의function foo(a) &#123; // 지역 변수 선언 const x = 10; const y = 20; // 메소드 호출 console.log(a + x + y); // 130&#125;// 함수 호출foo(100);// 메소드 호출console.log(x + y); // 3 1. 전역 코드 평가 한 줄씩 실행되기에 앞서 먼저 전역 코드가 평가된다.이때 전역의 변수 선언문과 함수 선언문이 평가되고 전역 변수와 전역 함수는 전역 스코프에 등록된다.var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티가 된다. 2. 전역 코드 실행 전역 코드 평가가 종료하면 순차적으로 전역 코드가 실행되어 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다. 3. 함수 코드 평가 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 먼저 함수 코드가 평가된다.이때 매개 변수와 지역 변수 선언문이 평가되고 그 결과, 매개 변수와 지역 변수는 지역 스코프에 등록된다.또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체도 생성되어 지역 스코프에 등록된다. 4. 함수 코드 실행 함수 코드 평가가 종료하면 순차적으로 함수 코드가 실행되어 매개 변수와 지역 변수에 값이 할당되고 console.log 메소드가 호출된다. console.log 메소드를 호출하기 위해 먼저 식별자 console을 스코프 체인을 통해 검색한다. 따라서 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다. 하지만 식별자 console은 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재한다. 이는 전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프에서 검색 가능하여야 한다는 것을 의미한다. 다음은 log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색한다. 그후 console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가된다. 각각의 식별자 a, x, y는 스코프 체인을 통해 검색한다. console.log 메소드의 실행이 종료되면 foo 함수 코드의 실행이 종료되고 foo 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다. 이처럼 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값을 관리할 수 있어야 한다. 그리고 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다. 또한 함수 호출이 종료하면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다. 이처럼 코드가 평가되고 실행되려면 아래와 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다. 현재 실행 중인 코드의 실행 순서를 변경(예를 들어 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다. 이 모든 것을 관리하는 것이 바로 실행 컨텍스트이다. 실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 다시 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다. 실행 컨텍스트 스택 실행 컨텍스트 스택(Execution context stack)를 스택자료(LIFO) 형태로 저장한다. 실행 컨텍스트 스택을 콜 스택(Call stack)이라고 부르기도 한다. 12345678910111213const x = 1;function foo () &#123; const y = 2; function bar () &#123; const z = 3; console.log(x + y + z); &#125; bar();&#125;foo(); // 6 동기식 처리 모델과 비동기식 처리 모델자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 이는 자바스크립트가 싱글 스레드(single thread)로 동작한다는 것을 의미한다. 실행 컨텍스트 스택의 최상위 스택(실행 중인 실행 컨텍스트)을 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들이다. 이들은 현재 실행 중인 실행 컨텍스트가 팝되어 실행 컨텍스트 스택에서 제거될 때까지 실행을 대기한다. 이처럼 하나의 처리가 종료되어야 다음 처리를 실행할 수 있는 것을 동기식 처리 모델(Synchronous processing model)이라고 한다. 동기식 처리 모델은 직렬적으로 태스크(task)를 수행한다. 즉, 태스크는 순차적으로 실행되며 어떤 작업이 수행 중이면 다음 작업은 대기하게 된다. 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때, 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 태스크들은 블로킹(blocking, 작업 중단)된다. 자바스크립트는 비동기식 처리 모델을 지원한다. 비동기식 처리 모델(Asynchronous processing model 또는 Non-Blocking processing model)은 병렬적으로 태스크를 수행한다. 즉, 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다. (동시성 부여) 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 태스크를 수행할 때, 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 태스크를 수행한다. 이후 서버로부터 데이터가 응답되면 이벤트가 발생하고 이벤트 핸들러가 응답된 데이터를 가지고 수행할 태스크를 계속해 수행한다. 자바스크립트의 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다. 비동기식 처리 모델은 자바스크립트에 동시성(concurrency)을 부여하여 싱글 스레드의 약점을 보완해 준다. 하지만 비동기식으로 동작하는 코드는 순차적으로 실행되지 않아 가독성이 좋지 않고 콜백 헬을 유발하며 에러 처리가 어렵다는 약점이 있다. 이에 대한 대책으로 ‘프로미스’ 가 나왔다.프로미스는 성공여부와 실패여부를 나누어 반환하고자하는것을 나눈다. 렉시컬 환경 렉시컬 환경(Lexical Environment)은 식별자가 선언되는 환경을 말한다. 즉, 렉시컬 스코프를 의미한다. 실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다. 실행 컨텍스트는 렉시컬 환경이라는 객체를 가지고 있다. 렉시컬 환경은 객체 형태의 스코프(전역, 함수, 블록 스코프)를 만들고 이곳에 식별자를 등록한다. 그리고 등록된 식별자에 바인딩된 값을 관리한다. 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 한다 전역 코드 평가소스 코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가한다. 전역 코드 평가는 아래 순서로 진행된다. 12345671. 전역 실행 컨텍스트 생성2. 전역 렉시컬 환경 생성 2.1. 전역 환경 레코드 생성 2.1.1. 객체 환경 레코드 생성 2.1.2. 선언적 환경 레코드 생성 2.2. 외부 렉시컬 환경에 대한 참조 할당 2.3. this 바인딩 함수 코드 평가123451. 함수 실행 컨텍스트 생성2. 함수 렉시컬 환경 생성 2.1. 함수 환경 레코드 생성 2.2. 외부 렉시컬 환경에 대한 참조 할당 2.3. this 바인딩 예제123456789101112131415var x = 1;const y = 2;function foo (a) &#123; var x = 3; const y = 4; function bar (b) &#123; const z = 5; console.log(a + b + x + y + z);&#125; bar(10);&#125;foo(20); // 42 전체 구상도","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"Number 래퍼 객체","slug":"number-object","date":"2019-10-22T02:19:39.000Z","updated":"2019-11-30T16:27:48.308Z","comments":true,"path":"2019/10/22/number-object/","link":"","permalink":"https://hyeok999.github.io/2019/10/22/number-object/","excerpt":"","text":"JavaScript Number 래퍼 객체 Number 래퍼 객체 Number Constructor Number() 생성자 함수를 통해서 만들어진 Number 객체는 객체다. Number Property Number.EPSILON Number.MAX_VALUE || Number.MIN_VALUE Number.POSITIVE_INFINITY Number.NEGATIVE_INFINITY Number.NaN Number.Method Number.isFinite(testValue: number): boolean Number.isInteger(testValue: number): boolean Number.isNaN(testValue: number): boolean Number.isSafeInteger(testValue: number): boolean Number.prototype.toExponential(fractionDigits?: number): string Number.prototype.toFixed(fractionDigits?: number): string Number.prototype.toString(radix?: number): string 정수 리터럴과 함께 메소드를 사용할 경우. 주의점 Number.prototype.valueOf(): number ES1 Number 래퍼 객체 Number 객체는 원시 타입 number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 레퍼(wrapper) 객체이다. 변수 또는 객체의 프로퍼티가 숫자를 값으로 가지고 있다면 Number 객체의 별도 생성없이 Number 객체의 프로퍼티와 메소드를 사용할 수 있다. 12var num = 1.5;console.log(num.toFixed()); // 2 위에서 원시 타입을 담고 있는 변수 num이 Number.prototype.toFixed() 메소드를 호출할 수 있는 것은 변수 num의 값이 일시적으로 wrapper객체로 변환되었기 때문이다. Number ConstructorNumber 객체는 Number() 생성자 함수를 통해 생성할 수 있다. (new는 생략할 수 있다.) 만일 인자가 숫자로 변환될 수 없다면 NaN을 반환한다. 1234567891011var x = new Number(123);var y = new Number('123');var z = new Number('str');console.log(x); // 123console.log(y); // 123console.log(z); // NaNvar o = Number('123');console.log(typeof o, o); // number 123 Number() 생성자 함수를 통해서 만들어진 Number 객체는 객체다.일반적으로 숫자를 사용할 때는 원시 타입 숫자를 사용한다. 12345678var x = 123;var y = new Number(123);console.log(x == y); // trueconsole.log(x === y); // falseconsole.log(typeof x); // numberconsole.log(typeof y); // object Number PropertyNumber.EPSILON Number.EPSILON은 JavaScript에서 표현할 수 있는 가장 작은 수이다. (ES6) Number.EPSILON은 약 2.2204460492503130808472633361816E-16 또는 2-52이다. Number.MAX_VALUE || Number.MIN_VALUE Number.MAX_VALUE는 JavaScript에서 Infinity를 제외한 표현할 수 있는 가장 큰 수 이다. Number.MAX_VALUE는 가장 큰 숫자(1.7976931348623157e+308)를 반환한다. Number.MIN_VALUE는 JavaScript에서 사용 가능한 가장 작은 숫자(5e-324)를 반환한다. MIN_VALUE는 0에 가장 가까운 양수 값이다. MIN_VALUE보다 작은 숫자는 0으로 변환된다. 12345678910111213Number.MAX_VALUE; // 1.7976931348623157e+308var num = 10;num.MAX_VALUE; // undefinedconsole.log(Infinity &gt; Number.MAX_VALUE); // true----------------------------------------------------Number.MIN_VALUE; // 5e-324var num = 10;num.MIN_VALUE; // undefinedconsole.log(Number.MIN_VALUE &gt; 0); // true Number.POSITIVE_INFINITY 양의 무한대 Infinity를 반환한다. 1234Number.POSITIVE_INFINITY // Infinityvar num = 10;num.POSITIVE_INFINITY; // undefined Number.NEGATIVE_INFINITY 음의 무한대 -Infinity를 반환한다. 1234Number.NEGATIVE_INFINITY // -Infinityvar num = 10;num.NEGATIVE_INFINITY; // undefined Number.NaN 숫자가 아님(Not-a-Number)을 나타내는 숫자값이다. Number.NaN 프로퍼티는 window.NaN 프로퍼티와 같다. 123console.log(Number('xyz')); // NaNconsole.log(1 * 'string'); // NaNconsole.log(typeof NaN); // number Number MethodNumber.isFinite(testValue: number): boolean ES6 매개변수에 전달된 값이 정상적인 유한수인지를 검사하여 그 결과를 Boolean으로 반환한다. 12345/** * @param &#123;any&#125; testValue - 검사 대상 값. 암묵적 형변환되지 않는다. * @return &#123;boolean&#125; */Number.isFinite(testValue) Number.isFinite()는 전역 함수 isFinite()와 차이가 있다. 전역 함수 isFinite()는 인수를 숫자로 변환하여 검사를 수행하지만 Number.isFinite()는 인수를 변환하지 않는다. 따라서 숫자가 아닌 인수가 주어졌을 때 반환값은 언제나 false가 된다. Number.isInteger(testValue: number): boolean ES6 매개변수에 전달된 값이 정수(Integer)인지 검사하여 그 결과를 Boolean으로 반환한다. 검사전에 인수를 숫자로 변환하지 않는다. 12345/** * @param &#123;any&#125; testValue - 검사 대상 값. 암묵적 형변환되지 않는다. * @return &#123;boolean&#125; */Number.isInteger(testValue) Number.isNaN(testValue: number): boolean ES6 매개변수에 전달된 값이 NaN인지를 검사하여 그 결과를 Boolean으로 반환한다. 12345/** * @param &#123;any&#125; testValue - 검사 대상 값. 암묵적 형변환되지 않는다. * @return &#123;boolean&#125; */Number.isNaN(testValue) Number.isNaN()는 전역 함수 isNaN()와 차이가 있다. 전역 함수 isNaN()는 인수를 숫자로 변환하여 검사를 수행하지만 Number.isNaN()는 인수를 변환하지 않는다. 따라서 숫자가 아닌 인수가 주어졌을 때 반환값은 언제나 false가 된다. Number.isSafeInteger(testValue: number): boolean ES6 매개변수에 전달된 값이 안전한(safe) 정수값인지 검사하여 그 결과를 Boolean으로 반환한다. 안전한 정수값은 -(253 - 1)와 253 - 1 사이의 정수값이다. 검사전에 인수를 숫자로 변환하지 않는다. 12345/** * @param &#123;any&#125; testValue - 검사 대상 값. 암묵적 형변환되지 않는다. * @return &#123;boolean&#125; */Number.isSafeInteger(testValue) Number.prototype.toExponential(fractionDigits?: number): string ES3 대상을 지수 표기법으로 변환하여 문자열로 반환한다. 지수 표기법이란 매우 큰 숫자를 표기할 때 주로 사용하며 e(Exponent) 앞에 있는 숫자에 10의 n승이 곱하는 형식으로 수를 나타내는 방식이다. 1234561234 = 1.234e+3/** * @param &#123;number&#125; [fractionDigits] - 0~20 사이의 정수값으로 소숫점 이하의 자릿수를 나타낸다. 옵션으로 생략 가능하다. * @return &#123;string&#125; */numObj.toExponential([fractionDigits]) Number.prototype.toFixed(fractionDigits?: number): string ES3 매개변수로 지정된 소숫점자리를 반올림하여 문자열로 반환한다. 12345/** * @param &#123;number&#125; [fractionDigits] - 0~20 사이의 정수값으로 소숫점 이하 자릿수를 나타낸다. 기본값은 0이며 옵션으로 생략 가능하다. * @return &#123;string&#125; */numObj.toFixed([fractionDigits]) 123456789101112var numObj = 12345.6789;// 소숫점 이하 반올림console.log(numObj.toFixed()); // '12346'// 소숫점 이하 1자리수 유효, 나머지 반올림console.log(numObj.toFixed(1)); // '12345.7'// 소숫점 이하 2자리수 유효, 나머지 반올림console.log(numObj.toFixed(2)); // '12345.68'// 소숫점 이하 3자리수 유효, 나머지 반올림console.log(numObj.toFixed(3)); // '12345.679'// 소숫점 이하 6자리수 유효, 나머지 반올림console.log(numObj.toFixed(6)); // '12345.678900' Number.prototype.toString(radix?: number): string ES1 숫자를 문자열로 변환하여 반환한다. 12345/** * @param &#123;number&#125; [radix] - 2~36 사이의 정수값으로 진법을 나타낸다. 옵션으로 생략 가능하다. * @return &#123;string&#125; */numObj.toString([radix]) 1234567891011121314var count = 10;console.log(count.toString()); // '10'console.log((17).toString()); // '17'console.log(17 .toString()); // '17'console.log((17.2).toString()); // '17.2'var x = 16;console.log(x.toString(2)); // '10000'console.log(x.toString(8)); // '20'console.log(x.toString(16)); // '10'console.log((254).toString(16)); // 'fe'console.log((-10).toString(2)); // '-1010'console.log((-0xff).toString(2)); // '-11111111' 정수 리터럴과 함께 메소드를 사용할 경우. 주의점177.toString(); // SyntaxError: Invalid or unexpected token 의 경우 .이 소숫점인지 아닌지 모르기 때문에 에러를 일으킨다. 따라서 다음과 같은 방법을 권장한다. 1(77).toString(); // '77' Number.prototype.valueOf(): number ES1 Number 객체의 원시 타입 값(primitive value)을 반환한다. 123456var numObj = new Number(10);console.log(typeof numObj); // objectvar num = numObj.valueOf();console.log(num); // 10console.log(typeof num); // number","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Method","slug":"Method","permalink":"https://hyeok999.github.io/tags/Method/"},{"name":"Rapper Object","slug":"Rapper-Object","permalink":"https://hyeok999.github.io/tags/Rapper-Object/"},{"name":"Number","slug":"Number","permalink":"https://hyeok999.github.io/tags/Number/"}]},{"title":"정규 표현식","slug":"regular-expression","date":"2019-10-22T02:00:56.000Z","updated":"2019-11-30T16:36:39.165Z","comments":true,"path":"2019/10/22/regular-expression/","link":"","permalink":"https://hyeok999.github.io/2019/10/22/regular-expression/","excerpt":"","text":"JavaScript 정규 표현식 정규 표현식 플래그 패턴 . 패턴 문자 또는 문자열 패턴 자주 사용하는 정규 표현식 특정 단어로 시작하는지 검사한다. 특정 단어로 끝나는지 검사한다. 숫자인지 검사한다. 하나 이상의 공백으로 시작하는지 검사한다. 아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리) 메일 주소 형식에 맞는지 검사한다. 핸드폰 번호 형식에 맞는지 검사한다. 특수 문자 포함 여부를 검사한다. RegExp Constructor 정규 표현식을 사용하는 메소드 RegExp Method RegExp.prototype.exec RegExp.prototype.test 정규 표현식 정규 표현식(Regular Expression)은 문자열에서 특정 내용을 찾거나 대체 또는 발췌하는데 사용한다.정규 표현식은 리터럴 표기법으로 생성할 수 있다. 정규표현식을 사용하는 자바스크립트 메소드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등이 있다. 12345678910111213const targetStr = 'This is a pen.';const regexr = /is/ig;// RegExp 객체의 메소드console.log(regexr.exec(targetStr)); // [ 'is', index: 2, input: 'This is a pen.' ]console.log(regexr.test(targetStr)); // true// String 객체의 메소드console.log(targetStr.match(regexr)); // [ 'is', 'is' ]console.log(targetStr.replace(regexr, 'IS')); // ThIS IS a pen.// String.prototype.search는 검색된 문자열의 첫번째 인덱스를 반환한다.console.log(targetStr.search(regexr)); // 2 ← indexconsole.log(targetStr.split(regexr)); // [ 'Th', ' ', ' a pen.' ] 플래그 Flag Meaning Description i Ignore Case 대소문자를 구별하지 않고 검색한다. g Global 문자열 내의 모든 패턴을 검색한다. m Multi Line 문자열의 행이 바뀌더라도 검색을 계속한다. 플래그는 옵션이므로 선택적으로 사용한다. 플래그를 사용하지 않은 경우 문자열 내 검색 매칭 대상이 1개 이상이더라도 첫번째 매칭한 대상만을 검색하고 종료한다. 123456789101112const targetStr = 'Is this all there is?';// 문자열 is를 대소문자를 구별하여 한번만 검색한다.let regexr = /is/;console.log(targetStr.match(regexr)); // [ 'is', index: 5, input: 'Is this all there is?' ]// 문자열 is를 대소문자를 구별하지 않고 대상 문자열 끝까지 검색한다.regexr = /is/ig;console.log(targetStr.match(regexr)); // [ 'Is', 'is', 'is' ]console.log(targetStr.match(regexr).length); // 3 패턴​ 검색하고 싶은 문자열을 지정한다. 이때 따옴표는 생략한다. 만약 따옴표를 입력시 따옴표까지 검색하게 된다.추가로 패턴에 특별한 의미를 지니는 메타문자 또는 기호로 표현할 수 있다. . 패턴.은 임의의 문자 한 개를 의미한다. 문자의 내용은 무엇이든지 상관없다.플래그를 사용하지 않을 경우 . 패턴이 많아도 첫 결과 만 검색된다.반복을 위해서는 g 플래그를 사용하면 . 패턴의 갯수대로 반환한다. 123456const targetStr = 'AA BB Aa Bb';// 임의의 문자 3개를 반복하여 검색const regexr = /.../g;console.log(targetStr.match(regexr)); // [ 'AA ', 'BB ', 'Aa ' ] 모든 문자를 선택하려면 .와 g를 동시에 지정한다. 1234567const targetStr = 'AA BB Aa Bb';// 임의의 한문자를 반복 검색const regexr = /./g;console.log(targetStr.match(regexr));// [ 'A', 'A', ' ', 'B', 'B', ' ', 'A', 'a', ' ', 'B', 'b' ] 문자 또는 문자열 패턴패턴에 문자 또는 문자열을 지정하면 일치하는 문자 또는 문자열을 추출한다. 플래그가 없으면 대소문자를 구별하고 첫번째 결과만 반환한다. 123456const targetStr = 'AA BB Aa Bb';// 'A'를 검색const regexr = /A/;console.log(targetStr.match(regexr)); // 'A' 모든 결과와 대소문자를 구별하지 않게 하려면 플래그 i를 사용한다. 123456const targetStr = 'AA BB Aa Bb';// 'A'를 대소문자 구분없이 반복 검색const regexr = /A/ig;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'A', 'a' ] 앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 +를 붙인다. 123456const targetStr = 'AA AAA BB Aa Bb';// 'A'가 한번이상 반복되는 문자열('A', 'AA', 'AAA', ...)을 반복 검색const regexr = /A+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'A' ] |를 사용하면 or의 의미를 가지게 된다. 123456const targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'를 반복 검색const regexr = /A|B/g;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'B', 'B', 'A', 'B' ] 분해되지 않은 단어 레벨로 추출하기 위해서는 +를 같이 사용하면 된다. 1234567const targetStr = 'AA AAA BB Aa Bb';// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...const regexr = /A+|B+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'BB', 'A', 'B' ] []내의 문자는 or로 동작한다. 그 뒤에 +를 사용하여 앞선 패턴을 한번 이상 반복하게 한다. 1234567const targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...const regexr = /[AB]+/g; // /A+|B+/gconsole.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'A', 'B' ] 범위를 지정하려면 []내에 -를 사용한다. 아래의 경우 대문자 알파벳을 추출한다. 12345678const targetStr = 'AA BB ZZ Aa Bb';// 'A' ~ 'Z'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ... ~ 또는 'Z', 'ZZ', 'ZZZ', ...const regexr = /[A-Z]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'ZZ', 'A', 'B' ] 대소문자를 구별하지 않고 알파벳을 추출하려면 아래와 같이 한다. 12345678const targetStr = 'AA BB Aa Bb';// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[A-Za-z]+/g;// 아래와 동일하다.// const regexr = /[A-Z]+/gi;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb' ] 숫자를 추출하는 방법이다. 123456const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9'가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[0-9]+/g;console.log(targetStr.match(regexr)); // [ '24', '000' ] 컴마 때문에 결과가 분리되므로 패턴에 포함시킨다. 123456const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[0-9,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ] \\d는 숫자를 의미한다. \\D는 ‘0’ ~ ‘9’가 아닌 문자 를 의미한다. 1234567891011const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색let regexr = /[\\d,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ]// '0' ~ '9'가 아닌 문자(숫자가 아닌 문자) 또는 ','가 한번 이상 반복되는 문자열을 반복 검색regexr = /[\\D,]+/g;console.log(targetStr.match(regexr)); // [ 'AA BB Aa Bb ', ',' ] \\w는 알파벳과 숫자를 의미한다. \\W는 \\w와 반대로 동작한다. 1234567891011const targetStr = 'AA BB Aa Bb 24,000';// 알파벳과 숫자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색let regexr = /[\\w,]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb', '24,000' ]// 알파벳과 숫자가 아닌 문자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색regexr = /[\\W,]+/g;console.log(targetStr.match(regexr)); // [ ' ', ' ', ' ', ' ', ',' ] 자주 사용하는 정규 표현식 특정 단정로 시작하는지 검색한다. 1234567const url = 'http://example.com';// 'http'로 시작하는지 검사// ^ : 문자열의 처음을 의미한다.const regexr = /^http/;console.log(regexr.test(url)); // true 특정 단어로 끝나는지 검사한다. 1234567const fileName = 'index.html';// 'html'로 끝나는지 검사// $ : 문자열의 끝을 의미한다.const regexr = /html$/;console.log(regexr.test(fileName)); // true 숫자인지 검사한다. 12345678const targetStr = '12345';// 모두 숫자인지 검사// [^]: 부정(not)을 의미한다. 얘를 들어 [^a-z]는 알파벳 소문자로 시작하지 않는 모든 문자를 의미한다.// [] 바깥의 ^는 문자열의 처음을 의미한다.const regexr = /^\\d+$/;console.log(regexr.test(targetStr)); // true 하나 이상의 공백으로 시작하는지 검사한다. 1234567const targetStr = ' Hi!';// 1개 이상의 공백으로 시작하는지 검사// \\s : 여러 가지 공백 문자 (스페이스, 탭 등) =&gt; [\\t\\r\\n\\v\\f]const regexr = /^[\\s]+/;console.log(regexr.test(targetStr)); // true 아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리) 1234567const id = 'abc123';// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사// &#123;4,10&#125;: 4 ~ 10자리const regexr = /^[A-Za-z0-9]&#123;4,10&#125;$/;console.log(regexr.test(id)); // true 메일 주소 형식에 맞는지 검사한다. 12345const email = 'ungmo2@gmail.com';const regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]&#123;2,3&#125;$/;console.log(regexr.test(email)); // true 핸드폰 번호 형식에 맞는지 검사한다. 12345const cellphone = '010-1234-5678';const regexr = /^\\d&#123;3&#125;-\\d&#123;3,4&#125;-\\d&#123;4&#125;$/;console.log(regexr.test(cellphone)); // true 특수 문자 포함 여부를 검사한다. 1234567891011121314const targetStr = 'abc#123';// A-Za-z0-9 이외의 문자가 있는지 검사let regexr = /[^A-Za-z0-9]/gi;console.log(regexr.test(targetStr)); // true// 아래 방식도 동작한다. 이 방식의 장점은 특수 문자를 선택적으로 검사할 수 있다.regexr = /[\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"]/gi;console.log(regexr.test(targetStr)); // true// 특수 문자 제거console.log(targetStr.replace(regexr, '')); // abc123 Javascript Regular ExpressionRegExp Constructor JS는 정규표현식을 위해 RegExp 객체를 지원한다. 객체 생성을 위해서 리터럴 방식과 RegExp 생성자 함수를 사용할 수 있다. 1new RegExp(pattern[, flags]) pattern 정규표현식의 텍스트 flags 정규표현식의 플래그 (g, i, m, u, y) 12345678// 정규식 리터럴/ab+c/i;new RegExp('ab+c', 'i');new RegExp(/ab+c/, 'i');new RegExp(/ab+c/i); // ES6 정규표현식을 사용하는 메소드 RegExp.prototype.exec RegExp.prototype.test String.prototype.match String.prototype.replace String.prototype.search String.prototype.split RegExp MethodRegExp.prototype.exec(target: string): RegExpExecArray | null ES3문자열을 검색하여 매칭 결과를 반환한다. 반환값은 배열 또는 null이다. 12345const target = 'Is this all there is?';const regExp = /is/;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] exec 메소드는 g 플래그를 지정하여도 첫번째 메칭 결과만을 반환한다. 12345const target = 'Is this all there is?';const regExp = /is/g;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] RegExp.prototype.test(target: string): boolean ES3문자열을 검색하여 매칭 결과를 반환한다. 반환값은 true 또는 false이다. 12345const target = 'Is this all there is?';const regExp = /is/;const res = regExp.test(target);console.log(res); // true","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"RegExr","slug":"RegExr","permalink":"https://hyeok999.github.io/tags/RegExr/"}]},{"title":"javascript 26강(M) 정규표현식","slug":"javascript-preview-26M","date":"2019-10-22T02:00:33.000Z","updated":"2019-11-30T16:38:23.890Z","comments":true,"path":"2019/10/22/javascript-preview-26M/","link":"","permalink":"https://hyeok999.github.io/2019/10/22/javascript-preview-26M/","excerpt":"","text":"JavaScript 26강 (M) 26강 : 정규 표현식 플래그 패턴 . 패턴 문자 또는 문자열 패턴 자주 사용하는 정규 표현식 특정 단어로 시작하는지 검사한다. 특정 단어로 끝나는지 검사한다. 숫자인지 검사한다. 하나 이상의 공백으로 시작하는지 검사한다. 아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리) 메일 주소 형식에 맞는지 검사한다. 핸드폰 번호 형식에 맞는지 검사한다. 특수 문자 포함 여부를 검사한다. RegExp Constructor 정규 표현식을 사용하는 메소드 RegExp Method RegExp.prototype.exec RegExp.prototype.test 26강정규 표현식 정규 표현식(Regular Expression)은 문자열에서 특정 내용을 찾거나 대체 또는 발췌하는데 사용한다.정규 표현식은 리터럴 표기법으로 생성할 수 있다. 정규표현식을 사용하는 자바스크립트 메소드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등이 있다. 12345678910111213const targetStr = 'This is a pen.';const regexr = /is/ig;// RegExp 객체의 메소드console.log(regexr.exec(targetStr)); // [ 'is', index: 2, input: 'This is a pen.' ]console.log(regexr.test(targetStr)); // true// String 객체의 메소드console.log(targetStr.match(regexr)); // [ 'is', 'is' ]console.log(targetStr.replace(regexr, 'IS')); // ThIS IS a pen.// String.prototype.search는 검색된 문자열의 첫번째 인덱스를 반환한다.console.log(targetStr.search(regexr)); // 2 ← indexconsole.log(targetStr.split(regexr)); // [ 'Th', ' ', ' a pen.' ] 플래그 Flag Meaning Description i Ignore Case 대소문자를 구별하지 않고 검색한다. g Global 문자열 내의 모든 패턴을 검색한다. m Multi Line 문자열의 행이 바뀌더라도 검색을 계속한다. 플래그는 옵션이므로 선택적으로 사용한다. 플래그를 사용하지 않은 경우 문자열 내 검색 매칭 대상이 1개 이상이더라도 첫번째 매칭한 대상만을 검색하고 종료한다. 123456789101112const targetStr = 'Is this all there is?';// 문자열 is를 대소문자를 구별하여 한번만 검색한다.let regexr = /is/;console.log(targetStr.match(regexr)); // [ 'is', index: 5, input: 'Is this all there is?' ]// 문자열 is를 대소문자를 구별하지 않고 대상 문자열 끝까지 검색한다.regexr = /is/ig;console.log(targetStr.match(regexr)); // [ 'Is', 'is', 'is' ]console.log(targetStr.match(regexr).length); // 3 패턴​ 검색하고 싶은 문자열을 지정한다. 이때 따옴표는 생략한다. 만약 따옴표를 입력시 따옴표까지 검색하게 된다.추가로 패턴에 특별한 의미를 지니는 메타문자 또는 기호로 표현할 수 있다. . 패턴.은 임의의 문자 한 개를 의미한다. 문자의 내용은 무엇이든지 상관없다.플래그를 사용하지 않을 경우 . 패턴이 많아도 첫 결과 만 검색된다.반복을 위해서는 g 플래그를 사용하면 . 패턴의 갯수대로 반환한다. 123456const targetStr = 'AA BB Aa Bb';// 임의의 문자 3개를 반복하여 검색const regexr = /.../g;console.log(targetStr.match(regexr)); // [ 'AA ', 'BB ', 'Aa ' ] 모든 문자를 선택하려면 .와 g를 동시에 지정한다. 1234567const targetStr = 'AA BB Aa Bb';// 임의의 한문자를 반복 검색const regexr = /./g;console.log(targetStr.match(regexr));// [ 'A', 'A', ' ', 'B', 'B', ' ', 'A', 'a', ' ', 'B', 'b' ] 문자 또는 문자열 패턴패턴에 문자 또는 문자열을 지정하면 일치하는 문자 또는 문자열을 추출한다. 플래그가 없으면 대소문자를 구별하고 첫번째 결과만 반환한다. 123456const targetStr = 'AA BB Aa Bb';// 'A'를 검색const regexr = /A/;console.log(targetStr.match(regexr)); // 'A' 모든 결과와 대소문자를 구별하지 않게 하려면 플래그 i를 사용한다. 123456const targetStr = 'AA BB Aa Bb';// 'A'를 대소문자 구분없이 반복 검색const regexr = /A/ig;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'A', 'a' ] 앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 +를 붙인다. 123456const targetStr = 'AA AAA BB Aa Bb';// 'A'가 한번이상 반복되는 문자열('A', 'AA', 'AAA', ...)을 반복 검색const regexr = /A+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'A' ] |를 사용하면 or의 의미를 가지게 된다. 123456const targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'를 반복 검색const regexr = /A|B/g;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'B', 'B', 'A', 'B' ] 분해되지 않은 단어 레벨로 추출하기 위해서는 +를 같이 사용하면 된다. 1234567const targetStr = 'AA AAA BB Aa Bb';// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...const regexr = /A+|B+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'BB', 'A', 'B' ] []내의 문자는 or로 동작한다. 그 뒤에 +를 사용하여 앞선 패턴을 한번 이상 반복하게 한다. 1234567const targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...const regexr = /[AB]+/g; // /A+|B+/gconsole.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'A', 'B' ] 범위를 지정하려면 []내에 -를 사용한다. 아래의 경우 대문자 알파벳을 추출한다. 12345678const targetStr = 'AA BB ZZ Aa Bb';// 'A' ~ 'Z'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ... ~ 또는 'Z', 'ZZ', 'ZZZ', ...const regexr = /[A-Z]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'ZZ', 'A', 'B' ] 대소문자를 구별하지 않고 알파벳을 추출하려면 아래와 같이 한다. 12345678const targetStr = 'AA BB Aa Bb';// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[A-Za-z]+/g;// 아래와 동일하다.// const regexr = /[A-Z]+/gi;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb' ] 숫자를 추출하는 방법이다. 123456const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9'가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[0-9]+/g;console.log(targetStr.match(regexr)); // [ '24', '000' ] 컴마 때문에 결과가 분리되므로 패턴에 포함시킨다. 123456const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[0-9,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ] \\d는 숫자를 의미한다. \\D는 ‘0’ ~ ‘9’가 아닌 문자 를 의미한다. 1234567891011const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색let regexr = /[\\d,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ]// '0' ~ '9'가 아닌 문자(숫자가 아닌 문자) 또는 ','가 한번 이상 반복되는 문자열을 반복 검색regexr = /[\\D,]+/g;console.log(targetStr.match(regexr)); // [ 'AA BB Aa Bb ', ',' ] \\w는 알파벳과 숫자를 의미한다. \\W는 \\w와 반대로 동작한다. 1234567891011const targetStr = 'AA BB Aa Bb 24,000';// 알파벳과 숫자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색let regexr = /[\\w,]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb', '24,000' ]// 알파벳과 숫자가 아닌 문자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색regexr = /[\\W,]+/g;console.log(targetStr.match(regexr)); // [ ' ', ' ', ' ', ' ', ',' ] 자주 사용하는 정규 표현식 특정 단정로 시작하는지 검색한다. 1234567const url = 'http://example.com';// 'http'로 시작하는지 검사// ^ : 문자열의 처음을 의미한다.const regexr = /^http/;console.log(regexr.test(url)); // true 특정 단어로 끝나는지 검사한다. 1234567const fileName = 'index.html';// 'html'로 끝나는지 검사// $ : 문자열의 끝을 의미한다.const regexr = /html$/;console.log(regexr.test(fileName)); // true 숫자인지 검사한다. 12345678const targetStr = '12345';// 모두 숫자인지 검사// [^]: 부정(not)을 의미한다. 얘를 들어 [^a-z]는 알파벳 소문자로 시작하지 않는 모든 문자를 의미한다.// [] 바깥의 ^는 문자열의 처음을 의미한다.const regexr = /^\\d+$/;console.log(regexr.test(targetStr)); // true 하나 이상의 공백으로 시작하는지 검사한다. 1234567const targetStr = ' Hi!';// 1개 이상의 공백으로 시작하는지 검사// \\s : 여러 가지 공백 문자 (스페이스, 탭 등) =&gt; [\\t\\r\\n\\v\\f]const regexr = /^[\\s]+/;console.log(regexr.test(targetStr)); // true 아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리) 1234567const id = 'abc123';// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사// &#123;4,10&#125;: 4 ~ 10자리const regexr = /^[A-Za-z0-9]&#123;4,10&#125;$/;console.log(regexr.test(id)); // true 메일 주소 형식에 맞는지 검사한다. 12345const email = 'ungmo2@gmail.com';const regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]&#123;2,3&#125;$/;console.log(regexr.test(email)); // true 핸드폰 번호 형식에 맞는지 검사한다. 12345const cellphone = '010-1234-5678';const regexr = /^\\d&#123;3&#125;-\\d&#123;3,4&#125;-\\d&#123;4&#125;$/;console.log(regexr.test(cellphone)); // true 특수 문자 포함 여부를 검사한다. 1234567891011121314const targetStr = 'abc#123';// A-Za-z0-9 이외의 문자가 있는지 검사let regexr = /[^A-Za-z0-9]/gi;console.log(regexr.test(targetStr)); // true// 아래 방식도 동작한다. 이 방식의 장점은 특수 문자를 선택적으로 검사할 수 있다.regexr = /[\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"]/gi;console.log(regexr.test(targetStr)); // true// 특수 문자 제거console.log(targetStr.replace(regexr, '')); // abc123 Javascript Regular ExpressionRegExp Constructor JS는 정규표현식을 위해 RegExp 객체를 지원한다. 객체 생성을 위해서 리터럴 방식과 RegExp 생성자 함수를 사용할 수 있다. 1new RegExp(pattern[, flags]) pattern 정규표현식의 텍스트 flags 정규표현식의 플래그 (g, i, m, u, y) 12345678// 정규식 리터럴/ab+c/i;new RegExp('ab+c', 'i');new RegExp(/ab+c/, 'i');new RegExp(/ab+c/i); // ES6 정규표현식을 사용하는 메소드 RegExp.prototype.exec RegExp.prototype.test String.prototype.match String.prototype.replace String.prototype.search String.prototype.split RegExp MethodRegExp.prototype.exec(target: string): RegExpExecArray | null ES3문자열을 검색하여 매칭 결과를 반환한다. 반환값은 배열 또는 null이다. 12345const target = 'Is this all there is?';const regExp = /is/;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] exec 메소드는 g 플래그를 지정하여도 첫번째 메칭 결과만을 반환한다. 12345const target = 'Is this all there is?';const regExp = /is/g;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] RegExp.prototype.test(target: string): boolean ES3문자열을 검색하여 매칭 결과를 반환한다. 반환값은 true 또는 false이다. 12345const target = 'Is this all there is?';const regExp = /is/;const res = regExp.test(target);console.log(res); // true","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"RegExr","slug":"RegExr","permalink":"https://hyeok999.github.io/tags/RegExr/"}]},{"title":"HOF-고차함수","slug":"HOF","date":"2019-10-21T12:23:10.000Z","updated":"2019-11-30T16:44:49.480Z","comments":true,"path":"2019/10/21/HOF/","link":"","permalink":"https://hyeok999.github.io/2019/10/21/HOF/","excerpt":"","text":"JavaScript 고차 함수 Array.prototype.sort Array.prototype.forEach Array.prototype.map Array.prototype.filter Array.prototype.reduce Array.prototype.some Array.prototype.every Array.prototype.find Array.prototype.findIndex 고차 함수내부적으로 for문을 돌며, 인수로 콜백함수를 받을 수 있다. Array.prototype.sort 배열명.sort() 배열의 요소를 적절하게 정렬. (기본적으로 오름차순) 원본 배열을 직접 변경하며 정렬된 배열을 반환. 문자열 요소들로 이루어진 배열의 정렬은 아무런 문제가 없다. 12345678910111213const fruits = ['Banana', 'Orange', 'Apple'];// 오름차순(ascending) 정렬fruits.sort();// sort 메소드는 원본 배열을 직접 변경한다.console.log(fruits); // ['Apple', 'Banana', 'Orange']// 내림차순(descending) 정렬fruits.reverse();// reverse 메소드도 원본 배열을 직접 변경한다.console.log(fruits); // ['Orange', 'Banana', 'Apple'] 숫자 배열은 정렬 시 추가 작업이 필요. 배열명.sort(function(a,b){return a - b;}); : 숫자 정렬 시 사용. 오름차순으로 정렬한다.배열명.sort(function(a,b){return b - a;}); : 숫자 정렬 시 사용. 내림차순으로 정렬한다. return 1 : 오름차순 return 0 : 같다. return -1 : 내림차순 1234567891011121314151617const points = [40, 100, 1, 5, 2, 25, 10];// 숫자 배열 오름차순 정렬// 비교 함수의 반환값이 0보다 작은 경우, a를 우선하여 정렬한다.points.sort((a, b) =&gt; &#123; return a - b; &#125;);console.log(points); // [1, 2, 5, 10, 25, 40, 100]// 숫자 배열에서 최소값 취득console.log(points[0]); // 1// 숫자 배열 내림차순 정렬// 비교 함수의 반환값이 0보다 큰 경우, b를 우선하여 정렬한다.points.sort((a, b) =&gt; &#123; return b - a; &#125;);console.log(points); // [100, 40, 25, 10, 5, 2, 1]// 숫자 배열에서 최대값 취득console.log(points[0]); // 100 Array.prototype.forEach 배열명.forEach((item, index, self) =&gt; { }); //item: 요소, index: 인덱스, self: this for문의 대체 메소드. (forEach가 가독성이 더 뛰어나다.) 배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행. 2번쨰 인수로 this를 전달 받을 수 있다. for처럼 중간에 break, continue로 빠져나갈 수 없다. undefined를 반환함. 12345678910111213141516const numbers = [1, 2, 3];let pows = [];// for 문으로 순회for (let i = 0; i &lt; numbers.length; i++) &#123; pows.push(numbers[i] ** 2);&#125;console.log(pows); // [1, 4, 9]pows = [];// forEach 메소드로 순회numbers.forEach(item =&gt; pows.push(item ** 2));console.log(pows); // [1, 4, 9] 콜백을 이용하여 직접 변경도 가능하다. 1234567const numbers = [1, 2, 3];// forEach 메소드는 원본 배열(this)을 변경하지 않는다.// 하지만 콜백 함수가 원본 배열(this)을 변경할 수는 있다.numbers.forEach((item, index, self) =&gt; self[index] = Math.pow(item, 2));console.log(numbers); // [1, 4, 9] 12345678910111213class Numbers &#123; numberArray = []; multiply(arr) &#123; // 화살표 함수 내부에서 this를 참조하면 // 상위 컨텍스트, 즉 multiply 메소드 내부의 this를 그대로 참조한다. arr.forEach(item =&gt; this.numberArray.push(item * item)); &#125;&#125;const numbers = new Numbers();numbers.multiply([1, 2, 3]);console.log(numbers.numberArray); // [1, 4, 9] 화살표 함수는 내부에 this가 없기 떄문에 자신의 상위 스코프의 this를 가져다가 쓴다. Array.prototype.map 배열명.map((item, index, self) =&gt; { }); //item: 요소, index: 인덱스, self: this 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행한다. map은 요소의 개수만큼 순회하면서 요소를 생성하여 반환한다. 콜백 함수의 반환한 값들이 요소로서 추가된 새로운 배열을 반환한다. 원본 배열은 변경되지 않는다. 희소 배열의 존재하지 않는 요소는 순회 대상에서 제외된다. this를 전달 받을 수 있다. 12345678910// map 메소드는 전달받은 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.[1, 2, 3].map((item, index, self) =&gt; &#123; console.log(`요소값: $&#123;item&#125;, 인덱스: $&#123;index&#125;, this: $&#123;self&#125;`); return item;&#125;);/*요소값: 1, 인덱스: 0, this: 1,2,3요소값: 2, 인덱스: 1, this: 1,2,3요소값: 3, 인덱스: 2, this: 1,2,3*/ 12345678910111213const numbers = [1, 4, 9];// 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행한다.// 그리고 콜백 함수의 반환한 값들이 요소로서 추가된 새로운 배열을 반환한다.const roots = numbers.map(item =&gt; Math.sqrt(item));// 위 코드의 축약표현은 아래와 같다.// const roots = numbers.map(Math.sqrt);// map 메소드는 새로운 배열을 반환한다console.log(roots); // [ 1, 2, 3 ]// map 메소드는 원본 배열은 변경하지 않는다console.log(numbers); // [ 1, 4, 9 ] Array.prototype.filter 배열명.filter((item, index, self) =&gt; { }); //item: 요소, index: 인덱스, self: this 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행한다. return 조건식에 부합하는 것을 반환한다. 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환 원본 배열은 변경되지 않는다. this를 전달 받을 수 있다. 12345678910// filter 메소드는 전달받은 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.[1, 2, 3].filter((item, index, self) =&gt; &#123; console.log(`요소값: $&#123;item&#125;, 인덱스: $&#123;index&#125;, this: $&#123;self&#125;`); return item % 2;&#125;);/*요소값: 1, 인덱스: 0, this: 1,2,3요소값: 2, 인덱스: 1, this: 1,2,3요소값: 3, 인덱스: 2, this: 1,2,3*/ 123456const numbers = [1, 2, 3, 4, 5];// 홀수만을 필터링한다 (1은 true로 평가된다)const odds = numbers.filter(item =&gt; item % 2);console.log(odds); // [1, 3, 5] Array.prototype.reduce 배열.reduce( (누적값, 현잿값, 인덱스, 요소) =&gt; { return 결과 }, 초깃값); reduce 메소드는 배열을 순회하며 콜백 함수의 이전 반환값과 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행하여 하나의 결과값을 반환한다. 원본 배열은 변경되지 않는다. 첫번째 인수로 콜백 함수 [ 반환값, 요소값, 인덱스, reduce호출한 배열(this)] 두번째 인수는 초기값. reduce 메소드는 배열을 순회하며 단일값을 구해야 하는 경우에 사용한다. 1234// 1부터 4까지 누적을 구한다.const sum = [1, 2, 3, 4].reduce((pre, cur, index, self) =&gt; pre + cur, 0);console.log(sum); // 10 첫번째 인수로 전달받은 콜백 함수는 4개의 인수를 전달받아 배열의 length만큼 총 4회 호출된다. 이때 콜백 함수로 전달되는 인수와 반환값은 아래와 같다. 구분 콜백 함수에 전달된 인수 콜백 함수의 반환값 pre cur index self 첫번째 순회 0 (초기값) 1 0 [1, 2, 3, 4] 1 (pre + cur) 두번째 순회 1 2 1 [1, 2, 3, 4] 3 (pre + cur) 세번째 순회 3 3 2 [1, 2, 3, 4] 6 (pre + cur) 네번째 순회 6 4 3 [1, 2, 3, 4] 10 (pre + cur 평균 구하기 123456789const values = [1, 2, 3, 4, 5, 6];const average = values.reduce((pre, cur, i, self) =&gt; &#123; // 마지막 순회인 경우, 누적값으로 평균을 구해 반환 // 마지막 순회가 아닌 경우, 누적값을 반환 return i === self.length - 1 ? (pre + cur) / self.length : pre + cur;&#125;, 0);console.log(average); // 3.5 최대값 구하기 1234const values = [1, 2, 3, 4, 5];const max = values.reduce((pre, cur) =&gt; (pre &gt; cur ? pre : cur), 0);console.log(max); // 5 하지만, Math.max 메소드를 사용하는 방법이 보다 직관적이다. min, max는 가변인자함수형태로 받는다. 1234const values = [1, 2, 3, 4, 5];const max = Math.max(...values);console.log(max); // 5 중복된 요소의 개수 구하기 1234567891011const fruits = ['banana', 'apple', 'orange', 'orange', 'apple'];const count = fruits.reduce((pre, cur) =&gt; &#123; // 첫번째 순회: pre =&gt; &#123;&#125;, cur =&gt; 'banana' // 빈 객체에 요소값을 프로퍼티 키로 추가하고 프로퍼티 값을 할당 // 만약 프로퍼티 값이 undefined이면 0으로 초기화 pre[cur] = (pre[cur] || 0) + 1; return pre;&#125;, &#123;&#125;); console.log(count); // &#123; banana: 1, apple: 2, orange: 2 &#125; 중첩 배열 평탄화 123456const values = [1, [2, 3], 4, [5, 6]];const flatten = values.reduce((pre, cur) =&gt; pre.concat(cur), []);// [1] =&gt; [1, 2, 3] =&gt; [1, 2, 3, 4] =&gt; [1, 2, 3, 4, 5, 6]console.log(flatten); // [1, 2, 3, 4, 5, 6] 중복 요소 제거 ( reduce보다는 filter이용하는게 더 직관적이다. ) 1234567891011121314151617181920const values = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];const result = values.reduce((pre, cur, i, self) =&gt; &#123; // 순회중인 요소의 인덱스가 자신의 인덱스라면 처음 순회하는 요소이다. // 이 요소만 배열에 담아 반환한다. // 순회중인 요소의 인덱스가 자신의 인덱스가 아니라면 중복된 요소이다. // 3번째 순회: [1, 2], 1, 2, [1, 2, 1, 3, 5, 4, 5, 3, 4, 4] // if ([1, 2, 1, 3, 5, 4, 5, 3, 4, 4].indexOf(1) === 2) =&gt; if(0 === 2) if (self.indexOf(cur) === i) pre.push(cur); return pre;&#125;, []);console.log(result); // [1, 2, 3, 5, 4]// filter 사용 시const values2 = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];// 순회중인 요소의 인덱스가 자신의 인덱스라면 처음 순회하는 요소이다. 이 요소만 반환한다.const result = values2.filter((v, i, self) =&gt; self.indexOf(v) === i);console.log(result); // [1, 2, 3, 5, 4] 이처럼 map, filter, some, every, find와 같은 모든 배열 고차 함수는 reduce로 구현할 수 있다. 12const sum = [].reduce((pre, cur) =&gt; pre + cur);// TypeError: Reduce of empty array with no initial value 이처럼 빈 배열로 reduce 메소드를 호출하면 에러가 발생한다.reduce 메소드에 초기값을 전달하면 에러가 발생하지 않는다. 12const sum = [].reduce((pre, cur) =&gt; pre + cur, 0);console.log(sum); // 0 객체의 프로퍼티 값을 합산하는 경우에는 반드시 초기값을 전달해야 한다. 123456789101112const products = [ &#123; id: 1, price: 100 &#125;, &#123; id: 2, price: 200 &#125;, &#123; id: 3, price: 300 &#125;];// 1번째 순회 : pre =&gt; 0, cur =&gt; 100// 2번째 순회 : pre =&gt; 100, cur =&gt; 200// 3번째 순회 : pre =&gt; 300, cur =&gt; 300const priceSum = products.reduce((pre, cur) =&gt; pre + cur.price, 0);console.log(priceSum); // 600 Array.prototype.some 배열명.some((item, index, self) =&gt; { }); //item: 요소, index: 인덱스, self: this 배열을 순회하며 요소 중 하나라도 콜백 함수의 테스트를 통과하면 true, 모든 요소가 콜백 함수의 테스트를 통과하지 못하면 false를 반환한다. 2번째 인자로 this를 전달 받을 수 있다. 1234567891011// 배열의 요소 중에 10보다 큰 요소가 1개 이상 존재하는지 확인let result = [5, 10, 15].some(item =&gt; item &gt; 10);console.log(result); // true// 배열의 요소 중에 0보다 작은 요소가 1개 이상 존재하는지 확인result = [5, 10, 15].some(item =&gt; item &lt; 0);console.log(result); // false// 배열의 요소 중에 'banana'가 1개 이상 존재하는지 확인result = ['apple', 'banana', 'mango'].some(item =&gt; item === 'banana');console.log(result); // true Array.prototype.every 배열명.every((item, index, self) =&gt; { }); //item: 요소, index: 인덱스, self: this every 메소드는 배열을 순회하며 모든 요소가 콜백 함수의 테스트를 통과하면 true, 요소 중 하나라도 콜백 함수의 테스트를 통과하지 못하면 false를 반환한다. 2번째 인자로 this를 전달 받을 수 있다. 1234567// 배열의 모든 요소가 3보다 큰지 확인let result = [5, 10, 15].every(item =&gt; item &gt; 3);console.log(result); // true// 배열의 모든 요소가 10보다 큰지 확인result = [5, 10, 15].every(item =&gt; item &gt; 10);console.log(result); // false Array.prototype.find 배열명.find((item, index, self) =&gt; { }); //item: 요소, index: 인덱스, self: this 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다. 참인 요소가 존재하지 않는다면 undefined를 반환한다. 반드시 첫번쨰 요소만 반환하고 끝난다. 2번째 인자로 this를 전달 받을 수 있다. 아래 예제에서는 프로퍼티 id의 값이 2인 배열 요소가 2개 있다. 그러나 정작 반환하는 것은 name: ‘Kim’ 뿐이다. 123456789101112const users = [ &#123; id: 1, name: 'Lee' &#125;, &#123; id: 2, name: 'Kim' &#125;, &#123; id: 2, name: 'Choi' &#125;, &#123; id: 3, name: 'Park' &#125;];// id가 2인 요소를 반환한다.const result = users.find(item =&gt; item.id === 2);// Array#find는 배열이 아니라 요소를 반환한다.console.log(result); // &#123;id: 2, name: 'Kim'&#125; filter 메소드는 콜백 함수의 실행 결과가 true인 요소만을 추출한 새로운 배열을 반환한다. 따라서 filter의 반환값은 언제나 배열이다. 하지만 find 메소드는 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환하므로 find의 결과값은 해당 요소값이다. 12345// Array#filter는 배열을 반환한다.[1, 2, 2, 3].filter(item =&gt; item === 2); // -&gt; [2, 2]// Array#find는 요소를 반환한다.[1, 2, 2, 3].find(item =&gt; item === 2); // -&gt; 2 Array.prototype.findIndex 배열명.findIndex((item, index, self) =&gt; { }); //item: 요소, index: 인덱스, self: this 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다. 콜백 함수의 실행 결과가 참인 요소가 존재하지 않는다면 -1를 반환한다. 반드시 첫번쨰 요소의 인덱스만 반환하고 끝난다. 2번째 인자로 this를 전달 받을 수 있다. 1234567891011121314151617181920const users = [ &#123; id: 1, name: 'Lee' &#125;, &#123; id: 2, name: 'Kim' &#125;, &#123; id: 2, name: 'Choi' &#125;, &#123; id: 3, name: 'Park' &#125;];function predicate(key, value) &#123; // key와 value를 기억하는 클로저를 반환 return item =&gt; item[key] === value;&#125;// Array#findIndex는 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다.// id가 2인 요소의 인덱스를 구한다.let index = users.findIndex(predicate('id', 2));console.log(index); // 1// name이 'Park'인 요소의 인덱스를 구한다.index = users.findIndex(predicate('name', 'Park'));console.log(index); // 3","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"HOF","slug":"HOF","permalink":"https://hyeok999.github.io/tags/HOF/"}]},{"title":"배열 메소드","slug":"array-method","date":"2019-10-21T12:16:43.000Z","updated":"2019-11-30T16:52:20.547Z","comments":true,"path":"2019/10/21/array-method/","link":"","permalink":"https://hyeok999.github.io/2019/10/21/array-method/","excerpt":"","text":"JavaScript 배열 메소드 Array.isArray Array.prototype.push Array.prototype.pop push 와 pop을 사용하여 stack 구현 Array.prototype.unshift Array.prototype.shift shift 와 pop을 사용하여 queqe 구현 Array.prototype.concat Array.prototype.splice Array.prototype.slice slice를 이용한 유사 배열 객체를 배열로 변환 Array.prototype.indexOf Array.prototype.join Array.prototype.reverse Array.prototype.fill fill vs Array.from Array.prototype.includes 배열 메소드 원본 배열(this)를 직접 변경하는 메소드(mutator method) mutator method 를 사용하려면 반드시 배열을 담고있는 변수를 필요로 한다. ( [1,2].push(3) ➤ 의미없는 코드 ) 원본 배열은 영향을 안주고 결과값을 새로운 배열로 return하는 메소드(accessor method) accessor method는 반드시 결과 값을 받을 변수를 필요로 한다. ( const result = [1,2].concat[3,4] ➤result가 필요함. ) 가급적으로 mutator method를 사용하지 않도록 한다.이유 : 각 method를 쓰면 예측이 불가능 하기 떄문이고 직접 변경 시키는 것은 차후에 변경 시켰는지 모를 수 있기 때문이다. Array.isArray Array.isArray는 주어진 인수가 배열이면 true를 반환. 배열이 아니면 false를 반환. Array.prototype.push 전달받은 인수를 원본 배열(this)의 마지막 요소로 추가. 변경된 length 값을 반환. 원본 배열(this)을 직접 변경 스택 구조 와 큐 구조에서 사용. 12345678const arr = [1, 2];// 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 값을 반환한다.let result = arr.push(3, 4);console.log(result); // 4 // [...arr, 3, 4 ]; ES6 Spread 문법// push 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [1, 2, 3, 4] Array.prototype.pop 원본 배열(this)에서 마지막 요소를 제거. 제거한 요소를 반환. / 원본 배열(this)이 빈 배열이면 undefined를 반환. 원본 배열(this)을 직접 변경한다. 스택 구조에서 사용. 12345678const arr = [1, 2];// 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.let result = arr.pop();console.log(result); // 2// pop 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [1] push 와 pop을 사용하여 stack 구현 1234567891011121314151617181920212223242526272829const Stack = (function () &#123; function Stack(array = []) &#123; if (!Array.isArray(array)) &#123; throw new TypeError(`$&#123;array&#125; is not an array.`); &#125; this.array = array; &#125; // 스택의 가장 마지막에 데이터를 밀어 넣는다. Stack.prototype.push = function (value) &#123; return this.array.push(value); &#125;; // 스택의 가장 마지막 데이터, 즉 가장 나중에 밀어 넣은 최신 데이터를 꺼낸다. Stack.prototype.pop = function () &#123; return this.array.pop(); &#125;; return Stack;&#125;());const stack = new Stack([1, 2]);console.log(stack); // [1, 2]stack.push(3);console.log(stack); // [1, 2, 3]stack.pop(); // -&gt; 3console.log(stack); // [1, 2] Array.prototype.unshift 인수로 전달받은 모든 값을 원본 배열(this)의 선두에 요소로 추가 변경된 length 값을 반환. 원본 배열(this)을 직접 변경한다. 12345678const arr = [1, 2];// 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다.let result = arr.unshift(3, 4); // [3, 4 , ...arr]; // ES6 Spread 문법console.log(result); // 4// unshift 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [3, 4, 1, 2] Array.prototype.shift 원본 배열(this)에서 첫번째 요소를 제거. 제거한 요소를 반환. / 원본 배열(this)이 빈 배열이면 undefined를 반환. shift 메소드는 원본 배열(this)을 직접 변경. 큐 구조에서 사용. 12345678const arr = [1, 2];// 원본 배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다.let result = arr.shift();console.log(result); // 1// shift 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [2] shift 와 pop을 사용하여 queqe 구현 1234567891011121314151617181920212223242526272829const Queue = (function () &#123; function Queue(array = []) &#123; if (!Array.isArray(array)) &#123; throw new TypeError(`$&#123;array&#125; is not an array.`); &#125; this.array = array; &#125; // 큐의 가장 마지막에 데이터를 밀어 넣는다. Queue.prototype.push = function (value) &#123; return this.array.push(value); &#125;; // 큐의 가장 처음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 꺼낸다. Queue.prototype.shift = function () &#123; return this.array.shift(); &#125;; return Queue;&#125;());const queue = new Queue([1, 2]);console.log(queue); // [1, 2]queue.push(3);console.log(queue); // [1, 2, 3]queue.shift(); // -&gt; 1console.log(queue); // [2, 3] Array.prototype.concat 인수로 전달된 값들(배열 또는 값)을 원본 배열(this)의 마지막 요소로 추가. 추가된 요소 새로운 배열을 만들어 반환. 인수로 전달한 값이 배열인 경우, 배열을 해체하여 새로운 배열의 요소로 추가. 원본 배열(this)은 변경되지 않음. 123456789101112131415161718const arr1 = [1, 2];const arr2 = [3, 4];// 배열 arr2를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환// 인수로 전달한 값이 배열인 경우, 배열을 해체하여 새로운 배열의 요소로 추가한다.let result = arr1.concat(arr2); // [...[1, 2], ...[3, 4]];console.log(result); // [1, 2, 3, 4]// 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환result = arr1.concat(3);console.log(result); // [1, 2, 3]// 배열 arr2와 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환result = arr1.concat(arr2, 5);console.log(result); // [1, 2, 3, 4, 5]// 원본 배열은 변경되지 않는다.console.log(arr1); // [1, 2] Array.prototype.splice 원본 배열(this)의 중간에 요소를 추가하거나 중간에 있는 요소를 제거. 원본 배열을 직접 변경한다. splice 메소드는 3개의 매개변수를 갖는다. start : 원본 배열의 요소를 제거하기 시작할 인덱스. start 만을 지정하면 원본 배열의 start부터 모든 요소를 제거. deleteCount : 원본 배열의 요소를 제거하기 시작할 인덱스인 start부터 제거할 요소의 개수. [deleteCount가 0인 경우, 아무런 요소도 제거] items : 제거한 위치에 삽입될 요소들의 목록. [ 생략할 경우, 원본 배열에서 지정된 요소들을 제거 ] 123456789const arr = [1, 2, 3, 4];// 원본 배열의 인덱스 1부터 2개의 요소를 제거하고 그 자리에 새로운 요소 20, 30을 삽입한다.const result = arr.splice(1, 2, 20, 30);// 제거한 요소가 배열로 반환된다.console.log(result); // [2, 3]// splice 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [1, 20, 30, 4] Array.prototype.slice slice 메소드는 인수로 전달된 범위의 요소들을 복사하여 반환. 원본 배열은 변경되지 않음. slice 메소드는 2개의 매개변수를 갖는다. start : 복사를 시작할 인덱스. 음수인 경우, 배열의 끝에서의 인덱스를 나타냄. ex) slice(-2)는 배열의 마지막 2개 요소를 반환. end : 복사를 종료할 인덱스. 이 인덱스에 해당하는 요소는 복사되지 않는다. 기본값은 length 값. start / end 전부 생략 시 다 뜯어냄. end만 생략시 start부터 전부 뜯어냄. slice로 복사한 내용은 얕은복사로 취급. (깊은 복사를 하고 싶다면 lodash 의 deep copy로 구현) 123456789101112const arr = [1, 2, 3];// arr[0]부터 arr[1] 이전(arr[1] 미포함)까지 복사하여 반환한다.let result = arr.slice(0, 1);console.log(result); // [1]// arr[1]부터 arr[2] 이전(arr[2] 미포함)까지 복사하여 반환한다.result = arr.slice(1, 2);console.log(result); // [2]// 원본은 변경되지 않는다.console.log(arr); // [1, 2, 3] slice를 이용한 유사 배열 객체를 배열로 변환 123456789101112function sum() &#123; // 유사 배열 객체를 배열로 변환(ES5) var arr = Array.prototype.slice.call(arguments); // const arr = [...arguments ]; (ES6 Spread 문법) console.log(arr); // [1, 2, 3] return arr.reduce(function (pre, cur) &#123; return pre + cur; &#125;, 0);&#125;console.log(sum(1, 2, 3)); // 6 Array.prototype.indexOf 원본 배열(this)에서 인수로 전달된 요소를 검색하여 인덱스를 반환. 중복되는 요소가 있는 경우, 첫번째 인덱스를 반환. 해당하는 요소가 없는 경우, -1을 반환. 12345678const arr = [1, 2, 2, 3];// 배열 arr에서 요소 2를 검색하여 첫번째 인덱스를 반환arr.indexOf(2); // -&gt; 1// 배열 arr에서 요소 4가 없으므로 -1을 반환arr.indexOf(4); // -1// 두번째 인수는 검색을 시작할 인덱스이다. 두번째 인수를 생략하면 처음부터 검색한다.arr.indexOf(2, 2); // 2 Array.prototype.join 원본 배열(this)의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 값, 즉 구분자(separator)로 연결한 문자열을 반환. 구분자는 생략 가능하며 기본 구분자는 ‘,’이다. 1234567891011121314const arr = [1, 2, 3, 4];// 기본 구분자는 ','이다.// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 기본 구분자 ','로 연결한 문자열을 반환let result = arr.join();console.log(result); // '1,2,3,4';// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 빈문자열로 연결한 문자열을 반환result = arr.join('');console.log(result); // '1234'// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환result = arr.join(':');console.log(result); // '1:2:3:4' Array.prototype.reverse 원본 배열(this)의 요소 순서를 반대로 변경한다. 원본 배열이 변경된다. 반환값은 변경된 배열이다. 1234567const arr = [1, 2, 3];const result = arr.reverse();// reverse 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [3, 2, 1]// 반환값은 변경된 배열이다.console.log(result); // [3, 2, 1] Array.prototype.fill ES6에서 새롭게 도입된 fill 메소드는 인수로 전달 받은 값을 배열의 처음부터 끝까지 채움. 원본 배열이 변경된다. 두번째 인수로 요소 채우기를 시작할 인덱스를 전달할 수 있다. 세번째 인수로 요소 채우기를 멈출 인덱스를 전달할 수 있다. 1234567891011121314151617181920212223const arr = [1, 2, 3];// 인수로 전달 받은 값 0을 요소로 배열의 처음부터 끝까지 채운다.arr.fill(0);// fill 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [0, 0, 0]const arr2 = [1, 2, 3];// 인수로 전달 받은 값 0를 요소로 배열의 인덱스 1부터 끝까지 채운다.arr2.fill(0, 1);// fill 메소드는 원본 배열을 직접 변경한다.console.log(arr2); // [1, 0, 0]const arr3 = [1, 2, 3, 4, 5];// 인수로 전달 받은 값 0를 요소로 배열의 인덱스 1부터 3 이전(인덱스 3 미포함)까지 채운다.arr3.fill(0, 1, 3);// fill 메소드는 원본 배열을 직접 변경한다.console.log(arr3); // [1, 0, 0, 4, 5] fill vs Array.from fill은 하나의 값만으로 채운다. 동적인 값을 채운다면 Array.from을 이용하면 값을 만들어 내면서 요소를 채운다. 123456// 인수로 전달받은 정수만큼 요소를 생성하고 0부터 1씩 증가하면 요소를 채운다.function generateSequences(length = 0) &#123; return Array.from(new Array(length), (v, i) =&gt; i);&#125;console.log(generateSequences(3)); // [0, 1, 2] Array.prototype.includes ES7에서 새롭게 도입된 includes 메소드는 배열 내에 특정 요소가 포함되어 있는지 확인 true 또는 false를 반환. 두번째 인수로 검색을 시작할 인덱스를 전달할 수 있다. 1234567891011121314const arr = [1, 2, 3];// 배열에 요소 2가 포함되어 있는지 확인한다.let result = arr.includes(2);console.log(result); // true// 배열에 요소 100이 포함되어 있는지 확인한다.result = arr.includes(100);console.log(result); // false// 두번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.// 배열에서 요소 1가 포함되어 있는지 인덱스 1부터 확인한다.result = arr.includes(1, 1);console.log(result); // false","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Array Method","slug":"Array-Method","permalink":"https://hyeok999.github.io/tags/Array-Method/"},{"name":"Array","slug":"Array","permalink":"https://hyeok999.github.io/tags/Array/"},{"name":"Method","slug":"Method","permalink":"https://hyeok999.github.io/tags/Method/"}]},{"title":"javascript-study-12","slug":"javascript-study-12","date":"2019-10-21T04:37:40.000Z","updated":"2019-11-30T16:28:36.345Z","comments":true,"path":"2019/10/21/javascript-study-12/","link":"","permalink":"https://hyeok999.github.io/2019/10/21/javascript-study-12/","excerpt":"","text":"JavaScript Study 12 용어 코딩스킬 화살표 함수 배열 ( Array ) 자바스크립트 배열은 배열이 아니다. 해시 테이블 일반적인 배열과 자바스크립트 배열의 장단점 정리 배열 생성 배열 리터럴 Array 생성자 함수 Array.from Array.of 배열 요소의 참조 배열 요소의 추가와 갱신 배열 요소의 삭제 배열 메소드 고차함수 용어 - ( 러버덕 ) 자바스크립트의 배열 화살표함수 배열 (생성, 참조, 추가 및 갱신, 삭제) 배열 메소드 고차 함수 코딩스킬 빌트인 API(ECMA Script) 웹 API - DOM, XMLHTTPRequset( Ajax ) 코딩스킬은 게속 쳐봐야한다. 화살표 함수화살표 함수는 선언문이 없고 반드시 변수에 담는 표현식(리터럴)만 제공한다. 코드 블록이 한줄 짜리라면 return과 {} 생략해서 사용이 가능하다. 코드 블록이 두줄 이상이라면 return 과 {}을 생략해서는 안된다. 따라서 화살표 함수는 한 줄 짜리 함수를 원하는 것. 매개 변수 선언 : 매개변수가 여러개 인 경우 () 내에 적는다. 1(x, y) =&gt; &#123; ... &#125; // true 매개 변수가 한 개인 경우 : ()를 생략이 가능하다. 1x =&gt; &#123;...&#125; 매개 변수가 없는 경우 : ()는 생략이 불가능하다. 1() =&gt; &#123; ... &#125; 배열 ( Array )객체 : 여러개의 데이터를 하나의 그룹( 키와 값 )으로 하여 관리한다. 값의 이름(키)이 있기 때문에 찾는 속도가 빠르다. 배열 : 객체와 다르게 값만 있기 때문에, 각 값들을 요소라 하고 요소를 찾기 위해서는 순서(인덱스) 를 이용한다. 배열은 for문으로 순회하기 좋은 자료구조이다. 자바스크립트에 배열이라는 타입은 존재하지 않는다. 배열은 객체이다. 1typeof arr // -&gt; object 배열은 순서를 지니고 있으므로 접근할 때 대괄호 표기법 와 index 으로 접근한다. 1234const arr = ['apple', 'banana', 'orange'];arr[0] // -&gt; 'apple'arr[1] // -&gt; 'banana'arr[2] // -&gt; 'orange' 배열은 요소의 개수, 즉 배열의 길이를 나타내는 length 프로퍼티를 갖는다. 1arr.length // -&gt; 3 자바스크립트 배열은 배열이 아니다. 타 언어의 배열의 요소는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열(Dense array)이라 한다. 이처럼 배열의 요소는 동일한 크기를 갖으며 빈틈없이 연속적으로 이어져 있으므로 아래와 같이 인덱스를 통해 단 한번의 연산으로 임의의 요소에 접근(임의 접근(Random access), 시간 복잡도 O(1))할 수 있다. 이는 매우 효율적이며 고속으로 동작한다. 1검색 대상 요소의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수 인덱스가 0인 요소의 메모리 주소 : 1000 + 0 * 8 = 1000 인덱스가 1인 요소에 메모리 주소 : 1000 + 1 * 8 = 1008 인덱스가 2인 요소에 메모리 주소 : 1000 + 2 * 8 = 1016 이처럼 배열은 인덱스를 통해 효율적으로 요소에 접근할 수 있다는 장점이 있다.하지만 정렬되지 않은 배열에서 특정한 값을 탐색하는 경우, 시간 복잡도 O(n))의 문제가 있다.또 배열에 요소를 삽입하거나 삭제하는 경우, 배열 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점도 있다. 자바스크립트의 배열 일반적인 배열과 다르다.배열의 요소가 연속적으로 이어져 있지 않고 비어있을 수도 있고 크기도 서로 다른 이러한 배열을 희소 배열(sparse array)이라 한다. 자바스크립트의 배열은 일반적인 배열의 동작을 흉내낸 특수한 객체이다. 1234567891011const arr = [1, 2, 3];console.log(Object.getOwnPropertyDescriptors(arr));/*&#123; '0': &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;, '1': &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;, '2': &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;, length: &#123; value: 3, writable: true, enumerable: false, configurable: false &#125;&#125;*/ 자바스크립트 배열의 요소는 사실 프로퍼티 값이다.자바스크립트에서 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 타입의 값이라도 배열의 요소가 될 수 있다. 123456789101112const arr = [ 'string', 10, true, null, undefined, NaN, Infinity, [ ], &#123; &#125;, function () &#123;&#125;]; 해시 테이블해시 함수를 사용하여 메모리의 위치를 지정한다. 해시는 배열 요소를 삽입하거나 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다. 자바스크립트의 배열은 해시 테이블로 구현된 객체로 구현되어 있기에 인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 구조적인 단점을 가지고 있다. 따라서 대부분의 모던 자바스크립트 엔진은 이러한 단점을 보완하기 위해 배열을 일반 객체와 구별하여 보다 배열처럼 동작하도록 최적화하여 구현하였다. 따라서 성능상 일반적인 타 언어의 배열보다 느리지 않다. 1234567891011121314151617const arr = []; //자바스크립트의 배열console.time('Array Performance Test');for (let i = 0; i &lt; 10000000; i++) &#123; arr[i] = i;&#125;console.timeEnd('Array Performance Test');// 약 340msconst obj = &#123;&#125;; //자바스크립트의 객체console.time('Object Performance Test');for (let i = 0; i &lt; 10000000; i++) &#123; obj[i] = i;&#125;console.timeEnd('Object Performance Test');// 약 600ms 일반적인 배열과 자바스크립트 배열의 장단점 정리 일반적인 배열은 인덱스로 배열 요소에 빠르게 접근할 수 있지만 요소를 삽입하거나 삭제하는 경우에는 효율적이지 않다. 자바스크립트 배열은 기본적으로 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근할 때 성능적인 면에서 일반적인 배열보다 느릴 수 밖에 없는 구조적인 단점을 갖지만 배열 요소를 삽입하거나 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다. ( 단점은 JS 엔진 브라우저 벤더사들에 의하여 보완되고 있다. ) 배열 생성배열 리터럴12const arr = [1, 2, 3];console.log(arr.length); // 3 빈 배열의 length 값은 0 이다. 12const arr = [];console.log(arr.length); // 0 객체의 프로퍼티 값이 없는 키를 참조 할 경우, undefined를 반환하는데, 배열도 똑같다. 빈 배열의 요소를 참조하면 undefined를 반환한다. 12const arr = [1, , 3]; // 희소 배열console.log(arr[1]); // undefined Array 생성자 함수 전달된 인수가 1개이고 숫자인 경우, 인수를 length 프로퍼티의 값으로 갖는 배열을 생성한다. 123const arr = new Array(10);console.log(arr); // [empty × 10]console.log(arr.length); // 10 전달된 인수가 없는 경우, 빈 배열을 생성한다. 즉, 배열 리터럴 []과 같다. 12const empty = new Array();console.log(empty); // [] 전달된 인수가 2개 이상이거나 숫자가 아닌 경우, 인수를 요소로 갖는 배열을 생성한다. 1234567// 전달된 인수가 1개이지만 숫자가 아니면 인수를 요소로 갖는 배열을 생성한다.const arr1 = new Array(&#123;&#125;);console.log(arr1); // [&#123;&#125;]// 전달된 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.const arr2 = new Array(1, 2, 3);console.log(arr2); // [1, 2, 3] new 키워드 없이도 사용이 가능하다. const arr = Array(1, 2, 3); Array.ofES6에서 새롭게 도입. 정적메소드다. Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다. 12345const arr1 = Array.of(1);console.log(arr1); // [1]const arr3 = Array.of('string');console.log(arr3); // 'string' Array.fromES6에서 새롭게 도입. 유사 배열 객체(array-like object) or 이터러블 객체(iterable object)를 변환하여 새로운 배열을 생성한다. 1234567// 문자열은 이터러블이다.const arr1 = Array.from('Hello');console.log(arr1); // [ 'H', 'e', 'l', 'l', 'o' ]// 유사 배열 객체를 새로운 배열을 변환하여 반환한다.const arr2 = Array.from(&#123; length: 2, 0: 'a', 1: 'b' &#125;);console.log(arr2); // [ 'a', 'b' ] 2번째 인수로 전달한 함수를 통해 값을 만들면서 요소를 채울 수 있다.동적으로 배열을 만들 수 있다. 1234// Array.from의 두번째 인수로 배열의 모든 요소에 대해 호출할 함수를 전달할 수 있다.// 이 함수는 첫번째 인수에 의해 생성된 배열의 요소값괴 인덱스를 순차적으로 전달받아 호출된다.const arr3 = Array.from(&#123; length: 5 &#125;, function (v, i) &#123; return i; &#125;);console.log(arr3); // [ 0, 1, 2, 3, 4 ] 배열 요소의 참조존재하지 않는 요소에 접근하면 undefined가 반환된다. 배열은 사실 인덱스를 프로퍼티 키로 갖는 객체이다. 12345const arr = [1, 2];// 인덱스가 2인 요소를 참조// 배열 arr에 인덱스가 2인 요소는 존재하지 않는다.console.log(arr[2]); // undefined 배열 요소의 추가와 갱신객체에 프로퍼티를 동적으로 추가할 수 있는 것처럼 배열에도 요소를 동적으로 추가할 수 있다. 1234567const arr = [0];// 배열 요소의 추가arr[1] = 1;console.log(arr); // [ 0, 1 ]console.log(arr.length); // 2 만약 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다. 12345// 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다.arr[100] = 100;console.log(arr); // [0, 1, empty × 98, 100]console.log(arr.length); // 101 이미 요소가 존재하는 요소에 값을 재할당하면 요소값이 갱신된다. 1234// 요소값의 갱신arr[1] = 10;console.log(arr); // [0, 10, empty × 98, 100] 인덱스에 정수 이외의 값을 넣게 되면 요소가 아닌 프로퍼티가 생성된다. 123456789101112131415const arr = [];// 배열 요소의 추가arr[0] = 1;arr['1'] = 2;// 프로퍼티 추가arr['foo'] = 3;arr[1.1] = 4;arr[-1] = 5;console.log(arr); // [1, 2, foo: 3, 1.1: 4, -1: 5]// 프로퍼티는 length에 영향을 주지 않는다.console.log(arr.length); // 2 배열 요소의 삭제delete 를 사용하게 되면 특정 요소를 empty로 비워둔다. 즉, 삭제가 아니라 희소배열처럼 비우게된다. (length값은 그대로)따서 그냥 delete 연산자 말고 splice , pop , shift 등을 사용한다. 12345678910const arr = [1, 2, 3];// 배열 요소의 삭제delete arr[1]; console.log(arr); // [1, empty, 3]console.log(arr.length); // 3 - length 그대로.arr.splice(1, 1);console.log(arr); // [1, 3]console.log(arr.length); // 2 - length 프로퍼티에 변경이 반영된다. 배열 메소드 배열 메소드 고차함수 고차함수","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 26강 배열 및 고차함수 2","slug":"javascript-preview-26-2","date":"2019-10-20T16:33:20.000Z","updated":"2019-11-30T16:38:30.304Z","comments":true,"path":"2019/10/21/javascript-preview-26-2/","link":"","permalink":"https://hyeok999.github.io/2019/10/21/javascript-preview-26-2/","excerpt":"","text":"JavaScript 26강 배열 고차 함수 26강 : 배열 개요 및 배열 메소드 배열 고차 함수 Array.prototype.sort() Array.prototype.forEach Array.prototype.map Array.prototype.filter Array.prototype.reduce Array.prototype.some Array.prototype.every Array.prototype.find Array.prototype.findIndex 26강 - 226강 - 1 내용 : 배열 개요 및 배열 메소드 배열 고차함수고차 함수(High Order Function, HOF)는 함수를 인자로 전달받거나 함수를 반환하는 함수를 말한다.다시 말해, 고차 함수는 인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환한다. 반복문,조건문은 가독성을 해치고, 변수의 값에 대한 보호가 안되기 때문에 오류 발생의 원이 될 수 있다. 함수형 프로그래밍은 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환으로 고차함수를 사용한다. 12345678910111213141516171819202122232425262728293031// 고차 함수 makeCounter는 함수를 인수로 전달받고 클로저를 반환한다.function makeCounter(predicate) &#123; // 자유 변수. num의 상태는 유지되어야 한다. let num = 0; // num의 상태를 유지하는 클로저를 반환한다. return function () &#123; // predicate를 호출하여 자유 변수 num의 상태를 변화시킨다. num = predicate(num); return num; &#125;;&#125;// 보조 함수function increase(n) &#123; return ++n;&#125;// 보조 함수function decrease(n) &#123; return --n;&#125;// 고차 함수 makeCounter는 함수를 인수로 전달받고 클로저를 반환한다.const increaser = makeCounter(increase);console.log(increaser()); // 1console.log(increaser()); // 2// 고차 함수 makeCounter는 함수를 인수로 전달받고 클로저를 반환한다.const decreaser = makeCounter(decrease);console.log(decreaser()); // -1console.log(decreaser()); // -2 Array.prototype.sort() 배열의 요소를 적절하게 정렬한다. 원본 배열을 적접 변경하여 정렬된 배열을 반환한다. 오름차순으로 정렬한다. 내림차순은 reverse 메소를 사용한다. sort 메소드는 Unicode 순서(문자열)로 정렬을 하기 떄문에 숫자는 배치를 해주지 않는다. 1234567const fruits = ['Banana', 'Orange', 'Apple'];// 오름차순(ascending) 정렬fruits.sort();// sort 메소드는 원본 배열을 직접 변경한다.console.log(fruits); // ['Apple', 'Banana', 'Orange'] 위 예제처럼 문자열은 문제 없이 오름차순 정렬이 된다. 123456const points = [40, 100, 1, 5, 2, 25, 10];points.sort();// 숫자 요소들로 이루어진 배열은 의도한 대로 정렬되지 않는다.console.log(points); // [1, 10, 100, 2, 25, 40, 5] 하지만 숫자로 된 배열을 sort 시에는 문제가 생긴다. 따라서 아래와 같은 코드를 이용한다. 배열명.sort(function(a,b){return a - b;}); : 숫자 정렬시 사용. 오름차순으로 정렬한다.배열명.sort(function(a,b){return b - a;}) : 숫자 정렬 시 사용. 내림차순으로 정렬한다. 123456789const points = [40, 100, 1, 5, 2, 25, 10];// 비교 함수의 반환값이 0보다 작은 경우, a를 우선하여 정렬한다. 오름차순 정렬points.sort(function (a, b) &#123; return a - b; &#125;);console.log(points); // [1, 2, 5, 10, 25, 40, 100]// 비교 함수의 반환값이 0보다 큰 경우, b를 우선하여 정렬한다. 내림차순 정렬points.sort(function (a, b) &#123; return b - a; &#125;);console.log(points); // [100, 40, 25, 10, 5, 2, 1] 객체를 요소로 갖는 배열을 정렬하는 예제는 아래와 같다. 1234567891011121314151617181920212223242526272829303132333435const todos = [ &#123; id: 4, content: 'JavaScript' &#125;, &#123; id: 1, content: 'HTML' &#125;, &#123; id: 2, content: 'CSS' &#125;];// 비교 함수function compare(key) &#123; return function (a, b) &#123; // 프로퍼티 값이 문자열인 경우, - 산술 연산으로 비교하면 NaN이 나오므로 비교 연산을 사용한다. return a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0); &#125;;&#125;// id를 기준으로 정렬todos.sort(compare('id'));console.log(todos);/*[ &#123; id: 1, content: 'HTML' &#125;, &#123; id: 2, content: 'CSS' &#125;, &#123; id: 4, content: 'JavaScript' &#125;]*/// content를 기준으로 정렬todos.sort(compare('content'));console.log(todos);/*[ &#123; id: 2, content: 'CSS' &#125;, &#123; id: 1, content: 'HTML' &#125;, &#123; id: 4, content: 'JavaScript' &#125;]*/ Array.prototype.forEach forEach 메소드는 for 문을 대체할 수 있는 메소드이다. forEach의 반환값은 undefined다. 희소 배열의 존재하지 않는 요소는 순회 대상에서 제외된다. 원본 배열을 변경할 수 없다. (단, 콜백함수가 변경할수는 있다.) 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백함수를 실행한다. 배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다.(즉, break / continue 사용 불가) this를 전달 받을 수 있다. 123456789// forEach 메소드는 전달받은 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.[1, 2, 3].forEach((item, index, self) =&gt; &#123; console.log(`요소값: $&#123;item&#125;, 인덱스: $&#123;index&#125;, this: $&#123;self&#125;`);&#125;);/*요소값: 1, 인덱스: 0, this: 1,2,3요소값: 2, 인덱스: 1, this: 1,2,3요소값: 3, 인덱스: 2, this: 1,2,3*/ 12345678910111213141516const numbers = [1, 2, 3];let pows = [];// for 문으로 순회for (let i = 0; i &lt; numbers.length; i++) &#123; pows.push(numbers[i] ** 2);&#125;console.log(pows); // [1, 4, 9]pows = [];// forEach 메소드로 순회numbers.forEach(item =&gt; pows.push(item ** 2));console.log(pows); // [1, 4, 9] numbers에 있는 각 요소를 item이라 하고 item 제곱화하여 pows에 각각 담는다. forEach 메소드는 원본 배열(this)을 변경하지 않는다. 하지만 콜백 함수가 원본 배열(this)을 변경할 수는 있다. 12345const numbers = [1, 2, 3];// 원본 배열을 직접 변경하려면 콜백 함수의 3번째 인자(this)를 사용한다.numbers.forEach((item, index, self) =&gt; self[index] = Math.pow(item, 2));console.log(numbers); // [1, 4, 9] forEach 메소드에 2번째 인자로 forEach 메소드 내부에서 this로 사용될 객체를 전달할 수 있다. 12345678910111213141516171819202122class Numbers &#123; numberArray = []; errorMultiply(arr) &#123; arr.forEach(function (item) &#123; // 일반 함수로 호출되는 콜백 함수 내부의 this는 전역 객체를 가리킨다. // TypeError: Cannot read property 'numberArray' of undefined this.numberArray.push(item * item); &#125;); &#125; multiply(arr) &#123; arr.forEach(function (item) &#123; // 외부에서 this를 전달하지 않으면 this는 전역 객체를 가리킨다. this.numberArray.push(item * item); &#125;, this); // forEach 메소드 내부에서 this로 사용될 객체를 전달 &#125;&#125;const numbers = new Numbers();numbers.multiply([1, 2, 3]);console.log(numbers.numberArray); // [1 , 4 , 9] 더 손쉽게는 ES6의 화살표 함수를 이용한다. 12345678910111213class Numbers &#123; numberArray = []; multiply(arr) &#123; // 화살표 함수 내부에서 this를 참조하면 // 상위 컨텍스트, 즉 multiply 메소드 내부의 this를 그대로 참조한다. arr.forEach(item =&gt; this.numberArray.push(item * item)); &#125;&#125;const numbers = new Numbers();numbers.multiply([1, 2, 3]);console.log(numbers.numberArray); // [1, 4, 9] Array.prototype.map 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행한다. 콜백 함수의 반환한 값들이 요소로서 추가된 새로운 배열을 반환한다. 원본 배열은 변경되지 않는다. 희소 배열의 존재하지 않는 요소는 순회 대상에서 제외된다. this를 전달 받을 수 있다. 12345678910// map 메소드는 전달받은 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.[1, 2, 3].map((item, index, self) =&gt; &#123; console.log(`요소값: $&#123;item&#125;, 인덱스: $&#123;index&#125;, this: $&#123;self&#125;`); return item;&#125;);/*요소값: 1, 인덱스: 0, this: 1,2,3요소값: 2, 인덱스: 1, this: 1,2,3요소값: 3, 인덱스: 2, this: 1,2,3*/ 12345678910111213const numbers = [1, 4, 9];// 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행한다.// 그리고 콜백 함수의 반환한 값들이 요소로서 추가된 새로운 배열을 반환한다.const roots = numbers.map(item =&gt; Math.sqrt(item));// 위 코드의 축약표현은 아래와 같다.// const roots = numbers.map(Math.sqrt);// map 메소드는 새로운 배열을 반환한다console.log(roots); // [ 1, 2, 3 ]// map 메소드는 원본 배열은 변경하지 않는다console.log(numbers); // [ 1, 4, 9 ] 새로운 배열의 length는 map 메소드를 호출한 배열, 즉 this의 length와 반드시 일치한다. forEach 메소드와 마찬가지로 map 메소드에 두번째 인자로 map 메소드 내부에서 this로 사용될 객체를 전달할 수 있다. 1234567891011121314151617class Prefixer &#123; constructor(prefix) &#123; this.prefix = prefix; &#125; prefixArray(arr) &#123; return arr.map(function (item) &#123; // 외부에서 this를 전달하지 않으면 this는 전역 객체를 가리킨다. return this.prefix + item; &#125;, this); // map 메소드 내부에서 this로 사용될 객체를 전달 &#125;&#125;const pre = new Prefixer('-webkit-');const preArr = pre.prefixArray(['linear-gradient', 'border-radius']);console.log(preArr);// ['-webkit-linear-gradient', '-webkit-border-radius'] 보다 나은 방법은 ES6의 화살표 함수를 사용하는 것이다. 12345678910111213141516class Prefixer &#123; constructor(prefix) &#123; this.prefix = prefix; &#125; prefixArray(arr) &#123; // 화살표 함수 내부에서 this를 참조하면 // 상위 컨텍스트, 즉 multiply 메소드의 this를 그대로 참조한다. return arr.map(item =&gt; this.prefix + item); &#125;&#125;const pre = new Prefixer('-webkit-');const preArr = pre.prefixArray(['linear-gradient', 'border-radius']);console.log(preArr);// ['-webkit-linear-gradient', '-webkit-border-radius'] Array.prototype.filter 배열을 순회하며 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행한다. 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환 원본 배열은 변경되지 않는다. this를 전달 받을 수 있다. 12345678910// filter 메소드는 전달받은 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.[1, 2, 3].filter((item, index, self) =&gt; &#123; console.log(`요소값: $&#123;item&#125;, 인덱스: $&#123;index&#125;, this: $&#123;self&#125;`); return item % 2;&#125;);/*요소값: 1, 인덱스: 0, this: 1,2,3요소값: 2, 인덱스: 1, this: 1,2,3요소값: 3, 인덱스: 2, this: 1,2,3*/ 123456const numbers = [1, 2, 3, 4, 5];// 홀수만을 필터링한다 (1은 true로 평가된다)const odds = numbers.filter(item =&gt; item % 2);console.log(odds); // [1, 3, 5] Array.prototype.reduce reduce 메소드는 배열을 순회하며 콜백 함수의 이전 반환값과 배열의 각 요소에 대하여 인자로 주어진 콜백 함수를 실행하여 하나의 결과값을 반환한다. 원본 배열은 변경되지 않는다. 첫번째 인수로 콜백 함수 [ 반환값, 요소값, 인덱스, reduce호출한 배열(this)] 두번째 인수는 초기값. reduce 메소드는 배열을 순회하며 단일값을 구해야 하는 경우에 사용한다. 1234// 1부터 4까지 누적을 구한다.const sum = [1, 2, 3, 4].reduce((pre, cur, index, self) =&gt; pre + cur, 0);console.log(sum); // 10 첫번째 인수로 전달받은 콜백 함수는 4개의 인수를 전달받아 배열의 length만큼 총 4회 호출된다. 이때 콜백 함수로 전달되는 인수와 반환값은 아래와 같다. 구분 콜백 함수에 전달된 인수 콜백 함수의 반환값 pre cur index self 첫번째 순회 0 (초기값) 1 0 [1, 2, 3, 4] 1 (pre + cur) 두번째 순회 1 2 1 [1, 2, 3, 4] 3 (pre + cur) 세번째 순회 3 3 2 [1, 2, 3, 4] 6 (pre + cur) 네번째 순회 6 4 3 [1, 2, 3, 4] 10 (pre + cur 평균 구하기 123456789101112const values = [1, 2, 3, 4, 5, 6];const average = values.reduce((pre, cur, i, self) =&gt; &#123; // 마지막 순회인 경우, 누적값으로 평균을 구해 반환 if (i === self.length - 1) &#123; return (pre + cur) / self.length; &#125; // 마지막 순회가 아닌 경우, 누적값을 반환 return pre + cur;&#125;);console.log(average); // 3 최대값 구하기 12345678910const values = [1, 2, 3, 4, 5];const max = values.reduce((pre, cur) =&gt; (pre &gt; cur ? pre : cur), 0);console.log(max); // 5하지만 Math.max 메소드를 사용하는 방법이 보다 직관적이다.const values = [1, 2, 3, 4, 5];const max = Math.max(...values);console.log(max); // 5 중복된 요소의 개수 구하기 1234567891011const fruits = ['banana', 'apple', 'orange', 'orange', 'apple'];const count = fruits.reduce((pre, cur) =&gt; &#123; // 첫번째 순회: pre =&gt; &#123;&#125;, cur =&gt; 'banana' // 빈 객체에 요소값을 프로퍼티 키로 추가하고 프로퍼티 값을 할당 // 만약 프로퍼티 값이 undefined이면 0으로 초기화 pre[cur] = (pre[cur] || 0) + 1; return pre;&#125;, &#123;&#125;);console.log(count); // &#123; banana: 1, apple: 2, orange: 2 &#125; 중첩 배열 평탄화 123456const values = [1, [2, 3], 4, [5, 6]];const flatten = values.reduce((pre, cur) =&gt; pre.concat(cur), []);// [1] =&gt; [1, 2, 3] =&gt; [1, 2, 3, 4] =&gt; [1, 2, 3, 4, 5, 6]console.log(flatten); // [1, 2, 3, 4, 5, 6] 중복 요소 제거 ( reduce보다는 filter이용하는게 더 직관적이다. ) 1234567891011121314151617181920const values = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];const result = values.reduce((pre, cur, i, self) =&gt; &#123; // 순회중인 요소의 인덱스가 자신의 인덱스라면 처음 순회하는 요소이다. // 이 요소만 배열에 담아 반환한다. // 순회중인 요소의 인덱스가 자신의 인덱스가 아니라면 중복된 요소이다. // 3번째 순회: [1, 2], 1, 2, [1, 2, 1, 3, 5, 4, 5, 3, 4, 4] // if ([1, 2, 1, 3, 5, 4, 5, 3, 4, 4].indexOf(1) === 2) =&gt; if(0 === 2) if (self.indexOf(cur) === i) pre.push(cur); return pre;&#125;, []);console.log(result); // [1, 2, 3, 5, 4]// filter 사용 시const values2 = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];// 순회중인 요소의 인덱스가 자신의 인덱스라면 처음 순회하는 요소이다. 이 요소만 반환한다.const result = values2.filter((v, i, self) =&gt; self.indexOf(v) === i);console.log(result); // [1, 2, 3, 5, 4] 이처럼 map, filter, some, every, find와 같은 모든 배열 고차 함수는 reduce로 구현할 수 있다. 12const sum = [].reduce((pre, cur) =&gt; pre + cur);// TypeError: Reduce of empty array with no initial value 이처럼 빈 배열로 reduce 메소드를 호출하면 에러가 발생한다.reduce 메소드에 초기값을 전달하면 에러가 발생하지 않는다. 12const sum = [].reduce((pre, cur) =&gt; pre + cur, 0);console.log(sum); // 0 객체의 프로퍼티 값을 합산하는 경우에는 반드시 초기값을 전달해야 한다. 123456789101112const products = [ &#123; id: 1, price: 100 &#125;, &#123; id: 2, price: 200 &#125;, &#123; id: 3, price: 300 &#125;];// 1번째 순회 : pre =&gt; 0, cur =&gt; 100// 2번째 순회 : pre =&gt; 100, cur =&gt; 200// 3번째 순회 : pre =&gt; 300, cur =&gt; 300const priceSum = products.reduce((pre, cur) =&gt; pre + cur.price, 0);console.log(priceSum); // 600 Array.prototype.some 배열을 순회하며 요소 중 하나라도 콜백 함수의 테스트를 통과하면 true, 모든 요소가 콜백 함수의 테스트를 통과하지 못하면 false를 반환한다. 2번째 인자로 this를 전달 받을 수 있다. 1234567891011// 배열의 요소 중에 10보다 큰 요소가 1개 이상 존재하는지 확인let result = [5, 10, 15].some(item =&gt; item &gt; 10);console.log(result); // true// 배열의 요소 중에 0보다 작은 요소가 1개 이상 존재하는지 확인result = [5, 10, 15].some(item =&gt; item &lt; 0);console.log(result); // false// 배열의 요소 중에 'banana'가 1개 이상 존재하는지 확인result = ['apple', 'banana', 'mango'].some(item =&gt; item === 'banana');console.log(result); // true Array.prototype.every every 메소드는 배열을 순회하며 모든 요소가 콜백 함수의 테스트를 통과하면 true, 요소 중 하나라도 콜백 함수의 테스트를 통과하지 못하면 false를 반환한다. forEach, map, filter 메소드와 마찬가지로 every 메소드의 콜백 함수는 요소값, 인덱스, 메소드를 호출한 배열, 즉 this를 전달 받을 수 있다. 2번째 인자로 this를 전달 받을 수 있다. 1234567// 배열의 모든 요소가 3보다 큰지 확인let result = [5, 10, 15].every(item =&gt; item &gt; 3);console.log(result); // true// 배열의 모든 요소가 10보다 큰지 확인result = [5, 10, 15].every(item =&gt; item &gt; 10);console.log(result); // false Array.prototype.find 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다. 참인 요소가 존재하지 않는다면 undefined를 반환한다. 반드시 첫번쨰 요소만 반환하고 끝난다. 2번째 인자로 this를 전달 받을 수 있다. 아래 예제에서는 프로퍼티 id의 값이 2인 배열 요소가 2개 있다. 그러나 정작 반환하는 것은 name: ‘Kim’ 뿐이다. 123456789101112const users = [ &#123; id: 1, name: 'Lee' &#125;, &#123; id: 2, name: 'Kim' &#125;, &#123; id: 2, name: 'Choi' &#125;, &#123; id: 3, name: 'Park' &#125;];// id가 2인 요소를 반환한다.const result = users.find(item =&gt; item.id === 2);// Array#find는 배열이 아니라 요소를 반환한다.console.log(result); // &#123;id: 2, name: 'Kim'&#125; Array.prototype.findIndex 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다. 콜백 함수의 실행 결과가 참인 요소가 존재하지 않는다면 -1를 반환한다. 반드시 첫번쨰 요소의 인덱스만 반환하고 끝난다. 2번째 인자로 this를 전달 받을 수 있다. 1234567891011121314151617181920const users = [ &#123; id: 1, name: 'Lee' &#125;, &#123; id: 2, name: 'Kim' &#125;, &#123; id: 2, name: 'Choi' &#125;, &#123; id: 3, name: 'Park' &#125;];function predicate(key, value) &#123; // key와 value를 기억하는 클로저를 반환 return item =&gt; item[key] === value;&#125;// Array#findIndex는 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다.// id가 2인 요소의 인덱스를 구한다.let index = users.findIndex(predicate('id', 2));console.log(index); // 1// name이 'Park'인 요소의 인덱스를 구한다.index = users.findIndex(predicate('name', 'Park'));console.log(index); // 3","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"HOF","slug":"HOF","permalink":"https://hyeok999.github.io/tags/HOF/"},{"name":"Array","slug":"Array","permalink":"https://hyeok999.github.io/tags/Array/"}]},{"title":"javascript 26강 배열 및 고차함수 1","slug":"javascript-preview-26-1","date":"2019-10-20T16:32:05.000Z","updated":"2019-11-30T16:38:35.705Z","comments":true,"path":"2019/10/21/javascript-preview-26-1/","link":"","permalink":"https://hyeok999.github.io/2019/10/21/javascript-preview-26-1/","excerpt":"","text":"JavaScript 26강 예습 26강 : 배열 배열이란? 객체 vs 배열 JS 배열은 배열이 아니다. length 프로퍼티와 희소 배열 배열 생성 배열 리터럴 Array 생성자 함수 Array.of Array.from 유사 배열 객체와 이터러블 객체 배열 요소의 참조 배열 요소의 추가와 갱신 배열 요소의 삭제 배열 메소드 Array.isArray Array.prototype.push Array.prototype.pop Array.prototype.unshift Array.prototype.shift pop과 shift를 이용한 queqe 구현 pop과 push를 이용한 stack 구현 Array.prototype.concat Array.prototype.splice Array.prototype.slice Array.prototype.indexOf Array.prototype.join Array.prototype.reverse Array.prototype.fill Array.prototype.includes 고차 함수 26강 - 1배열배열이란? 순서가 있는 값들의 리스트를 의미한다. 하나의 변수에 여러 개의 값을 저장할 수 있는 장점이 있다. 배열이 가지고 있는 값을 요소(element)라 부른다. JS에서 값으로 인정하는 모든 것은 배열의 요소가 될 수 있다. 자바스크립트에서 배열이라는 타입은 존재하지 않는다. 배열은 객체이다. 1typeof arr // -&gt; object 배열은 배열리터럴 과 Array 생성자 함수로 생성 할 수 있다. 배열리터럴 1const arr = ['apple', 'banana', 'orange']; Array 생성자 12const arr = new Array();arr = ['apple', 'banana', 'orange']; 배열의 생성자 함수는 Array이며 배열의 프로토타입 객체는 Array.prototype이다. Array.prototype은 배열을 위한 빌트인 메소드 들을 제공한다. 객체 vs 배열 구분 객체 배열 구조 프로퍼티 키와 프로퍼티 값 인덱스와 요소 값의 참조 프로퍼티 키 인덱스 값의 순서 x ○ length 프로퍼티 x ○ JS 배열은 배열이 아니다.​ 일반적인 배열이라는 개념은 동일한 크기의 메모리공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. 일반적인 배열의 요소들은 하나의 타입으로 통일되어 서로 연속적으로 인접하고 있는 밀집 배열(Dense array)이다. 12검색 대상 요소의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수- 인덱스가 2인 요소에 메모리 주소 : 1000 + 2 * 8 = 1016 밀집 배열의 장점 : 한번의 연산으로 모든 요소에 접근이 가능하다. 효율적이면 고속으로 동작함.밀집 배열의 단점 : 특정 값 탐색 시 처음부터 선행 - 시간복잡도 O(n), 배열 삭제 및 삽입시 요소를 이동시켜야 함. ​ 자바스크립트의 배열은 요소를 위한 동일한 크기의 메모리를 할당해주지 않으며 연속적으로 나열하지도 않는다. 이러한 배열을 희소 배열(sparse array)이라 한다. 1234567891011const arr = [1, 2, 3];console.log(Object.getOwnPropertyDescriptors(arr));/*&#123; '0': &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;, '1': &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;, '2': &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;, length: &#123; value: 3, writable: true, enumerable: false, configurable: false &#125;&#125;*/ 위 예제를 보면 배열 arr은 각각 프로퍼티로 0 , 1 , 2 를 각각 가지고 있다. 즉 배열은 객체이다. JS에서 배열은 일반적인 배열을 흉내낸 객체이다. JS 배열의 장점 : 배열 요소를 삽입하거나 삭제하는 경우에는 해시 테이블을 따라 가기 때문에 일반 배열보다 빠르다.JS 배열의 단점 : 해시 테이블로 구현된 객체이므로 인덱스 자체로 배열 요소에 접근시 일반적인 배열보다 느린 구조다. 따라서 JS에서는 이러한 구조적 단점을 보안하고자 배열을 객체와 달리하여 속도를 향상시켰다. 1234567891011121314151617181920const arr = [];console.time('Array Performance Test');for (let i = 0; i &lt; 10000000; i++) &#123; arr[i] = i;&#125;console.timeEnd('Array Performance Test');// 약 340msconst obj = &#123;&#125;;console.time('Object Performance Test');for (let i = 0; i &lt; 10000000; i++) &#123; obj[i] = i;&#125;console.timeEnd('Object Performance Test');// 약 600ms 객체 obj는 배열 arr 보다 성능면에서 2배정도 차이가 났다. 객체 obj에게 숫자를 프로퍼티키로 주면 &#39;&#39;는 안붙지만 내부에서 암묵적으로 문자열로 변환된다. length 프로퍼티와 희소 배열length 프로퍼티는 요소의 개수, 즉 배열의 길이를 나타내는 정수를 값으로 갖는다. length 프로퍼티의 값은 빈 배열일 경우, 0이며 빈 배열이 아닐 경우, 가장 큰 인덱스에 1을 더한 것과 같다. 12[].length // -&gt; 0[1, 2, 3].length // -&gt; 3 배열에서 사용할 수 있는 가장 작은 인덱스는 0이며 가장 큰 인덱스는 232 – 2(4,294,967,294)이다. length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제하면 자동 갱신된다. 배열의 length에 임의의 숫자 값을 명시적으로 할당할 수도 있다. 현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다. 1234567const arr = [1, 2, 3, 4, 5];// length 프로퍼티에 현재 length 프로퍼티 값보다 작은 숫자 값을 할당arr.length = 3;// 배열의 길이가 줄어든다.console.log(arr); // [1, 2, 3] 만약 length에 프로퍼티 값보다 큰 값을 할당하면 length 프로퍼티 값은 변경되지만 실제로 배열의 길이가 늘어나지는 않는다. 12345678const arr = [1];// length 프로퍼티에 현재 length 프로퍼티 값보다 큰 숫자 값을 할당arr.length = 3;// length 프로퍼티 값은 변경되지만 실제로 배열의 길이가 늘어나지는 않는다.console.log(arr.length); // 3console.log(arr); // [1, empty × 2] 즉, arr[1]과 arr[2]에는 값이 존재하지 않는다. 값이 없이 비어있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다. 1234567console.log(Object.getOwnPropertyDescriptors(arr));/*&#123; '0': &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;, length: &#123; value: 3, writable: true, enumerable: false, configurable: false &#125;&#125;*/ 위와 같이 배열의 요소가 연속적으로 위치 하지 않고 땜방 마냥 비어있는 배열을 희소배열이라 한다. JS는 희소 배열을 문법적으로 허용하고 있으며 앞 , 중간 , 뒤 부분 어느곳도 비울 수 있다. 12345678910111213141516// 희소 배열const sparse = [, 2, , 4];// 희소 배열의 length 프로퍼티 값은 요소의 개수와 일치하지 않는다.console.log(sparse.length); // 4console.log(sparse); // [empty, 2, empty, 4]// 배열 sparse에는 인덱스가 0, 2인 요소가 존재하지 않는다.console.log(Object.getOwnPropertyDescriptors(sparse));/*&#123; '1': &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;, '3': &#123; value: 4, writable: true, enumerable: true, configurable: true &#125;, length: &#123; value: 4, writable: true, enumerable: false, configurable: false &#125;&#125;*/ 희소 배열은 length와 배열 요소의 개수가 일치하지 않는다. 희소 배열의 length는 실제 배열의 요소 개수보다 언제나 크다. 배열 생성배열 리터럴배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 대괄호([])로 묶는다. 1234567const arr = [];console.log(arr.length); // 0const arr = [1, , 3]; // 희소 배열console.log(arr.length); // 3console.log(arr); // [1, empty, 3]console.log(arr[1]); // undefined arr[1]이undefined인 이유는 실제 객체인 arr에 프로퍼티 키가 ‘1’인 프로퍼티가 존재하지 않기 때문이다. Array 생성자 함수 Array 생성자 함수를 통해 배열을 생성할 수 있다. Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작한다. 전달된 인수가 1개이고 숫자인 경우, 인수를 length 프로퍼티의 값으로 갖는 배열을 생성한다. 1234const arr = new Array(10);console.log(arr); // [empty × 10]console.log(arr.length); // 10 이때 생성된 배열은 희소 배열이다. length 프로퍼티의 값은 0이 아니지만 실제로 배열의 요소는 존재하지 않는다. 1234console.log(Object.getOwnPropertyDescriptors(arr));/*&#123; length: &#123; value: 10, writable: true, enumerable: false, configurable: false &#125; &#125;*/ 전달된 인수는 0 ~ 232-1(4294967295) 사이의 정수이어야 한다. 전달된 인수가 범위를 벗어나면 RangeError가 발생한다. 12345// 전달된 인수가 음수이면 에러가 발생한다.new Array(-1); // RangeError: Invalid array length// 배열에는 요소를 최대 4294967295개 갖을 수 있다.new Array(4294967296); // RangeError: Invalid array length 전달된 인수가 없는 경우, 빈 배열을 생성한다. 즉, 배열 리터럴 []과 같다. 123const empty = new Array();console.log(empty); // [] 전달된 인수가 2개 이상이거나 숫자가 아닌 경우, 인수를 요소로 갖는 배열을 생성한다. 123456789// 전달된 인수가 1개이지만 숫자가 아니면 인수를 요소로 갖는 배열을 생성한다.const arr1 = new Array(&#123;&#125;);console.log(arr1); // [&#123;&#125;]// 전달된 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.const arr2 = new Array(1, 2, 3);console.log(arr2); // [1, 2, 3] Array 생성자 함수는 new 연산자와 호출하지 않더라도, 즉 함수로 호출하더라도 배열을 생성하는 생성자 함수로 동작한다. 12const arr = Array(1, 2, 3);console.log(arr); // [1, 2, 3] Array.of​ ES6에서 도입됨. 전달된 인수를 요소로 갖는 배열을 생성함. Array.of는 Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다. 123456789// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.const arr1 = Array.of(1);console.log(arr1); // // [1]const arr2 = Array.of(1, 2, 3);console.log(arr2); // [1, 2, 3]const arr3 = Array.of('string');console.log(arr3); // 'string' Array.from​ ES6에서 도입됨. 유사 배열 객체 또는 이터러블 객체를 변환하여 새로운 배열을 생성함. 정적 메소드이다. 1234567// 문자열은 이터러블이다.const arr1 = Array.from('Hello');console.log(arr1); // [ 'H', 'e', 'l', 'l', 'o' ]// 유사 배열 객체를 새로운 배열을 변환하여 반환한다.const arr2 = Array.from(&#123; length: 2, 0: 'a', 1: 'b' &#125;);console.log(arr2); // [ 'a', 'b' ] Array.from을 사용하면 두번째 인수로 전달한 함수를 통해 값을 만들면서 요소를 채울 수 있다. Array.from({ length: 길이값 }, function (길이값, 현재값) { return 현재값; }); 1234// Array.from의 두번째 인수로 배열의 모든 요소에 대해 호출할 함수를 전달할 수 있다.// 이 함수는 첫번째 인수에 의해 생성된 배열의 요소값괴 인덱스를 순차적으로 전달받아 호출된다.const arr3 = Array.from(&#123; length: 5 &#125;, function (v, i) &#123; return i; &#125;);console.log(arr3); // [ 0, 1, 2, 3, 4 ] 유사 배열 객체와 이터러블 객체 유사배열 객체 : 배열처럼 인덱스로 프로퍼티 값에 접근이 가능하다. length 프로퍼티를 갖는 객체legth 프로퍼티로 인해 반복문으로 순회가 가능한 구조다. 이터러블 객체 : Symbol.iterator 메소드를 구현하여 for…of 문으로 순회할 수 있으며 Spread 문법의 대상으로 사용할 수 있는 객체를 말한다.ES6에서 제공하는 빌트인 이터러블은 Array, String, Map, Set, DOM data structure(NodeList, HTMLCollection), Arguments 등 배열 요소의 참조 배열 요소를 참조할 때에는 대괄호([]) 표기법을 사용한다. 희소 배열의 존재하지 않는 요소를 참조하면 undefined가 반환된다. 배열은 사실 인덱스를 프로퍼티 키로 갖는 객체이다. 따라서 존재하지 않는 프로퍼티 키로 객체의 프로퍼티에 접근했을 때 undefined를 반환하는 것처럼 배열도 존재하지 않는 요소를 참조하면 undefined가 반환한다. 배열 요소의 추가와 갱신 객체에 프로퍼티를 동적으로 추가할 수 있는 것처럼 배열에도 요소를 동적으로 추가할 수 있다. 요소가 존재하지 않는 인덱스의 배열 요소에 값을 할당하면 새로운 요소가 추가된다. length 프로퍼티 값은 자동 갱신된다. 123456const arr = [0, 1];// 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다.arr[100] = 100;console.log(arr); // [0, 1, empty × 98, 100]console.log(arr.length); // 101 123456789// 명시적으로 값을 할당하지 않은 요소는 생성되지 않는다.console.log(Object.getOwnPropertyDescriptors(arr));/*&#123; '0': &#123; value: 0, writable: true, enumerable: true, configurable: true &#125;, '1': &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;, '100': &#123; value: 100, writable: true, enumerable: true, configurable: true &#125;, length: &#123; value: 101, writable: true, enumerable: false, configurable: false &#125;*/ 요소 값 갱신 : 존재하는 요소에 값을 재할당시 요소값이 갱신된다. 1234// 요소값의 갱신arr[1] = 10;console.log(arr); // [0, 10, empty × 98, 100] 인덱스는 요소의 위치를 나타내므로 반드시 0 이상의 정수(또는 정수 형태의 문자열)를 사용하여야 한다. 만약 정수 이외의 값을 인덱스처럼 사용하면 요소가 생성되는 것이 아니라 프로퍼티가 생성된다. 이때 추가된 프로퍼티는 length 프로퍼티의 값에 영향을 주지 않는다. 1234567891011121314const arr = [];// 배열 요소의 추가arr[0] = 1;arr['1'] = 2; // 문자열 '1'을 숫자 1로 암묵적 타입 변환// 프로퍼티 추가arr['foo'] = 3;arr[1.1] = 4;console.log(arr); // [1, 2, foo: 3, 1.1: 4]// 프로퍼티는 length에 영향을 주지 않는다.console.log(arr.length); // 2 - arr[0] , arr[1] 배열 요소의 삭제 배열의 특정 요소를 삭제하기 위해 delete 연산자를 사용할 수 있다. (delete 연산자는 프로퍼티 키만 삭제하므로 length에는 영향을 주지 않는다. ) length에 영향을 주고 싶다면 배열명.shift() 혹은 배열명.splice(인덱스위치, 부터 개수)를 이용한다. 12345678const arr = [1, 2, 3];// 배열 요소의 삭제delete arr[1];console.log(arr); // [1, empty, 3]// 프로퍼티는 length에 영향을 주지 않는다.console.log(arr.length); // 3 배열의 특정 요소를 완전히 삭제하여 length 프로퍼티 값에도 반영되게 하기 위해서는 Array.prototype.splice 메소드를 사용한다.(shift() 혹은 pop()도 영향을 준다.) 123456const arr = [1, 2, 3];// Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소수)// arr[1]부터 1개의 요소를 제거arr.splice(1, 1);console.log(arr); // [1, 3] 배열 메소드Array.prototype에는 배열을 다룰 때 필요한 메소드를 제공. ( 2가지 타입이 존재 ) 배열에는 원본 배열을 직접 변경하는 메소드(mutator method) 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method) Array.isArray 정적 메소드 Array.isArray는 주어진 인수가 배열이면 true, 배열이 아니면 false를 반환한다. 1234567891011121314// trueArray.isArray([]);Array.isArray([1, 2]);Array.isArray(new Array());// falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(1);Array.isArray('Array');Array.isArray(true);Array.isArray(false); Array.prototype.push (스택/큐 구현 용이) 원본 배열 직접 변경 원본 배열에 전달받은 인수를 마지막 요소로 추가함. length 영향 o 변경된 length 값을 반환함. length값으로 직접 추가하는 것이 push() 보다 성능이 좋음. spread 문법으로 대체 가능 1234567891011const arr = [1, 2];// arr.push(3)와 동일한 처리를 한다. 이 방법이 push 메소드보다 빠르다.arr[arr.length] = 3;console.log(arr); // [1, 2, 3]const newArr = [...arr, 4];// arr.push(4);console.log(newArr); // [1, 2, 3, 4] Array.prototype.pop (스택 구현 용이) 원본 배열 직접 변경 마지막 요소를 제거함. length 영향 o 제거한 요소를 반환함. (빈 배열이라면 undefined) 12345678const arr = [1, 2];// 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.let result = arr.pop();console.log(result); // 2// pop 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [1] Array.prototype.unshift 원본 배열 직접 변경 인수로 전달 받은 모든 값을 원본 배열의 맨 앞에 추가함. length 영향 o 변경된 length 값을 반환함. spread 문법으로 대체 가능. 1234567891011121314const arr = [1, 2];// 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다.let result = arr.unshift(3, 4);console.log(result); // 4// unshift 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [3, 4, 1, 2]// ES6 Spread 문법const newArr = [3, ...arr];// arr.unshift(3);console.log(newArr); // [3, 4, 1, 2] Array.prototype.shift (큐 구현 용이) 원본 배열 직접 변경 첫번째 요소를 제거함. length 영향 o 제거한 요소를 반환함. (빈 배열이라면 undefined) 12345678const arr = [1, 2];// 원본 배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다.let result = arr.shift();console.log(result); // 1// shift 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [2] pop과 shift를 이용한 queqe 구현객체로 큐(FIFO) 선입선출 자료구조 구현. 1234567891011121314151617181920212223242526272829const Queue = (function () &#123; function Queue(array = []) &#123; if (!Array.isArray(array)) &#123; throw new TypeError(`$&#123;array&#125; is not an array.`); &#125; this.array = array; &#125; // 큐의 가장 마지막에 데이터를 밀어 넣는다. Queue.prototype.push = function (value) &#123; return this.array.push(value); &#125;; // 큐의 가장 처음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 꺼낸다. Queue.prototype.shift = function () &#123; return this.array.shift(); &#125;; return Queue;&#125;());const queue = new Queue([1, 2]);console.log(queue); // [1, 2]queue.push(3);console.log(queue); // [1, 2, 3]queue.shift(); // -&gt; 1console.log(queue); // [2, 3] pop과 push를 이용한 stack 구현객체로 스택(LIFO) 후입선출 자료구조 구현. 1234567891011121314151617181920212223242526272829const Stack = (function () &#123; function Stack(array = []) &#123; if (!Array.isArray(array)) &#123; throw new TypeError(`$&#123;array&#125; is not an array.`); &#125; this.array = array; &#125; // 스택의 가장 마지막에 데이터를 밀어 넣는다. Stack.prototype.push = function (value) &#123; return this.array.push(value); &#125;; // 스택의 가장 마지막 데이터, 즉 가장 나중에 밀어 넣은 최신 데이터를 꺼낸다. Stack.prototype.pop = function () &#123; return this.array.pop(); &#125;; return Stack;&#125;());const stack = new Stack([1, 2]);console.log(stack); // [1, 2]stack.push(3);console.log(stack); // [1, 2, 3]stack.pop(); // -&gt; 3console.log(stack); // [1, 2] Array.prototype.concat 배열의 마지막 요소로 추가한 새로운 배열을 반환. 원본 배열은 유지. 인수로 전달한 값이 배열인 경우, 배열을 해체하여 새로운 배열 요소로 추가함. 123456789101112131415161718const arr1 = [1, 2];const arr2 = [3, 4];// 배열 arr2를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환// 인수로 전달한 값이 배열인 경우, 배열을 해체하여 새로운 배열의 요소로 추가한다.let result = arr1.concat(arr2);console.log(result); // [1, 2, 3, 4]// 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환result = arr1.concat(3);console.log(result); // [\"1, 2, 3]// 배열 arr2와 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환result = arr1.concat(arr2, 5);console.log(result); // [1, 2, 3, 4, 5]// 원본 배열은 변경되지 않는다.console.log(arr1); // [1, 2] concat을 이용한 push와 unshift 대체가 가능하다. 123456789101112131415161718192021const arr1 = [3, 4];// unshift 메소드는 원본 배열을 직접 변경한다.arr1.unshift(1, 2);console.log(arr1); // [1, 2, 3, 4]// push 메소드는 원본 배열을 직접 변경한다.arr1.push(5, 6);console.log(arr1); // [1, 2, 3, 4, 5, 6]// unshift와 push 메소드는 concat 메소드로 대체할 수 있다.const arr2 = [3, 4];// concat 메소드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.// arr1.unshift(1, 2)를 아래와 같이 대체할 수 있다.let result = [1, 2].concat(arr2);console.log(result); // [1, 2, 3, 4]// arr1.push(5, 6)를 아래와 같이 대체할 수 있다.result = result.concat(5, 6);console.log(result); // [1, 2, 3, 4, 5, 6] concat은 인수로 받은 배열을 해체하여 새로운 배열로 조합하지만, push,unshift는 배열 자체를 그냥 추가한다. 12345678910111213141516171819202122const arr1 = [3, 4];// unshift와 push 메소드는 인수로 전달받은 배열을 그대로 원본 배열의 요소로 추가한다arr1.unshift([1, 2]);arr1.push([5, 6]);console.log(arr1); // [[1, 2], 3, 4,[5, 6]]const arr2 = [3, 4];// concat 메소드는 인수로 전달받은 배열을 해체하여 새로운 배열의 요소로 추가한다let result1 = [1, 2].concat(arr2);result1 = result1.concat([5, 6]);console.log(result1); // [1, 2, 3, 4, 5, 6]//concat 메소드는 ES6의 Spread 문법으로 대체할 수 있다.let result2 = [1, 2].concat([3, 4]);console.log(result2); // [1, 2, 3, 4]// concat 메소드는 ES6의 Spread 문법으로 대체할 수 있다.let result3 = [...[1, 2], ...[3, 4]];console.log(result3); // [1, 2, 3, 4] concat 메소드는 ES6의 Spread 문법으로 대체할 수 있다. Array.prototype.splice 원본 배열 직접 변경 중간에 요소를 추가하거나 제거하는 경우 사용. 제거한 요소들을 반환함. 3개의 매개변수를 가짐 start : 원본 배열의 요소를 제거하기 시작할 인덱스이다. start 만을 지정시 start부터 뒤는 모두 제거한다. deleteCount : 원본 배열의 요소를 제거하기 시작할 인덱스인 start부터 제거할 요소의 개수이다. deleteCount가 0인 경우, 아무런 요소도 제거되지 않는다. (옵션) items : 제거한 위치에 삽입될 요소들의 목록이다. 생략할 경우, 원본 배열에서 지정된 요소들을 제거만 한다. (옵션) 123456789const arr = [1, 2, 3, 4];// 원본 배열의 인덱스 1부터 2개의 요소를 제거하고 그 자리에 새로운 요소 10, 30을 삽입한다.const result = arr.splice(1, 2, 20, 30);// 제거한 요소가 배열로 반환된다.console.log(result); // [2, 3]// splice 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [1, 20, 30, 4] Array.prototype.slice 원본 배열은 유지. 인수로 전달된 범위의 요소들을 복사하여 반환한다. 2개의 매개변수를 가짐. start : 복사를 시작할 인덱스이다. 음수인 경우, 배열의 끝에서의 인덱스를 나타낸다.예를 들어 slice(-2)는 배열의 마지막 2개의 요소를 반환한다. end : 복사를 종료할 인덱스이다. 이 인덱스에 해당하는 요소는 복사되지 않는다. 옵션이며 기본값은 length 값이다. 1234567891011121314151617181920const arr = [1, 2, 3];// arr[0]부터 arr[1] 이전(arr[1] 미포함)까지 복사하여 반환한다.let result = arr.slice(0, 1);console.log(result); // [1]// arr[1]부터 arr[2] 이전(arr[2] 미포함)까지 복사하여 반환한다.result = arr.slice(1, 2);console.log(result); // [2]// 원본은 변경되지 않는다.console.log(arr); // [1, 2, 3]// 2번째 인수 생략시 1인수의 인덱스 가 가리킨 곳부터 전부다 복사함.const result2 = arr.slice(1);console.log(result2); // [2, 3]// 인수 전부 생략시 전부 복사해서 새로운 배열 만듬.const copy = arr.slice();console.log(copy); // [1, 2, 3] slice 메소드의 두번째 인수를 생략하면 첫번째 인수에 해당하는 인덱스부터 모든 요소를 복사하여 반환한다. slice 메소드의 인수를 모두 생략하면 원본 배열의 새로운 복사본을 생성하여 반환한다. slice는 유사 배열 객체를 배열로 변환시키는 작업에 많이 사용된다. slice는 얕은 복사를 한다. deep copy는 lodash의 deepClone을 사용한다. 123456789101112function sum() &#123; // 유사 배열 객체를 배열로 변환 var arr = Array.prototype.slice.call(arguments); // const arr = [...arguments ]; Spread 문법 console.log(arr); // [1, 2, 3] return arr.reduce(function (pre, cur) &#123; return pre + cur; &#125;);&#125;console.log(sum(1, 2, 3)); // 6 Array.prototype.indexOf 배열에 인수에 해당되는 요소의 위치(index)를 반환한다. 중복되는 요소가 있는 경우, 첫번째 인덱스를 반환한다. 해당하는 요소가 없는 경우 -1을 반환한다. 두번쨰 인수는 검색을 시작할 인덱스를 지정한다. 생략시 처음부터 검색. 12345678const arr = [1, 2, 2, 3];// 배열 arr에서 요소 2를 검색하여 첫번째 인덱스를 반환arr.indexOf(2); // -&gt; 1// 배열 arr에서 요소 4가 없으므로 -1을 반환arr.indexOf(4); // -1// 두번째 인수는 검색을 시작할 인덱스이다. 두번째 인수를 생략하면 처음부터 검색한다.arr.indexOf(2, 2); // 2 Array.prototype.join 원본 배열의 모든 요소를 문자열로 변환 후, 구분자로 연결한 문자열을 반환한다. 원본 배열은 유지. 구분자는 생략이 가능하며 기본 구분자는 ; 이다. 1234567891011121314const arr = [1, 2, 3, 4];// 기본 구분자는 ','이다.// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 기본 구분자 ','로 연결한 문자열을 반환let result = arr.join();console.log(result); // '1,2,3,4';// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 빈문자열로 연결한 문자열을 반환result = arr.join('');console.log(result); // '1234'// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환result = arr.join(':');console.log(result); // '1:2:3:4' Array.prototype.reverse 배열의 요소 순서를 반대로 변경함. 원본 배열 직접 변경. 변경된 배열을 반환한다. 1234567const arr = [1, 2, 3];const result = arr.reverse();// reverse 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [3, 2, 1]// 반환값은 변경된 배열이다.console.log(result); // [3, 2, 1] Array.prototype.fill ES6에서 도입됨. 인수로 전달받은 값을 요소로 배열의 처음부터 끝까지 모두 변경함. 원본 배열 직접 변경. 2번째 요소를 생략하면 모든 요소를 다 변경한다. 2번째 요소에 인덱스를 전달하면 해당 인덱스 부터 모든 요소를 다 변경함. 3번쨰 요소에 인덱스를 전달하면 해당 인덱스(자신은 미포함)까지 모든 요소를 다 변경한다. 1234567891011121314151617181920212223const arr = [1, 2, 3];// 인수로 전달 받은 값 0을 요소로 배열의 처음부터 끝까지 채운다.arr.fill(0);// fill 메소드는 원본 배열을 직접 변경한다.console.log(arr); // [0, 0, 0]const arr2 = [1, 2, 3];// 인수로 전달 받은 값 0를 요소로 배열의 인덱스 1부터 끝까지 채운다.arr2.fill(0, 1);// fill 메소드는 원본 배열을 직접 변경한다.console.log(arr2); // [1, 0, 0]const arr3 = [1, 2, 3, 4, 5];// 인수로 전달 받은 값 0를 요소로 배열의 인덱스 1부터 3 이전(인덱스 3 미포함)까지 채운다.arr3.fill(0, 1, 3);// fill 메소드는 원본 배열을 직접 변경한다.console.log(arr3); // [1, 0, 0, 4, 5] fill 메소드는 요소로 채울 경우, 모든 요소를 하나의 값으로만 채울 수 있다. Array.from을 사용할 경우, 여러개의 값을 만들면서 요소를 채울 수 있다. 123456// 인수로 전달받은 정수만큼 요소를 생성하고 0부터 1씩 증가하면 요소를 채운다.function generateSequences(length = 0) &#123; return Array.from(new Array(length), (v, i) =&gt; i);&#125;console.log(generateSequences(3)); // [0, 1, 2] Array.prototype.includes ES7에서 새롭게 도입됨. 배열 내에 특정 요소가 포함되어 있는지 확인하여 boolean을 반환. 두번째 인수로 검색을 시작할 인덱스를 전달함. 1234567891011121314const arr = [1, 2, 3];// 배열에 요소 2가 포함되어 있는지 확인한다.let result = arr.includes(2);console.log(result); // true// 배열에 요소 100이 포함되어 있는지 확인한다.result = arr.includes(100);console.log(result); // false// 두번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.// 배열에서 요소 1가 포함되어 있는지 인덱스 1부터 확인한다.result = arr.includes(1, 1);console.log(result); // false 배열의 인덱스 위치를 반환하는 Array.prototype.indexOf를 이용해도 배열의 요소가 있는지 없는지 판단이 가능하다. Array.prototype.indexOf 은 인덱스의 요소가 없을 경우 -1을 반환한다. 하지만 indexOf 메소드는 배열에 NaN이 포함되어 있는지 확인할 수 없는 문제가 있다. 12console.log([NaN].indexOf(NaN) !== -1); // falseconsole.log([NaN].includes(NaN)); // true 26강 - 2 내용 : 고차 함수","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"HOF","slug":"HOF","permalink":"https://hyeok999.github.io/tags/HOF/"},{"name":"Array","slug":"Array","permalink":"https://hyeok999.github.io/tags/Array/"}]},{"title":"daily_algorithm20","slug":"daily-algorithm20","date":"2019-10-19T08:14:12.000Z","updated":"2019-11-30T16:47:40.370Z","comments":true,"path":"2019/10/19/daily-algorithm20/","link":"","permalink":"https://hyeok999.github.io/2019/10/19/daily-algorithm20/","excerpt":"","text":"문제 출처 : 프로그래머스 기능 개발문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93,30,55] [1,30,5] [2,1] 입출력 예 설명첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 12345678910111213141516171819202122232425function solution(progresses, speeds) &#123; var answer = []; let booleanValue; let count; while (progresses.length) &#123; booleanValue = false; count = 0; for (let i = 0; i &lt; progresses.length; i++) &#123; progresses[i] += speeds[i]; &#125; while (progresses.length != 0 &amp;&amp; progresses[0] &gt;= 100) &#123; booleanValue = true; count++; progresses.shift(); speeds.shift(); &#125; if (booleanValue == true) &#123; answer.push(count); &#125; &#125; return answer;&#125; 도저히 알고리즘이 떠 오르질 않아서 타 블로그의 내용을 보고 이해했다. 다음에 다시 도전 할 것.해당 문제는 배열을 맨 앞부터 잘라내는 방식 큐 ( FIFO )으로 해결한다. 변수 기능치가 100이 될 경우 올라갈 배포 count count값이 들어갔는지 체크할 booleanValue 현재 기능 정도와 스피드를 각각 더한다. 동시에 기능 배열의 길이가 0이 아니고 0번쨰 기능이 100이 되어야만 다음 기능들도 배포가 가능하므로 0번째 기능이 100이상 인지 체크한다. 100이상이라면 count수를 올리고 count값이 올라갔으므로 booleanValue를 바꿔준다. 기능과 스피드 정도의 배열을 각각 앞부터 잘라낸다. 만약 booleanValue가 참일경우 answer에 해당 카운드값을 넣는다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm19","slug":"daily-algorithm19","date":"2019-10-19T08:14:08.000Z","updated":"2019-11-30T16:47:55.085Z","comments":true,"path":"2019/10/19/daily-algorithm19/","link":"","permalink":"https://hyeok999.github.io/2019/10/19/daily-algorithm19/","excerpt":"","text":"문제 출처 : 프로그래머스 예산문제 설명S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다. 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다. 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다. d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다. budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다. 입출력 예 d budget result [1,3,2,5,4] 9 3 [2,2,3,3] 10 4 입출력 예 설명입출력 예 #1각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다. 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다. 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다. 3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다. 입출력 예 #2모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다. 1234567891011121314151617181920212223/*function solution(d, budget) &#123; var answer = 0; d = d.sort(function(a,b) &#123; return a-b; &#125;) for(var i=0; i&lt;d.length, 0&lt;budget; i++)&#123; console.log(budget); budget = budget-d[i]; if(budget &gt;= 0)&#123; answer++; &#125; &#125; return answer;&#125;*/function solution(d, budget) &#123; d.sort(function(a, b)&#123;return a - b&#125;); while (d.reduce(function(a, b) &#123;return a + b&#125;, 0) &gt; budget) &#123; d.pop(); &#125; return d.length;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-11","slug":"javascript-study-11","date":"2019-10-18T10:50:36.000Z","updated":"2019-11-30T16:28:42.348Z","comments":true,"path":"2019/10/18/javascript-study-11/","link":"","permalink":"https://hyeok999.github.io/2019/10/18/javascript-study-11/","excerpt":"","text":"JavaScript Study 11 용어 캡슐화(정보 은폐) 생성자 함수에 의한 프로토타입 교체 인스턴스에 의한 프로토타입의 교체 직접상속 Object.prototype의 빌트인 메소드를 객체가 직접 호출하는 것을 비추천 객체 리터럴 내부에서 __ proto __에 의한 직접 상속 정적 메소드 for…in 문 strict mode 전역 객체 전역 프로퍼티(Global property) this 호출 방식 this의 binding 확정시간 bind Call Apply 용어 - ( 러버덕 ) 캡슐화 생성자 함수에 의한 프로토타입 교체 인스턴스에 의한 프로토타입의 교체 직접상속 Object.prototype의 빌트인 메소드를 객체가 직접 호출하는 것을 비추천하는 이유 객체 리터럴 내부에서 __ proto __에 의한 직접 상속 정적 메소드 for…in 문 전역 객체 전역 프로퍼티(Global property) this 호출 방식 this의 binding 확정시간 bind Call Apply Prototype캡슐화 ( 정보 은폐 )다른 클래스 기반 프로그램언어에서 public , private, protected 를 이용해서 캡슐화를 하여 클래스를 보호하면 정보를 은폐한다. 하지만 JS에서는 클로저를 통해 캡슐화를 지원한다. (추후 버전에서는 JS도 클래스를 출시 한다.) 즉, 캡슐화는 객체의 정보(프로퍼티,상태)를 공개할 것과 공개하지 않을 것을 정해서 보여준다. 캡슐화를 했다하여 무조건 외부에서 참조가 불가능 한 것은 아니다. 예를들어 중첩함수와 같은 방식으로 캡슐화를 했다면 모듈패턴을 사용해서 외부에서 접근이 가능하다. JS가 접근제한자를 갖지 않는 이유는 필요가 없기 때문이다. 123456789101112131415161718192021const Person = (function () &#123; // 생성자 함수 let _name = ''; function Person(name) &#123; _name = name; &#125; // 프로토타입 메소드 // 중첩함수가 아님 Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;_name&#125;`); &#125;; // 생성자 함수를 반환 return Person;&#125;());const me = new Person('Lee');console.log(me);me.sayHello(); 함수내에 있는 변수의 생명주기는 함수가 끝나는 동시에 끝난다. 모든 함수는 호출 될 때, 자신이 정의된 스코프의 상위 스코프를 기억한다. (렉시컬 Evironment) 따라서 위 예제에서 변수 _let이 존재하는 블록이 끝났어도(삭제되었어도) 기억하고서 값을 반환할 수 있는 것이다. 모든 함수가 [[Environment]] 라는 내부 슬롯 - 기억하는 자료구조를 가지고 있다. 생성자 함수에 의한 프로토타입 교체아래는 생성자.prototype 내용 자체를 교체한것이다. Person.prototype ={sayHello() { console.log(...); }}; 따라서 constructor 프로퍼티가 없어서 링크가 깨져버렸다. 12345678910111213141516const Person = (function () &#123; function Person(name) &#123; this.name = name; &#125; // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 Person.prototype = &#123; sayHello() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; &#125;; return Person;&#125;());const me = new Person('Lee'); 위 예제를 살려주려면 constructor 프로퍼티를 다시 살려줘야만한다. 1234567Person.prototype = &#123; // constructor 프로퍼티와 생성자 함수 간의 링크 설정 constructor: Person, sayHello() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;&#125;; 인스턴스에 의한 프로토타입의 교체 아래는 생성자.prototype 자체를 원하는 객체로 바꾼 것이다. 그런데 parent는 일반 객체이므로 constructor가 없기 때문에 링크가 역시 깨져버렸다. 1234567891011121314151617181920function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee');// 프로토타입으로 교체할 객체const parent = &#123; // constructor: Person, sayHello() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;&#125;;// ① me 객체의 프로토타입을 parent 객체로 교체한다.Object.setPrototypeOf(me, parent);// 위 코드는 아래의 코드와 동일하게 동작한다.// me.__proto__ = parent;me.sayHello(); // Hi! My name is Lee 직접상속프로토타입의 링크를 안꺠뜨리고 바꾸려면 Object.create함수를 이용한다. 1234567/** * 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환한다. * @param &#123;Object&#125; prototype - 생성할 객체의 프로토타입으로 지정할 객체 * @param &#123;Object&#125; [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체 * @returns &#123;Object&#125; 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체 */Object.create(prototype[, propertiesObject]) 12345678910111213141516171819202122232425262728293031323334353637383940414243// 프로토타입이 null인 객체를 생성한다.// 즉, 생성된 객체는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.// obj → nulllet obj = Object.create(null);console.log(Object.getPrototypeOf(obj) === null); // true// Object.prototype를 상속받지 못한다.console.log(obj.toString()); // TypeError: obj.toString is not a function// obj = &#123;&#125;;와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype);console.log(Object.getPrototypeOf(obj) === Object.prototype); // true// obj = &#123; x: 1 &#125;;와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype, &#123; x: &#123; value: 1 &#125;&#125;);// 위 코드는 아래와 동일하다.// obj = Object.create(Object.prototype);// obj.x = 1;console.log(obj.x); // 1console.log(Object.getPrototypeOf(obj) === Object.prototype); // trueconst myProto = &#123; x: 10 &#125;;// 객체를 직접 상속받는다.// obj → myProto → Object.prototype → nullobj = Object.create(myProto);console.log(obj.x); // 10console.log(Object.getPrototypeOf(obj) === myProto); // true// 생성자 함수function Person(name) &#123; this.name = name;&#125;// obj = new Person('Lee')와 동일하다.// obj → Person.prototype → Object.prototype → nullobj = Object.create(Person.prototype);obj.name = 'Lee';console.log(obj.name); // Leeconsole.log(Object.getPrototypeOf(obj) === Person.prototype); // true Object.prototype의 빌트인 메소드를 객체가 직접 호출하는 것을 비추천 ESLint에서는 Object.create(null)과 같이 프로토타입이 null이 객체를 프로토타입으로 삼고있는 객체가 있을 수 있으므로, 빌트인 메소드를 부를 때 객체명.빌트인메소드 하는 것을 추천하지않고 있다. 123456789101112// 프로토타입이 null인 객체를 생성한다.const obj = Object.create(null);obj.a = 1;// 즉, 생성된 객체는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.console.log(Object.getPrototypeOf(obj) === null); // true// obj는 Object.prototype의 빌트인 메소드를 사용할 수 없다. (비추천)console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function// Object.prototype의 빌트인 메소드는 객체로 직접 호출하지 않는다.console.log(Object.prototype.hasOwnProperty.call(obj, 'a')); // true call 함수를 이용하여 Object.prototype.hasOwnProperty.call(obj, &#39;a&#39;)를 불러낸다. call(객체,&#39;인수&#39;) call에 넘길 인수가 많을 경우 , 로 더 적워줘도 된다. call은 가변인자를 받는다. 이와 같은 방법은 call bind apply 등이 존재한다. 객체 리터럴 내부에서 proto에 의한 직접 상속const obj = Object.create(myProto); === const obj = { __ proto __: myProto }; 1234567891011121314const myProto = &#123; x: 10 &#125;;// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.const obj = &#123; y: 20, // 객체를 직접 상속받는다. // obj → myProto → Object.prototype → null __proto__: myProto&#125;;// 위 코드는 아래와 동일하다.// const obj = Object.create(myProto, &#123; y: &#123; value: 20 &#125; &#125;);console.log(obj.x, obj.y); // 10 20console.log(Object.getPrototypeOf(obj) === myProto); // true 정적 메소드 정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다. 1234567891011121314151617181920212223242526// 생성자 함수function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;// Person 생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다.// 정적 프로퍼티Person.staticProp = 'static prop';// 정적 메소드Person.staticMethod = function () &#123; console.log('staticMethod');&#125;;const me = new Person('Lee');// 생성자 함수에 추가한 정적 프로퍼티/메소드는 생성자 함수로 참조/호출한다.Person.staticMethod(); // staticMethod// 정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.// 인스턴스로 참조/호출할 수 있는 프로퍼티/메소드는 프로토타입 체인 상에 존재해야 한다.me.staticMethod(); // TypeError: me.staticMethod is not a function for…in 문 객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다. for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다 for…in문은 실질적으로 실행되는 위치가 {}안이므로 let , const 를 사용할 수 있다. ( const를 재 할당이 아닌 재 선언으로 취급한다. ) 12345678910111213for (변수선언문 in 객체) &#123; … &#125;const person = &#123; name: 'Lee', address: 'Seoul'&#125;;// for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다. 단, 순서는 보장되지 않는다.for (const prop in person) &#123; console.log(prop + ': ' + person[prop]);&#125;// name: Lee// address: Seoul strict mode strict mode에서 일반 함수의 this strict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다. 이때 에러는 발생하지 않는다. 12345678910111213(function () &#123; 'use strict'; function foo() &#123; console.log(this); // undefined //non-strict - window &#125; foo(); function Foo() &#123; console.log(this); // Foo &#125; new Foo();&#125;()); 전역 객체브라우저 환경에서 전역 객체의 이름은 window( self ) 다. 전역객체의 프로퍼티 : API(web, node) , 전역 함수, var키워드로 선언한 전역 변수, 표준 빌트인 객체(Object, String, Number, Function, Array…) 전역 객체는 개발자가 의도적으로 생성할 수 없다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 123456// 문자열 'F'를 16진수로 해석하여 10진수로 변환하여 반환한다.console.log(window.parseInt('F', 16)); // 15// 전역 객체 window의 메소드인 parseInt은 window.parseInt 또는 parseInt으로 호출할 수 있다.console.log(parseInt('F', 16)); // 15console.log(window.parseInt === parseInt); // true 전역 프로퍼티(Global property)전역 프로퍼티는 전역 객체(window)의 프로퍼티를 의미한다. 애플리케이션 전역에서 사용하는 값들을 나타내기 위해 사용한다. Infinity Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다. NaN NaN 프로퍼티는 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. console.log(typeof NaN) // number undefined undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다. 빌트인 전역 함수 eval : 문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. (가급적 사용 금지)isFinite : 유한수 , 무한수인지 체크 boolean 반환isNaN : NaN인지 판단하여 boolean 반환parseFloat : 문자열을 부동소수점 숫자로 변환하여 반환한다.parseInt : 문자열을 정수형 숫자로 변환하여 반환한다.encodeURI / decodeURI : 매개변수로 전달된 URI를 인코딩한다.encodeURIComponent / decodeURIComponent : 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩한다. this this가 가리키는 값, 즉 this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 호출 방식일반함수로서 호출 : foo( ); ➤ this : window생성자함수로서 호출: new foo( ); ➤ this : 인스턴스메소드로서 호출 : o.foo( ); ➤ this : 메소드를 호출한 객체간접 호출 : foo.call(x); ➤ this : 전달한 것이 this this는 함수를 어떻게 호출 했느냐로 동적으로 결정한다. 콜백이나 중첩 함수의 this는 대부분 window를 가리킨다. (물론, 고차함수의 마음이다.) this의 binding 확정시간 함수가 호출 되었을 때, this의 binding이 확정 된다. 바인딩(binding) : 바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다. 함수 호출 방식 this 바인딩 일반 함수 호출 전역 객체 메소드 호출 메소드를 호출한 객체 생성자 함수 호출 생성자 함수가 (미래에) 생성할 인스턴스 Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체 bind Function.prototype에 들어있는 함수 bind(함수객체) - 단, 호출은 하지 않는다. this만 갈아낀다. bind는 명시적으로 함수를 호출해야만 한다. Call Apply Function.prototype에 들어있는 함수 자신의 앞 함수를 호출한다. 첫번째 인수를 함수 안에 있는 this 대신 사용한다. Call 은 두번째 인수부터 쉼표로 구분한 리스트 형식으로 전달한다. Applye는 두번째 인수부터 배열형태으로 넘기거나 혹은 생략한다. 우선순위 1. Apply 2. Call 12345678910111213function convertArgsToArray() &#123; console.log(arguments); // arguments 객체를 배열로 변환 // slice: 배열의 특정 부분에 대한 복사본을 생성한다. const arr = Array.prototype.slice.apply(arguments); // const arr = Array.prototype.slice.call(arguments); console.log(arr); return arr;&#125;convertArgsToArray(1, 2, 3); // [ 1, 2, 3 ] slice는 내부에서 this를 건다. 그러나 Array.prototype는 객체다! 참고) 전역객체는 표준 빌트인 객체(Object, String, Number, Function, Array…)를 프로퍼티로 갖는다. 따라서 slice내부의 this를 교체하기 위해서 apply(arguments); / call(arguments); 을 이용한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"arrange_method","slug":"arrange-method","date":"2019-10-18T10:17:06.000Z","updated":"2019-11-30T16:52:50.113Z","comments":true,"path":"2019/10/18/arrange-method/","link":"","permalink":"https://hyeok999.github.io/2019/10/18/arrange-method/","excerpt":"","text":"함수 정리 Object.getPrototypeOf(인스턴스명); 해당 인스턴스 객체의 프로토타입을 반환한다. Object.setPrototypeOf(프로토타입의 하위 객체명, 바꿀객체명); == 객체명.__ proto __ = 바꿀 객체명; 객체명의 프로토타입을 바꿀객체명으로 교체한다. 링크를 복구시켜야되므로 비추천 Object.getOwnPropertyDescriptor(객체명 , ‘프로퍼티’); 해당 객체의 프로퍼티에 대한 내용을 반환한다. (어트리뷰트를 알려달라.) Object.create(프로토타입으로 지정할 객체명 [, 생성할 객체의 프로퍼티를 갖는 객체 ]) 프로토타입을 직접 상속한다. 옵션으로 프로퍼티를 지정할 수 있다. 프로토타입의 체인을 교체하면서 프로토타입을 교체할 때 사용한다. let obj = Object.create(null) ; obj → null // 아무 상속을 받지 않겠다. let obj = Object.create(Object.prototype, { x: { value: 1 } } ); obj → Object.prototype → null // obj = { x: 1 };와 동일하다. let obj = Object.create(myProto); obj → myProto → Object.prototype → null // myProto 객체를 상속받는다. Object[객체명].hasOwnProperty(‘프로퍼티명’); = &#39;프로퍼티 키명&#39; in 객체명 해당 인스턴스에 고유 프로퍼티가 있냐고 묻는다. 반환값은 boolean으로 한다. &#39;프로퍼티 키명&#39; in 객체명은 상속받은 것까지 전부 확인하고 boolean 으로 반환한다. Object[객체명].hasOwnProperty(‘프로퍼티명’); 를 사용할 때 call , bind , apply 함수를 섞어 이용하면 this를 선택가능. Object.defineProperty(객체명, ‘생성 및 바꿀 프로퍼티명’, { 어트리뷰트들 }); 객체의 프로퍼티를 추가하거나 수정한다. (객체가 생성되어있어야만 한다.) 1234567// 데이터 프로퍼티Object.defineProperty(객체명, ‘생성 및 바꿀 프로퍼티명’, &#123; value: 값, writable: false(+생략시) || true , enumerable: false(+생략시) || true , configurable: false(+생략시) || true &#125;); 12345678// 접근자 프로퍼티 get , set 둘다 미작성시 데이터 프로퍼티 가 된다.Object.defineProperty(객체명, ‘생성 및 바꿀 프로퍼티명’, &#123; get: function ()&#123;&#125;, (기명함수, 익명함수 모두가능.(단 기명함수 이름은 외부에서 소용없다.) 미작성시 undefined), set: function ()&#123;&#125;, (기명함수, 익명함수 모두가능.(단 기명함수 이름은 외부에서 소용없다.) 미작성시 undefined), writable: false(+생략시) || true , enumerable: false(+생략시) || true , configurable: false(+생략시) || true &#125;); Object.keys(객체명) 해당 객체에 있는 프로퍼티 키 들 만 배열형태로 반환한다. Object.values(객체명) 해당 객체에 있는 프로퍼티 값 들 만 배열형태로 반환한다. Object.entries(객체명) 해당 객체에 있는 프로퍼티 키와 값 쌍의 배열을 ➤ 배열형태에 담아 반환한다. 1console.log(Object.entries(person)); // [[\"name\", \"Lee\"], [\"address\", \"Seoul\"]] 객체명 instanceof 생성자함수명 instanceof 연산자는 이항 연산자로서 좌변에 객체를 가기키는 식별자,우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다.만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다.평가 결과는 boolean으로 반환한다. &#39;프로퍼티 키명&#39; in 객체명 상속받은 모든 프로토타입의 프로퍼티 와 자신의 프로퍼티까지 모두 확인한다. 해당 객체에 프로퍼티 키가 존재하는지 안하는지를 boolean 형태로 반환한다. 12345678const person = &#123; name: 'Lee', address: 'Seoul' &#125;;// person 객체에 name 프로퍼티가 존재한다.console.log('name' in person); // true// person 객체에 address 프로퍼티가 존재한다.console.log('address' in person); // true// person 객체에 age 프로퍼티가 존재하지 않는다.console.log('age' in person); // false for…in 문 객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다. for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다. for…in문은 실질적으로 실행되는 위치가 {}안이므로 let , const 를 사용할 수 있다. ( const를 재 할당이 아닌 재 선언으로 취급한다. ) 12345678910111213for (변수선언문 in 객체) &#123; … &#125;const person = &#123; name: 'Lee', address: 'Seoul'&#125;;// for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다. 단, 순서는 보장되지 않는다.for (const prop in person) &#123; console.log(prop + ': ' + person[prop]);&#125;// name: Lee// address: Seoul 빌트인 전역 함수 (전역객체(window)의 메소드)eval : 문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. (가급적 사용 금지) isFinite : 유한수 , 무한수인지 체크 boolean 반환 isNaN : NaN인지 판단하여 boolean 반환 parseFloat : 문자열을 부동소수점 숫자로 변환하여 반환한다. parseInt : 문자열을 정수형 숫자로 변환하여 반환한다. encodeURI / decodeURI : 매개변수로 전달된 URI를 인코딩한다. encodeURIComponent / decodeURIComponent : 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩한다. 고차 함수들filter 함수123배열객체명.filter(function(currentValue, index, Array) &#123; return return의 조건식이 true인 currentValue 만 모아서 반환 &#125; map 함수reduce 함수누적값에 현잿값을 넣어가면 순 배열.reduce((누적값, 현잿값, 인덱스, 요소) =&gt; { return 결과 }, 초깃값); 배열.reduce( function (누적값, 현잿값, 인덱스, 요소) { return 결과 }, 초깃값); 12345678result = oneTwoThree.reduce((acc, cur, i) =&gt; &#123; console.log(acc, cur, i); return acc + cur;&#125;, 0);// 0 1 0// 1 2 1// 3 3 2result; // 6 foreach , map , reduce , findIndex , for~of(객체를 이터러블 화 할 필요가 있다.) setTimeout Arraysort 함수배열명.sort() : 배열 내용을 문자열로 간접변환 한 후 문자열 순으로 정렬.( 반활할때는 원래 타입으로 돌려놓는다. ) 배열명.sort(function(a,b){return a - b;}); : 숫자 정렬시 사용. 오름차순으로 정렬한다.배열명.sort(function(a,b){return b - a;}) : 숫자 정렬 시 사용. 내림차순으로 정렬한다. pop() , shift() 함수배열명.pop(): 배열의 마지막 아이템 제거. 배열명.shift(): 배열의 첫번째 아이템 제거. number 타입 - Math.abs(); , 고차함수 string 타입 - split, splice, slice, join, 공백없애는함수 array 타입 - 고차함수, indexOf , 정렬함수 객체 - for in","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"HOF","slug":"HOF","permalink":"https://hyeok999.github.io/tags/HOF/"},{"name":"Array Method","slug":"Array-Method","permalink":"https://hyeok999.github.io/tags/Array-Method/"},{"name":"Array","slug":"Array","permalink":"https://hyeok999.github.io/tags/Array/"},{"name":"Method","slug":"Method","permalink":"https://hyeok999.github.io/tags/Method/"}]},{"title":"javascript 19강 엄격모드","slug":"javascript-preview-19","date":"2019-10-17T12:26:27.000Z","updated":"2019-11-30T16:39:54.725Z","comments":true,"path":"2019/10/17/javascript-preview-19/","link":"","permalink":"https://hyeok999.github.io/2019/10/17/javascript-preview-19/","excerpt":"","text":"JavaScript 19강 예습 strict mode 란? strict mode의 적용 전역과 함수에 strict mode를 적용하는 것은 피하자. strict mode가 발생 시키는 에러 strict mode 적용에 의한 변화 19강엄격 모드 strict mode 란?123456function foo() &#123; x = 10;&#125;foo();console.log(x); // ? console.log(x); 의 정답은 10이 된다. 이유는 x의 키워드를 안적어주었기 때문에 x는 암묵적으로 전역객체의 프로퍼티가 되기 때문이다. 이러한 문법오류를 막기 위해서 반드시 var, let, const와 같은 키워드로 변수를 생성해야만 한다. 하지만, 오타나 문법 지식의 미비로 인한 실수는 언제나 발생하는 것이다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 보다 근본적인 접근이 필요하다. 다시 말해, 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발을 하는 것이 보다 근본적인 해결책이라고 할 수 있다. ES5 부터 strict mode가 추가되었다. strict mode는 기존의 JS언어의 문법을 보다 엄격하게 관리하여 오류를 출력한다. ESLint와 같은 린트 도구를 사용하면 strict mode와 유사한 효과를 얻을 수 있다. strict mode의 적용 strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 &#39;use strict&#39;;를 추가한다. 전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다. 123456'use strict';function foo() &#123; x = 10; // ReferenceError: x is not defined&#125;foo(); 만약 전역 혹은 함수 의 선두에 strict mode를 위치시키지 않으면 제대로 동작하지 않는다. 전역과 함수에 strict mode를 적용하는 것은 피하자.1234567891011121314151617&lt;html&gt;&lt;body&gt; &lt;script&gt; 'use strict'; &lt;/script&gt; &lt;script&gt; x = 1; // 에러가 발생하지 않는다. console.log(x); // 1 &lt;/script&gt; &lt;script&gt; 'use strict'; y = 1; // ReferenceError: y is not defined console.log(y); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위와 같이 scirpt 태그 단위로 use strict를 쓸 경우 다른 script 태그에게는 여향을 안주고 사용할 수 있다. 하지만, 이럴 경우 strict mode 스크립트 와 non-strict mode 스크립트를 혼용하는 것은 오류를 일으킬 수 있으며, 외부 라이브러리를 사용하는 경우에는 그 라이브러리가 non-strict mode 일 수도 있기 때문에 바람직하지 않다. 또한 함수도 일일이 만들어서 strict를 각각 지정해주어야 되기 때문에 피하도록 한다. 따라서, strict mode를 쓸 때는 즉시 실행 함수를 이용하여 선두에 strict mode를 적용하고서 이용한다. 123456// 즉시 실행 함수의 선두에 strict mode 적용(function () &#123; 'use strict'; // Do something...&#125;()); strict mode가 발생 시키는 에러 암묵적 전역 변수 : ReferenceError: x is not defined delete 연산자로 변수, 함수, 매개변수의 삭제 : SyntaxError: Delete of an unqualified identifier in strict mode. 매개변수 이름의 중복 : SyntaxError: Duplicate parameter name not allowed in this context with 문의 사용 : SyntaxError: Strict mode code may not include a with statement strict mode 적용에 의한 변화 일반 함수의 this strict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다. 이 때 에러는 발생하지 않는다. 12345678910111213(function () &#123; 'use strict'; function foo() &#123; console.log(this); // undefined // non-strict : window &#125; foo(); function Foo() &#123; console.log(this); // Foo &#125; new Foo();&#125;()); arguments 객체 strict mode 에서는 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다. 12345678(function (a) &#123; 'use strict'; // 매개변수에 전달된 인수를 재할당하여 변경 a = 2; // 변경된 인수가 arguments 객체에 반영되지 않는다. console.log(arguments); // &#123; 0: 1, length: 1 &#125; // nos-strict: &#123; 0: 2, length: 1 &#125;&#125;(1));","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Strict Mode","slug":"Strict-Mode","permalink":"https://hyeok999.github.io/tags/Strict-Mode/"}]},{"title":"daily_algorithm18","slug":"daily-algorithm18","date":"2019-10-17T11:28:44.000Z","updated":"2019-11-30T16:48:02.906Z","comments":true,"path":"2019/10/17/daily-algorithm18/","link":"","permalink":"https://hyeok999.github.io/2019/10/17/daily-algorithm18/","excerpt":"","text":"문제 출처 : 프로그래머스 같은 숫자는 싫어문제 설명배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면, arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다. arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다. 배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요. 제한사항 배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수 입출력 예 arr answer [1,1,3,3,0,1,1] [1,3,0,1] [4,4,4,3,3] [4,3] 입출력 예 설명입출력 예 #1,2문제의 예시와 같습니다. 12345678function solution(arr) &#123; let answer = []; answer = arr.filter(function (currentValue, index) &#123; return currentValue !== arr[index - 1]; &#125;); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-10","slug":"javascript-study-10","date":"2019-10-17T10:50:36.000Z","updated":"2019-11-30T16:29:09.144Z","comments":true,"path":"2019/10/17/javascript-study-10/","link":"","permalink":"https://hyeok999.github.io/2019/10/17/javascript-study-10/","excerpt":"","text":"JavaScript Study 10 용어 Prototype 상속의 문제점 메소드의 종류 __ proto __ 접근자 프로퍼티 객체 리터럴의 프로토타입 __ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유 프로토타입의 생성 시점 Object.create 직접 상속 용어 - ( 러버덕 ) 객체 인스턴스 리터럴 상속 메소드 __ proto __ 이란? 객체 리터럴의 프로토타입 함수 객체의 protype 프로퍼티 Prototype객체 : 사람이 구체적으로 이해할 수 있게끔 어떠한 사물이나 개념을 속성 ( 프로퍼티 ) 만 추상화하여 프로그래밍적으로 표현한 것. 인스턴스 : 객체를 사용하게끔 실물화 한 것. (생성자함수, 클래스로 인해 탄생) 클래스 : JS에서 클래스는 내부적으로 돌아가는 함수다. __ proto __ : 모든 객체가 소유중. 단방향 링크트 리스트. 접근자 프로퍼티. getter / setter prototytpe : 함수 객체만 소유중. 함수 객체의 prototype 프로퍼티 상속 : 부모 객체로 부터 메소드나 프로퍼티를 물려받는 행위. 일급객체가 갖는 4가지 특징 무명의 객체를 갖는다. 런타임에 실행할수있다. 변수에 값으로서 담을수있다. 매개변수에 전달할 수 있다. 함수의 결과값으로 반환할 수 있다. 모든 객체는 부모가 있다.( Object.prototype의 부모는 없다. - null ) 123456789101112// 생성자 함수function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee');// Person.prototype: Person 생성자 함수는 prototype 프로퍼티를 통해// 자신이 생성할 인스턴스(이 경우에는 me)의 프로토타입을 할당// me.__proto__: 객체 me의 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입에 접근// 결국 Person.prototype와 me.__proto__는 결국 동일한 프로토타입을 가리킨다.console.log(Person.prototype === me.__proto__); // true me -&gt; Person.prototype -&gt; Object.prototype -&gt; null : 프로토타입 체인 프로토타입 체인 vs 스코프 체인 프토타입 체인 : 프로퍼티를 찾는다. 스코프 체인 : 스코프내에서 식별자를 찾는다. 만약me.toString();이라는 명령이 들어왔다면 me라는 식별자를 스코프체인을 통해서 찾는다. 식별자를 찾았다면 .toString()이라는 프로퍼티 키를 프로토타입 체인을 통해서 찾는다. 인스턴스의 프로토타입은 생성자함수에 의하여 결정되게 된다. 상속의 문제점1234567891011121314151617181920212223// 생성자 함수function Circle(radius) &#123; this.radius = radius; this.getArea = function () &#123; // Math.PI는 원주율을 나타내는 상수이다. // Math.pow는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다. return Math.PI * Math.pow(this.radius, 2); &#125;;&#125;// 인스턴스 생성// 반지름이 1인 인스턴스 생성const circle1 = new Circle(1);// 반지름이 2인 인스턴스 생성const circle2 = new Circle(2);// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는// getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.// 따라서 getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.console.log(circle1.getArea === circle2.getArea); // falseconsole.log(circle1.getArea()); // 3.141592653589793console.log(circle2.getArea()); // 12.566370614359172 Circle 함수 내부에서 this.radius = radius;의 경우, 상태기 때문에 만들어질 인스턴스가 모두 가지고 있어야만한다. 왜냐하면 이것은 상태고 변경될수 있기 때문이다. 하지만 this.getArea = function () { .. }의 경우 모든 인스턴스가 가질 필요없다. 왜냐하면 이것은 동작이고 고정되었으며 하는 행위이기 때문이다. 따라서 이것을 바꾸기 위해서는 상속을 통해 프로토타입에서 행위를 하는 메서드만 가지고 있으면 될 뿐이다. 12345678910111213141516171819202122// 생성자 함수function Circle(radius) &#123; this.radius = radius;&#125;// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.Circle.prototype.getArea = function () &#123; return Math.PI * Math.pow(this.radius, 2);&#125;;// 인스턴스 생성const circle1 = new Circle(1);const circle2 = new Circle(2);// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.console.log(circle1.getArea === circle2.getArea); // trueconsole.log(circle1.getArea()); // 3.141592653589793console.log(circle2.getArea()); // 12.566370614359172 인스턴스 circle1 과 인스턴스 circle2는 Circle.prototype을 찾아갈수있다. ( Object.prototype이 물려준 circle1.__ proto __를 통해서 찾아갈수있다. ) 인스턴스 circle1 과 인스턴스 circle2는 Circle 생성자 함수을 찾아갈수있다. ( circle1.contructor === circle1.__ proto __ . constructor === Circle.prototype.constructor ) Circle 생성자 함수 는 인스턴스 circle1 과 인스턴스 circle2을 찾아갈 수 없다. 메소드 종류인스턴스가 “new” 하면 프로토타입 과 인스턴스가 연결이 된다. 인스턴스 메소드 : 인스턴스가 무조건 존재해야만 한다. person.makjiengu() 프로토타입 메소드 : 인스턴스 무조건 필요한것은 아니나, this의 문제가 있어 인스턴스를 필요로한다. person.toString() 정적 메소드 : 인스턴스 과정 없이 사용할 수 있다. Object.getPrototypeOf(person) __ proto __ 접근자 프로퍼티 모든 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다. __ proto __ 는 비표준화 되어있었다. ES6로 넘어오면서 각 브라우저에 __ proto __를 많이 사용하다보니 표준화하면서 되었지만 그전에는 비표준이었기 때문에 호환성 문제가 일어날수 있으므로 다음과 같은 메소드를 쓰라고 하였다. Object.getPrototypeOf(인스턴스명) : 해당 인스턴스의 프로토타입을 반환한다. 12345// __proto__ 는 가급적으로 사용하지 말아라.console.log( circle.__proto__ === Circle.prototype ); // true // 따라서 아래 문법을 추가 해주었음.console.log( Object.getPrototypeOf(circle) === Circle.prototype ); 객체 리터럴의 프로토타입123const person = &#123; name : 'Lee' &#125;;console.log(Object.getPrototypeOf(person) === Object.prototype); 객체는 생성자 함수로 만든 것이 아니고 객체 리터럴로 만든것인데 객체리터럴은 마치 Object 생성자가 만든 것으로 볼 수 있다. 객체는 ObjectCreate가 만든다. ( 추상연산 ) 리터럴 표기법 생성자 함수 프로토타입 객체 리터럴 Object Object.protptype 함수 리터럴 Function Function.prototype 배열 리터럴 Array Array.prototype 정규 표현식 리터럴 RegExp RegExp.protptype 리터럴 표기법으로 생성된 객체들은 해당 생성자 함수가 만든 것이 아니다. 비슷한 동작원리로 인해 프로토타입이 해당으로 가는 것이다. 일반 객체의 프로토타입 : Object.prototype 이다. 배열 객체의 프로토타입 : Array.prototype 이다. 함수 객체의 프로토타입 : Function.prototype 이다. 모든 객체의 종점 프로토타입 : null __ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유1234567const parent = &#123;&#125;;const child = &#123;&#125;;// child의 프로토타입을 parent로 지정child.__proto__ = parent;// parent의 프로토타입을 child로 설정parent.__proto__ = child; // TypeError: Cyclic __proto__ value 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함. 프로토타입의 생성 시점프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 일반함수 , 생성자함수 : constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. 12345678// Person 호이스팅// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.console.log(Person.prototype); // &#123;constructor: ƒ&#125;// 생성자 함수function Person(name) &#123; this.name = name;&#125; 빌트인 생성자 함수 : 전역객체(window) 가 만들어질 때, 다 같이 만들어진다. Object.create 직접 상속Object.create(프로토타입으로 지정할 객체명 [, 생성할 객체의 프로퍼티를 갖는 객체 ]) 12345678910111213141516171819202122232425262728293031// 프로토타입이 null인 객체를 생성한다.// 즉, 생성된 객체는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.// obj → nulllet obj = Object.create(null);// obj = &#123;&#125;;와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype);// obj → Object.prototype → nullobj = Object.create(Object.prototype, &#123; x: &#123; value: 1 &#125;&#125;);// obj.x = 1; 와 동일하다.// 객체를 직접 상속받는다.// obj → myProto → Object.prototype → nullconst myProto = &#123; x: 10 &#125;;obj = Object.create(myProto);console.log(obj.x); // 10console.log(Object.getPrototypeOf(obj) === myProto); // true// 생성자 함수// obj = new Person('Lee')와 동일하다.// obj → Person.prototype → Object.prototype → nullfunction Person(name) &#123; this.name = name;&#125;obj = Object.create(Person.prototype);obj.name = 'Lee'; 여기서 주의할 것. Object.create(객체 || null [, 직접 프로퍼티 어트리뷰트 지정 혹은 객체]) 을 이용해서 객체를 생성할 경우,직접 프로퍼티 어트리뷰트를 지정하고 생략한다면 기본값으로 false를 반환한다. 반대로 객체 리터럴로 객체를 만들었다면 모든 어트리뷰트는 true를 반환한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 21강 this","slug":"javascript-preview-21","date":"2019-10-16T21:55:15.000Z","updated":"2019-11-30T16:38:39.224Z","comments":true,"path":"2019/10/17/javascript-preview-21/","link":"","permalink":"https://hyeok999.github.io/2019/10/17/javascript-preview-21/","excerpt":"","text":"JavaScript 21강 예습 21강 : this this 키워드 this는 코드 어디든지 참조가능하다. 함수 호출 방식과 this 바인딩 일반 함수 호출 메소드 호출 생성자 함수 호출 Function.prototype.apply/call 메소드에 의한 간접 호출 Function.prototype.bind 메소드에 의한 간접 호출 21강thisthis 키워드 동작인 메소드는 자신이 속한 객체의 상태를 참조하고 변경할 수 있어야 한다. 즉, 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다. this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. this가 가리키는 값 - this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다. 바인딩(binding) 바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다. 12345678910111213141516171819202122232425// 객체 리터럴const circle = &#123; radius: 5, getDiameter() &#123; // this는 메소드를 호출한 객체를 가리킨다. return 2 * this.radius; &#125;&#125;;console.log(circle.getDiameter()); // 10// 생성자 함수function Circle(radius) &#123; // this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius;&#125;Circle.prototype.getDiameter = function () &#123; // this는 생성자 함수가 생성할 인스턴스를 가리킨다. return 2 * this.radius;&#125;;// 인스턴스 생성const circle = new Circle(5);console.log(circle.getDiameter()); // 10 this는 코드 어디든지 참조가능하다. 일반 함수 및 전역의 this ➤ window ( strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. ) 생성자의 this ➤ 인스턴스 객체 객체 및 메소드 ➤ 자기 자신 12345678910111213141516171819202122232425262728// this는 어디서든지 참조 가능하다.// 전역에서 this는 전역 객체 window를 가리킨다.console.log(this); // windowfunction square(number) &#123; // 일반 함수 내부에서 this는 전역 객체 window를 가리킨다. console.log(this); // window return number * number;&#125;square(2);const person = &#123; name: 'Lee', getName() &#123; // 메소드 내부에서 this는 메소드를 호출한 객체를 가리킨다. console.log(this); // &#123;name: \"Lee\", getName: ƒ&#125; return this.name; &#125;&#125;;console.log(person.getName()); // Leefunction Person(name) &#123; // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다. console.log(this); // Person &#123; name: \"Lee\" &#125; this.name = name;&#125;const me = new Person('Lee'); 함수 호출 방식과 this 바인딩this가 가리키는 값, 즉 this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 함수를 호출하는 방식은 아래와 같이 다양하다. 일반 함수 호출 메소드 호출 생성자 함수 호출 Function.prototype.apply/call/bind 메소드에 의한 간접 호출 123456789101112131415161718192021222324252627282930// this에 바인딩될 객체는 함수 호출 방식에 따라 동적으로 결정된다.const foo = function () &#123; console.dir(this);&#125;;// 동일한 함수도 다양한 방식으로 호출할 수 있다.// 1. 일반 함수 호출// foo 함수를 일반적인 방식으로 호출// this는 전역 객체 window를 가리킨다.foo(); // window// 2. 메소드 호출// foo 함수를 프로퍼티의 값으로 할당하여 호출// this는 메소드를 호출한 객체 obj를 가리킨다.const obj = &#123; foo &#125;;obj.foo(); // obj// 3. 생성자 함수 호출// foo 함수를 new 연산자와 함께 생성자 함수로 호출// this는 생성자 함수가 생성한 인스턴스를 가리킨다.new foo(); // foo &#123;&#125;// 4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출// this는 인수에 의해 결정된다.const bar = &#123; name: 'bar' &#125;;foo.call(bar); // barfoo.apply(bar); // barfoo.bind(bar)(); // bar 주의할 것은 동일한 함수도 다양한 방식으로 호출할 수 있다는 것. 일반 함수 호출12345678function foo() &#123; console.log(\"foo's this: \", this); // window function bar() &#123; console.log(\"bar's this: \", this); // window &#125; bar();&#125;foo(); 일반함수호출 - 엄격모드 - 12345678910function foo() &#123; 'use strict'; console.log(\"foo's this: \", this); // undefined function bar() &#123; console.log(\"bar's this: \", this); // undefined &#125; bar();&#125;foo(); 123456789101112131415161718192021222324// var 키워드로 선언한 변수 value는 전역 객체의 프로퍼티이다.var value = 1;// const 키워드로 선언한 변수 value는 전역 객체의 프로퍼티가 아니다.// const value = 1;const obj = &#123; value: 100, foo() &#123; console.log(\"foo's this: \", this); // &#123;value: 100, foo: ƒ&#125; console.log(\"foo's this.value: \", this.value); // 100 // 메소드 내에서 정의한 중첩 함수 function bar() &#123; console.log(\"bar's this: \", this); // window console.log(\"bar's this.value: \", this.value); // 1 &#125; // 메소드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 // 중첩 함수 내부의 this에는 전역 객체가 바인딩된다. bar(); &#125;&#125;;obj.foo(); obj.foo()는 메소드로 호출하였기 때문에 this는 자기 자신 foo를 가리킬것이고 중첩함수 bar()는 객체 내부에서 일반 함수 호출로 인해 전역 window와 바인딩될것이다. 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩된다. 콜백함수 혹은 중첩함수 내부에서 메소드처럼 this를 동작시키려면 다음과 같은 방법을 이용하낟. that이용 12345678910111213141516var value = 1;const obj = &#123; value: 100, foo() &#123; // this 바인딩(obj)를 변수 that에 할당한다. const that = this; // 콜백 함수 내부에서 this 대신 that을 참조한다. setTimeout(function () &#123; console.log(that.value); // 100 &#125;, 100); &#125;&#125;;obj.foo(); this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메소드 12345678910111213var value = 1;const obj = &#123; value: 100, foo() &#123; // 콜백 함수에 명시적으로 this를 바인딩한다. setTimeout(function () &#123; console.log(this.value); // 100 &#125;.bind(this), 100); &#125;&#125;;obj.foo(); 메소드 호출 메소드 내부의 this는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩된다는 것이다. 12345678910const person = &#123; name: 'Lee', getName() &#123; // 메소드의 this는 메소드를 호출한 객체에 바인딩된다. return this.name; &#125;&#125;;// 메소드 getName을 호출한 객체는 person이다.console.log(person.getName()); // Lee 프로토타입 메소드 내부에서 사용된 this도 일반 메소드와 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다. 123456789101112131415function Person(name) &#123; this.name = name;&#125;Person.prototype.getName = function () &#123; return this.name;&#125;;const me = new Person('Lee');// getName 메소드를 호출한 객체는 me이다.console.log(me.getName()); // ① LeePerson.prototype.name = 'Kim';// getName 메소드를 호출한 객체는 Person.prototype이다.console.log(Person.prototype.getName()); // ② Kim ①의 경우, getName 메소드를 호출한 객체는 me이다. 따라서 getName 메소드 내부의 this는 me를 가리키며 this.name은 ‘Lee’이다. ②의 경우, getName 메소드를 호출한 객체는 Person.prototype이다. Person.prototype도 객체이므로 직접 메소드를 호출할 수 있다. 따라서 getName 메소드 내부의 this는 Person.prototype를 가리키며 this.name은 ‘Kim’이다. 생성자 함수 호출생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다. 1234567891011121314151617// 생성자 함수function Circle(radius) &#123; // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// 인스턴스의 생성// 반지름이 5인 Circle 객체를 생성const circle1 = new Circle(5);// 반지름이 10인 Circle 객체를 생성const circle2 = new Circle(10);console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 Function.prototype.apply/call 메소드에 의한 간접 호출 Function.prototype.apply, Function.prototype.call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다. apply와 call 메소드는 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있다. 12345678/** * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다. * @param thisArg - this로 사용될 객체 * @param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체 * @returns 호출된 함수의 반환값 */Function.prototype.apply(thisArg[, argsArray]) 12345678/** * 주어진 this 바인딩과 인수 리스트를 사용하여 함수를 호출한다. * @param thisArg - this로 사용될 객체 * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트 * @returns 호출된 함수의 반환값 */Function.prototype.call (thisArg[, arg1[, arg2[, ...]]]) 123456789101112function getThisBinding() &#123; return this;&#125;// this로 사용할 객체const thisArg = &#123; a: 1 &#125;;console.log(getThisBinding()); // window// 함수(getThisBinding)를 호출하면서 인수로 전달한 객체를 호출한 함수의 this에 바인딩한다.console.log(getThisBinding.apply(thisArg)); // &#123; a: 1 &#125;console.log(getThisBinding.call(thisArg)); // &#123; a: 1 &#125; apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. apply와 call 메소드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우이다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice와 같은 배열의 메소드를 사용할 수 없으나 apply와 call 메소드를 이용하면 가능하다. 12345678910111213function convertArgsToArray() &#123; console.log(arguments); // arguments 객체를 배열로 변환 // slice: 배열의 특정 부분에 대한 복사본을 생성한다. const arr = Array.prototype.slice.apply(arguments); // const arr = Array.prototype.slice.call(arguments); console.log(arr); return arr;&#125;convertArgsToArray(1, 2, 3); // [ 1, 2, 3 ] Function.prototype.bind 메소드에 의한 간접 호출Function.prototype.bind 메소드는 apply와 call 메소드와는 달리 함수를 호출하지 않고 this로 사용할 객체만을 전달한다. 123456789101112function getThisBinding() &#123; return this;&#125;// this로 사용할 객체const thisArg = &#123; a: 1 &#125;;// bind 메소드는 함수에 this로 사용할 객체를 전달한다.// bind 메소드는 함수를 호출하지는 않는다.console.log(getThisBinding.bind(thisArg)); // getThisBinding// bind 메소드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.console.log(getThisBinding.bind(thisArg)()); // &#123;a: 1&#125; bind는 주로 콜백함수 혹은 중첩함수등에서 자주 이용된다. 123456789101112131415161718function Person(name) &#123; this.name = name;&#125;Person.prototype.doSomething = function (callback) &#123; // ① callback();&#125;;function foo() &#123; console.log(this.name); // ②&#125;const person = new Person('Lee');person.doSomething(foo); // ''// =&gt; window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이다. window.name의 기본값은 ''이다.// 만약 Node.js 환경에서 실행하면 undefined가 출력된다. 위 예제에서 foo()를 호출하면 일반함수이므로 window를 가리키게 된다. 콜백 함수 foo는 외부 함수 doSomething를 돕는 헬퍼 함수(보조 함수)의 역할을 하기 때문에 외부 함수 doSomething 내부의 this와 콜백 함수 내부의 this가 상이하면 문맥상 문제가 발생한다. 따라서 콜백 함수 내부의 this를 콜백 함수를 호출하는 외부 함수 내부의 this와 일치시켜 주어야 한다. 이때 bind 메소드를 사용하여 this를 일치시킬 수 있다. 물론 apply와 call 메소드를 사용할 수도 있다. 123456789101112131415161718function Person(name) &#123; this.name = name;&#125;Person.prototype.doSomething = function (callback) &#123; // ① callback.bind(this)(); // callback.apply(this); // callback.call(this);&#125;;function foo() &#123; console.log(this.name); // ②&#125;const person = new Person('Lee');person.doSomething(foo); // Lee 지금까지 함수 호출 방식에 따라 this 바인딩이 동적으로 결정되는 것에 대해 살펴보았다. 함수 호출 방식 this 바인딩 일반 함수 호출 전역 객체 메소드 호출 메소드를 호출한 객체 생성자 함수 호출 생성자 함수가 (미래에) 생성할 인스턴스 Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"this","slug":"this","permalink":"https://hyeok999.github.io/tags/this/"}]},{"title":"javascript 20강 프로퍼티,빌트인","slug":"javascript-preview-20","date":"2019-10-16T21:00:08.000Z","updated":"2019-11-30T16:39:23.304Z","comments":true,"path":"2019/10/17/javascript-preview-20/","link":"","permalink":"https://hyeok999.github.io/2019/10/17/javascript-preview-20/","excerpt":"","text":"JavaScript 20강 예습 20강 : 전역 객체 전역 프로퍼티 Infinity (대문자주의) NaN undefined 빌트인 전역 함수 eval isFinite isNaN parseInt toString encodeURI / decodeURI encodeURIComponent / decodeURIComponent 20강전역 객체 전역 객체는 코드가 실행되기 이전 단계에 JS엔진에 의해 생성되는 특수한 객체. 클라이언트 사이드 환경 = windolw 서버 사이드 환경 = global 전역객체의 구성 표준 빌트인 객체 ( Object, String, Number, Function, Array… ) 환경(클라이언트 사이드, 서버 사이드)에 따른 호스트 객체(WEB API, 호스트 API) var키워드로 선언한 전역 변수, 전역 함수, 선언하지 않은 변수에 값을 할당한 암묵적 전역 변수 전역 객체의 특징 개발자가 의도적으로 생성할 수 없다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 123456// 문자열 'F'를 16진수로 해석하여 10진수로 변환하여 반환한다.console.log(window.parseInt('F', 16)); // 15// 전역 객체 window의 메소드인 parseInt은 window.parseInt 또는 parseInt으로 호출할 수 있다.console.log(parseInt('F', 16)); // 15console.log(window.parseInt === parseInt); // true 전역 프로퍼티 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다. 애플리케이션 전역에서 사용하는 값들을 나타내기 위해 사용한다. 1. Infinity (대문자주의) Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다. 123// 전역 프로퍼티는 window를 생략하고 참조할 수 있다.console.log(window.Infinity === Infinity); // trueconsole.log(typeof Infinity); // number 2. NaN NaN 프로퍼티는 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. NaN 프로퍼티는 Number.NaN 프로퍼티와 같다. 1234console.log(window.NaN); // NaNconsole.log(Number('xyz')); // NaNconsole.log(1 * 'string'); // NaNconsole.log(typeof NaN); // number 3. undefined undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다. 12345console.log(window.undefined); // undefinedvar foo;console.log(foo); // undefinedconsole.log(typeof undefined); // undefined 빌트인 전역 함수 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메소드이다. eval 문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. 전달된 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환한다. 함수 자체에서 코드를 평가하고 동적으로 실행한다는 것. 1234567891011121314// 표현식인 문console.log(eval('1 + 2;')); // 3// 표현식이 아닌 문console.log(eval('var x = 5;')); // undefined// 변수 x가 선언되었다.console.log(x); // 5// 객체 리터럴은 반드시 괄호로 둘러싼다.var o = eval('(&#123; a: 1 &#125;)');console.log(o); // &#123;a: 1&#125;// 함수 리터럴은 반드시 괄호로 둘러싼다.var f = eval('(function() &#123; return 1; &#125;)');console.log(f()); // 1 123456789101112var x = 1;function foo() &#123; // eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수정한다. eval('var x = 2;'); console.log(x); // 2&#125;foo();// eval 함수는 자신이 호출된 스코프 외부에 영향를 주지 않는다.console.log(x); // 1 eval 함수는 전역메소드이므로 렉시컬 스코프를 따르는 JS의 특성상 함수 정의가 평가되는 시점에서 스코프가 결정이 되는데 그렇다면 eval는 전역객체의 스코프를 따라야만 한다. 하지만 eval는 런타임 foo함수의 스코프를 동적으로 수정할 수 있다. 엄격 모드(strict mode)에서 eval 함수는 기존의 스코프를 수정하지 않고 자신만의 독자적인 스코프를 생성한다. eval 함수에 전달한 변수 선언문이 let, const 키워드를 사용했다면 엄격 모드가 적용된다. (독자적 스코프) 1eval('const x = 2; console.log(x);'); // 2 isFinite 매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다. 12345678910console.log(isFinite(Infinity)); // falseconsole.log(isFinite(NaN)); // falseconsole.log(isFinite('Hello')); // falseconsole.log(isFinite('2005/12/12')); // falseconsole.log(isFinite(0)); // trueconsole.log(isFinite(2e64)); // trueconsole.log(isFinite('10')); // true: '10' → 10console.log(isFinite(null)); // true: null → 0console.log(+null); // 0 isNaN 매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리런 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다. 123456789101112131415161718192021222324// 숫자console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // false// 문자열console.log(isNaN('blabla')); // true: 'blabla' → NaNconsole.log(isNaN('10')); // false: '10' → 10console.log(isNaN('10.12')); // false: '10.12' → 10.12console.log(isNaN('')); // false: '' → 0console.log(isNaN(' ')); // false: ' ' → 0// 불리언console.log(isNaN(true)); // false: true → 1console.log(isNaN(null)); // false: null → 0// undefinedconsole.log(isNaN(undefined)); // true: undefined → NaN// 객체console.log(isNaN(&#123;&#125;)); // true: &#123;&#125; → NaN// dateconsole.log(isNaN(new Date())); // false: new Date() → Numberconsole.log(isNaN(new Date().toString())); // true: String → NaN parseFloat 매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환한다. 123456789console.log(parseFloat('3.14')); // 3.14console.log(parseFloat('10.00')); // 10// 공백으로 구분된 문자열은 첫번째 문자열만 변환한다.console.log(parseFloat('34 45 66')); // 34console.log(parseFloat('40 years')); // 40// 첫번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.console.log(parseFloat('He was 40')); // NaN// 전후 공백은 무시된다.console.log(parseFloat(' 60 ')); // 60 parseInt 매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수이다. 123456789101112131415161718192021// '10'을 10진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10')); // 10// '10'을 2진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10', 2)); // 2// '10'을 8진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10', 8)); // 8// '10'을 16진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10', 16)); // 16console.log(parseInt(10.123)); // 10console.log(parseInt('10.123')); // 10// 16진수 리터럴 ‘0xf’를 16진수로 해석하고 10진수 정수로 그 결과를 반환한다.console.log(parseInt('0xf')); // 15// 위 코드와 같다.console.log(parseInt('f', 16)); // 15// 2진수 리터럴(0b로 시작) =&gt; 0 이후 무시console.log(parseInt('0b10')); // 0// 8진수 리터럴(ES6에서 도입. 0o로 시작) =&gt; 0 이후 무시console.log(parseInt('0o10')); // 0 첫번째 매개변수에 전달된 문자열의 첫번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환한다. 1234// 'A'는 10진수로 해석할 수 없다.console.log(parseInt('A0')); // NaN// '2'는 2진수로 해석할 수 없다.console.log(parseInt('20', 2)); // NaN 하지만 첫번째 매개변수에 전달된 문자열의 두번째 문자부터 해당 진수를 나타내는 숫자가 아닌 문자(예를 들어 2진수의 경우, 2)와 마주치면 이 문자와 계속되는 문자들은 전부 무시되며 해석된 정수값만을 반환한다. 12345678// 10진수로 해석할 수 없는 'A'이후의 문자는 모두 무시된다.console.log(parseInt('1A0')); // 1// 2진수로 해석할 수 없는 '2'이후의 문자는 모두 무시된다.console.log(parseInt('102', 2)); // 2// 8진수로 해석할 수 없는 '8'이후의 문자는 모두 무시된다.console.log(parseInt('58', 8)); // 5// 16진수로 해석할 수 없는 'G'이후의 문자는 모두 무시된다.console.log(parseInt('FG', 16)); // 15 첫번째 매개변수에 전달된 문자열에 공백이 있다면 첫번째 문자열만 해석하여 반환하며 전후 공백은 무시된다. 만일 첫번째 문자열을 숫자로 해석할 수 없는 경우, NaN을 반환한다. 1234567// 공백으로 구분된 문자열은 첫번째 문자열만 변환한다.console.log(parseInt('34 45 66')); // 34console.log(parseInt('40 years')); // 40// 첫번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.console.log(parseInt('He was 40')); // NaN// 전후 공백은 무시된다.console.log(parseInt(' 60 ')); // 60 toString( ) 기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메소드를 사용한다. 1234567891011const x = 15;// 15을 2진수로 변환하여 그 결과를 문자열로 반환한다.console.log(x.toString(2)); // '1111'// 15을 8진수로 변환하여 그 결과를 문자열로 반환한다.console.log(x.toString(8)); // '17'// 15을 16진수로 변환하여 그 결과를 문자열로 반환한다.console.log(x.toString(16)); // 'f'// 숫자값을 문자열로 변환한다.console.log(x.toString()); // '15' encodeURI / decodeURI encodeURI 함수는 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다. URI는 인터넷에 있는 자원을 나타내는 유일한 주소를 말한다. URI의 하위개념으로 URL, URN이 있다. 123456789101112/** * 완전한 URI를 전달받아 인코딩하여 이스케이프 처리한다. * @param &#123;string&#125; uri - 완전한 URI * @returns &#123;string&#125; 인코딩된 URI */encodeURI(uri)/** * 인코딩된 URI을 전달받아 이스케이프 처리되기 이전으로 디코딩한다. * @param &#123;string&#125; encodedURI - 인코딩된 URI * @returns &#123;string&#125; 디코딩된 URI */decodeURI(encodedURI) 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. 123456789101112// 완전한 URIconst uri = 'http://example.com?name=이웅모&amp;job=programmer&amp;teacher';// encodeURI 함수는 완전한 URI를 전달받아 인코딩하여 이스케이프 처리한다.const enc = encodeURI(uri);console.log(enc);// http://example.com?name=%EC%9D%B4%EC%9B%85%EB%AA%A8&amp;job=programmer&amp;teacher// decodeURI 함수는 인코딩된 완전한 URI를 전달받아 이스케이프 처리되기 이전으로 디코딩한다.const dec = decodeURI(enc);console.log(dec);// http://example.com?name=이웅모&amp;job=programmer&amp;teacher encodeURIComponent / decodeURIComponentencodeURIComponent 함수은 매개변수로 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. 단, 알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( ) 문자는 이스케이프 처리에서 제외된다. 123456789101112/** * URI의 구성요소를 전달받아 인코딩하여 이스케이프 처리한다. * @param &#123;string&#125; uriComponent – URI의 구성요소 * @returns &#123;string&#125; 인코딩된 URI의 구성요소 */encodeURIComponent(uriComponent)/** * 인코딩된 URI의 구성요소를 전달받아 이스케이프 처리되기 이전으로 디코딩한다. * @param &#123;string&#125; encodedURIComponent - 인코딩된 URI의 구성요소 * @returns &#123;string&#125; 디코딩된 URI의 구성요소 */decodeURIComponent(encodedURIComponent) encodeURIComponent 함수는 매개변수로 전달된 문자열을 URI의 구성요소인 쿼리 파라미터의 일부 간주한다. 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩한다. 반면 encodeURI 함수는 매개변수로 전달된 문자열을 완전한 URI 전체라고 간주한다. 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩하지 않는다. 12345678910111213141516171819202122// URI의 쿼리 파라미터const uriComp = 'name=이웅모&amp;job=programmer&amp;teacher';// encodeURIComponent 함수는 매개변수로 전달된 문자열을 URI의 구성요소인 쿼리 파라미터의 일부 간주한다.// 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩한다.let enc = encodeURIComponent(uriComp);console.log(enc);// name%3D%EC%9D%B4%EC%9B%85%EB%AA%A8%26job%3Dprogrammer%26teacherlet dec = decodeURIComponent(enc);console.log(dec);// 이웅모&amp;job=programmer&amp;teacher// encodeURI 함수는 매개변수로 전달된 문자열을 완전한 URI로 간주한다.// 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩하지 않는다.enc = encodeURI(uriComp);console.log(enc);// name=%EC%9D%B4%EC%9B%85%EB%AA%A8&amp;job=programmer&amp;teacherdec = decodeURI(enc);console.log(dec);// name=이웅모&amp;job=programmer&amp;teacher","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Property","slug":"Property","permalink":"https://hyeok999.github.io/tags/Property/"}]},{"title":"javascript 18강 프로토타입","slug":"javascript-preview-18","date":"2019-10-16T16:40:50.000Z","updated":"2019-11-30T16:40:25.757Z","comments":true,"path":"2019/10/17/javascript-preview-18/","link":"","permalink":"https://hyeok999.github.io/2019/10/17/javascript-preview-18/","excerpt":"","text":"JavaScript 18강 예습 18강 : 프로토타입 객체 지향 프로그래밍 상속과 프로토타입 프로토타입 과 객체 __ proto __ 접근자 프로퍼티 __ proto __ 접근자 프로퍼티 다. __ proto __ 접근자 프로퍼티 상속을 통해 사용된다. 프로토타입 체인 __ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유 __ proto __ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천. 함수 객체의 prototype 프로퍼티 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입 프로토타입의 constructor 프로퍼티와 생성자 함수 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입 리터럴 표기법에 의해 생성된 객체 프로토타입의 생성 시점 사용자 정의 생성자 함수와 프로토타입 생성 시점 빌트인 생성자 함수와 프로토타입 생성 시점 객체 생성 방식과 프로토타입의 결정 Object 생성자 함수에 의해 생성된 객체의 프로토타입 생성자 함수에 의해 생성된 객체의 프로토타입 프로토타입 체인 캡슐화 오버라이딩 과 프로퍼티 쉐도잉 프로토타입의 교체 생성자 함수에 의한 프로토타입의 교체 인스턴스에 의한 프로토타입의 교체 instanceof 연산자 직접 상속 Object.create에 의한 직접 상속 빌트인 객체들은 간접적인 호출을 추천한다. 객체 리터럴 내부에서 __ proto __에 의한 직접 상속 정적 프로퍼티/메소드 프로퍼티 존재 확인 프로퍼티 열거 18강프로토 타입 클래스 ES6에서 제공되는 함수. 새로운 객체 생성 메카니즘. 기존 프로포타입 기반 패턴의 문법적 설탕. 문법적 설탕(syntactic sugar)라는 것이 의미하는 것은 문법적 기능은 그대로인데 그것을 읽는 사람이 직관적으로 쉽게 코드를 읽을 수 있게 만든다는 것. 객체지향 프로그래밍 객체의 상태(state)를 나타내는 데이터(property)와 상태 데이터를 조작할 수 있는 동작(behavior)(method)을 하나의 논리적인 단위로 묶어 생각한다. 이때 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조를 객체(object)라 한다. 이러한 객체들의 집합으로 표현하려는 프로그래밍 패러다임을 객체지향 프로그래밍이라 한다. 상속과 프로토 타입 상속 : 어떤 객체의 프로퍼티 나 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것. 프로토타입 : JS는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. 중복을 제거하는 방법은 코드를 적극적으로 재사용하는 것이다. 1234567891011121314151617181920212223// 생성자 함수function Circle(radius) &#123; this.radius = radius; this.getArea = function () &#123; // Math.PI는 원주율을 나타내는 상수이다. // Math.pow는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다. return Math.PI * Math.pow(this.radius, 2); &#125;;&#125;// 인스턴스 생성// 반지름이 1인 인스턴스 생성const circle1 = new Circle(1);// 반지름이 2인 인스턴스 생성const circle2 = new Circle(2);// getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.// 하지만 Circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메소드를 중복 생성하고// 모든 인스턴스가 중복 소유한다.console.log(circle1.getArea === circle2.getArea); // falseconsole.log(circle1.getArea()); // 3.141592653589793console.log(circle2.getArea()); // 12.566370614359172 circle1 과 circle2의 radius는 각 인스턴스마다 프로퍼티 값이 다르다. getArea 메소드는 모든 인스턴스가 동일한 내용의 메소드를 사용한다. 즉, getArea 메소드는 중복 생성이 되고 모든 인스턴스가 중복으로 소유하게 된다. 위의 문제를 상속을 통해 불필요한 중복을 제거해 보자. 자바스크립트는 프로토타입(prototype)을 기반으로 상속을 구현한다. 123456789101112131415161718192021function Circle(radius) &#123; this.radius = radius;&#125;// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.Circle.prototype.getArea = function () &#123; return Math.PI * Math.pow(this.radius, 2);&#125;;// 인스턴스 생성const circle1 = new Circle(1);const circle2 = new Circle(2);// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.console.log(circle1.getArea === circle2.getArea); // trueconsole.log(circle1.getArea()); // 3.141592653589793console.log(circle2.getArea()); // 12.566370614359172 Circle 생성자 함수가 만든 모든 인스턴스는 자신의 프로토타입(Circle.prototype)의 모든 프로퍼티와 메소드를 상속을 받는다. 따라서 getArea메소드는 단 1개만 생성되고 Circle의 프로토타입에 할당이 되어있다. 그리고 모든 인스턴스는 getArea메소드를 상속받아 사용할 수 있다. 이처럼, 상속은 코드의 재사용을 극대화 시켜줄 수 있다. 프로토 타입 객체 객체 지향 프로그래밍의 근간 ‘상속’을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체. 다른 객체에 공유 프로퍼티(메소드 포함)를 제공. 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 모든 객체는 생성될 때 [[Prototype]] 내부 슬롯의 값으로 프로토타입의 참조를 저장한다. 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다. 객체 리터럴에 의해 생성된 객체의 프로토타입 Object.prototype과생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어 있다. 인스턴스(객체) x는 자신의 프로토타입(생성자함수.prototype)에게 접근하기 위해 링크프로퍼티인 __ proto __ 로 자신의 [[Prototype]] 내부 슬롯이 가리키는 객체에 접근할 수 있다. 생성자 함수 Fn()는 자신의 프로퍼티 prototype을 통해 프로토타입(생성자함수.prototype)에 접근할 수 있다. 프로토타입(생성자함수.prototype)은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다. ( 객체 리터럴에 의해 생성된 객체의 프로토 타입은 Object.prototype이다.생성자 함수에 의해 생성된 객체는 생성자함수.prototype 프로퍼티에 바인딩 되어 있다. ) 모든 객체는 하나의 프로토 타입을 갖는다. 프로토 타입은 null 이거나 객체다. 모든 프로토 타입은 생성자 함수와 연결 되어 있다. (즉, 생성자함수 &lt;-&gt; 프로토타입 &lt;-&gt; 객체) __ proto __ 접근자 프로퍼티 모든 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다. __ proto __ 접근자 프로퍼티다.1const person = &#123; name: 'Lee' &#125;; 빨간 박스로 표시한 것이 person 객체의 프로토타입인 Object.prototype __ proto __ 접근자 프로퍼티를 통해 person 객체의 [[Prototype]] 내부 슬롯이 가리키는 객체인 Object.prototype에 접근한 결과를 표시한것. __ proto __ 접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다. Object.prototype의 프로퍼티인 __ proto __ 접근자 프로퍼티는 getter/setter 함수라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다. __ proto __ 를 통해 프로토타입에 접근하면 내부적으로 __ proto __ 접근자 프로퍼티의 getter 함수인 get __ proto __가 호출. __ proto __ 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 __ proto __ 접근자 프로퍼티의 setter 함수인 set __ proto __가 호출 123456789const obj = &#123;&#125;;const parent = &#123; x: 1 &#125;;// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득obj.__proto__;// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체obj.__proto__ = parent;console.log(obj.x); // 1 __ proto __ 접근자 프로퍼티는 상속을 통해 사용된다. __ proto __ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다. 모든 객체는 상속을 통해 Object.prototype.__ proto __ 접근자 프로퍼티를 사용할 수 있다. 123456789// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.console.log(person.hasOwnProperty('__proto__')); // false// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티이다.console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.console.log(&#123;&#125;.__proto__ === Object.prototype); // true 프로토타입 체인​ JS는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 __ proto __ 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며 이 객체는 모든 객체에게 상속된다. __ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함. 따라서, 단방향 링크드 리스트형태로 구현을 해야만 한다. 1234567const parent = &#123;&#125;;const child = &#123;&#125;;// child의 프로토타입을 parent로 지정child.__proto__ = parent;// parent의 프로토타입을 child로 설정parent.__proto__ = child; // TypeError: Cyclic __proto__ value 위와 같은 코드가 있다면 비정상적인 프로토타입 체인을 통해 프로퍼티 검색시 무한루프에 빠지게 되므로 단방향으로 구성해야만 한다. __ proto __ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천. 모든 객체가 __ proto __ 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다. 직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성할 수도 있다. 대신 프로포타입의 참조를 취득하고 변경을 원할 떈 Object.getPrototypeOf 메소드 와Object.setPrototypeOf 메소드를 이용한다. 123456789const obj = &#123;&#125;;const parent = &#123; x: 1 &#125;;// obj 객체의 프로토타입을 취득Object.getPrototypeOf(obj); // obj.__proto__;// obj 객체의 프로토타입을 교체Object.setPrototypeOf(obj, parent); // obj.__proto__ = parent;console.log(obj.x); // 1 함수 객체의 prototype 프로퍼티 함수 객체는 __ proto __ 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다.일반 객체에는 prototype 프로퍼티가 없다. 12345// 함수 객체는 prototype 프로퍼티를 소유한다.console.log((function () &#123;&#125;).hasOwnProperty('prototype')); // true// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.console.log(&#123;&#125;.hasOwnProperty('prototype')); // false prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로서 사용될 때,생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킨다.따라서 생성자 함수로서 호출할 수 없는 함수, 즉 함수의 종류가 Arrow, Method인 함수인 non-constructor는 프로토타입이 생성되지 않으며 prototype 프로퍼티도 소유하지 않는다. 모든 객체가 가지고 있는(엄밀히 말하면 Object.prototype로부터 상속받은) proto 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 구분 소유 값 사용 주체 사용 목적 proto 접근자 프로퍼티 모든 객체 프로토타입의 참조 모든 객체 모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용 prototype 프로퍼티 함수 객체 프로토타입의 참조 생성자 함수 생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 생성자 함수로 객체를 생성한 후 proto 접근자 프로퍼티와 prototype 프로퍼티로 프로토타입 객체에 접근. 123456789101112// 생성자 함수function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee');// Person.prototype: Person 생성자 함수는 prototype 프로퍼티를 통해// 자신이 생성할 인스턴스(이 경우에는 me)의 프로토타입을 할당// me.__proto__: 객체 me의 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입에 접근// 결국 Person.prototype와 me.__proto__는 결국 동일한 프로토타입을 가리킨다.console.log(Person.prototype === me.__proto__); // true 동일한 프로토타입을 가리킨다. 프로토타입의 constructor 프로퍼티와 생성자 함수 모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다. 123456789// 생성자 함수function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee');// me 객체의 생성자 함수는 Person이다.console.log(me.constructor === Person); // true 위 예제에서 Person 생성자 함수는 me 객체를 생성했다. 이때 me 객체는 프로토타입의 contructor 프로퍼티를 통해 생성자 함수와 연결된다. me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototype에 constructor 프로퍼티가 있다. me 객체는 프로토타입인 Person.prototype에 constructor 프로퍼티를 상속받아 사용할 수 있다. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입12345678910111213// 생성자 함수에 의해 생성된 인스턴스// obj 객체를 생성한 생성자 함수는 Object이다.const obj = new Object();// add 함수 객체를 생성한 생성자 함수는 Function이다.const add = new Function('a', 'b', 'return a + b');// 생성자 함수function Person(name) &#123; this.name = name;&#125;// me 객체를 생성한 생성자 함수는 Person이다.const me = new Person('Lee'); 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해서 생성자 함수와 연결된다.이때 생성자 함수는 인스턴스를 생성한 생성자 함수다. ( 위 예제로 치면, obj / new / me &lt;-&gt; 각 생성자함수.프로토타입 &lt;-&gt; Object( ),Function( ),Person( ) ) 리터럴 표기법에 의해 생성된 객체1234567891011// 객체 리터럴const obj = &#123;&#125;;// 함수 리터럴const add = function (a, b) &#123; return a + b; &#125;;// 배열 리터럴const arr = [1, 2, 3];// 정규표현식 리터럴const regexr = /is/ig; 위 객체들도 프로토타입이 존재한다. 객체 const obj = {};의 경우 객체 리터럴에 의해 생성된 객체이다. 하지만 객체 obj는 Object 생성자 함수와 constructor 프로퍼티로 연결되어있다. 즉, Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다. 그리고 인수가 전달되지 않았을 때 추상 연산 ObjectCreate을 호출하여 빈 객체를 생성한다. 인수가 전달된 경우에는 인수를 객체로 변환한다. 1234567891011121314151617// Object 생성자 함수에 의한 객체 생성let obj = new Object();console.log(obj); // &#123;&#125;// Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다.// 인수가 전달되지 않았을 때 추상 연산 ObjectCreate을 호출하여 빈 객체를 생성한다.obj = Object();console.log(obj); // &#123;&#125;// 인수가 전달된 경우에는 인수를 객체로 변환한다.// Number 객체 생성obj = new Object(123);console.log(obj); // Number &#123;123&#125;// String 객체 생성obj = new Object('123');console.log(obj); // String &#123;\"123\"&#125; 리터럴 표기법(객체 리터럴, 함수 리터럴, 배열 리터럴, 정규 표현식 리터럴 등)에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 리터럴 표기법 생성자 함수 프로토타입 객체 리터럴 Object Object.protptype 함수 리터럴 Function Function.prototype 배열 리터럴 Array Array.prototype 정규 표현식 리터럴 RegExp RegExp.protptype 프로토타입의 생성 시점생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자 함수와 자바스크립트가 기본 제공하는 빌트인 생성자 함수로 구분할 수 있다. 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 사용자 정의 생성자 함수와 프로토타입 생성 시점일반 함수(함수 선언문, 함수 표현식)로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로서 호출할 수 있다.생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. 이처럼 빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며 생성된 프로토타입의 프로토타입은 언제나 Object.prototype이다. 빌트인 생성자 함수와 프로토타입 생성 시점( Object, String, Number, Function, Array, RegExp, Date, Promise 등 ) = 빌트인 생성자 함수 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 전역 객체(window)는 누구보다도 먼저 생성된다. 전역 객체는 Object, String, Number, Function, Array, RegExp, Date, Math와 같은 표준 빌트인 객체(standard built-in object)를 프로퍼티로 갖는다. Math를 제외한 표준 빌트인 객체는 생성자 함수 객체이다. 객체 생성 방식과 프로토타입의 결정객체는 아래와 같이 다양한 생성 방법이 있다. 객체 리터럴 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스 (ES6) 이와 같이 다양한 방식으로 생성된 모든 객체는 각각의 방식 마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 ObjectCreate에 의해 생성된다는 공통점을 갖는다. ObjectCreate는 런타임에 새로운 객체를 생성하는 추상 연산이고,필수적으로 자신이 생성할 객체의 프로토타입(proto)을 인수로 전달받는다.자신이 생성할 객체에 추가할 프로퍼티 목록은 옵션으로 전달할 수 있다. 객체 리터럴에 의해 생성된 객체의 프로토타입1const obj = &#123; x: 1 &#125;; 객체 obj는 Object.prototype을 프로토타입으로 갖게 되며 이로써 Object.prototype을 상속받는다. obj 객체는 ( constructor 프로퍼티와 hasOwnProperty 메소드 등을 소유X ) 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메소드를 자신의 자산인 것처럼 자유롭게 사용할 수 있다. 12345const obj = &#123; x: 1 &#125;;// 객체 obj는 Object.prototype을 상속받는다.console.log(obj.constructor === Object); // trueconsole.log(obj.hasOwnProperty('x')); // true Object 생성자 함수에 의해 생성된 객체의 프로토타입명시적으로 Object 생성자 함수를 호출하면 ObjectCreate를 호출. 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype. Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype. 객체 리터럴과 Object 생성자 함수에 의한 객체 생성 방식의 차이는 프로퍼티를 추가하는 방식에 있다. 객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티를 추가하지만 Object 생성자 함수 방식은 일단 빈객체를 생성한 이후 프로퍼티를 추가해야 한다. 생성자 함수에 의해 생성된 객체의 프로토타입new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 1234567891011121314function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;const me = new Person('Lee');const you = new Person('Kim');me.sayHello(); // Hi! My name is Leeyou.sayHello(); // Hi! My name is Kim 프로토타입 체인123456789101112131415161718function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;const me = new Person('Lee');// hasOwnProperty는 Object.prototype의 메소드이다.console.log(me.hasOwnProperty('name')); // trueconsole.log(Object.getPrototypeOf(me) === Person.prototype); // true//Person.prototype의 프로토타입은 Object.prototype이다. 프로토타입의 프로토타입은 언제나 Object.prototype이다.console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // true me.hasOwnProperty(&#39;name&#39;)와 같이 메소드를 호출하면 자바스크립트 엔진은 아래와 같은 과정을 거쳐 메소드를 검색한다. 물론 프로퍼티를 검색하는 경우도 마찬가지다. 먼저 hasOwnProperty 메소드를 호출한 me 객체에서 hasOwnProperty 메소드를 검색한다. me 객체에는 hasOwnProperty 메소드가 없으므로 프로토타입 체인을 따라, 다시 말해 proto 접근자 프로퍼티에 바인딩되어 있는 프로토타입(위 예제의 경우, Person.prototype)으로 이동하여 hasOwnProperty 메소드를 검색한다. Person.prototype에도 hasOwnProperty 메소드가 없으므로 프로토타입 체인을 따라, 다시 말해 proto 접근자 프로퍼티에 바인딩되어 있는 프로토타입(위 예제의 경우, Object.prototype)으로 이동하여 hasOwnProperty 메소드를 검색한다. Object.prototype에는 hasOwnProperty 메소드가 존재한다. 자바스크립트 엔진은 Object.prototype.hasOwnProperty 메소드를 호출한다. 이때 Object.prototype.hasOwnProperty 메소드의 this에는 me 객체가 바인딩된다. 캡슐화 캡슐화(encapsulation)는 정보의 일부를 외부에 감추어 은닉(정보 은닉(information hiding))하는 것을 말한다. 123456789101112131415161718192021const Person = (function () &#123; // 자유 변수이며 private하다 let _name = ''; // 생성자 함수 function Person(name) &#123; _name = name; &#125; // 프로토타입 메소드 Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;_name&#125;`); &#125;; // 생성자 함수를 반환 return Person;&#125;());const me = new Person('Lee');// _name은 지역 변수이므로 외부에서 접근하여 변경할 수 없다. 즉, private하다.me._name = 'Kim';me.sayHello(); // Hi! My name is Lee 즉시 실행 함수를 사용하여 생성자 함수와 프로토타입을 확장하는 코드를 하나의 함수 내에 깔끔하게 모을 수 있다. return을 생성자 함수 Person을 했기 때문에, 지역변수 _name 은 처음 초기화 할때만 해당이 되는 것이다. 오버라이딩 과 프로퍼티 쉐도잉 오버라이딩(Overriding) 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식이다. 오버로딩(Overloading) 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메소드를 구현하고 매개변수에 의해 메소드를 구별하여 호출하는 방식이다. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다. 프로퍼티 쉐도잉 123456789101112131415161718192021222324const Person = (function () &#123; // 생성자 함수 function Person(name) &#123; this.name = name; &#125; // 프로토타입 메소드 Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;; // 생성자 함수를 반환 return Person;&#125;());const me = new Person('Lee');// 인스턴스 메소드me.sayHello = function () &#123; console.log(`Hey! My name is $&#123;this.name&#125;`);&#125;;// 인스턴스 메소드가 호출된다. 프로토타입 메소드는 인스턴스 메소드에 의해 가려진다.me.sayHello(); // Hey! My name is Lee 즉, 프로토타입에 있는 SayHello를 복사해서 와서 사용하는 것. 따라서, sayHello를 삭제해도 프로토타입에 남아있다. 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다. 다시 말해 하위 객체를 통해 프로토타입에 get 액세스는 허용되나 set 액세스는 허용되지 않는다. 만약 프로토타입 프로퍼티를 변경또는 삭제하려면 직접 접근 해야만 한다. 프로토타입의 교체 프로토타입은 다른 임의의 객체로 변경할 수 있다. 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다. 생성자 함수에 의한 프로토타입의 교체 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다. 12345678910111213141516const Person = (function () &#123; function Person(name) &#123; this.name = name; &#125; // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 Person.prototype = &#123; sayHello() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; &#125;; return Person;&#125;());const me = new Person('Lee'); 위 예제는 Person의 프로토타입에 객체 리터럴을 할당하였다. 이렇게 되면 결국 Person 생성자 함수가 생성할 객체의 프토로타입을 객체리터럴로 교체한것이다. 이렇게 될 경우, me의 생성자 함수를 검색시 Person이 아닌 Object를 반환하게 된다. 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. 따라서 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티이다. 1234// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.console.log(me.constructor === Person); // false// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.console.log(me.constructor === Object); // true 파괴된 constructor 프로퍼티 와 생성자 함수 간의 링크를 되살리기. 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살린다. 1234567891011121314151617const Person = (function () &#123; function Person(name) &#123; this.name = name; &#125; // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 Person.prototype = &#123; constructor: Person, sayHello() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125; &#125;; return Person;&#125;());const me = new Person('Lee'); 인스턴스에 의한 프로토타입의 교체인스턴스의 proto 접근자 프로퍼티(또는 Object.setPrototypeOf 메소드)를 통해 프로토타입을 교체할 수 있다. Object.setPrototypeOf(프로토타입을 바꾸고 싶은 객체, 프로토타입으로 적용할 객체); 12345678910111213141516171819function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee');// 프로토타입으로 교체할 객체const parent = &#123; sayHello() &#123; console.log(`Hi! My name is $&#123;this.name&#125;`); &#125;&#125;;// ① me 객체의 프로토타입을 parent 객체로 교체한다.Object.setPrototypeOf(me, parent);// 위 코드는 아래의 코드와 동일하게 동작한다.// me.__proto__ = parent;me.sayHello(); // Hi! My name is Lee 바뀌버린 프로토타입 또한 생성자때처럼 constructor를 가지고 있지 않다.인스턴스에 의한 프로토타입 교체도 constructor 프로퍼티와 생성자 함수 간의 연결을 파괴한다. 따라서 프로토 타입의 constructor 프로퍼티로 me 객체의 생성자 함수를 검색하면 Person이 아니라, Object가 나온다. 1234// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.console.log(me.constructor === Person); // false// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.console.log(me.constructor === Object); // true 생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체는 내부에서 하느냐 외부에서 하느냐의 차이다. instanceof 연산자1객체 instanceof 생성자 함수 instanceof 는 좌측은 식별자 우측은 생성자 함수를 가리키는 식별자를 둔다. 좌측의 객체가 우측의 함수의 인스턴스가 아닐 경우 false를 맞을경우 true를 반환한다. 123456789101112// 생성자 함수function Person(name) &#123; this.name = name;&#125;const me = new Person('Lee');// me 객체는 Person 생성자 함수에 의해 생성된 인스턴스이다.console.log(me instanceof Person); // true// instanceof 연산자는 상속 관계를 고려한다.// me 객체는 Object.prototype을 상속받기 때문에 아래의 코드는 true로 평가된다.console.log(me instanceof Object); // true 만약 위 예제에서 me객체가 가리키는 프로토타입을 다른 객체로 교체해버린다면 instanceof 시 false를 반환한다. 이유는 교체된 프로토타입의 constructor 프로퍼티가 존재하지 않기 때문이다. 즉, instanceof 연산자는 생성자 함수의 prototype 프로퍼티가 가리키는 객체가 프로토타입 체인 상에 존재하는지 확인한다. 직접 상속Object.create에 의한 직접 상속 Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메소드의 첫번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다. 두번째 매개변수에는 생성할 객체의 프로퍼티를 갖는 객체를 전달한다. (옵션이므로 생략 가능) 1Object.create(prototype[, propertiesObject]) 12345678910111213141516171819202122232425262728293031323334353637383940414243// 프로토타입이 null인 객체를 생성한다.// 즉, 생성된 객체는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.// obj → nulllet obj = Object.create(null);console.log(Object.getPrototypeOf(obj) === null); // true// Object.prototype를 상속받지 못한다.console.log(obj.toString()); // TypeError: obj.toString is not a function// obj = &#123;&#125;;와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype);console.log(Object.getPrototypeOf(obj) === Object.prototype); // true// obj = &#123; x: 1 &#125;;와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype, &#123; x: &#123; value: 1 &#125;&#125;);// 위 코드는 아래와 동일하다.// obj = Object.create(Object.prototype);// obj.x = 1;console.log(obj.x); // 1console.log(Object.getPrototypeOf(obj) === Object.prototype); // trueconst myProto = &#123; x: 10 &#125;;// 객체를 직접 상속받는다.// obj → myProto → Object.prototype → nullobj = Object.create(myProto);console.log(obj.x); // 10console.log(Object.getPrototypeOf(obj) === myProto); // true// 생성자 함수function Person(name) &#123; this.name = name;&#125;// obj = new Person('Lee')와 동일하다.// obj → Person.prototype → Object.prototype → nullobj = Object.create(Person.prototype);obj.name = 'Lee';console.log(obj.name); // Leeconsole.log(Object.getPrototypeOf(obj) === Person.prototype); // true 장점 new 연산자가 없이도 객체를 생성할 수 있다. 프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다. 객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다. 빌트인 객체들은 간접적인 호출을 추천한다​ Object.create를 통해서 객체를 생성하고 프로토타입을 지정해줄 때, 만약 null 값을 지정한다면 빌트인객체는 Object.prototype의 빌트 메서드들은 사용할 수 없다. 따라서 다음과 같은 간접호출을 사용하도록 한다. 12// Function.prototype.apply/call/bind 메소드Object.prototype.hasOwnProperty.call(obj, 'a') 객체 리터럴 내부에서 __ proto __에 의한 직접 상속​ Object.create 메소드는 직접 상속은 위와 같이 여러 장점이 있다. 하지만 두번째 인자로 프로퍼티를 정의하는 것은 번거롭다. 일단 객체를 생성한 이후, 프로퍼티를 추가하는 방법도 있으나 이 또한 깔끔한 방법은 아니다. ES6에서는 객체 리터럴 내부에서 proto 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다. 1234567891011121314const myProto = &#123; x: 10 &#125;;// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.const obj = &#123; y: 20, // 객체를 직접 상속받는다. // obj → myProto → Object.prototype → null __proto__: myProto&#125;;// 위 코드는 아래와 동일하다.// const obj = Object.create(myProto, &#123; y: &#123; value: 20 &#125; &#125;);console.log(obj.x, obj.y); // 10 20console.log(Object.getPrototypeOf(obj) === myProto); // true 정적 프로퍼티/메소드정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다. 1234567891011121314151617181920212223242526// 생성자 함수function Person(name) &#123; this.name = name;&#125;// 프로토타입 메소드Person.prototype.sayHello = function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;`);&#125;;// Person 생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다.// 정적 프로퍼티Person.staticProp = 'static prop';// 정적 메소드Person.staticMethod = function () &#123; console.log('staticMethod');&#125;;const me = new Person('Lee');// 생성자 함수에 추가한 정적 프로퍼티/메소드는 생성자 함수로 참조/호출한다.Person.staticMethod(); // staticMethod// 정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.// 인스턴스로 참조/호출할 수 있는 프로퍼티/메소드는 프로토타입 체인 상에 존재해야 한다.me.staticMethod(); // TypeError: me.staticMethod is not a function Person 생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다. Person 생성자 함수 객체가 소유한 프로퍼티/메소드를 정적 프로퍼티/메소드라고 부른다. 정적 프로퍼티와 메서드는 인스턴스로 참조 및 호출이 불가능하다. (인스턴스가 참조및 호출 가능한건 프로토타입체인에 존재해야한다.) 참고) Object.create 메소드도 Object 생성자 함수의 정적 메소드다. 따라서 상속이 불가능하다. 프로퍼티 존재 확인 in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다. in 연산자의 사용 방법은 아래와 같다. ‘프로퍼티키’ in 객체 1234567891011const person = &#123; name: 'Lee', address: 'Seoul'&#125;;// person 객체에 name 프로퍼티가 존재한다.console.log('name' in person); // true// person 객체에 address 프로퍼티가 존재한다.console.log('address' in person); // true// person 객체에 age 프로퍼티가 존재하지 않는다.console.log('age' in person); // false 프로퍼티 열거 객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다. for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다. for (변수선언문 in 객체) { … } for…in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값인 ture인 프로퍼티를 순회하며 열거(enumeration)한다. 123456789101112const person = &#123; name: 'Lee', address: 'Seoul'&#125;;// for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다. 단, 순서는 보장되지 않는다.for (const prop in person) &#123; console.log(prop + ': ' + person[prop]);&#125;// name: Lee// address: Seoul 만약 프로퍼티 어트리뷰트의 [[Enumerable]] , enumrable이 false 값이라면 해당 프로퍼티는 열거 하지않고 넘어간다. 상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티만을 열거하려면 Object.prototype.hasOwnProperty 메소드를 사용하여 객체 자신의 프로퍼티인지 확인해야 한다. 123456789101112131415const person = &#123; name: 'Lee', address: 'Seoul'&#125;;Object.setPrototypeOf(person, &#123; age: 20 &#125;);for (const prop in person) &#123; // 객체 자신의 프로퍼티인지 확인한다. if (!person.hasOwnProperty(prop)) continue; console.log(prop + ': ' + person[prop]);&#125;// name: Lee// address: Seoul","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Prototype","slug":"Prototype","permalink":"https://hyeok999.github.io/tags/Prototype/"}]},{"title":"daily_algorithm17","slug":"daily-algorithm17","date":"2019-10-16T01:19:32.000Z","updated":"2019-11-30T16:48:39.589Z","comments":true,"path":"2019/10/16/daily-algorithm17/","link":"","permalink":"https://hyeok999.github.io/2019/10/16/daily-algorithm17/","excerpt":"","text":"문제 출처 : poiema 알고리즘 연습 문제 26. 특별한 정렬 **n개의 정수를 가진 배열이 있다. 이 배열은 양의 정수와 음의 정수를 모두 가지고 있다. 이 배열을 좀 특별한 방법으로 정렬해야 한다. 음의 정수는 앞쪽에 내림차순으로, 양의 정수는 뒷쪽에 있어야 한다. 단, 인수로 주어진 원본 배열은 변경되지 않아야 한다. 예를 들어, [-1, 1, 3, -2, 2, 0]이 주어졌을 때, [-1, -2, 0, 1, 2, 3]를 반환한다. 12345678function specialSort(array) &#123; return array.sort();&#125;const testArray = [-1, 1, 3, -2, 2, 0];console.log(testArray); // [ -1, 1, 3, -2, 2, 0 ]console.log(specialSort(testArray)); // [ -1, -2, 0, 1, 2, 3 ] 27. 요일 구하기 **2016년 1월 1일은 금요일이다. 2016년 a월 b일은 무슨 요일일까? 두 수 a, b를 입력받아 a월 b일이 무슨 요일인지 출력하는 getDayName 함수를 완성하라. 요일의 이름은 일요일부터 토요일까지 각각 SUN, MON, TUE, WED, THU, FRI, SAT를 출력한다. 예를 들어 a=5, b=24가 입력된다면 5월 24일은 화요일이므로 TUE를 반환한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function getDayName(a, b) &#123; let answer = ''; const dayOfTheWeek = ['FRI', 'SAT', 'SUN', 'MON', 'TUE', 'WED', 'THU']; let j = 0; for (let month = 1; month &lt;= a; month++) &#123; switch (month) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: for (let x = 1; x &lt;= 31; x++) &#123; if (month == a &amp;&amp; x == b) &#123; answer = dayOfTheWeek[j]; break; &#125; else &#123; j++; if (j == 7) &#123; j = 0; &#125; &#125; &#125; break; case 4: case 6: case 9: case 11: for (let x = 1; x &lt;= 30; x++) &#123; if (month == a &amp;&amp; x == b) &#123; answer = dayOfTheWeek[j]; break; &#125; else &#123; j++; if (j == 7) &#123; j = 0; &#125; &#125; &#125; break; default: for (let x = 1; x &lt;= 29; x++) &#123; if (month == a &amp;&amp; x == b) &#123; answer = dayOfTheWeek[j]; break; &#125; else &#123; j++; if (j == 7) &#123; j = 0; &#125; &#125; &#125; break; &#125; &#125; return answer;&#125;console.log(getDayName(5, 24)); // TUE// 다른 풀이function getDayNameOther(a, b) &#123; let month = String(a); let day = String(b); const week = ['SUN', 'MON', 'TUE', 'WEN', 'THU', 'FRI', 'SAT']; if (month.length &lt; 2) &#123; month = `0$&#123;month&#125;`; &#125; if (day.length &lt; 2) &#123; day = `0$&#123;day&#125;`; &#125; let answer = week[new Date(`2016-$&#123;month&#125;-$&#123;day&#125;`).getDay()]; return answer;&#125;console.log(getDayNameOther(5, 24)); // TUEconsole.log(getDayNameOther(1, 1)); // FRI","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"javascript-study-09","slug":"javascript-study-09","date":"2019-10-15T11:47:13.000Z","updated":"2019-11-30T16:29:17.675Z","comments":true,"path":"2019/10/15/javascript-study-09/","link":"","permalink":"https://hyeok999.github.io/2019/10/15/javascript-study-09/","excerpt":"","text":"JavaScript Study 09 용어 버전의 숫자 의미 객체 프로퍼티 종류 데이터 프로퍼티 접근자 프로퍼티 프로퍼티 판별 동작 과정 내부 슬롯, 내부 메소드 생성자 Object 생성자 함수 생성자 함수 생성자 함수의 로직 this , 일반 함수로서의 호출 / 메소드로서의 호출 / 생성자 함수로서의 호출 내부 메소드 [[Call]] 과 [[Construct]] new 연산자 일급 객체 arguments 프로퍼티 length 프로퍼티 용어 - ( 러버덕 ) 데이터 프로퍼티 접근자 프로퍼티(억세스 프로퍼티) 내부 슬롯 내부 메서드 생성자 함수 Object 생성자 함수 this 메소드? 메소드? new 연산자 일급 객체 버전의 숫자 의미 객체12345678910111213const PERSON = &#123; name : 'Lee', // getName : function( )&#123; &#125; //-&gt; 함수라 부른다 getName( )&#123; // 축약표현 -&gt; 메소드라 부른다. return this.name; &#125;&#125;const NAME = PERSON.getName();console.log(NAME); // 'Lee'console.log(Object.getOwnPropertyDescriptors(PERSON)); 프로퍼티 키는 식별자 네이밍 규칙을 준수하면 ‘’을 생략이 가능하다. 내부적으로는 문자열로 되어있다.프로퍼티 값은 데이터타입( 문자열, 숫자, Symbol, undefined, null, boolean, 객체 )이 모두 올수 있다.특히 함수(객체)를 프로퍼티 값으로 받게되면 그 부분을 메소드 라 칭한다. 객체를 만들때는 객체를 만들고자 하는 몇가지 특징을 추려서 만든다. (추상화라 한다.) 객체의 프로퍼티 값은 state 상태를 의미한다. 위 예제에서 Person 객체의 name 의 상태는 &#39;Lee&#39;이다. 객체의 메소드는 behavior 행위 를 의미한다. 위 예제에서 Person 객체의 행위는 getName()이다. PERSON.getName() 은 값이다. ( 표현식인 문 ) 따라서, 상수 NAME에 PERSON.getName() 을 할당한다. 프로퍼티 종류 데이터 프로퍼티 : 키와 값으로 구성된 일반적인 프로퍼티다. 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티. 접근자 함수는 getter/setter 함수라고도 부른다. 프로퍼티 어트리뷰트를 확인하는 방법. Object.getOwnPropertyDescriptors(객체명)프로퍼티 어트리뷰트 정의(변경)하는 방법. Object.defineProperty(객체명,&#39;프로퍼티명&#39;,정의내용)1. 데이터 프로퍼티 : 키와 값으로 구성된 일반적인 프로퍼티다.123456789101112const PERSON = &#123; firstName : 'Lee', // 데이터 프로퍼티 lastNmae : 'Hyeok', // 데이터 프로퍼티 getFullName( )&#123; // 데이터 프로퍼티 return `$&#123;this.name&#125; $&#123;this.lastName&#125;`; &#125;&#125;const NAME = PERSON.getFullName();console.log(NAME); // 'Lee'console.log(Object.getOwnPropertyDescriptors(PERSON)); console.log(Object.getOwnPropertyDescriptors(PERSON)); 을 실행하면 나오는 로그. 12345678910111213// 프로퍼티 디스크립터 객체&#123; firstName: // 데이터 프로퍼티 &#123; value: 'Lee', writable: true, enumerable: true, configurable: true &#125;, lastName: // 데이터 프로퍼티 &#123; value: 'Hyeok', writable: true, enumerable: true, configurable: true &#125; &#125; ​ value: [λ: getName]​ ➤ 값 ​ writable: true​ ➤ 재할당 여부 ​ enumerable: true​ ➤ 열거 여부 ​ configurable: true​ ➤ 설정 여부 2. 접근자(억세스) 프로퍼티 : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티. 접근자 함수는 getter/setter 함수라고도 부른다.접근자 프로퍼티 활용 선언 get 함수명( ) { return 값;} set 함수명( 인수 ) { this를 활용해 코딩} get 호출 객체명.함수 - 예 ) PERSON.fullName; ➤ ( ) 호출 구문을 넣으면 안된다. set 호출 객체명.함수 = 값 - 예 ) PERSON.firstName = ‘Kim’; 123456789101112131415const PERSON = &#123; firstName: 'Lee', lastName: 'Hyeok', get fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;, set fullName(firstName) &#123; this.firstName = firstName; &#125;&#125;;PERSON.fullName = 'Kim';console.log(PERSON.fullName); // 'Lee'console.log(Object.getOwnPropertyDescriptors(PERSON)); console.log(Object.getOwnPropertyDescriptors(PERSON)); 을 실행하면 나오는 로그. 123456789101112131415&#123; firstName: //데이터 프로퍼티 &#123; value: 'Lee', writable: true, enumerable: true, configurable: true &#125;, lastName: //데이터 프로퍼티 &#123; value: 'Hyeok', writable: true, enumerable: true, configurable: true &#125;, fullName: //접근자 프로퍼티 &#123; get: [λ: get fullName], set: [λ: set fullName], enumerable: true, configurable: true &#125; &#125; get 은 특징 인수가 없고 return이 있어야 한다.set 은 인수를 받아야되기 때문에 매개변수가 있어야되고 return이 없어도 된다. get, set 은 서로 같은 프로퍼티다. 즉 한쌍이라 생각하면 된다. get 과 set 의 프로퍼티들은 각각 내부 슬롯 [[Get]] , [[Set]]에 셋팅된다. ​ get : [λ: getName]​ ➤ 프로퍼티의 값을 읽을 때 호출되는 접근자 함수. ​ set: [λ: set fullName]​ ➤ 프로퍼티의 값을 저장할 때 호출되는 접근자 함수. ​ enumerable: true​ ➤ 열거 여부 ​ configurable: true​ ➤ 설정 여부 프로퍼티 판별 동작 과정 JS엔진은 먼저 프로퍼티 키가 유효한지 확인한다. 프로토타입 체인에서 프로퍼티를 검색한다. 해당 프로퍼티 어트리뷰트를 확인하며 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. 데이터라면 원시값을 반환하고, 접근자 프로퍼티 라면 [[Get]] 혹은 [[Set]]의 값, 즉 getter/setter를 호출하여 결과를 반환한다. 내부 슬롯 , 내부 메서드 내부슬롯 : JS 엔진의 프로퍼티 (명사적인 의미) [[Value]] [[prototype]] 내부메서드 : JS 엔진의 메소드 (동사적인 의미) [[Set]] [[Get]] 일부 내부 슬롯 과 내부 메서드 [[Get]] 같은 메서드들은 열람이 허락 되어있지만, 내부 슬롯과 내부 메소드는 객체의 프로퍼티가 아니다. 내부 슬롯과 내부 메소드는 직접적으로 접근하거나 호출할 수 있는 방법을 원칙적으로 제공하지 않는다. 생성자​ 객체를 만드는 방법 객체 리터럴 생성자 함수 Object 생성자 함수 Class [ ES6 ] 프로토타입 : JS의 모든 객체는 부모 역할을 하는 객체가 있는데 그것이 prototype 객체라고 한다. (상속을 자식에게 해주는 객체) 위 예제의 o객체의 부모 Object.prototype에게 접근하기 위한 링크 프로퍼티 : __ proto __ Object 생성자 함수함수를 new 연산자와 함께 Object 생성자를 호출하면 retunr 값으로 빈 객체를 만들어 반환한다. new 연산자로 만들어진 생성자를 인스턴스라 한다. Object생성자 함수는 일반 함수들과는 다르게 선 호출 하고나서빈 객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다. 생성자 함수는 템플릿 역할을 하여 비슷한 내용의 객체를 여러개 만들어낼 수 있다. 1234567891011// 빈 객체의 생성const person = new Object();// 프로퍼티 추가person.name = 'Lee';person.sayHello = function () &#123; console.log('Hi! My name is ' + this.name);&#125;;console.log(person); // &#123;name: \"Lee\", sayHello: ƒ&#125;person.sayHello(); // Hi! My name is Lee ​ 자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의빌트인(intrinsic 내장) 생성자 함수를 제공한다. 생성자 함수생성자 함수는 템플릿 역할을 하여 비슷한 내용의 객체를 여러개 만들수 있기 때문에 편하다. 생성자 함수의 로직 함수를 new 연산자와 생성자를 호출하면 빈 객체를 생성한다. this에 빈객체를 할당한다. this의 빈객체 내부에서 프로퍼티 추가, 메서드추가 등등 을 한다. 생성자 함수는 마지막에 return = this;를 암묵적으로 실행한다. (마지막에 return을 안적어줘도 되는 이유임)(생성자 함수는 return을 사용하지 말아야한다.) 문법 12345678910111213// 생성자 함수function Person(name)&#123; console.log(this); // Person&#123; &#125; this.name = name; this.sayHi = function()&#123; return this.name; &#125;; console.log(this); // Person &#123; name : 'Lee', sayHi: [λ]&#125;&#125;//const me = Person(); // undefined const me = new Person('Kim');console.log(me); // Person &#123; name: 'Lee', sayHi: [λ] &#125; ; 123456789101112131415// 생성자 함수function Circle(radius) &#123; // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// 인스턴스의 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 this , 일반 함수로서의 호출 / 메소드로서의 호출 / 생성자 함수로의 호출 일반 함수의 this ➤ 전역객체 (window) 객체(메소드) 리터럴의 this ➤ 자신 (self) 생성자 함수의 this ➤ 인스턴스 일반 함수로서의 호출 / 메소드로서의 호출 / 생성자 함수로의 호출 123456789101112131415// 함수는 다양한 방식으로 호출될 수 있다.function foo() &#123; console.log(this);&#125;// 일반적인 함수로서 호출// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.foo(); // window// 메소드로서 호출const obj = &#123; foo &#125;; // ES6 프로퍼티 축약 표현obj.foo(); // obj , 메소드 this는 자신의 객체를 가리킴.// 생성자 함수로서 호출const inst = new foo(); // inst, 생성자 this는 인스턴스를 가리킴 내부 메소드 [[Call]]과 [[Construct]]함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다.생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다. 함수는 객체이므로 일반 객체(Ordinary object)와 동일하게 동작할 수 있다. 즉, 함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다. *함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 *([[Call]]이 없는 객체는 함수가 아니다.) 함수가 new 연산자(또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다. ( 메서드와 화살표 함수는 [[Construct]] 가 없다. 즉, 메서드와 화살표함수는 생성자 함수가 될 수 없다. ) JS엔진이 함수를 생성할 때 사용하는 추상연산(FunctionCreate)코드. 첫번쨰 매개변수 kind에 담기는 함수타입.함수가 태어나면 JS엔진이 관리하는 내부슬롯에 3가지 타입의 함수타입이 있다. normal ( 일반적인 함수 ) - constructor arrow (메소드 축약표현을 사용한것.) sayHi() - non-constructor method (화살표 함수) - non-constructor new 연산자 만약, 생성자로 호출 했는데 return 문이 존재하고 return하는 값이 객체라면 그것을 반환하고, 원시값이라면 무시한다. 따라서 new 로 생성자를 만들어서 쓰려고 할 때는 return 반환문이 존재해서는 안된다. 반대로, new 연산자를 없이 생성자 함수를 호출한다면 일반 함수로 동작하게 된다. 일반 함수에서의 this는 전역객체 (window)를 가리키고 있기 때문에 매우 조심해야한다. new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 한다. new 연산자 미기재 방어법사람은 실수하기 마련이고, 파스칼 케이스를 통해서 해당 함수가 생성자를 위한 함수라고 기재를 했음에도 일반함수로 불러들일 수 있을 것이다. 따라서 이러한 문제를 막기 위해 2가지 방법이 있다. new.target (IE 미지원) : new 연산자와 함께 호출되었는지 확인할 수 있다. 123456789101112131415161718// 생성자 함수function Circle(radius) &#123; // 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined이다. if (!new.target) &#123; //이 함수가 new와 함께 호출되었는지 아닌지 판단 //new와 호출안하면 undefined가 되는데 // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); //new.target에 new가 없으면 new붙여서 싫행 &#125; this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); if (!(this instanceof Circle)) 해당 구문의 뜻은 이러하다. 해당 this 가 Circle의 인스턴스 냐 라고 묻는 것. 123456789101112131415161718192021 // Scope-Safe Constructor Patternfunction Circle(radius) &#123; // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고 // this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다. // 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다. // 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다. if (!(this instanceof Circle)) &#123; // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); &#125; this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); // 10 new 연산자와 함꼐 생성자를 만드는 빌트인 함수들은 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다. 1234567891011let obj = new Object();console.log(obj); // &#123;&#125;obj = Object();console.log(obj); // &#123;&#125;let f = new Function('x', 'return x ** x');console.log(f); // ƒ anonymous(x) &#123; return x ** x &#125;f = Function('x', 'return x ** x');console.log(f); // ƒ anonymous(x) &#123; return x ** x &#125; 일급 객체 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다. 함수의 매개 변수에게 전달할 수 있다. 함수의 결과값으로 반환할 수 있다. 자바스크립트의 함수는 아래 예제와 같이 위의 조건을 모두 만족하므로 일급 객체이다. 함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. arguments 프로퍼티 함수 호출 시 전달된 인수들의 정보를 담음 순회 가능한 유사 배열 객체다. 지역변수처럼 사용해야됨. 함수 외부에서는 사용 불가. 인수 값이 마음대로 들어오는 가변 인자 함수에서 유용하다. 1234567891011121314function sum() &#123; let res = 0; // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다. for (let i = 0; i &lt; arguments.length; i++) &#123; res += arguments[i]; &#125; return res;&#125;console.log(sum()); // 0console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3)); // 6 for문을 사용하지 않고 배열로 변환해서 사용하기도 한다. 12345678910function sum() &#123; // arguments 객체를 배열로 변환 const array = Array.prototype.slice.call(arguments); return array.reduce(function (pre, cur) &#123; return pre + cur; &#125;, 0);&#125;console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3, 4, 5)); // 15 1234567// ES6 Rest parameterfunction sum(...args) &#123; return args.reduce((pre, cur) =&gt; pre + cur, 0);&#125;console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3, 4, 5)); // 15 length 프로퍼티함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다. 123456789101112function foo() &#123;&#125;console.log(foo.length); // 0function bar(x) &#123; return x;&#125;console.log(bar.length); // 1function baz(x, y) &#123; return x * y;&#125;console.log(baz.length); // 2","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_algorithm16","slug":"daily-algorithm16","date":"2019-10-15T03:53:25.000Z","updated":"2019-11-30T16:48:31.948Z","comments":true,"path":"2019/10/15/daily-algorithm16/","link":"","permalink":"https://hyeok999.github.io/2019/10/15/daily-algorithm16/","excerpt":"","text":"문제 출처 : poiema 알고리즘 연습 문제 21. 두 정수 사이의 합adder 함수는 정수 x, y를 인수로 전달받는다. 두 수와 두 수 사이에 있는 모든 정수를 더해서 리턴하도록 함수를 완성하라. x와 y가 같은 경우는 둘 중 아무 수나 리턴한다. x, y는 음수나 0, 양수일 수 있으며 둘의 대소 관계도 정해져 있지 않다. 예를 들어 x가 3, y가 5이면 12를 리턴한다. 12345678910111213function adder(x, y) &#123; if (x === y) return x; let answer = 0; for (let i = x; i &lt;= y; i++) &#123; answer += i; &#125; return answer;&#125;console.log(adder(3, 5)); // 12 22. 배열의 인접한 요소곱 중 가장 큰 값 구하기인수로 주어진 정수의 배열에서 인접한 요소의 곱이 가장 큰 값을 반환하는 함수를 완성하라. 예를 들어 인수가 [3, 6, -2, -5, 7, 3]인 경우, 21을 반환한다. 1234567891011function adjacentElementsProduct(arr) &#123; const TEMP = []; for (let i = 1; i &lt; arr.length; i++) &#123; TEMP.push(arr[i - 1] * arr[i]); &#125; return Math.max.apply(0, TEMP);&#125;console.log(adjacentElementsProduct([3, 6, -2, -5, 7, 3])); // 21 23. 배열에서 특정 값만을 구하기인수로 주어진 배열 arr에서 짝수이고 3보다 큰 수만을 구하여 이를 배열로 반환하는 함수를 작성하라 123456789101112function getArray(arr) &#123; const numArray = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] % 2 == 0 &amp;&amp; arr[i] &gt; 3) &#123; numArray.push(arr[i]); &#125; &#125; return numArray;&#125;console.log(getArray([1, 2, 3, 4, 5, 6])); // [ 4, 6 ] 24. 평균구하기인수로 주어진 배열의 평균을 구하는 함수를 완성하라. 12345678910function average(array) &#123; let answer = 0; for (let i = 0; i &lt; array.length; i++) &#123; answer += array[i]; &#125; return answer / array.length;&#125;console.log(average([5, 3, 4])); // 4 25. 최단 거리 1차원 점의 쌍 구하기 (DAUM)1차원의 점들이 주어졌을 때, 그 중 가장 거리가 짧은 것(들)의 쌍을 배열로 반환하는 함수를 작성하라. (단 점들의 배열은 모두 정렬되어있다고 가정한다.) 예를들어 [1, 3, 4, 8, 13, 17, 20, 23, 24]이 주어졌다면, 결과값은 [[3, 4], [23, 24]]가 될 것이다. 1234567891011121314151617181920function findMinDistance(array) &#123; const temp = []; const ANSWER = []; for (let i = 1; i &lt; array.length; i++) &#123; temp.push(array[i] - array[i - 1]); &#125; for (let i = 0; i &lt; temp.length; i++) &#123; if (temp[i] == Math.min.apply(0, temp)) &#123; ANSWER.push([array[i], array[i + 1]]); &#125; &#125; return ANSWER;&#125;// 1차원 점의 배열// var array = [1, 3, 4, 8, 13, 17, 20, 23, 24];const array = [1, 3, 4, 8, 13, 17, 20, 23, 24];console.log(findMinDistance(array)); // [[3, 4], [23, 24]]","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"daily_algorithm15","slug":"daily-algorithm15","date":"2019-10-15T03:53:18.000Z","updated":"2019-11-30T16:49:11.876Z","comments":true,"path":"2019/10/15/daily-algorithm15/","link":"","permalink":"https://hyeok999.github.io/2019/10/15/daily-algorithm15/","excerpt":"","text":"문제 출처 : poiema 알고리즘 연습 문제 16. 소수 찾기numberOfPrime 메소드는 정수 n을 매개변수로 입력받는다. 1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하도록 numberOfPrime 함수를 완성하라. 예를 들어 10을 입력받았다면, 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환한다. 소수(素數, prime number)는 2, 3, 5, 7, 11, 13, 17…과 같이 1과 자신 이외의 어떤 수로도 나눠지지 않는 1보다 큰 양의 정수이다. 12345678910111213141516171819function numberOfPrime(n) &#123; let result = 0; let count = 0; for (let i = 2; i &lt;= n; i++) &#123; count = 0; for (let j = 1; j &lt;= i; j++) &#123; if (i % j == 0) &#123; count++; &#125; &#125; if (count == 2) &#123; result++; &#125; &#125; return result;&#125;console.log(numberOfPrime(10)); // 4 17. 피보나치 수피보나치 수는 0과 1로 시작하며, 다음 피보나치 수는 바로 앞의 두 피보나치 수의 합이 된다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946… 2 이상의 n이 입력되었을 때, n번째 피보나치 수를 반환하는 fibonacci 함수를 작성하라. 예를 들어 n = 3이라면 2를 반환한다. 1234567891011function fibonacci(n) &#123; if (n === 0) return 0; if (n === 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2);&#125;console.log(fibonacci(2)); // 1console.log(fibonacci(3)); // 2console.log(fibonacci(4)); // 3console.log(fibonacci(5)); // 5console.log(fibonacci(6)); // 8 18. 각 자릿수의 합 구하기정수 n이 주어지면, n의 각 자릿수의 합을 구해서 반환하는 digitSum 함수를 완성하라. 예를 들어 n = 123이면 1 + 2 + 3 = 6을 반환한다. 단, n은 100,000,000 이하의 정수로 한다. 1234567891011121314151617181920212223242526272829303132function digitSum(n) &#123; if (n &lt; 0 || n &gt; 100000000) return false; const number = String(n); let answer = 0; for (let i = 0; i &lt; number.length; i++) &#123; answer += +number[i]; &#125; return answer;&#125;console.log(digitSum(123)); // 6console.log(digitSum(987)); // 24console.log(digitSum(100000001));// false/*function digitSum(n) &#123; if (n &lt; 0 || n &gt; 100000000) return false; let number = String(n); number = number.split(''); const answer = number.reduce(function (sumValue, currentValue) &#123; return +sumValue + +currentValue; &#125;); return answer;&#125;console.log(digitSum(123)); // 6console.log(digitSum(987)); // 24console.log(digitSum(100000001)); // false*/ 19. 하샤드 수하샤드 수는 그 수의 각 자릿수 숫자의 합으로 그 수가 나누어지는 양의 정수를 말한다. 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 한다. 예를들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수이다. 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42, 45, 48, 50, 54, 60, 63, 70, 72, 80, 81, 84, 90, 100, 102, 108, 110, 111, 112, 114, 117, 120, 126, 132, 133, 135, 140, 144, 150, 152, 153, 156, 162, 171, 180, 190, 192, 195, 198, 200 Harshad함수는 양의 정수 n을 매개변수로 입력받는다. 이 n이 하샤드수인지 아닌지 판단하는 함수를 완성하라. 예를 들어 n이 10, 12, 18이면 True를 리턴 11, 13이면 False를 리턴한다. 123456789101112131415161718function isHarshad(n) &#123; const number = String(n); let result = 0; for (let i = 0; i &lt; number.length; i++) &#123; result += +number[i]; &#125; console.log(result); return number % result === 0;&#125;console.log(isHarshad(10)); // trueconsole.log(isHarshad(12)); // trueconsole.log(isHarshad(18)); // trueconsole.log(isHarshad(11)); // falseconsole.log(isHarshad(13)); // false 20. 배열의 첫 요소와 마지막 요소로 배열 만들기배열의 첫 요소와 마지막 요소를 나타내는 정수를 인자로 받아 정수의 배열을 반환하는 함수를 완성하라. 예를 들어 인수가 [10, 15]인 경우, [ 10, 11, 12, 13, 14, 15 ]를 반환한다. 1234567891011function generateRange(from, to) &#123; const res = []; for (let i = from; i &lt;= to; i++) &#123; res.push(i); &#125; return res;&#125;console.log(generateRange(10, 15)); // [ 10, 11, 12, 13, 14, 15 ]","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"javascript 17강 함수와 일급객체","slug":"javascript-preview-17","date":"2019-10-15T01:36:32.000Z","updated":"2019-11-30T16:41:01.035Z","comments":true,"path":"2019/10/15/javascript-preview-17/","link":"","permalink":"https://hyeok999.github.io/2019/10/15/javascript-preview-17/","excerpt":"","text":"JavaScript 17강 예습 17강 : 함수와 일급 객체 일급 객체 함수 객체의 프로퍼티 arguments 프로퍼티 caller 프로퍼티 length 프로퍼티 name 프로퍼티 __ proto __ 프로퍼티 prototype 프로퍼티 17강함수와 일급 객체 일급 객체란? 무명의 리터럴로 생성할 수 있다. (즉, 런타임에 생성이 가능해야한다.) 변수나 자료 구조에 저장할 수 있다. 함수의 매개 변수에게 전달할 수 있다. 함수의 결과값으로 반환할 수 있다. 위 조건을 만족하는 객체를 일급 객체(first-class object)라 칭한다. 12345678910111213141516171819202122232425262728293031323334// 1. 함수는 무명의 리터럴로 생성할 수 있다.// 2. 함수는 변수에 저장할 수 있다.// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.const increase = function (num) &#123; return ++num;&#125;;const decrease = function (num) &#123; return --num;&#125;;// 2. 함수는 객체에 저장할 수 있다.const predicates = &#123; increase, decrease &#125;;// 3. 함수의 매개 변수에게 전달할 수 있다.// 4. 함수의 반환값으로 사용할 수 있다.function makeCounter(predicate) &#123; let num = 0; return function () &#123; num = predicate(num); return num; &#125;;&#125;// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.const increaser = makeCounter(predicates.increase);console.log(increaser()); // 1console.log(increaser()); // 2// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.const decreaser = makeCounter(predicates.decrease);console.log(decreaser()); // -1console.log(decreaser()); // -2 함수 일급 객체 = 객체와 동일하게 이용가능 객체는 값이므로 함수는 값과 동일하게 취급가능( 변수 할당문, 객체의 프로퍼티, 배열의 요소, 함수 호출의 인수, 반환문) 리터럴로 어디서든 정의할 수 있고 런타임에 함수 객체로 평가된다. 매개 변수에 전달할 수 있고 결과값으로도 반환할 수 있다. 함수 객체의 프로퍼티12345function square(number) &#123; return number * number;&#125;console.dir(square); 일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다. 이 프로퍼티 들의 프로퍼티 어트리뷰트를 Object.getOwnPropertyDescriptor 메소드로 확인해 보면 아래와 같다. 1234567891011121314151617181920212223242526272829303132function square(number) &#123; return number * number;&#125;// arguments는 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'arguments');// &#123;value: null, writable: false, enumerable: false, configurable: false&#125;// caller는 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'caller');// &#123;value: null, writable: false, enumerable: false, configurable: false&#125;// length는 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'length');// &#123;value: 1, writable: false, enumerable: false, configurable: true&#125;// name은 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'name');// &#123;value: \"square\", writable: false, enumerable: false, configurable: true&#125;// prototype은 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'prototype');// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;// __proto__는 square 함수 객체의 프로퍼티가 아니다.Object.getOwnPropertyDescriptor(square, '__proto__');// undefined// __proto__는 Object.prototype 객체의 접근자 프로퍼티이다.// square 함수 객체는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125; 데이터 프로퍼티 : 키와 값으로 구성된 일반적인 프로퍼티다. 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티. 접근자 함수는 getter/setter 함수라고도 부른다. arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 데이터 프로퍼티. _ proto _는 접근자 프로퍼티이며 함수 객체의 프로퍼티가 아닌 Object.prototype 객체의 프로퍼티를 상속받은 것임. arguments 프로퍼티 arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object) 함수 내부에서 지역 변수처럼 사용된다. 즉, 함수 외부에서는 사용할 수 없다. 123456789function multiply(x, y) &#123; console.log(arguments); return x * y;&#125;console.log(multiply()); // NaNconsole.log(multiply(1)); // NaNconsole.log(multiply(1, 2)); // 2console.log(multiply(1, 2, 3)); // 2 multiply(1, 2, 3)으로 초과된 인수는 arguments가 소유하고 있다. arguments 객체의 callee 프로퍼티는 호출된 함수, 즉 arguments 객체를 생성한 함수를 가리키고arguments 객체의 Symbol(Symbol.iterator) 프로퍼티는 arguments 객체를 순회 가능한 자료 구조인 이터러블(iterable)로 만들기 위한 프로퍼티다. 1234567891011121314function multiply(x, y) &#123; // 이터레이터 const iterator = arguments[Symbol.iterator](); // 이터레이터의 next 메소드를 호출하여 이터러블 객체 arguments를 순회 console.log(iterator.next()); // &#123;value: 1, done: false&#125; console.log(iterator.next()); // &#123;value: 2, done: false&#125; console.log(iterator.next()); // &#123;value: 3, done: false&#125; console.log(iterator.next()); // &#123;value: undefined, done: true&#125; return x * y;&#125;multiply(1, 2, 3); arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다. 1234567891011121314function sum() &#123; let res = 0; // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다. for (let i = 0; i &lt; arguments.length; i++) &#123; res += arguments[i]; &#125; return res;&#125;console.log(sum()); // 0console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3)); // 6 caller 프로퍼티 함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다. length 프로퍼티 함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다. 123456789101112function foo() &#123;&#125;console.log(foo.length); // 0function bar(x) &#123; return x;&#125;console.log(bar.length); // 1function baz(x, y) &#123; return x * y;&#125;console.log(baz.length); // 2 arguments 객체의 length 프로퍼티는 인자의 개수를 가리키고, 함수 객체의 length 프로퍼티는 매개변수의 개수를 가리킨다. name 프로퍼티 함수의 이름을 나타내는 프로퍼티. (변수 이름 아니다. 함수 이름임.) ES6부터 정식 표준이 되었다. ES5 와 ES6의 동작이 달리하므로 주의. 익명 함수 표현식의 경우 ES5 ➤ 빈 문자열 익명 함수 표현식의 경우 ES6 ➤ 함수 객체를 가리키는 변수 이름 12345678910111213// 기명 함수 표현식var namedFunc = function foo() &#123;&#125;;console.log(namedFunc.name); // foo// 익명 함수 표현식var anonymousFunc = function() &#123;&#125;;// ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.// ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.console.log(anonymousFunc.name); // anonymousFunc// 함수 선언문(Function declaration)function bar() &#123;&#125;console.log(bar.name); // bar __ proto __ 접근자 프로퍼티 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다. __ proto __ 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 데이터 프로퍼티** : 키와 값으로 구성된 일반적인 프로퍼티다. 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티. 접근자 함수는 getter/setter 함수라고도 부른다. [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 __ proto __ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다. 123456789const obj = &#123; a: 1 &#125;;// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.console.log(obj.__proto__ === Object.prototype); // true// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.// hasOwnProperty 메소드는 Object.prototype의 메소드이다.console.log(obj.hasOwnProperty('a')); // trueconsole.log(obj.hasOwnProperty('__proto__')); // false prototype 프로퍼티 prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다. 12345// 함수 객체는 prototype 프로퍼티를 소유한다.console.log((function() &#123;&#125;).hasOwnProperty('prototype')); // true// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.console.log((&#123;&#125;).hasOwnProperty('prototype')); // false prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"https://hyeok999.github.io/tags/function/"},{"name":"first-class Object","slug":"first-class-Object","permalink":"https://hyeok999.github.io/tags/first-class-Object/"}]},{"title":"javascript 16강 생성자함수","slug":"javascript-preview-16","date":"2019-10-15T01:36:30.000Z","updated":"2019-11-30T16:41:26.561Z","comments":true,"path":"2019/10/15/javascript-preview-16/","link":"","permalink":"https://hyeok999.github.io/2019/10/15/javascript-preview-16/","excerpt":"","text":"JavaScript 16강 예습 16강 : 생성자 함수에 의한 객체 생성 Object 생성자 함수 생성자 함수 객체 리터럴에 의한 객체 생성 방식의 문제점 생성자 함수에 의한 객체 생성 방식의 장점 내부 메소드 [[Call]] 과 [[Construct]] FunctionCreate 생성자 함수의 인스턴스 생성 과정 new 연산자 new.target 스코프 세이프 생성자 패턴 (Scope-Safe Constructor) 16강생성자 함수에 의한 객체 생성 Object 생성자 함수 new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다. 1234567891011// 빈 객체의 생성const person = new Object();// 프로퍼티 추가person.name = 'Lee';person.sayHello = function () &#123; console.log('Hi! My name is ' + this.name);&#125;;console.log(person); // &#123;name: \"Lee\", sayHello: ƒ&#125;person.sayHello(); // Hi! My name is Lee 생성자 함수 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수. 인스턴스는 생성자 함수 혹은 클래스에 의해 생성된 객체를 의미한다. 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. JS는 Object, String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인(intrinsic 내장) 생성자 함수를 제공한다. 하지만 Object 생성자 함수 방식은 특별한 이유가 없다면 가독성면에서 불편하다. 12345678910111213141516171819202122232425262728293031323334// String 생성자 함수에 의한 String 객체 생성const strObj = new String('Lee');console.log(typeof strObj); // objectconsole.log(strObj); // String &#123;\"Lee\"&#125;// Number 생성자 함수에 의한 Number 객체 생성const numObj = new Number(123);console.log(typeof numObj); // objectconsole.log(numObj); // Number &#123;123&#125;// Boolean 생성자 함수에 의한 Boolean 객체 생성const boolObj= new Boolean(true);console.log(typeof boolObj); // objectconsole.log(boolObj); // Boolean &#123;true&#125;// Function 생성자 함수에 의한 Function 객체(함수) 생성const func = new Function('x', 'return x * x');console.log(typeof func); // functionconsole.dir(func); // ƒ anonymous(x )// Array 생성자 함수에 의한 Array 객체(배열) 생성const arr = new Array(1, 2, 3);console.log(typeof arr); // objectconsole.log(arr); // (3) [1, 2, 3]// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성const regExp = new RegExp(/ab+c/i);console.log(typeof regExp); // objectconsole.log(regExp); // /ab+c/i// Date 생성자 함수에 의한 Date 객체 생성const date = new Date();console.log(typeof date); // objectconsole.log(date); // Tue Mar 19 2019 02:38:26 GMT+0900 (한국 표준시) 객체 리터럴에 의한 객체 생성 방식의 문제점 객체 리터럴은 매우 직관적이며 간편하다. 하지만 객체 리터럴은 단 하나만의 객체를 생성하기 때문에, 동일한 프로퍼티를 갖는 객체를 여러개 생성 해야할 경우, 매번 같은 프로퍼티를 기술해야하는 비효율적인면이 존재한다. 1234567891011121314151617const circle1 = &#123; radius: 5, getDiameter() &#123; return 2 * this.radius; &#125;&#125;;console.log(circle1.getDiameter()); // 10const circle2 = &#123; radius: 10, getDiameter() &#123; return 2 * this.radius; &#125;&#125;;console.log(circle2.getDiameter()); // 20 circle1 circle2 의 메소드는 동일한데 같은 코드를 2번이나 적어야하는 비효율적인 면이 있다. 생성자 함수에 의한 객체 생성 방식의 장점​ 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다. 12345678910111213141516171819202122232425// 생성자 함수function Circle(radius) &#123; // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// 인스턴스의 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다.// 즉, 일반적인 함수의 호출이다.const circle3 = Circle(15);// 일반 함수 Circle은 반환문이 없으므로 암묵적으로 undefined를 반환한다.console.log(circle3); // undefined// 일반 함수 Circle내의 this는 전역 객체를 가리킨다.console.log(radius); // 15 여기서 나오는 this는 무엇일까? this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다.this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다. 함수 호출 방식 this가 가리키는 값 일반 함수로서 호출 전역 객체 메소드로서 호출 메소드를 호출한 객체 생성자 함수로서 호출 생성자 함수가 (미래에) 생성할 인스턴스 123456789101112131415// 함수는 다양한 방식으로 호출될 수 있다.function foo() &#123; console.log(this);&#125;// 일반적인 함수로서 호출// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.foo(); // window// 메소드로서 호출const obj = &#123; foo &#125;; // ES6 프로퍼티 축약 표현obj.foo(); // obj// 생성자 함수로서 호출const inst = new foo(); // inst 내부 메소드 [[Call]] 과 [[Construct]]함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다. 함수는 객체이므로 일반 객체와 동일하게 프로퍼티와 메소드를 가질수 있다. 123456789101112// 함수는 객체이다.function foo() &#123;&#125;// 함수는 객체이므로 프로퍼티를 소유할 수 있다.foo.prop = 10;// 함수는 객체이므로 메소드를 소유할 수 있다.foo.method = function () &#123; console.log(this.prop);&#125;;foo.method(); // 10 내부 메소드 [[Call]]을 갖는 함수 객체를 callable이라 하며, 내부 메소드인 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor라고 부른다. callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자(또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다. 1234567function foo() &#123;&#125;// 일반적인 함수로서 호출: [[Call]]이 호출된다.foo();// 생성자 함수로서 호출: [[Construct]]가 호출된다.new foo(); 모든 함수는 호출하는 객체이므로 callable이어야 한다.(즉, [[Call]]을 모두 가지고 있다.) 반면에 모든 함수 객체가 [[Construct]]를 갖지는 않는다. 즉, 함수객체는 모두 callable이지만 constructor 일 수도 non-constructor일 수도 있다. FunctionCreate JS엔진이 함수를 생성할 때 사용하는 추상연산 설명을 위해 사용되는 함수와 유사한 의사 코드. FunctionCreate는 함수 정의가 평가될 때 호출된다. 함수 정의 방식에 따라 FunctionCreate의 첫번째 매개변수 kind에 함수의 종류를 나타내는 문자열이 전달된다. 구분 함수의 종류를 나타내는 문자열 일반 함수 정의(함수 선언문, 함수 표현식)를 평가할 때 Normal 화살표 함수 정의를 평가할 때 Arrow 메소드 정의를 평가할 때 Method 12345678910111213141516171819202122232425// 일반 함수 정의 : kind = 'Normal'function foo() &#123;&#125;const bar = function () &#123;&#125;;// 프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.const baz = &#123; x: function () &#123;&#125;&#125;;// 일반 함수로 정의된 함수만이 constructor이다.new foo(); // OKnew bar(); // OKnew baz.x(); // OK// 화살표 함수 정의 : kind = 'Arrow'const arrow = () =&gt; &#123;&#125;;new arrow(); // TypeError: arrow is not a constructor// 메소드 정의 : kind = 'Method'// ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.const obj = &#123; x() &#123;&#125;&#125;;new obj.x(); // TypeError: obj.x is not a constructor 함수 정의 방식에 따라 함수의 종류를 구분한다. (ECMAScript에서 Method는 ES6 메소드 축약 표현만을 의미 ) 함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자 또는 super 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다. 123456789function foo() &#123;&#125;// 일반적인 함수로서 호출: [[Call]]이 호출된다.// 모든 함수 객체는 [[Call]]이 구현되어 있다.foo();// 생성자 함수로서 호출: [[Construct]]가 호출된다.// 이때 [[Construct]]를 갖지 않는다면 에러가 발생한다.new foo(); 생성자 함수는 일반적으로 첫문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다. 생성자 함수의 인스턴스 생성 과정 생성자 함수의 역할은 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당) 생성자 함수가 인스턴스를 생성하는 것은 필수이고, 생성된 인스턴스를 초기화하는 것은 옵션이다. new 연산자와 함께 생성자 함수가 호출되면 JS엔진은 다음과 같은 동작을 한다. 인스턴스 생성과 this 바인딩 암묵적으로 빈 객체가 생성된다. 생성자 함수가 생성한 인스턴스의 프로토타입으로 생성자 함수의 prototype 프로퍼티가 가리키는 객체가 설정된다. 빈 객체, 즉 인스턴스는 this에 바인딩된다. 프로토 타입 : 어떤 객체의 부모 역할을 하는 객체.프로토 타입은 하위 객체에게 자신의 프로퍼티와 메소드를 상속함. 123456789101112131415function Circle(radius) &#123; // 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. console.log(this); // Circle &#123;&#125; console.log(Object.getPrototypeOf(this) === Circle.prototype); // true this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// 0. 인스턴스 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성 인스턴스 초기화 생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 123456789function Circle(radius) &#123; // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125; 인스턴스 반환 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 123456789101112131415function Circle(radius) &#123; // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;; // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다&#125;// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.const circle = new Circle(1);console.log(circle); // Circle &#123;radius: 1, getDiameter: ƒ&#125; 예외1) 만약 명시적으로 객체 { }를 반환하면 this는 반환되지 못한다. 1234567891011121314151617function Circle(radius) &#123; // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;; // 3. 암묵적으로 this를 반환한다. // 명시적으로 객체를 반환하면 암묵적인 this 반환이 무시된다. return &#123;&#125;;&#125;// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.const circle = new Circle(1);console.log(circle); // &#123;&#125; 예외2) 만약 명시적으로 원시값을 반환하면 원시값을 무시하고 this가 반환된다. 1234567891011121314151617function Circle(radius) &#123; // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;; // 3. 암묵적으로 this를 반환한다. // 명시적으로 원시 값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다. return 100;&#125;// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.const circle = new Circle(1);console.log(circle); // Circle &#123;radius: 1, getDiameter: ƒ&#125; new 연산자new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 한다. 생성자 함수를 new와 함께 호출 시 항상 객체가 반환된다. 기본값은 this가 참조되는 객체이다. 12345678910111213141516171819// 생성자 함수로서 정의하지 않은 일반 함수function add(x, y) &#123; return x + y;&#125;// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출let inst = new add();// 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.console.log(inst); // &#123;&#125;// 객체를 반환하는 일반 함수function createUser(name, role) &#123; return &#123; name, role &#125;;&#125;// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출inst = new createUser('Lee', 'admin');// 함수가 생성한 객체를 반환한다.console.log(inst); // &#123;name: \"Lee\", role: \"admin\"&#125; new.target (IE 미지원)new 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생할 수 있다. 이러한 위험을 피하기 위해 ES6에서는 new.target을 지원한다. new.target을 사용하면 new연산자와 함께 호출되었는지 확인할 수 있다. new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리키며 new 연산자 없이 호출된 함수 내부의 new.target은 undefined다. 1234567891011121314151617// 생성자 함수function Circle(radius) &#123; // 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined이다. if (!new.target) &#123; // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); &#125; this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); 위 예제는 생성자함수로 호출이 아닌 일반 함수로 호출시 new.target을 통해 new 언산자 없이 호출했는지 판별하고 맞다면 다시 new를 붙여 Circle함수를 생성자함수로 재 호출한다. 스코프 세이프 생성자 (Scope-Safe Constructor) 패턴. new.target을 사용할 수 없는 상황이라면 스코프 세이프 생성자(Scope-Safe Constructor) 패턴을 사용할 수 있다. 123456789101112131415161718192021// Scope-Safe Constructor Patternfunction Circle(radius) &#123; // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고 // this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다. // 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다. // 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다. if (!(this instanceof Circle)) &#123; // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); &#125; this.radius = radius; this.getDiameter = function () &#123; return 2 * this.radius; &#125;;&#125;// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); // 10 new 연산자와 함께 생성자 함수에 의해 생성된 객체(인스턴스)는 프로토타입에 의해 생성자 함수와 연결된다. 이를 이용해 new 연산자와 함께 호출되었는지를 확인할 수 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Constructor","slug":"Constructor","permalink":"https://hyeok999.github.io/tags/Constructor/"}]},{"title":"javascript 15강 프로퍼티","slug":"javascript-preview-15","date":"2019-10-15T01:36:27.000Z","updated":"2019-11-30T16:41:57.701Z","comments":true,"path":"2019/10/15/javascript-preview-15/","link":"","permalink":"https://hyeok999.github.io/2019/10/15/javascript-preview-15/","excerpt":"","text":"JavaScript 15강 예습 15강 : 프로퍼티 정의 프로퍼티 정의란? 프로퍼티 정의 및 동적 생성 내부 / 슬롯 메소드 내부 메소드 [[ Get ]] 접근자 프로퍼티 접근자 프로퍼티와 데이터 프로퍼티의 구별 방법 프로퍼티 어트리뷰트 데이터 프로퍼티의 어트리뷰트 접근자 프로펕 Object.defineProperty 메소드 15강프로퍼티 정의 프로퍼티 정의란? 프로퍼티 어트리뷰트의 값을 정의하여 프로퍼티의 상태를 관리하는 것을 말한다. 프로퍼티 값을 갱신 가능하도록 할 것인지, 프로퍼티를 열거 가능하도록 할 것인지, 프로퍼티를 재정의 가능하도록 할 것인지 정의. *JS 엔진은 프로퍼티를 생성(객체 리터럴의 평가, 프로퍼티 동적 생성)할 때, * 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의 프로퍼티 정의 및 동적 생성프로퍼티 어트리뷰트란? 프로퍼티의 상태를 나타내는 값 123456789101112const obj = &#123;&#125;;// 자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는// 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.obj.prop = 10;// 정의된 프로퍼티 어트리뷰트는 Object.getOwnPropertyDescriptor 메소드로 확인할 수 있다.const descriptor = Object.getOwnPropertyDescriptor(obj, 'prop');console.log(descriptor);// obj 객체의 prop 프로퍼티는 value, writable, enumerable, configurable// 어트리뷰트가 정의되어 있다.// &#123;value: 10, writable: true, enumerable: true, configurable: true&#125; 위 예제에서 JS엔진은 먼저, obj라는 객체 안에 prop라는 프로퍼티가 있는지 확인한다. prop 가 없다면 동적으로 생성한 후 10을 할당한다. 이를 동적 생성이라 한다. 동적 생성은 프로퍼티가 존재하지 않을 때, 프로퍼티를 생성하여 추가하는 것. 동적 생성시 프로퍼티 어트리뷰트를 기본값으로 지정한다. 프로퍼티 정의는 프로퍼티 어트리뷰트를 정의하는 것 ( 프로퍼티 어트리뷰트 : 프로퍼티의 상태 ) 프로퍼티 상태는 프로퍼티의 값, 갱신여부, 열거가능여부, 재정의 가능 여부 를 말한다. 프로퍼티 어트리뷰트는 Object.getOwnPropertyDescriptor 메소드를 사용해 참조할 수 있다. 이 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 객체인 프로퍼티 디스크립터(PropertyDescriptor)를 반환한다. 123456789101112// 하나의 프로퍼티 어트리뷰트를 표현하는 프로퍼티 디스크립터 객체를 취득한다.const descriptor = Object.getOwnPropertyDescriptor(obj, 'prop');console.log(descriptor);// &#123;value: 10, writable: true, enumerable: true, configurable: true&#125;// ES8// 모든 프로퍼티 어트리뷰트를 표현하는 프로퍼티 디스크립터 객체를 취득한다.const descriptors = Object.getOwnPropertyDescriptors(obj);console.log(descriptors);// &#123;// prop: &#123; value: 10, writable: true, enumerable: true, configurable: true &#125;// &#125; 존재하지 않는 프로퍼티 / 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환된다. Object.getOwnPropertyDescriptor(객체명, &#39;키명&#39;) 내부 슬롯/메소드 내부 슬롯과 내부 메소드는 ECMAScript 스펙에서 요구하는 객체와 관련된 내부 상태와 내부 동작을 정의한 것이다. 내부 슬롯과 내부 메소드는 객체의 프로퍼티가 아니다. 따라서 내부 슬롯과 내부 메소드는 직접적으로 접근하거나 호출할 수 있는 방법을 원칙적으로 제공하지 않는다. 단, 일부 내부 슬롯과 내부 메소드(의 구현체)에 간접적으로 접근할 수 있는 수단은 있다. 내부 메소드 [[ Get ]]내부 메소드 [[ Get ]]는 프로퍼티 키로 프로퍼티 값에 접근하면 내부적으로 호출된다. 프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 문자열 또는 심볼이어야 한다. (“9.3 프로퍼티” 참고) 프로토타입 체인에서 프로퍼티를 검색한다. 검색된 프로퍼티가 “데이터 프로퍼티(Data property)“라면 프로퍼티 값,즉 데이터 프로퍼티의 프로퍼티 어트리뷰트 [[Value]]의 값을 그대로 반환한다. 만약 프로퍼티가 “접근자 프로퍼티(Accessor property)”라면 접근자 프로퍼티의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다. 프로토 타입 과 프로토 타입 체인 프로토 타입 : 어떤 객체의 부모 역할을 하는 객체프로토 타입은 하위 객체에게 자신의 프로퍼티와 메소드를 상속함. 프로토 타입 체인 : 프로토 타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조를 의미. 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 프로토타입 체인을 따라 프로토타입의 프로퍼티나 메소드를 차례대로 검색한다. 접근자 프로퍼티​ 프로퍼티는 데이터 프로퍼티 와 접근자 프로퍼티로 구분된다. 데이터 프로퍼티 : 키와 값으로 구성된 일반적인 프로퍼티다. 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티 접근자 함수는 getter/setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다. 123456789101112131415161718192021222324252627282930313233343536373839const person = &#123; // 데이터 프로퍼티 firstName: 'Ungmo', lastName: 'Lee', // fullName은 접근자 함수로 구성된 접근자 프로퍼티이다. // getter 함수 get fullName() &#123; return this.firstName + ' ' + this.lastName; &#125;, // setter 함수 set fullName(name) &#123; [this.firstName, this.lastName] = name.split(' '); &#125;&#125;;// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.console.log(person.firstName + ' ' + person.lastName); // Ungmo Lee// 접근자 프로퍼티를 통한 프로퍼티 값의 저장// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.person.fullName = 'Heegun Lee';console.log(person); // &#123;firstName: \"Heegun\", lastName: \"Lee\"&#125;// 접근자 프로퍼티를 통한 프로퍼티 값의 참조// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.console.log(person.fullName); // Heegun Lee// firstName는 데이터 프로퍼티이다.// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');console.log(descriptor);// &#123;value: \"Heegun\", writable: true, enumerable: true, configurable: true&#125;// fullName는 접근자 프로퍼티이다.// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');console.log(descriptor);// &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125; person 객체의 firstName과 lastName 프로퍼티는 일반적인 데이터 프로퍼티. 메소드 앞에 get,set이 붙은 메소드가 있는데 이것들이 바로 getter와 setter 함수이고 getter/setter 함수의 이름 fullName이 접근자 프로퍼티이다. 접근자 프로퍼티는 자체적으로 값(value 프로퍼티 어트리뷰트)을 가지지 않으며 다만 데이터 프로퍼티의 값을 읽거나 저장할 때 관여할 뿐이다. 접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메소드가 호출되어 아래와 같이 동작한다. 프로퍼티 키가 유효한지 확인한다. 프로퍼티 키 “fullName”은 문자열이므로 유효한 프로퍼티 키이다. 프로토타입 체인에서 프로퍼티를 검색한다. person 객체에 fullName 프로퍼티가 존재한다. 검색된 fullName 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName 프로퍼티는 접근자 프로퍼티이다. 접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메소드가 반환하는 프로퍼티 디스크립터(PropertyDescriptor) 객체의 get 프로퍼티 값과 같다. 접근자 프로퍼티와 데이터 프로퍼티의 구별 방법1234567// 일반 객체의 __proto__는 접근자 프로퍼티이다.Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;// 함수 객체의 prototype은 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(function() &#123;&#125;, 'prototype');// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125; 프로퍼티 어트리뷰트데이터 프로퍼티의 어트리뷰트프로퍼티 어트리뷰트 / 프로퍼티 디스크립터 객체의 프로퍼티 [[Value]] / value 프로퍼티 키에 접근하면 [[Get]]에 의해 반환되는 값 프로퍼티 키로 값을 저장하면 [[Value]]에 값을 저장한다. 프로퍼티가 없다면 프로퍼티를 생성하고 저장한다. [[Writable]] / writable 프로퍼티 값의 변경가능 여부를 나타내며, boolean 값 을 지님. false 면 해당 프로퍼티의 [[Value]]를 변경 불가. [[Enumerable]] / enumerable 프로퍼티의 열거 가능 여부를 나타내며, boolean 갑을 지님. false 면 for…in 문이나 Object,keys 메소드 등으로 열거 불가. [[Comfigurable]] / configurable 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 지님. false 면, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. 접근자 프로퍼티프로퍼티 어트리뷰트 / 프로퍼티 디스크립터 객체의 프로퍼티 [[Get]] 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수. [[Set]] 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수. [[Enumerable]] 데이터 프로퍼티의 [[Enumerable]]와 같다. [[Configurable]] 데이터 프로퍼티의 [[Configurable]]와 같다. Object.defineProperty 메소드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const obj = &#123; prop1: 1 &#125;;// 프로퍼티 동적 추가obj.prop2 = 2;// 프로퍼티 어트리뷰트를 표현하는 프로퍼티 디스크립터 객체를 취득한다.const descriptor = Object.getOwnPropertyDescriptor(obj, 'prop2');console.log(descriptor);// → &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;Object.defineProperty 메소드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수는 객체의 참조와 데이터 프로퍼티의 키인 문자열 그리고 프로퍼티 디스크립터 객체를 전달한다.const person = &#123;&#125;;// 데이터 프로퍼티 정의Object.defineProperty(person, 'firstName', &#123; value: 'Ungmo', writable: true, enumerable: true, configurable: true&#125;);Object.defineProperty(person, 'lastName', &#123; value: 'Lee'&#125;);let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');console.log('firstName', descriptor);// firstName &#123;value: \"Ungmo\", writable: true, enumerable: true, configurable: true&#125;// 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.descriptor = Object.getOwnPropertyDescriptor(person, 'lastName');console.log('lastName', descriptor);// lastName &#123;value: \"Lee\", writable: false, enumerable: false, configurable: false&#125;// [[Enumerable]]의 값이 false인 경우,// 해당 프로퍼티는 for…in 문이나 Object.keys 등으로 열거할 수 없다.// lastName 프로퍼티는 [[Enumerable]]의 값이 false이므로 열거되지 않는다.console.log(Object.keys(person)); // [\"firstName\"]// [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.// 에러는 발생하지 않고 무시된다.// lastName 프로퍼티는 [[Writable]]의 값이 false이므로 값을 변경할 수 없다.person.lastName = 'Kim';// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제할 수 없다.// 에러는 발생하지 않고 무시된다.// lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.delete person.lastName;// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 재정의할 수 없다.// Object.defineProperty(person, 'lastName', &#123; enumerable: true &#125;);// Uncaught TypeError: Cannot redefine property: lastNamedescriptor = Object.getOwnPropertyDescriptor(person, 'lastName');console.log('lastName', descriptor);// lastName &#123;value: \"Lee\", writable: false, enumerable: false, configurable: false&#125;// 접근자 프로퍼티 정의Object.defineProperty(person, 'fullName', &#123; // getter 함수 get: function () &#123; // === get() &#123; return this.firstName + ' ' + this.lastName; &#125;, // setter 함수 set: function (name) &#123; // === set(name) &#123; [this.firstName, this.lastName] = name.split(' '); &#125;, enumerable: true, configurable: true&#125;);descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');console.log('fullName', descriptor);// fullName &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;person.fullName = 'Heegun Lee';console.log(person); // &#123;firstName: \"Heegun\", lastName: \"Lee\"&#125; Object.defineProperty 메소드로 프로퍼티 정의할 때 프로퍼티 디스크립터 객체의 프로퍼티를 일부 누락할 수 있다. 프로퍼티 디스크립터 객체에서 누락된 어트리뷰트는 아래와 같이 기본값이 적용된다. 프로퍼티 디스크립터 객체의 프로퍼티 대응하는 프로퍼티 어트리뷰트 디스크립터 객체의 프로퍼티 누락 시의 기본값 value [[Value]] undefined get [[Get]] undefined set [[Set]] undefined writable [[Writable]] false enumerable [[Enumerable]] false configurable [[Configurable]] false 123456789101112131415161718192021222324252627282930313233const person = &#123;&#125;;Object.defineProperties(person, &#123; // 데이터 프로퍼티 정의 firstName: &#123; value: 'Ungmo', writable: true, enumerable: true, configurable: true &#125;, lastName: &#123; value: 'Lee', writable: true, enumerable: true, configurable: true &#125;, // 접근자 프로퍼티 정의 fullName: &#123; // getter 함수 get: function () &#123; return this.firstName + ' ' + this.lastName; &#125;, // setter 함수 set: function (name) &#123; [this.firstName, this.lastName] = name.split(' '); &#125;, enumerable: true, configurable: true &#125;&#125;);person.fullName = 'Heegun Lee';console.log(person); // &#123;firstName: \"Heegun\", lastName: \"Lee\"&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Property","slug":"Property","permalink":"https://hyeok999.github.io/tags/Property/"}]},{"title":"javascript 데일리 테스트 1","slug":"javascript-daily-test01","date":"2019-10-14T11:02:58.000Z","updated":"2019-11-30T16:44:30.934Z","comments":true,"path":"2019/10/14/javascript-daily-test01/","link":"","permalink":"https://hyeok999.github.io/2019/10/14/javascript-daily-test01/","excerpt":"","text":"JavaScript Weekly Test 오답 및 개념 재정리 Javascript vs ECMAScript ECMAScript는 자바스크립트의 표준 사양인 ECMA-262 이다.ECMAScript는 자바스크립트의 모든 영역을 담고 잇는 것이 아니라.통상영역만 담고 있다.es6, es5 등등 ECMASciprt의 사양을 의미한다. JS는 ECMAscript를 포함한 클라이언트 사이드 web api이다.(그래서 JS를 탑재한 브라우저는 노드는 쓸 수 없는 dom , fetch 등의 API를 다룰 수 있다. ) 변수란? 변할 수 있는 하나의 값을 담는 메모리 공간 그 자체. 하나의 값을 저장하기 위해 메모리 공간에 붙인 이름. javascript 데이터 타입 문자열 , 숫자 , symbol, undefined, null, boolean, 객체 리터럴이란 무엇인가? 사람이 알아볼 수 있는 언어로 값의 생성을 명령하는 것 var foo = 42 / -0; console.log(foo); -Infinity 음의 무한대, 추가정리 : 숫자 타입의 3가지 특별한 값 Infinity : 양의 무한대 // (10/0); -Infinity : 음의 무한대 // (10 / -0); NaN : 산술 연산 불가(not-a-number) // (1 * ‘String’); var x = 5;일 때, console.log(x != ‘5’); 의 결과는 무엇인가? false 추가정리: == 혹은 !=은 비교할 때 데이터타입을 암묵적으로 맞추어서 비교를 하려고 한다.(에러 방지하기 위함) 따라서 변수 x 와 문자열 5의 값을 비교할때 타입은 맞춰서 비교를 하기에 둘의 값은 같다. 따라서 답이 같이 않냐고 물었기 때문에 false를 반환한다. 만약, 타입 조차 비교를 하고 싶다면 ==이 아닌 ===을 사용해야만 한다. var foo = false &amp;&amp; ‘Cat’; 일 때, foo 의 값은 무엇인가? false console.log(!!null); true 추가정리: false 값들 빈문자열 &#39;&#39; undefined null NaN 0, -0 false","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"daily test","slug":"daily-test","permalink":"https://hyeok999.github.io/tags/daily-test/"}]},{"title":"javascript-study-08","slug":"javascript-study-08","date":"2019-10-14T10:22:46.000Z","updated":"2019-11-30T16:29:27.314Z","comments":true,"path":"2019/10/14/javascript-study-08/","link":"","permalink":"https://hyeok999.github.io/2019/10/14/javascript-study-08/","excerpt":"","text":"JavaScript Study 08 용어 스코프 순수 함수 비순수 함수 스코프의 종류 스코프 체인 렉시컬 스코프 암묵적 전역 변수 JS 모듈 미지원 모듈 전역 변수의 문제점 전역 변수 사용 억제 방법 let, const와 블록 레벨 스코프 var 키워드로 선언한 변수의 문제점 let 키워드와 var 키워드의 차이점 const 키워드 const 키워드와 객체 var : let : const 용어 - ( 러버덕 ) 스코프 순수 함수 비순수 함수 전역 변수 암묵적 전역 변수 지역 변수 let : var : const var 의 문제점 let 키워드 특징 const 키워드 특징 스코프 JS엔진이 식별자를 찾는 규칙. 식별자가 유효한 범위 스코프는 유효범위 , 변수의 생명주기와 큰 관련이 있다. JS에서는 함수가 스코프 큰 관련이 있다. 객체의 프로퍼티는 스코프에 존재하는게 아니라, 프로토타입 스코프 체인에 존재한다. 함수의 코드 블록이 스코프를 만든다. 자바스크립트는 함수 레벨 스코프다. 함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있고 , 몸체 외부에서는 참조할 수 없다. ➤ 매개변수를 참조할 수 있는 유효한 범위, 즉 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문이다. 123456789101112//순수 함수function add(x, y) &#123; // 매개변수는 함수 몸체 내부에서만 참조할 수 있다. // 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부이다. console.log(x, y); // 2 5 return x + y;&#125;add(2, 5);// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.console.log(x, y); // ReferenceError: x is not defined 123456789//비순수 함수var num = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.function increase() &#123; return ++num; // 외부 상태를 변경한다.&#125;console.log(increase()); // 1console.log(increase()); // 2 num은 누구나 참조할 수 있는 전역 변수이다. increase()에서도 num은 참조할 수 있다. 이렇게 누구나 사용 가능 하게끔 설정할 때는 변수보다는 상수를 이용하는게 더 효율적이다. 단, 상수는 재할당이 불가능하므로 해당 값이 변해도 되는지를 판단을 하여야만 한다. 순수 함수 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다. ( 위 add예제 ) 비순수 함수 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 함수. ( 위 increase 예제 ) 즉, 스코프는 식별자가 유효한 범위를 의미*모든 식별자(변수 명 ← (함수명), 클래스 명 등)은 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다. * 12345678910var x = 'global';function foo() &#123; var x = 'local'; console.log(x); // ① local&#125;foo();console.log(x); // ② global 스코프의 종류​ 코드는 전역(global)과 지역(local)으로 구분할 수 있다. 구분 설명 스코프 변수 전역 코드의 가장 바깥 영역 전역 스코프 전역 변수 지역 함수 몸체 내부 지역 스코프 지역 변수 이때 변수는 자신이 선언된 위치(전역 또는 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다. 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수이다. 전역 변수는 어디서든지 참조할 수 있다. 부모는 부모꺼만 쓸 수 있고, 자식은 자신과 부모꺼 모두 사용할 수 있다. 1234567891011// 1.var x = 5;function fn() &#123; var x = 9; console.log(x); // 1-1 : 9 return x;&#125;fn();console.log(x); // 1-2: 5 1234567891011// 2.var x = 5;function fn() &#123; x = 9; console.log(x); // 2-1 : 9 return x;&#125;fn();console.log(x); // 2-2 : 9 1 과 2의 차이는 무엇일까? 1은 fn()의 지역 스코프에서 x라는 변수를 선언하여 9를 할당하였다. 결국 전역 스코프의 x는 변하지 않는다. 2는 fn() 지역 스코프에서 x라는 변수에 9를 재할당 한 것이다. 결국 2는 전역 스코프의 x값이 바뀌고 9가 출력된다. 스코프 체인 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다. 이는 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 의미. 변수를 참조할 때, **자바스크립트 엔진은 **스코프 체인을 통해변수를 참조하는 코드의 스코프에서 시작하여상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 123456789101112131415// 전역 함수function foo() &#123; console.log('global function foo');&#125;function bar() &#123; // 중첩 함수 function foo() &#123; console.log('local function foo'); &#125; foo(); // ①&#125;bar(); 렉시컬 스코프 JS에서는 상위 스코프의 결정 방식을 렉시컬 스코프 하게 짓는다. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. 12345678910111213var x = 1;function foo() &#123; var x = 10; bar();&#125;function bar() &#123; console.log(x);&#125;foo(); // ?bar(); // ? 정답은 foo는 1 , bar 도 1이다. bar는 전역 스코프에서 정의가 되었다. 따라서 bar의 스코프 위치는 전역의 바로 아래이다. 따라서 bar()를 호출했을 때, bar()의 내용물은 결국 전역 스코프에 읽게 된다. 만약 bar()가 foo() 내부의 스코프를 타서 x값을 읽어드렸다면, 이를 동적 스코프(함수를 호출한 위치로 스코프 결정)라 한다. 대부분의 언어(JS를 포함)는 렉시컬 스코프를 지원한다. 이유는 동적 스코프는 가독성이 떨어지기 때문이다. 암묵적 전역 변수12345678function foo() &#123; // 선언하지 않은 변수에 값을 할당하면 암묵적 전역 변수가 된다. x = 10;&#125;foo();console.log(x); // 10 나는 foo()라는 변수와 foo()내부의 x 를 선언한적이 없다. 근데 foo()를 호출할수 있고 또 console.log에서 x를 찾아 출력까지 했다.. 이처럼 선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역 변수를 선언하고 값을 할당한다. 과정 함수 foo가 호출 변수 x에 값을 할당하기 위해 자바스크립트 엔진은 스코프 체인을 따라서 함수 foo의 스코프부터 변수 x의 선언을 찾는다. 함수 foo에는 x의 선언이 존재하지 않으므로 전역에서 x의 선언을 찾는다. 전역 스코프에서도 변수 x의 선언을 찾을 수 없다. ➤ 참조에러를 발생시켜야 하지만, 자바스크립트 엔진은 암묵적으로 전역 변수 x를 선언한다. JS 모듈 미지원만약 2개의 .js파일이 있다고 가정하고. 하나의 html파일에서 js를 로드했다고 하자. 1234567891011// x.jsfunction foo() &#123; i = 0; // 암묵적 전역 변수 // ...&#125;// y.jsfor (var i = 0; i &lt; 5; i++) &#123; foo(); console.log(i);&#125; 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script src='x.js'&gt;&lt;/script&gt; &lt;script src='y.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이경우 y.js의 var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다.따라서 for문에서 선언한 i는 전역 변수이다.이미 암묵적 전역 변수 i가 있으므로 변수 i는 중복 선언된다.결국 y.js 에서 호출한 foo() 때문에 i는 게속 0으로 할당될 것이고 무한루프에 빠지게 된다. 여기서 HTML에서 로드한 js파일들은 모두 하나의 전역 스코프를 공유한다. 자바스크립트 파일을 여러 개로 분리하여도 결국 하나의 자바스크립트 파일로 통합된 것처럼 동작한다. 즉, i는 서로간에 충돌을 일으킨다. 다시 말해 자바스크립트는 파일마다 독립적인 파일 스코프를 갖지 않는다. *자바스크립트에는 모듈이라는 개념이 없기 때문. *모듈화가 되려면 file스코프를 지원되어야 한다. 를 해결하기 위해 번들링 (Webpack) 이라는 개념이 나왔다. (이는 추후에 공부) 모듈모듈의 역할 : Bundling 애플리케이션을 구성하는 개별적 요소로 재사용이 가능한 코드 조각을 의미 공개가 필요한 API만을 외부에 노출시키며, 세부적인 부분은 캡슐화로 정보은닉. ES6 부터 기능이 제공. 전역 변수의 문제점 스코프를 통해 전역변수가 위험하다는 것을 직간접적으로 느꼈을 것이다. 따라서 생명주기에 대해 제대로 공부해야한다. 긴 생명주기로 인해 버그 발생률을 높인다. (이름 충돌, 메모리 리소스 높이는 원인, 상태 변경 등등) 모든코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용하는 것. 스코프 체인상 종점에 존재하기 때문에 검색속도가 느리다. 파일이 분리되어도 전역 스코프는 공유하기 때문에 네임스페이스 오염이 일어난다. 리소스 활용이 어려워진다. 전역 변수 사용 억제 방법 즉시 실행 함수 네임 스페이스 객체 12345var MYAPP = &#123;&#125;; // 전역 네임 스페이스 객체MYAPP.name = 'Lee';console.log(MYAPP.name); // Lee 모듈패턴 12345678910111213141516171819202122var Counter = (function () &#123; // private 변수 var num = 0; // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다. return &#123; increase() &#123; // 메소드 축약 표현 return ++num; &#125;, decrease() &#123; // 메소드 축약 표현 return --num; &#125; &#125;;&#125;());// private 변수는 외부로 노출되지 않는다.console.log(Counter.num); // undefinedconsole.log(Counter.increase()); // 1console.log(Counter.increase()); // 2console.log(Counter.decrease()); // 1console.log(Counter.decrease()); // 0 위 예제에서는 return을 이용하여 변수의 노출 여부를 판단하고 있다. 자바스크립트의 강력한 기능인 클로저를 기반으로 동작하는 모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. let, const 와 블록 레벨 스코프var 키워드로 선언한 변수의 문제점 변수호이스팅 (가독성 방해 No.1) 중복 선언 허용. (중복 선언시, 에러를 유발하는게 아닌 재할당처럼 동작) 암묵적 전역 변수 (var키워드 없이 할당할 경우. 강제 전역 변수로 암묵적 실행) 지역 레벨 스코프를 지원, 블록 레벨 스코프 사용불가(for, if 등등) let 키워드와 var 키워드의 차이점 변수 중복 성언 금지 : 중복 선언시 문법 에러를 유발. 12345678var foo = 123;// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.var foo = 456;let bar = 123;// let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.let bar = 456; // SyntaxError: Identifier 'bar' has already been declared 블록 레벨 스코프를 지원 123456789let foo = 123; // 전역 변수&#123; let foo = 456; // 지역 변수 let bar = 456; // 지역 변수&#125; // -&gt; 블록 레벨 스코프console.log(foo); // 123console.log(bar); // ReferenceError: bar is not defined 변수 이름은 스코프만 분리되어 있으면 된다. (그렇다고 좋은것 이나고 가급적이면 이름을 다르게 지어야한다.) 위 코드는 { } 블록으로 스코프가 나뉘게 되었다. let은 블록 레벨 스코프를 따른다. 변수 호이스팅 : let은 변수 호이스팅을 안하는것 처럼 보일 뿐, 호이스팅을 한다. let은 호이스팅 할 경우, undefined로 초기화 시키지 않는다. 초기화는 변수 선언문에 도달했을 때 실행된다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 TDZ (일시적 사각지대)라 칭한다. 123456let foo = 1; // 전역 변수&#123; console.log(foo); // ReferenceError: foo is not defined - TDZ일시적 사각지대 let foo = 2; // 지역 변수&#125; 전역 객체와 let window는 전역객체다. var 키워드 만든 전역변수, 전역 함수와 암묵적으로 만들어진 전역 변수들은 window의 프로퍼티다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 반면에, let 와 const로 만든 전역 변수는 window의 프로퍼티가 아니다. let, const의 전역 변수의 생명주기는 죽을 때는 실행코드가 전부 실행되고 끝날때 끝난다.(window는 실행코드가 끝나도 살아있다.) let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다. 123456// 이 예제는 브라우저 환경에서 실행시켜야 한다.let x = 1;// let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.console.log(window.x); // undefinedconsole.log(x); // 1 const 키워드 상수를 선언할 때 사용. 상수도 변수다. 다만, 재할당만 불가능함. 재할당불가 변수 선언과 동시 할당해야만 한다. 변수를 선언할때 가급적이면 const로 상수를 선언하고 필요한 경우에만 let을 이용하여야 한다. const 키워드와 객체const 키워드로 선언된 변수는 재할당이 금지된다.객체는 변경 가능한 값(mutable value)이다.따라서 const 키워드로 선언된 변수에 할당된 객체는 변경이 가능하다. 12345678const person = &#123; name: 'Lee'&#125;;// 객체는 변경 가능한 값이다.person.name = 'Kim';console.log(person); // &#123;name: \"Kim\"&#125; var vs. let vs. const변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 원시 값의 경우, 가급적 상수를 사용하는 편이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지 않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전하다. var와 let, 그리고 const 키워드는 다음처럼 사용하는 것을 추천한다. ES6를 사용한다면 var 키워드는 사용하지 않는다. 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다. 변경이 발생하지 않는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 보다 안전하다. 변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당을 하는 경우가 드물다. 따라서 변수를 선언할 때에는 일단 const 키워드를 사용하도록 하자. 반드시 재할당이 필요하다면(반드시 재할당이 필요한지 한번 생각해 볼 일이다.) 그때 const를 let 키워드로 변경해도 결코 늦지 않는다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_algorithm14","slug":"daily-algorithm14","date":"2019-10-14T00:43:50.000Z","updated":"2019-11-30T16:49:39.525Z","comments":true,"path":"2019/10/14/daily-algorithm14/","link":"","permalink":"https://hyeok999.github.io/2019/10/14/daily-algorithm14/","excerpt":"","text":"문제 출처 : poiema 알고리즘 연습 문제 11. Check Palindrompalindrome(팰린드롬/회문)은 왼쪽에서 오른쪽으로 읽은 다음, 오른쪽부터 왼쪽으로 다시 읽어도 똑같은 형태와 의미를 유지하는 문장이나 단어를 지칭한다. 인자로 전달한 문자열이 palindrome인지 검사하여 Boolean값을 반환하는 함수를 완성하라. 단, 반드시 1자 이상의 문자열을 인자로 전달한다. 123456789101112131415161718function checkPalindrom(str) &#123; if (str.length &lt; 1 || str == undefined) return false; let j = str.length; for (let i = 0; i &lt; str.length; i++) &#123; if (str[i] === str[j - 1]) &#123; j--; &#125; else &#123; return false; &#125; &#125; return true;&#125;console.log(checkPalindrom('dad')); // trueconsole.log(checkPalindrom('mom')); // trueconsole.log(checkPalindrom('palindrom')); // falseconsole.log(checkPalindrom('s')); // true 12. 중복 요소 제거 **인수로 전달된 배열의 요소 중에서 중복된 요소를 제외하고 유니크한 요소만을 반환하는 함수를 작성하라. for 문은 사용하지 않도록 하자. 1234567function uniq(array) &#123; return array.filter(function (item, index) &#123; return array.indexOf(item) == index; &#125;);&#125;console.log(uniq([2, 1, 2, 3, 4, 3, 4])); // [ 2, 1, 3, 4 ] 13. 중복없는 배열 **길이가 n인 배열에 1부터 n까지 숫자가 중복 없이 한 번씩 들어 있는지를 확인하려고 한다. 1부터 n까지 숫자가 중복 없이 한 번씩 들어 있는 경우 true를, 아닌 경우 false를 반환하도록 함수 isNotOverlapArray을 완성하라. 단, 배열의 요소는 정수이다. 예를 들어 주어진 배열이 [4, 1, 3, 2]이라면 true, [4, 1, 3] 또는 [1, 3]이라면 false를 반환한다. 123456789function isNotOverlapArray(array) &#123; return array.every(function (currentValue, index) &#123; return currentValue &lt;= array.length &amp;&amp; array.indexOf(currentValue) === index; &#125;);&#125;console.log(isNotOverlapArray([4, 1, 3, 2])); // trueconsole.log(isNotOverlapArray([4, 1, 3])); // falseconsole.log(isNotOverlapArray([1, 2, 2])); // false 14. 중복된 요소 ***인수로 전달된 배열의 요소 중에서 중복된 요소만으로 구성된 배열을 반환하는 함수를 작성하라. for 문은 사용하지 않도록 하자. 1234567function findDuplicated(array) &#123; return array.filter(function (currentValue, index) &#123; return array.indexOf(currentValue) !== index; &#125;);&#125;console.log(findDuplicated([1, 2, 3, 4, 1, 2, 3])); // [ 1, 2, 3 ] 15. 약수의 합어떤 수를 입력받아 그 수의 약수를 모두 더한 수를 구하는 sumDivisor 함수를 완성하라. 예를 들어 12가 입력된다면 12의 약수는 [1, 2, 3, 4, 6, 12]가 되고, 총 합은 28이 되므로 28을 반환한다. 약수(約數, divisor)는 어떤 수를 나누었을 때 나머지가 0인 수를 말하며, 배수 관계와 서로 반대되는 개념이다 12345678910111213function sumDivisor(num) &#123; let result = 0; for (let i = 1; i &lt;= num; i++) &#123; if (num % i == 0) &#123; result += i; &#125; &#125; return result;&#125;console.log(sumDivisor(12)); // 28","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"daily_algorithm13","slug":"daily-algorithm13","date":"2019-10-13T16:31:49.000Z","updated":"2019-11-30T16:49:30.914Z","comments":true,"path":"2019/10/14/daily-algorithm13/","link":"","permalink":"https://hyeok999.github.io/2019/10/14/daily-algorithm13/","excerpt":"","text":"문제 출처 : poiema 알고리즘 연습 문제 6. 핸드폰번호 가리기핸드폰 요금 고지서에 표시할 전화번호는 개인정보 보호를 위해 맨 뒷자리 4자리를 제외한 나머지를 *으로 바꿔야 한다. 전화번호를 나타내는 문자열 str을 입력받는 hideNumbers 함수를 완성하라 예를들어 s가 ‘01033334444’면 *******4444를 리턴하고, ‘027778888’인 경우는 *****8888을 리턴한다. 12345678910111213141516function hideNumbers(str) &#123; let answer = ''; for (let i = 0; i &lt; str.length - 4; i++) &#123; answer += '*'; &#125; for (let i = str.length - 4; i &lt; str.length; i++) &#123; answer += str[i]; &#125; console.log(answer); return answer;&#125;console.log(hideNumbers('01033334444')); // *******4444console.log(hideNumbers('027778888')); // *****8888 7. 문자열을 숫자로 바꾸기strToInt 메소드는 문자열을 인수로 전달받는다. 전달받은 문자열 인수를 숫자로 변환한 결과를 반환하도록 strToInt를 작성하라. 예를 들어 str이 ‘1234’이면 1234를 반환하고, ‘-1234’이면 -1234를 반환한다. str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없다. 123456function strToInt(str) &#123; return +str;&#125;console.log(strToInt('1234')); // 1234console.log(strToInt('-1234')); // -1234 8. 수박수박수박수박수박수?waterMelon 함수는 정수를 인수로 전달받는다. 길이가 n이고, 수박수박수…와 같은 패턴을 유지하는 문자열을 리턴하도록 함수를 완성하라. 예를 들어 n이 4이면 ‘수박수박’을 리턴하고 3이라면 ‘수박수’를 리턴한다. 1234567891011121314151617function waterMelon(n) &#123; let answer = ''; for (let i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) &#123; answer += '수'; &#125; else &#123; answer += '박'; &#125; &#125; return answer;&#125;// console.log(`n이 3인 경우: $&#123;waterMelon(3)&#125;`);// console.log(`n이 4인 경우: $&#123;waterMelon(4)&#125;`);console.log(`n이 3인 경우: $&#123;waterMelon(3)&#125;`);console.log(`n이 4인 경우: $&#123;waterMelon(4)&#125;`); 9. 정수제곱근 판별하기nextSqaure함수는 정수를 인수로 전달받는다. n이 임의의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 임의의 정수 x의 제곱이 아니라면 ‘no’를 리턴하는 함수를 작성하라. 예를 들어 n이 121이라면 이는 정수 11의 제곱이므로 (11+1)의 제곱인 144를 리턴하고, 3이라면 ‘no’을 리턴한다. 1234567891011121314151617181920212223function nextSqaure(n) &#123; let answer = 0; if (n === undefined) return 'no'; for (let i = 0; i &lt;= n; i++) &#123; if (i ** 2 === n) &#123; answer = (i + 1) ** 2; break; &#125; else &#123; answer = 'no'; &#125; &#125; return answer;&#125;console.log(nextSqaure()); // noconsole.log(nextSqaure(0)); // 1console.log(nextSqaure(1)); // 4console.log(nextSqaure(2)); // noconsole.log(nextSqaure(3)); // noconsole.log(nextSqaure(121)); // 144console.log(nextSqaure(165)); // noconsole.log(nextSqaure(400)); // 441 10. 배열의 최대/최소값 구하기 *배열의 요소 중 최대값/최소값을 반환하는 함수를 완성하라. 123456789function getMaxValueFromArray(array) &#123; return Math.max.apply(0, array);&#125;console.log(getMaxValueFromArray([3, 6, -2, -5, 7, 3])); // 7function getMinValueFromArray(array) &#123; return Math.min.apply(0, array);&#125;console.log(getMinValueFromArray([3, 6, -2, -5, 7, 3])); // -5","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"javascript 13강~14(전역변수의 문제점, 블록 레벨 스코프)","slug":"javascript-preview-1314","date":"2019-10-13T16:16:35.000Z","updated":"2019-11-30T16:32:38.538Z","comments":true,"path":"2019/10/14/javascript-preview-1314/","link":"","permalink":"https://hyeok999.github.io/2019/10/14/javascript-preview-1314/","excerpt":"","text":"JavaScript 13강~14강 예습 13강 : 전역 변수의 문제점 변수의 생명 주기 전역 변수의 생명 주기 진입점 JS의 return 위치 전역의 var 키워드 전역 변수의 문제점 암묵적 결합 implicit coupling 긴 생명 주기 스코프 체인 상에서 종점에 존재 네임스페이스 오염 전역 변수 사용 억제 방법 즉시 실행 함수 네임 스페이스 객체 모듈 패턴 ES6 모듈 14강 : let, const와 블록 레벨 스코프 var 키워드로 선언한 변수의 문제점 변수 중복 선언 허용 함수 레벨 스코프 변수 호이스팅 let 키워드 변수 중복 선언 금지 블록 레벨 스코프 변수 호이스팅 전역 객체와 let const 키워드 선언과 초기화 상수 const키워드와 객체 var vs. let vs. const 13강전역 변수의 문제점 변수의 생명 주기 변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 가비지 컬렉터에 의해 언젠가 소멸된다. 즉, 변수는 생명주기 를 지니고 있다. 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다. 하지만, 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다. 12345678function foo() &#123; var x = 'local'; console.log(x); // local return x;&#125;foo();console.log(x); // ReferenceError: x is not defined 지역변수 x는 함수 foo가 호출되기 전까지는 생성되지 않는다.함수를 호출하지 않으면 변수 선언문이 실행되지 않기 때문이다. 정리하면, 함수가 호출될 경우 함수 내부의 선언문들이 먼저 실행되고 undefined를 할당받는다. 함수가 종료되면 지역변수도 소멸되어 생명주기가 종료된다. 즉, 함수가 호출되어 실행되는 동안에만 지역변수는 유효를 가진다. 지역변수의 생명주기 = 함수의 생명주기 변수 호이스팅 : 위 정리 내용을 토대로 보면 변수 호이스팅은 스코프를 단위로 동작한다. 전역 변수의 생명 주기 전역 코드들은 실행(호출 포함)하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다. 진입점​ 진입점은 C난 Java등은 프로그램 시작시 main함수를 호출한다. 이를 진입점 또는 시작점이라 한다. JS의 return 위치​ return은 함수 몸체 내부에서만 사용할 수 있다. 전역에서 return문을 사용하면 문법에러를 일으킨다. 전역의 var 키워드 var키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 브라우저 환경에서 전역 객체는 window이기 때문에 브라우저 환경에서 var키워드로 선언한 전역변수는 window의 프로퍼티가 된다. 이 전역 객체 window는 웹페이지 종료 시점까지 유효하며, 전역변수 var키워드는 웹페이 종료할 때까지 유효하다. 전역 변수의 문제점1. 암묵적 결합 implicit coupling​ 전역 변수는 내 의도와는 다르게 어디서든지 전역변수를 참조 및 변경이 가능하다. 이는 암묵적 결합을 허용하는 것으로 변수의 유효 범위가 크면 클 수록 코드의 가독성은 나빠지고 의도치 않게 상태가 바뀔 수 있다. 2. 긴 생명주기​ 전역 변수는 생명주기가 프로그램의 종료시점과 거의 일치하므로, 이는 상태 변경기회를 늘리게 된다. 또한 메모리에도 게속 상주하게 되는 것이므로 리소스도 오랜 기간 소비한다. 이러한 문제는 오류를 발생시킬 확률을 증가시킨다. 3. 스코프 체인 상에서 종점에 존재​ 전역 변수는 스코프 체인 상에서 종점에 존재한다. 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 의미하는데, 결국, 전역변수의 검색 속도가 가장 느리다는 것을 의미한다. 4. 네임 스페이스 오염​ JS의 가장 큰 문제는 .js 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다는 것이다. 즉, .js 파일을 나누어 협업을 진행하게 될 경우 전역 변수 이름으로 충돌이 생길 확률이 매우 높다. 전역 변수 사용 억제 방법 전역 변수를 사용하여야 할 이유를 찾지 못했다면 지역변수를 사용해야 한다. 변수의 스코프는 좁을수록 좋다. 1. 즉시 실행 함수​ 즉시 실행 함수는 함수 정의와 호출을 동시에 진행하다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이러한 특성은 전역 변수의 사용을 제한하는 한 방법이다. 이는, 라이브러리 등에서 자주 사용된다. 123456(function () &#123; var foo = 10; // 즉시 실행 함수의 지역 변수 // ...&#125;());console.log(foo); // ReferenceError: foo is not defined 2. 네임 스페이스 객체​ 네임 스페이스 객체는 말 그대로 Namespace 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다. 12345678var MYAPP = &#123;&#125;; // 전역 네임 스페이스 객체MYAPP.person = &#123; name: 'Lee', address: 'Seoul'&#125;;console.log(MYAPP.person.name); // Lee 네임 스페이스 안에 객체를 만들어서 계층적으로도 활용이 가능하다. 네임 스페이스를 분리하여 식별자 충돌을 방지하는 효과는 있으나 네임 스페이스 객체 자체가 전역 변수에 할당이 되므로 유용하지는 않다. 3. 모듈 패턴​ 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 형성한다. 모듈 패턴은 JS의 강력한 기능인 클로저를 기반으로 동작한다. 이는 전역 변수의 억제와 캡슐화까지 구현을 할 수 있다. 캡슐화란 ? 외부에 공개될 필요가 없는 정부를 외부에 노출하지 않고 숨기는 것(정보 은닉 - information hiding) 모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 캡슐화를 구현하기 위해 사용한다. 1234567891011121314151617181920212223// 변수에 즉시 실행 함수 할당var Counter = (function () &#123; // private 변수 var num = 0; // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다. return &#123; increase() &#123; return ++num; &#125;, decrease() &#123; return --num; &#125; &#125;;&#125;());// private 변수는 외부로 노출되지 않는다.console.log(Counter.num); // undefinedconsole.log(Counter.increase()); // 1console.log(Counter.increase()); // 2console.log(Counter.decrease()); // 1console.log(Counter.decrease()); // 0 4. ES6 모듈​ 전역 변수의 남발을 억제하기 위해서 ES6에서 도입된 모듈을 사용할 수 있다. 현재 아직까지 모든 브라우저가 ES6를 전부 지원하고 있지 않기 때문에, SystemJS, RequireJS,Webpack등의 모듈 번들러를 이용한다. 14강let, const 와 블록 레벨 스코프 var 키워드로 선언한 변수의 문제점1. 변수 중복 선언 허용12345var x = 1;// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.var x = 100;console.log(x); // 100 변수 x가 중복 선언 되었다. 같은 스코프 내에서 변수를 중복 선언하면 나중에 작성된 변수 선언문은 JS엔진에 의해 var 키워드가 없는 것처럼 동작한다. 또한 에러는 발생시키지 않는다. 2. 함수 레벨 스코프​ var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 따라서 함수 외부에서 선언한 변수는 모두 전역 변수이다. 12345678910111213141516var x = 1;if (true) &#123; // var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다. // 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다. // 따라서 x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다. // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다. var x = 10; console.log(x); // 10&#125;for (var x = 0; x &lt; 5; x++) &#123; console.log(x); // 0 1 2 3 4&#125;console.log(x); // 5 위 예제처럼, 결국 최종 출력은 ‘5’ 가 된다. x가 연속적으로 재할당이 이루어졌기 때문이다. 3. 변수 호이스팅1234567891011// 이 시점에는 변수 호이스팅에 의해 이미 변수 foo가 선언되었다. (1. 선언 단계)// 변수 foo는 undefined로 초기화된다. (2. 초기화 단계)console.log(foo); // undefined// 변수에 값을 할당 (3. 할당 단계)foo = 123;console.log(foo); // 123// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.var foo; 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의하여 에러를 유발하지 않는다. 다만, 이러한 방법은 프로그램의 흐름 상 가독성을 떨어뜨리고 예상치 못한 에러를 발생시킬 여지를 준다. let 키워드 var 키워드의 이러한 문제들로 하여, ES6에서 let과 const를 도입하였다. 변수 중복 선언 금지​ var 키워드와는 다르게 let 키워드는 변수를 중복 선언시 문법 에러를 발생시킨다. 12345678var foo = 123;// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.var foo = 456;let bar = 123;// let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.let bar = 456; // SyntaxError: Identifier 'bar' has already been declared 블록 레벨 스코프 var 키워드 : 함수의 코드 블록( { } )만을 지역 스코프로 인정한다. 함수 레벨 스코프 let 키워드 : 모든 코드 블록 ( 함수, if, for, while, try/catch 등등) 을 지역 스코프로 인정하다. 블록 레벨 스코프 123456789et foo = 123; // 전역 변수&#123; let foo = 456; // 지역 변수 let bar = 456; // 지역 변수&#125;console.log(foo); // 123console.log(bar); // ReferenceError: bar is not defined 참조 불가 변수 호이스팅12console.log(foo); // ReferenceError: foo is not definedlet foo; var 키워드는 변수 선언시 암묵적으로 선언 - 초기화 + 할당(undefined)가 모두 이루어진다. let 키워드는 변수 선언시 암묵적은 선언 단계만 진행되며 초기화 단계는 변수 선언문에 도달 했을 때 실행된다. 따라서 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지는 변수를 참조할 수 없다. 스코프 시작 지점부터 let 키워드의 초기화 시작 지점 전까지의 구간을 일시적 사각지대(TDZ) 라고 부른다. 123456789// 런타임 이전에 선언 단계가 실행된다.// 아직 변수가 초기화되지 않았다. 따라서 변수 선언문 이전에 변수를 참조할 수 없다.console.log(foo); // ReferenceError: foo is not definedlet foo; // 변수 선언문에서 초기화 단계가 실행된다.console.log(foo); // undefinedfoo = 1; // 할당문에서 할당 단계가 실행된다.console.log(foo); // 1 그렇다면 let 키워드로 생성된 변수는 호이스팅이 되지 않는걸까? 정답은 : 아니다. 이유는 다음 예제를 보자 12345678910111213let boo = 1;&#123; console.log(boo); // 1&#125;//위 / 아래 비교let foo = 1;&#123; console.log(foo); // Reference Error : foo is not defined let foo = 2;&#125; 위 boo는 전역변수로 선언을 하였기에 그룹 연산자{ }에서 console 을 찍어도 1이 출력된다. 그런데, foo는 전역변수로 선언했음에도 그룹 연산자{ }에서 console 을 찍었을 때 Reference Error를 유발했다. 이유는 그룹 연산자{ } 내부에 있는 foo가 호이스팅되었기 때문이다. 전역 객체와 let var 키워드 로 생성된 전역 변수는 window(최상위 객체)에 암묵적으로 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. let 키워드로 생성된 전역 변수는 window의 프로퍼티가 아니다.따라서, window.x와 같이 접근할 수 없다.let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다. const 키워드 상수 : 변하지 앟는 고정된 값 const 키워드는 상수를 선언하기 위해 사용된다. 하지만, 반드시 상수만을 위해 사용되는 것은 아니며, let 키워드와 대부분 동일한 특징을 지니고 있다. ​ let 키워드와 비슷한 점이 많이 있기 때문에, 다른점을 언급한다. 선언과 초기화​ let 키워드로 선언된 변수는 재할당이 자유롭다. (재선언은 X) const 키워드로 선언된 변수는 재할당이 금지 다. 1234567// 0.1은 변해서는 않되는 상수로서 사용될 값이다.// 변수 이름을 대문자로 선언하여 상수를 저장하고 있음을 명확히 나타낸다.const TAX_RATE = 0.1;// const 키워드로 선언한 변수는 재할당이 금지된다.// 상수는 재할당이 금지된 변수이다.TAX_RATE = 0.2; // TypeError: Assignment to constant variable. ​ 또한, const 키워드로 선언한 변수는 선언과 동시에 할당이 이루어져야 한다. ( 에러를 유발한다. ) 123// const 선언만 할 경우, 에러유발const FOO;// SyntaxError: Missing initializer in const declaration const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 갖는다. 상수​ 상수는 가독성, 유지보수의 편의를 위하여 적극적으로 사용해야 한다. 상수로 이루어진 변수의 이름은 대문자로 선언하여 상수임을 확실하게 드러낸다. 또한 여러단어가 겹칠 경우, _(언더 스코어) 로 단어의 네이밍을 구분짓는다. 12345678910// 세율const TAX_RATE = 0.1// 세전 가격let preTaxPrice = 100;// 세후 가격let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);console.log(afterTaxPrice); // 110 세율은 쉽게 바뀌지 않는 값이며 프로그램 전체에서 고정된 값을 사용해야 한다. 상수로 세율을 정의하면 값의 의미를 쉽게 파악할 수 있다. 또한 상수는 프로그램 전체에서 공통 사용하므로 나중에 세율이 변경되면 상수만을 변경하면 되기 때문에 유지보수성이 대폭 향상된다. const 키워드와 객체const 키워드로 선언된 변수는 재할당이 금지된다. 더 정확히 말하면, 원시 값을 할당한 경우이다. 원시 값은 변경 불가능한 값이기에 상수에 할당된다면 재할당이 금지되므로 변경할 방법이 없다. 반면에, 객체를 할당한 경우 역시 재할당은 금지되어 있다. 하지만 객체는 변경 가능한 값이므로 객체 자체를 변경하는 것은 가능하다. 12345678const person = &#123; name: 'Lee'&#125;;// 객체는 변경 가능한 값이다.person.name = 'Kim';console.log(person); // &#123;name: \"Kim\"&#125; const 키워드는 재할당을 금지할 뿐 “불변(immutable)”을 의미하지는 않는다. 다시 말해, 새로운 객체를 재할당하는 것은 불가능하지만 객체의 내용(프로퍼티의 추가, 삭제, 프로퍼티 값의 변경)을 변경하는 것은 가능하다. ( 배열을 추가하거나 삭제하거나 변경하는 것도 포함된다. ) 객체의 내용이 변경되더라도 변수에 할당된 주소값은 변경되지 않는다. var vs. let vs. const 변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 원시 값의 경우, 가급적 상수를 사용하는 편이 좋다.그리고 객체를 재할당하는 경우는 생각보다 흔하지 않다.const 키워드를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전하다. var와 let, 그리고 const 키워드는 다음처럼 사용하는 것을 추천한다. ES6를 사용한다면 var 키워드는 사용하지 않는다. 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다. 변경이 발생하지 않는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 보다 안전하다. 변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당을 하는 경우가 드물다.따라서 변수를 선언할 때에는 일단 const 키워드를 사용하도록 하자. 반드시 재할당이 필요하다면(반드시 재할당이 필요한지 한번 생각해 볼 일이다.)그때 const를 let 키워드로 변경해도 결코 늦지 않는다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_algorithm12","slug":"daily-algorithm12","date":"2019-10-12T10:40:30.000Z","updated":"2019-11-30T16:49:51.132Z","comments":true,"path":"2019/10/12/daily-algorithm12/","link":"","permalink":"https://hyeok999.github.io/2019/10/12/daily-algorithm12/","excerpt":"","text":"문제 출처 : poiema 알고리즘 연습 문제 1. 짝수와 홀수evenOrOdd 함수는 정수 num을 매개변수로 받는다. num은 1이상의 정수이며, num이 음수인 경우는 없다. num이 짝수일 경우 ‘Even’을 반환하고 홀수인 경우 ‘Odd’를 반환하도록 evenOrOdd 함수를 완성하라. 단, if문을 사용한 답과 삼항 조건 연산자를 사용한 답 두가지를 제시하여야 한다. 1234567891011121314151617181920// if문function evenOrOdd(num) &#123; if(num % 2 == 0) &#123; return \"Even\"; &#125; return \"Odd\";&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even// 3항 연산자function evenOrOdd(num) &#123; return num % 2 == 0 ? 'Even' : 'Odd';&#125;console.log(evenOrOdd(2)); // Evenconsole.log(evenOrOdd(3)); // Oddconsole.log(evenOrOdd(1000)); // Even 2. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라. 단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다. (hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n] 12345678910111213141516function getCount8 () &#123; let count8 = 0; let countNum; for(let i = 1; i &lt; 10001; i++) &#123; countNum = String(i); for(let j = 0; j &lt; countNum.length; j++ )&#123; if(countNum[j] == '8')&#123; count8++; &#125; &#125; &#125; return count8;&#125;console.log(getCount8()); 3. 문자열 다루기alphaString46 함수는 문자열 s를 매개변수로 입력받는다. s의 길이가 4 ~ 6이고, 숫자로만 구성되어 있는지 확인하는 alphaString46 함수를 완성하라. 예를 들어 s가 ‘a234’이면 false를 리턴하고 ‘1234’라면 true를 리턴한다. 123456789101112131415161718function alphaString46(s) &#123; if (s == undefined) &#123; return false; &#125; if (s.length &gt; 3 &amp;&amp; s.length &lt; 7) &#123; if (NaN || +s) &#123; return true; &#125; return false; &#125; return false;&#125;console.log(alphaString46('1234')); // trueconsole.log(alphaString46('9014')); // trueconsole.log(alphaString46('723')); // falseconsole.log(alphaString46('a234')); // falseconsole.log(alphaString46('')); // falseconsole.log(alphaString46()); // false 4. 문자열 내 p와 y의 개수numPY함수는 대문자와 소문자가 섞여있는 문자열 s를 인수로 전달받는다. s에 존재하는 ‘p’의 개수와 ‘y’의 갯수를 비교해 같으면 true, 다르면 false를 리턴하도록 함수를 완성하라. 대소문자를 구별하지 않으며 ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 true를 리턴한다. 예를 들어 s가 ‘pPoooyY’면 true를 리턴하고 ‘Pyy’라면 false를 리턴한다. 123456789101112131415161718192021function numPY(s) &#123; let countP = 0; let countY = 0; if (s == undefined) return true; for (let i = 0; i &lt; s.length; i++) &#123; if ( s[i] == 'p' || s[i] == 'P') &#123; countP++; &#125; if ( s[i] == 'y' || s[i] == 'Y') &#123; countY++; &#125; &#125; return Boolean(countP == countY);&#125;console.log(numPY('pPoooyY')); // trueconsole.log(numPY('Pyy')); // falseconsole.log(numPY('ab')); // trueconsole.log(numPY('')); // trueconsole.log(numPY()); // true 5. 이상한 문자 만들기toWeirdCase함수는 문자열을 인수로 전달받는다. 문자열 s에 각 단어의 짝수번째 인덱스 문자는 대문자로, 홀수번째 인덱스 문자는 소문자로 바꾼 문자열을 리턴하도록 함수를 완성하라. 예를 들어 s가 ‘hello world’라면 첫번째 단어는 ‘HeLlO’, 두번째 단어는 ‘WoRlD’로 바꿔 ‘HeLlO WoRlD’를 리턴한다. 주의) 문자열 전체의 짝/홀수 인덱스가 아니라 단어(공백을 기준)별로 짝/홀수 인덱스를 판단한다. 1234567891011121314151617181920212223242526272829function toWeirdCase(s) &#123; const strArray = s.split(' '); let fullStr = ''; function UpCase(str) &#123; return str.toUpperCase(); &#125; function LowCase(str) &#123; return str.toLowerCase(); &#125; for (let i = 0; i &lt; strArray.length; i++) &#123; for (let j = 0; j &lt; strArray[i].length; j++) &#123; if (j % 2 == 0) &#123; fullStr += UpCase(strArray[i][j]); &#125; else &#123; fullStr += LowCase(strArray[i][j]); &#125; &#125; fullStr += ' '; &#125; return fullStr;&#125;console.log(toWeirdCase('hello world')); // 'HeLlO WoRlD'console.log(toWeirdCase('my name is lee')); // 'My NaMe Is LeE'","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"javascript-study-07","slug":"javascript-study-07","date":"2019-10-11T04:15:31.000Z","updated":"2019-11-30T16:29:40.291Z","comments":true,"path":"2019/10/11/javascript-study-07/","link":"","permalink":"https://hyeok999.github.io/2019/10/11/javascript-study-07/","excerpt":"","text":"JavaScript Study 07 용어 함수 함수란? 함수정의 및 호출 함수 사용 이유 함수 리터럴 함수 객체 vs 객체 함수 리터럴의 구성요소 함수 리터럴과 함수 선언문의 차이 함수 만드는 4가지 방법 Function 생성자 함수 화살표 함수 함수 선언식 함수 선언문 객체 생성의 Flow 함수 표현식 함수 호이스팅 함수 호출 매개 변수와 인수 인수확인 외부 상태의 변경과 함수형 프로그래밍 반환문 return의 생략 다양한 함수의 형태 즉시 실행 함수 ( IIFE ) 재귀함수 중첩함수 * 콜백함수 ** 용어 - ( 러버덕 ) 함수 파트 전부 함수함수란? 함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것. 프로그래밍 언어의 함수는 입력을 받아서 출력을 내보낸다. 이때 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다. 또한 함수는 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다. 파라미터(Parameter) = 매개변수 , 멤버변수, 인자 아구멘트(Argument) = 인수 함수의 정의 및 호출​ 함수는 정의 를 통해 생성한다. ( 함수선언문의 경우, 호이스팅 되어 런타임 이전에 이미 정의가 완료된다. ) 1234// 함수 정의 (함수 선언문)function add(x, y) &#123; return x + y;&#125; ​ 함수는 정의만 해서는 해당 코드가 실행되지는 않는다. 호출을 해야 비로서 실행되고 결과를 반환한다. 12345// 함수 호출var result = add(2, 5);// 함수 add에 인수 2, 5를 전달하면서 호출하면 7을 반환한다.console.log(result); // 7 ​ 함수 내부에서 선언된 변수들은 함수가 호출되면 실행된다. 123456function add(x) &#123; var y = 20; return x + y;&#125;console.log( add(10) ); // 함수를 호출하면서 변수 y의 선언-초기화-할당이 진행된다. argument(인수) 와 parameter(매개 변수)는 일치하는게 이상적인 함수 코딩이다. 1234function add(x, y) &#123; return x + y;&#125;add(2, 5); // 7 함수 호출문은 값으로 평가되는 표현식 이다. 12345function add(x, y) &#123; return x + y;&#125;var result = add(2, 5); console.log(result) // 7 함수 사용 이유 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 함수 리터럴함수 객체 VS 객체 일반 객체는 호출할 수 없지만, 함수 객체는 호출할 수 있다. 함수 리터럴의 구성요소​ : function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성 함수 이름 네이밍 규칙을 준수한 식별자 함수 몸체 내에서만 참조할 수 있는 식별자 함수 이름은 생략 가능 기명 함수(named function): 이름이 있는 함수 익명 함수(anonymous function): 이름이 없는 함수 매개변수 목록 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분 매개변수에 인수 할당 매개변수는 함수 몸체 내에서 변수와 동일하게 취급되기 때문에 식별자 네이밍 규칙 준수 함수 몸체 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록 함수 호출에 의해 실행됨 함수 리터럴과 함수 선언문의 차이 그룹 연산자 ( )안에 들어오는 것은 피연산자이다. 피연산자로 들어오는 것은 리터럴 , 값이어야만 한다. 결국, ( function foo( ) { } )는 리터럴 및 값이 되는것이다. 함수 리터럴은 이름을 가질수도 있고, 안가질수도 있다.함수 리터럴의 식별자는 자신의 몸체 내부에서만 유효 하다. 그룹 연산자 ( ) 내에 있는 것은 함수 선언문이 아니다.다시 말해, 자바스크립트 엔진은 그룹 연산자 () 내에 있는 문을 함수 선언문이 아닌 함수 리터럴로 해석한다.그룹 연산자의 피연산자는 값으로 평가할 수 있는 표현식이다.따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다. 123var foo = function bar () &#123; &#125;; // foo에 값으로써 들어간 함수 -&gt; 함수 표현식 함수 만드는 방법 4가지Function 생성자 함수 생성자 함수란 ? 객체를 생성하는 함수 따라서 Function 생성자 함수 는 함수라는 객체를 생성하는 함수다. 생성된 함수는 클로저를 생성하지 않음 함수 선언문이나 함수 표현식으로 생성한 함수와 생성자 함수는 동일하게 동작X 1234// 첫번째 인수, 두번째 인수, 마지막 인수는 반환값var add = new Function('x', 'y', 'return x + y');console.log(add(2, 5)); // 7 화살표 함수 function 키워드 대신 화살표를 사용하여 간단하게 함수 선언 (익명 함수). ES6에 도입. 화살표 함수는 대부분을고차함수 콜백 함수에 이용한다. 기존의 함수와 this 바인딩 방식이 다름 prototype 프로퍼티 없음 arguments 객체를 생성하지 않음 1234// 화살표 함수const add = (x, y) =&gt; x + y;console.log(add(2, 5)); // 7 함수 선언문 함수 선언문은 함수 리터럴과 표기법과 형태가 동일하지만 함수 명을 생략할 수 없다.함수 선언문은 표현식이 아닌 문이기에 변수에 할당이 불가능하다.표현식이 아닌 문은 평가 시 undefined를 반환한다. 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수 명인 것이다.아래 예제를 예를들어보면 함수 명 add로 호출한 것이 아닌 함수선언문이 호이스팅 되면 생성된 암묵적 변수 add를 호출한 것이다. 123456789101112// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 참조// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.console.dir(add); // ƒ add(x, y)// 함수 호출console.log(add(2, 5)); // 7 함수 선언문 객체 생성의 Flow 함수 객체 생성 함수 이름으로 변수(식별자)를 암묵적으로 실행 Binding 함수표현식 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당 가능 (함수 이름 생략 가능) = 함수 리터럴: 함수를 정의하는 표현식인 문 일급객체(first-class object): 값처럼 변수에 할당 가능, 프로퍼티 값이나 배열여 요소가 될 수 있다. 즉, 함수를 값처럼 사용 가능 123456// 함수 표현식var add = function(x, y) &#123; return x + y;&#125;;console.log(add(2, 5)); 함수 호이스팅1234567891011121314151617// 함수 참조console.dir(add); // ƒ add(x, y)console.dir(sub); // undefined// 함수 호출console.log(add(2, 5)); // 7console.log(sub(2, 5)); // TypeError: sub is not a function// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 표현식var sub = function (x, y) &#123; return x - y;&#125;; 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 가능. ( 어디서든 호출 가능 ) ( 자바스크립트 엔진에 의해 먼저 실행 (호이스팅 됨) ) 함수 표현식으로 정의한 함수는 변수에 할당 이전에 호출 불가능 ( 변수가 호이스팅 ) 런타임 이전에 실행되는 것은 변수이며 변수는 undefined로 초기화 변수 할당문의 값인 함수는 실행되는 시점인 런타임에 평가되어 변수에 할당된다. 함수 호출 함수를 참조하는 변수와 한 쌍의 소괄호인 함수 호출 연산자로 호출. 12345function add(x, y) &#123; return x + y;&#125;add(1, 2); // &lt;- 함수 호출 함수 호출 시 현재의 실행 흐름은 중단하고 호출된 함수로 컨트롤 넘김 이 때, 매개 변수에 인수가 할당되고 함수 몸체의 문들이 실행되기 시작 매개변수(parameter)와 인수(argument)매개변수는 함수를 정의할 때 선언하고 함수 몸체 내부에서 변수와 동일하게 취급됨.(즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 변수와 마찬가지로 undefined로 초기화된 이후 인수로 할당됨) 인수는 함수를 호출할 때 매개변수에게 전달하는 값을 의미한다. 함수의 매개변수는 가능한 적은게 좋다. (최대 3개까지 맞추는게 좋음)만약, 함수 매개변수가 4개이상이면 객체로 넘기는것이 좋다. 123456$.ajax(&#123; method: 'POST', url: '/user', data: &#123; id: 1, name: 'Lee' &#125;, cache: false&#125;); 위는 jQuery의 ajax 메소드이다. 해당 함수의 인수는 1개다. (객체)그리고 객체의 프로퍼티는 총 4개다. ( 또한, 객체의 프로퍼티는 순서가 필요없고 이름에만 의미가 있다. ) 또한 위 코드에서 함수 내부에 객체를 선언한 이유는 다른 식별자들이 참조할 수 없게 만들기 때문이다.해당 함수만 저 객체를 독점 사용하기 위해서이다. ( 보안적이유 )만약 다른 식별자들이 저 객체를 참조한다고 함수를 실행했을 때 변해버린 값이 반환될수도 있기 때문이다. 인수 미달 및 초과될 경우 12345678910111213// 인수 미달, 매개변수가 더 많은 경우function add(x, y) &#123; return x + y;&#125;console.log(add(2)); // NaN// 인수 초과, 매개변수가 더 적은 경우function add(x, y) &#123; return x + y;&#125;console.log(add(2, 5, 10)); // 7 인수 미달 : 할당받지 못한 매개변수는 선언만 된 것이므로 undefined상태가 된다. 따라서 위 예제는 2 + undefined = NaN이 출력. 인수 초과 : 초과된 인수는 무시됨 - 초과된 인수는 암묵적으로 arguments 객체의 프로퍼티에 보관된다. 인수 확인 코드상으로는 어떤 타입의 인수를 전달하여야 하는지, 어떤 타입의 값을 반환해야 하는지 명확하여야 한다. 자바스크립트는 타입이 값에 의해 정해지기 때문에 매우 느슨하다. 이러한 느슨함을 막기 위해서는 방어코드를 작서해야한다. 1234567// 조건1 : 매개변수로 숫자만을 받아야한다.// 조건2 : 매개변수는 무조건 2개 다 받아야한다.function add(x, y) &#123; return x + y;&#125;console.log(add(2)); // NaN console.log(add('a', 'b')); // 'ab' ​ 위 코드에서 원하지 않는 결과가 게속 나온다. 이유는 자바스크립트는 동적타이핑을 지원하는데 이에 대한 방어코드를 전혀 구성해놓은게 없기 때문이다. 따라서 Typescript 를 사용하게 되면 값이 아닌 변수의 키워드를 이용해 타입을 지정할 수 있다. 다른 방법으로는, 조건식을 이용하여 방어코드를 직접 구축하는 방법이다. 1234567891011// if로 구현한 방어코드function add(x, y) &#123; if (typeof x !== 'number' || typeof y !== 'number') &#123; throw new TypeError('매개변수에 숫자 타입이 아닌 값이 할당되었습니다.'); &#125; //방어코드 return x + y;&#125;console.log(add(2)); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.console.log(add('a', 'b')); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다. 외부 상태의 변경과 함수형 프로그래밍함수의 매개변수에 값을 전달하는 방식을 값에 의한 호출(Call by value), 참조에 의한 호출(Call by reference)로 구별하는 부르는 경우도 있으나 동작 방식은 값에 의한 전달, 참조에 의한 전달과 동일하다. 아래 예제를 살펴보자. 1234567891011121314151617181920function changeVal(primitive, obj) &#123; primitive += 100; obj.name = 'Kim';&#125;// 외부 상태var num = 100;var person = &#123; name: 'Lee' &#125;;console.log(num); // 100console.log(person); // &#123;name: \"Lee\"&#125;// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.changeVal(num, person);// 원시 값은 원본이 훼손되지 않는다.console.log(num); // 100// 객체는 원본이 훼손된다.console.log(person); // &#123;name: \"Kim\"&#125; 위와 같은 방식의 코딩은 객체의 추척을 어렵게 만든다. (즉, 값이 바뀌었는지 않바뀌었는지;;;) 이와 같은 함수를 비순수함수 라 칭한다. 순수 함수 : 함수 내부(지역 스코프)만 영향을 준다.비순수 함수 : 함수 외부까지도 영향을 준다.JS는 상태를 변환하는게 에러의 원인이라고 판단한다. 따라서 비순수함수를 최대한 억제 및 줄이고 순수함수를 사용하도록 노력해야만 한다. 순수함수 vs 비순수함수 반환문​ 함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 반환 할 수 있다. 함수는 실행시 return을 만나면 함수 실행을 중단하고 몸체를 빠져나간다.(즉, 중단한다.) return의 생략 return 키워드는 생략이 가능하다. 다만, 생략시 return undefined를 결과로 반환한다. return 값도 생략이 가능하다. 역시 생략시 return undefined를 결과로 반환한다. 다양한 함수의 형태즉시 실행 함수 ( IIFE ) 단 한번만 호출되며 다시는 호출 할 수 없다. 즉시 실행 함수는 익명 즉시 실행 함수를 사용하는 것이 일반적이다. 클로저를 쓸 때 사용된다. 의외로 많이 사용된다. 123456// 익명 즉시 실행 함수(function () &#123; var a = 3; var b = 5; return a * b;&#125;()); 재귀함수 자기 자신을 호출하는 함수 재귀 함수는 무한 호출되며 stack overflow에러를 유발할 위험이 다분하다. 따라서 최대한 적게 이용하고 대부분은 재귀함수는 while, for( + if )등으로 대체가 가능하다. 1234567891011121314// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.// n! = 1 * 2 * ... * (n-1) * nfunction factorial(n) &#123; // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다. if (n &lt;= 1) return 1; return factorial(n - 1) * n;&#125;console.log(factorial(0)); // 0! = 1console.log(factorial(1)); // 1! = 1console.log(factorial(2)); // 2! = 1 * 2 = 2console.log(factorial(3)); // 3! = 1 * 2 * 3 = 6console.log(factorial(4)); // 4! = 1 * 2 * 3 * 4 = 24console.log(factorial(5)); // 5! = 1 * 2 * 3 * 4 * 5 = 120 중첩함수 * 함수 내부에 함수가 있을 수 있다. 이를 중첩 함수(nested function) 또는 내부 함수(Inner function)라 한다. 12345678910111213141516171819function outer() &#123; //1. outer의 네이밍 값을 변수 선언문에 변수로 저장하여 호이스팅됨 (함수가 다 저장됨) var x = 1; //3. x = undefined값으로 초기화됨 //5. x에 1을 할당 function inner() &#123; // 3-1. 호이스팅되서 런타임전에 메모리 값이 잡힘 7. inner 함수 들어감 var y = 2; //8. y값 undefined 할당 -&gt; 9. 런타임 실행 -&gt; 10. y에 2할당 console.log(x + y); //11. x+y값 평가 후 출력 //12 return문이 없으면 undefined가 할당되서 함수를 빠져나옴 &#125; //4. undefined로 잡힘 -&gt; 런타임실행 inner(); //6. inner 함수 실행 console.log(x + y); //13. 실행 //변수는 하위변수을 참조할 수 없어서 y값에 할당될 값이 없어서 1 + y 가 되지만 y값이 선언조차 안되서 referenceerror가뜸 // return undefined 생략되있음 &#125;outer();//2. 실행 콜백함수 ** 중요 콜백함수는 고차함수에 인수(Argument) 로써 사용되는 함수를 뜻한다. 고차함수는 매개변수를 함수로 받는 함수를 말한다. 1234567891011121314151617// outer는 고차함수다. - 이유는 매개변수를 함수로 받고 있다.function outer(fn) &#123; var x = 1; var y = 2; return fn(x, y);// 3&#125; // 일반함수function inner(x, y) &#123; var dd = x + y; return dd;&#125;console.log( // outer라는 고차함수에 inner을 넣음으로 inner는 콜백함수가 되었다. outer(inner)); 기본적으로 콜백함수는 고차함수를 사용할 때 사용하며, 가능한 이 함수들은 루프를 도는 형식이기에 사용을 하지 않도록 최대한 노력을 해야한다. 고차함수들로는 map,filter,reduce,find 등등이 있다. map, filter의 예 1234567891011121314// 콜백 함수를 사용하는 고차 함수 mapvar res = [1, 2, 3].map(function (item) &#123; return item * 2;&#125;); //내부에서는 for문이 돈다//배열[1,2,3]객체가 가지고 있는 메서드(map)console.log(res); // [ 2, 4, 6 ]// 콜백 함수를 사용하는 고차 함수 filterres = [1, 2, 3].filter(function (item) &#123; return item % 2;&#125;);console.log(res); // [ 1, 3 ]","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_algorithm11","slug":"daily-algorithm11","date":"2019-10-11T01:59:53.000Z","updated":"2019-11-30T16:49:59.078Z","comments":true,"path":"2019/10/11/daily-algorithm11/","link":"","permalink":"https://hyeok999.github.io/2019/10/11/daily-algorithm11/","excerpt":"","text":"문제 출처 : 프로그래머스 가운데 글자 가져오기문제 설명단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다. 재한사항 s는 길이가 1 이상, 100이하인 스트링입니다. 입출력 예 s return abcde c qwer 1234567891011function solution(s) &#123; var answer = ''; if(s.length%2 == 1) &#123; answer = s.slice(s.length/2, s.length/2+1); &#125; else&#123; answer = s.slice(s.length/2-1, s.length/2+1); &#125; console.log(answer); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript 12강 스코프","slug":"javascript-preview-12","date":"2019-10-10T16:58:26.000Z","updated":"2019-11-30T16:42:51.969Z","comments":true,"path":"2019/10/11/javascript-preview-12/","link":"","permalink":"https://hyeok999.github.io/2019/10/11/javascript-preview-12/","excerpt":"","text":"JavaScript 12강 예습 12강 : 스코프 스코프란? 비순수 함수 스코프 위치에 따른 값 코드의 문맥과 환경 var 키워드로 선언한 변수의 중복 선언 let, const 스코프의 종류 전역과 전역 스코프 지역과 지역 스코프 스코프 체인 스코프 체인에 의한 변수 검색 스코프 체인에 의한 함수 검색 함수 레벨 스코프 렉시컬 스코프 암묵적 전역 변수 12강스코프 스코프란? 유효범위를 뜻하는 스코프는 JS를 포함한 모든 프로그래밍 언어즤 기본적이면 중요한 개념이다. *모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. * *이를 스코프(Scope, 유효범위)라 한다. * 즉, 스코프는 식별자가 유효한 범위를 말한다. 12345678var num = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.function increase() &#123; return ++num; // 외부 상태를 변경한다.&#125;console.log(increase()); // 1console.log(increase()); // 2 num은 전역 변수이기 때문에 increase 함수를 통해 값이 늘어난다. 비순수 함수​ increase 함수처럼 함수 내부의 상태(함수 내부에서 선언한 변수 또는 원시 타입의 매개 변수)만이 아니라 함수 외부 상태(num)까지 변경하는 함수를 비순수 함수(impure function)라고 한다. 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수(pure function)를 사용하는 것이 좋다. 스코프 위치에 따른 값12345678910var x = 'global';function foo() &#123; var x = 'local'; console.log(x); // ① local&#125;foo();console.log(x); // ② global 위 예제에서 JS엔진은 스코프를 통해 어떤 변수를 참조하고 출력해야할지 결정한다. 여기서 스코프란, JS엔진이 식별자를 검색할 때 사용하는 규칙이라고 할 수 있다. 코드의 문맥과 환경 “코드가 어디서 실행되며 주변에 어떤 코드들이 있는지”를 환경(Environment)이라고 부른다. 즉, 코드의 문맥(Context)은 환경으로 이루어진다. 이를 구현한 것이 “실행 컨텍스트(Execution context)”이며 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 스코프는 실행 컨텍스트와 깊은 관련이 있다. 만약 스코프란 개념이 없다면 같은 네이밍을 가진 변수들끼리 충동을 일으키기 때문에 모든 변수는 고유한 네이밍을 가져야 할것이다. 만약 그럴경우, 소스가 길어지게 될 경우 변수 네이밍을 전부다 기억해야되는 불상사가 생길수도 있다. 따라서, 스코프를 이용하여 이러한 충돌을 방지하고 같은 네이밍을 쓸 수 있다. var 키워드로 선언한 변수의 중복 선언 var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다. 12345678function foo() &#123; var x = 1; // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다. // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. var x = 2; console.log(x); // 2&#125;foo(); let , const 하지만 let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다. 123456function bar() &#123; let x = 1; // let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다. let x = 2; // SyntaxError: Identifier 'x' has already been declared&#125;bar(); 스코프의 종류스코프는 전역(global)과 지역(local)으로 나뉜다. 구분 설명 스코프 변수 전역 코드의 가장 바깥 영역 전역 스코프 전역 변수 지역 함수 몸체 내부 지역 스코프 지역 변수 전역과 전역 스코프 전역 : 코드의 가장 바깥 영역을 의미. 전역은 전역 스코프를 만든다. 전역 변수는 어디서든지 참조할 수 있다. 지역과 지역 스코프 지역 : 함수 몸체 내부를 의미. 지역은 지역 스코프를 만든다. 지역 변수는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조가 가능하다. 스코프 체인​ 함수 몸체 내부에서 정의한 함수를 ‘중첩 함수(nested function)’, 중첩 함수를 포함하는 함수를 ‘외부 함수(outer function)’라고 부른다. ​ 여기서 생기는 함수들의 중첩은 곧 함수의 지역 스코프도 중첩이 될 수 있다는 것을 의미하며,스코프는 곧 함수의 중첩에 의해 계층적 구조를 지닌다는 것을 알 수 있다. 또한 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이러한 스코프들간의 계층적인 연결을 스코프 체인이라 부른다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 스코프 체인에 의한 변수 검색 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다. 스코프 체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이루어진 상속(Inheritance)과 유사하다. 상속을 통해 부모의 자산을 자식이 자유롭게 사용할 수 있지만 자식의 자산을 부모가 사용할 수는 없다. 스코프 체인도 마찬가지 개념이다. 스코프 체인에 의한 함수 검색123456789101112131415// 전역 함수function foo() &#123; console.log('global function foo');&#125;function bar() &#123; // 중첩 함수 function foo() &#123; console.log('local function foo'); &#125; foo(); // ①&#125;bar(); 자바스크립트 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 따라서 위 예제의 모든 함수는 자바스크립트 엔진에 의해 암묵적으로 선언된 함수 이름과 동일한 이름의 변수에 할당된다. 이처럼 함수도 변수에 할당되기 때문에 스코프를 갖는다. 사실 함수는 변수에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바가 없다. 따라서 스코프를 “변수를 검색할 때 사용하는 규칙”이라고 표현하기 보다는 “식별자를 검색하는 규칙”이라고 표현하는 것이 보다 적합하다. 함수 레벨 스코프 var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프(Function level scope)라 한다. let , const 키워드는 블록 레벨 스코프(함수 몸체 만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든 것)를 지원한다. 123456789var i = 10;// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.for (var i = 0; i &lt; 5; i++) &#123; console.log(i); // 0 1 2 3 4&#125;// 의도치 않게 변수의 값이 변경되었다.console.log(i); // 5 렉시컬 스코프12345678910111213var x = 1;function foo() &#123; var x = 10; bar();&#125;function bar() &#123; console.log(x);&#125;foo(); // ?bar(); // ? 상위 스코프를 결정 짓는 방식은 2가지가 있다. 동적 스코프 : 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다. 렉시컬(정적) 스코프 : 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. JS는 렉시컬 스코프를 따른다. 위 예제에서 bar( ) 함수의 정의는 전역이다. 따라서 bar( )의 상위 스코프는 전역으로 결정이된다. 전역 변수 x의 값이 1이므로 foo( ) 와 bar( ) 모두 정답은 1이다. 렉시컬 스코프는 클로저 와 관계 깊다. (추후 학습) 암묵적 전역 변수12345678function foo() &#123; // 선언하지 않은 변수에 값을 할당하면 암묵적 전역 변수가 된다. x = 10;&#125;foo();console.log(x); // 10 선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역 변수를 선언하고 값을 할당한다. 위는 소스에서 JS엔진은 다음과 같이 동작한다. 함수 foo의 스코프에서 변수 x에 관한 선언을 찾는다. 못찾을 경우, 상위 스코프(전역) 으로 이동해 변수 x에 관한 선언을 찾는다. 역시 못찾을 경우, 참조 에러를 발생 시켜야 겠지만, JS엔진은 암묵적으로 변수 x를 선언한다. 이러한 변수를 암묵적 전역 변수라 한다. 12345// x.jsfunction foo() &#123; i = 0; // 암묵적 전역 변수 // ...&#125; 12345678// y.js// var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다.// 따라서 for문에서 선언한 i는 전역 변수이다.// 이미 암묵적 전역 변수 i가 있으므로 변수 i는 중복 선언된다.for (var i = 0; i &lt; 5; i++) &#123; foo(); console.log(i);&#125; 서로 분리된 x.js와 y.js 라는 서로 다른 파일이 존재한다고 가정하자. 여기서 HTML이 위 두 파일을 다음처럼 로드할 경우, 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script src='x.js'&gt;&lt;/script&gt; &lt;script src='y.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/htm HTML에서 로드한 자바스크립트 파일은 여러 개로 분리되어 있다해도 하나의 전역 스코프를 공유한다. 다시 말해 자바스크립트는 파일마다 독립적인 파일 스코프를 갖지 않는다. 따라서 자바스크립트 파일을 여러 개로 분리하여도 결국 하나의 자바스크립트 파일로 통합된 것처럼 동작한다. 이러한 특징은 자바스크립트에 모듈이라는 개념이 없기 때문이다. 위 예제에서는 결국 나중에 선언된 y.js의 i값이 x.js의 i값을 덮어씌우게 된다. 결국, JS는 변수의 중복 선언을 허용하기 때문에 어떠한 에러도 발생시키지 않고 무한 반복 상태에 빠져들게 될 것이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Scope","slug":"Scope","permalink":"https://hyeok999.github.io/tags/Scope/"}]},{"title":"javascript 11강 함수","slug":"javascript-preview-11","date":"2019-10-10T16:56:43.000Z","updated":"2019-11-30T16:43:15.882Z","comments":true,"path":"2019/10/11/javascript-preview-11/","link":"","permalink":"https://hyeok999.github.io/2019/10/11/javascript-preview-11/","excerpt":"","text":"JavaScript 11강 예습 11강 : 함수 함수란? 함수정의 함수호출 함수의 사용 이유 함수 리터럴 함수와 일반 객체의 공통점 및 차이점 함수 정의 4가지 함수 만드는 방법 및 호이스팅 함수 선언문 함수 표현식 함수 생성 시점과 함수 호이스팅 Function 생성자 함수 화살표 함수 : ES6 함수 호출 매개변수와 인수 인수 확인 매개변수의 개수 외부 상태의 변경과 함수형 프로그래밍 반환문 다양한 함수의 형태 즉시 실행 함수 재귀 함수 중첩 함수 콜백 함수 11강함수 함수란? 자바스크립트의 핵심 오브 핵심 “입력(input)”을 받아서 “출력(output)”을 내보내는 일련의 과정을 정의한 것 \u0010 ​ 함수는 함수 정의(Function Definition)을 통하여 생성한다. 아래는 수학적 함수를 프로그래밍적 함수로 보여준 &lt;예&gt; 이다. 1234567// f(x, y) = x + yfunction add(x, y) &#123; return x + y;&#125;// f(2, 5) = 7add(2, 5); // 7 함수 정의(Function Definition)와 함수 호출(Function call/invoke)을 통해서 보여진다. 함수 정의1234// 함수 정의function add(x, y) &#123; return x + y;&#125; 함수 호출12345// 함수 호출var result = add(2, 5);// 함수 add에 인수 2, 5를 전달하면서 호출하면 7을 반환한다.console.log(result); // 7 함수의 사용 이유 함수는 필요시 여러 번 호출이 가능하다.이는 결국, 동일한 작업을 반복적으로 해야만 한다면 정의된 함수를 재사용하는 것이 효율적일 것이다. 코드 수정 및 추가 또한 함수부분만 수정 및 추가를 하면 되므로 코드의 유지보수 및 편의성을 높이게 된다.함수는 식별자를 붙일 수 있다. 따라서, 함수 명을 좋은 이름으로 하여여 코드의 가독성을 높일 수 있을 것이다. 함수 리터럴​ 객체 리터럴 표기법으로 객체를 만들수 있듯이( var obj = { }),함수도 함수 리터럴 표기법을 이용해 함수를 생성할 수 있다. 함수는 객체라는 사실을 잊어서는 안된다.자바스크립트의 함수는 일급 객체이다. = 값으로 사용 가능하다는 소리 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록 그리고 함수 몸체로 구성된다. 1234// 변수에 함수 리터럴을 할당var add = function add(x, y) &#123; return x + y;&#125;; 함수 리터럴의 구성 요소에 대한 설명은 아래와 같다. 함수 이름 함수 이름은 식별자이다. 따라서 식별자 네이밍 규칙을 준수해야 한다. 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. 함수 이름은 생략할 수 있다. 함수 이름이 있는 함수를 기명 함수(named function), 함수 이름이 없는 함수를 익명 함수(anonymous function)라 한다. 매개변수 목록 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분한다. 매개변수에는 인수가 할당된다. 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다. 함수 몸체 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. 함수 몸체는 함수 호출에 의해 실행된다. 함수 와 일반 객체의 공통점 및 차이점 - 일반 객체 함수 공통점 데이터타입 : 객체 데이터타입 : 객체 차이점 - 호출 호출불가 호출가능 차이점 - 프로퍼티 일반 프로퍼티 소유 고유 프로퍼티 소유 함수 정의 4가지함수를 정의하는 방법은 4가지가 있다. 함수 선언문(Function Declaration/Function Statement) 123function add(x, y) &#123; return x + y;&#125; 함수 표현식(Function Expression) 123var add = function (x, y) &#123; return x + y;&#125;; Function 생성자 함수(Function Constructor) 1var add = new Function('x', 'y', 'return x + y'); 화살표 함수(Arrow Function): ES6 1var add = (x, y) =&gt; x + y; 함수는 정의? 선언? ​ 함수는 선언하다고 안하고 정의한다고 표현 한다.이유는 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.따라서 ECMAScript 사양에서도 변수에는 선언, 함수는 정의라고 표현한다. 함수 만드는 방법 및 호이스팅함수 선언문함수 선언문은 함수 리터럴 표기법과 형태가 동일하다. 단, 함수 선언문은 함수 이름을 생략할 수 없다. 123456789101112// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 참조// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.console.dir(add); // ƒ add(x, y)// 함수 호출console.log(add(2, 5)); // 7 위에서 “함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다” 라고 한적이 있다. 이 뜻은 함수를 생성시 함수 객체를 생성한다.이 때 생성된 함수 객체를 할당할 변수가 필요하다. 함수 객체를 변수에 할당하지 않으면 생성된 함수 객체를 사용할 수 없고 아무도 참조하고 있지 않는 함수 객체는 결국 가비지 컬렉터에 의해 메모리에서 해제된다. 즉, JS엔진은 함수 명과 동일한 명의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 123456// function add(x, y)var add = function add(x, y) &#123; return x + y;&#125;;console.log(add(2, 5)); // 7 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수 add인 것이다. 결론 : JS엔진은 함수 선언문을 함수 표현식으로 반환하여 함수 객체를 생성함. 함수 표현식자바스크립트의 객체는 값처럼 변수에 할당 할 수도 있고 프로퍼티의 값이 될 수도 있으며 배열의 요소가 될 수도 있다.이러한 객체를 일급 객체(first-class object)라 한다. 자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. 함수표현식은 함수를 값처럼 사용하여 변수에 할당하는 방식이다. 123456// 함수 표현식var add = function (x, y) &#123; return x + y;&#125;;console.log(add(2, 5)); // 7 또 여기서 함수 표현식은 함수명이 필요 없는 익명 함수를 사용이 가능하다. 함수명은 함수 내부에서만 접근이 가능하기에 외부에서는 당연히 접근불가 이다. 1234567891011// 기명 함수 표현식var add = function foo (x, y) &#123; return x + y;&#125;;// 함수 객체를 가리키는 변수로 호출console.log(add(2, 5)); // 7// 함수 이름으로 호출하면 ReferenceError가 발생한다.// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.console.log(foo(2, 5)); // ReferenceError: foo is not defined 함수 생성 시점과 함수 호이스팅 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(Function Hoisting)이라 한다. 함수 표현식은 호이스팅이 안된다. 함수 호이스팅은 변수 호이스팅과는 미묘한 차이가 있다. 변수 호이스팅은 선언 단계와 초기화 단계가 동시에 진행되며 다른 코드가 실행되기 이전에 자바스크립트 엔진에 의해 암묵적으로 수행된다. 하지만 함수 선언문의 함수 호이스팅은 선언 단계와 초기화 단계, 그리고 할당 단계(암묵적으로 선언된 변수에 함수 객체를 할당)까지 동시에 진행된다. 함수 표현식은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 1234567891011121314151617// 함수 참조console.dir(add); // ƒ add(x, y)console.dir(sub); // undefined// 함수 호출console.log(add(2, 5)); // 7console.log(sub(2, 5)); // TypeError: sub is not a function// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 표현식var sub = function (x, y) &#123; return x - y;&#125;; 함수 호이스팅은 함수 호출 전에 반드시 함수를 선언하여야 한다는 당연한 규칙을 무시한다. 따라서 코드의 구조를 엉성하게 만들 수 있다. 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있다. Function 생성자 함수 Function 생성자 함수는 매개변수 목록과 함수 몸체를 문자열로 전달받는다. new 연산자와 함께 호출하며 생성된 함수 객체를 반환한다. (사실 new 연산자 없이 호출하여도 결과는 동일하다.) 123var add = new Function('x', 'y', 'return x + y');console.log(add(2, 5)); // 7 생성자 함수로 함수를 생성하는 방식 일반적이지 않고 바람직 하지도 않다. 생성자 함수는 함수 선언식, 표현식과는 다르게 동작하고 클로저를 생성하지 않는다. ( 추후에 더 이야기 ) 123456789101112131415var add1 = (function () &#123; var a = 10; return function (x, y) &#123; return x + y + a; &#125;;&#125;());console.log(add1(1, 2)); // 13var add2 = (function () &#123; var a = 10; return new Function('x', 'y', 'return x + y + a;');&#125;());console.log(add2(1, 2)); // ReferenceError: a is not defined 화살표 함수 : ES6​ ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다. 123456789// 화살표 함수const add = function (x,y)&#123; return x + y;&#125;const add = (x, y) =&gt; x + y;console.log(add(2, 5)); // 7 함수 호출​ 함수는 함수를 참조하는 변수와 한 쌍의 소괄호( )인 함수 호출 연산자로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다. 이 인수는 매개변수에 할당할 수 있는 값이어야 한다. 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘긴다. 이때 매개변수에 인수가 할당되고 함수 몸체의 문들이 실행되기 시작한다. 매개변수와 인수함수외부 -&gt; 함수내부 접근시 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다.인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다. 1234567function add(x, y) &#123; return x + y;&#125;var result = add(2, 5);console.log(result); // 7 매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 변수와 마찬가지로 undefined로 초기화된 이후 인수가 할당된다. 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다. 함수는 매개변수의 개수와 인수(argument)의 개수를 체크하지 않는다. 인수가 부족한 경우, 매개변수의 값은 undefined이다. 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 *에러가 발생하지는 않는다. * 1234567function add(x, y) &#123; return x + y;&#125;console.log(add(2)); // NaN// y에는 인수가 전달이 안되었으므로 y = undefined가 되있다.// 2 + undefined = NaN이다. 또 다른 경우에는, 인수가 더 많을 경우이다. 이 경우, 초과되는 인수는 무시한다. ( 완전 무시가 아닌, 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. ) 12345function add(x, y) &#123; return x + y;&#125;console.log(add(2, 5, 10)); // 답 7 , 10을 받을 매개변수는 존재하지 않기에 무시한다. 인수 확인​ 아래 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실행할 것이다. 이러한 상황이 발생한 이유는 아래와 같다. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 자바스크립트는 동적 타입 언어이다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정하지 않는다. 1234567// 1 + 2 를 하여 숫자 3의 결과를 얻고 싶다.function add(x, y) &#123; return x + y;&#125;console.log(add(2)); // NaNconsole.log(add('a', 'b')); // 'ab' ​ 자바스크립트는 동적 타이핑이라는 기능으로 인하여 어떤 타입의 인수를 전달해야하는지, 어떤 타입의 값을 반환해야하는지를 설명해주지 않는다. 따라서 이를 해결하기 위하여 적절한 인수가 전달되는지를 체크해야한다. 12345678910function add(x, y) &#123; if (typeof x !== 'number' || typeof y !== 'number') &#123; throw new TypeError('매개변수에 숫자 타입이 아닌 값이 할당되었습니다.'); &#125; return x + y;&#125;console.log(add(2)); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.console.log(add('a', 'b')); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다. 매개변수의 개수 매개변수는 순서에 의미가 있다. 따라서 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 함수의 사용 방법을 어렵게 만들고 실수를 발생시킬 가능성을 높인다. 또한 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 변경되므로 함수를 사용하는 코드 전체가 영향을 받는다. *함수의 매개변수는 코드 이해에 방해가 되는 요소이므로 이상적인 매개변수 개수는 0개이며 적을 수록 좋다. * 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다. 아래는 jQuery의 ajax 메소드에 객체를 인수로 전달하는 예제이다. 123456$.ajax(&#123; method: 'POST', url: '/user', data: &#123; id: 1, name: 'Lee' &#125;, cache: false&#125;); 하지만 주의할 것은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부작용이 발생한다는 것이다. 외부 상태의 변경과 함수형 프로그래밍원시 값은 값에 의한 전달(Pass by value), 객체는 참조에 의한 전달(Pass by reference) 방식으로 동작. 매개변수는 값에 의한 호출(Call by value) , 참조에 의한 호출(Call by reference) 로 구별하기도 하나, 동작 방식은 값에 의한 전달, 참조에 의한 전달과 동일하다. 1234567891011121314151617181920function changeVal(primitive, obj) &#123; primitive += 100; obj.name = 'Kim';&#125;// 외부 상태var num = 100;var person = &#123; name: 'Lee' &#125;;console.log(num); // 100console.log(person); // &#123;name: \"Lee\"&#125;// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.changeVal(num, person);// 원시 값은 원본이 훼손되지 않는다.console.log(num); // 100// 객체는 원본이 훼손된다.console.log(person); // &#123;name: \"Kim\"&#125; 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경하여도 원본은 훼손되지 않는다.다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 원시값의 원본을 변경하는 어떠한 부수 효과(side-effect)도 발생하지 않는다. 객체 타입 인수는 참조값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조값으로 참조한 객체를 변경할 경우 원본이 훼손된다.다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본 객체가 변경되는 **부수 효과가 발생한다. ​ 외부의 상태(위 예제의 경우, 참조 타입의 변수 person)를 변경시키는 것은 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. ​ 이런 문제는 객체가 변경할 수 없는 값이며 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용이다. 참조에 의한 전달 방식을 통해 참조값이 공유되어 있는 객체는 언제든지 변경될 수 있다. 복잡한 코드에서 객체의 변경을 추척하는 일은 매우 어려운일이다. 따라서 객체의 변경을 추척하려면 Observer 패턴등을 이용해 추가 대응을 해야한다. Observer 패턴 중 하나는, 객체를 불변 객체로 만들어서 사용하는 방법이 있다.이는 객체를 마치 원시값처럼 변경 불가능한 값으로 동작하게 만드는 것인데, 객체의 상태 변경이 필요한 경우에만 참조가 아닌 객체의 방어적 복사를 통해 원본 객체를 완전히 복제(deep copy)하고 새로운 객체를 생성해 변경한다. 함수형 프로그래밍에서는 어떤 외부 상태도 변경시키지 않는, 즉 부수 효과가 없는 함수를 순수 함수(Pure function), 외부 상태를 변경시키는 즉, 부수 효과가 있는 함수를 비순수 함수(Impure function)라고 부른다. 위 예제같은 비순수 함수는 코드의 복잡성을 증가시키며, 이를 최대한 억제하는 프로그래밍을 해야한다. 함수형 프로그래밍은 변수의 사용을 억제하여 상태 변경을 피하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임이다. 변수 값은 누군가에 의해 언제든지 변경될 수 있고, 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 만들어 가독성을 해치고 오류 발생의 근본적 원인이 될 수 있기 때문이다. 함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수 있다. 반환문 함수는 return키워드를 이용하여 실행 결과를 값으로 반환이 가능하다. 반환문은 다음과 같은 3가지의 역할을 한다. 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다. 반환문은 return 키워드 뒤에 지정한 값을 반환한다. return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. 반환문은 생략이 가능하며 생략 시 함수를 전부 실행하고 암묵적으로 undefined 를 반환한다. 다양한 함수의 형태1. 즉시 실행 함수 함수 정의와 동시에 즉시 호출되는 실행함수. 그룹 연산자 ( )로 묶어주어야만 하며, 안묶으면 에러를 발생한다. 1회성이며, 1번 호출시 다시는 호출할 수없다. 기본적으로 익명 즉시 실행함수를 사용하는것이 일반적이다.(함수 이름이 있어도 사용은 가능하나 재호출 불가) 123456789101112131415// 익명 즉시 실행 함수(function () &#123; var a = 3; var b = 5; return a * b;&#125;());// 기명 즉시 실행 함수... 사용은 가능하나 재호출이 불가능하다.(function foo() &#123; var a = 3; var b = 5; return a * b;&#125;());foo(); // ReferenceError: foo is not defined 즉시 함수를 여러가지 방법. ( 1번쨰가 제일 일반적이다. ) 123456789101112131415(function () &#123; // ...&#125;());(function () &#123; // ...&#125;)();!function () &#123; // ...&#125;();+function () &#123; // ...&#125;(); 즉시함수 예제, 12345678910111213var res = (function () &#123; var a = 3; var b = 5; return a * b;&#125;());console.log(res); // 15res = (function (a, b) &#123; return a * b;&#125;(3, 5));console.log(res); // 15 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름이 충돌하는 것을 방지할 수 있다. 이를 위한 목적으로 즉시 실행 함수를 사용하기도 한다. 2. 재귀함수 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀 호출을 하는 함수를 재귀 함수라 칭한다. 재귀함수는 반드시 탈출구를 만들어야 하며 만들지 않을 경우 무한루프에 빠지게된다. 재귀함수의 대표적인 예 - 팩토리얼 1234567891011121314// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.// n! = 1 * 2 * ... * (n-1) * nfunction factorial(n) &#123; // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다. if (n &lt;= 1) return 1; return factorial(n - 1) * n;&#125;console.log(factorial(0)); // 0! = 1console.log(factorial(1)); // 1! = 1console.log(factorial(2)); // 2! = 1 * 2 = 2console.log(factorial(3)); // 3! = 1 * 2 * 3 = 6console.log(factorial(4)); // 4! = 1 * 2 * 3 * 4 = 24console.log(factorial(5)); // 5! = 1 * 2 * 3 * 4 * 5 = 120 재귀 함수는 stack overflow 와 같은 에러를 유발할수 있기 때문에 가급적이면 사용을 자제해야한다. 3. 중첩 함수 함수 내부에 정의된 함수를 중첩함수 또는 내부 함수라 한다. 자신을 포함하는 외부함수를 돕는 헬퍼함수의 역할을 한다. 외부 함수는 중첩 함수의 변수에 접근이 불가능하다. 반면에 중첩 함수는 외부 함수의 변수에 접근이 가능하다. 12345678910111213141516function outer() &#123; var x = 1; // 중첩 함수 function inner() &#123; var y = 2; // 외부 함수의 변수를 참조할 수 있다. console.log(x + y); // 3 &#125; inner(); // 중첩 함수의 변수를 참조할 수 없다. console.log(x + y); // ReferenceError: y is not defined&#125;outer(); 콜백 함수 자바스크립트는 1급 객체이므로 함수의 매개변수에 함수를 전달이 가능하다. 123456789101112131415161718// 콜백 함수를 전달받는 함수function print(f) &#123; var string = 'Hello'; // 콜백 함수를 전달받는 함수가 콜백 함수의 호출 시기를 결정하고 호출 return f(string);&#125;// print 함수에 콜백 함수를 전달하면서 호출var res1 = print(function (str) &#123; return str.toUpperCase();&#125;);// print 함수에 콜백 함수를 전달하면서 호출var res2 = print(function (str) &#123; return str.toLowerCase();&#125;);console.log(res1, res2); // HELLO hello ​ print 함수는 함수를 인수로 전달받는다. print 함수에 인수로 전달된 함수는 print 함수가 호출할 시기를 결정하여 호출한다. 이때 print 함수에 인수로 전달된 함수를 콜백 함수(Callback function)라고 한다. 콜백 함수는 콜백 함수를 인수로 전달 받은 함수가 호출 시점을 결정하여 호출한다. 콜백 함수가 콜백 함수를 전달받는 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 인수로 곧바로 전달하는 것이 일반적이다. 이때 콜백 함수로서 전달된 함수 리터럴은 콜백 함수를 전달받은 함수가 호출될 때 평가되어 생성된다. 중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수는 함수에 전달되어 헬퍼 함수의 역할을 한다. 단, 중첩 함수는 고정되어 있어서 교체할 수 없지만 콜백 함수는 함수 외부에서 인수로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 12345678910111213141516171819202122232425262728// 콜백 함수를 사용하지 않으면 함수를 분리해야 한다.function printToUpperCase() &#123; var string = 'Hello'; return string.toUpperCase();&#125;console.log(printToUpperCase()); // HELLOfunction printToLowerCase() &#123; var string = 'Hello'; return string.toLowerCase();&#125;console.log(printToLowerCase()); // hello// 콜백 함수를 외부에서 전달하면 콜백 함수에 따라 다양한 동작을 하는 함수를 만들 수 있다.function print(f) &#123; var string = 'Hello'; return f(string);&#125;console.log(print(function (str) &#123; return str.toUpperCase();&#125;)); // HELLOconsole.log(print(function (str) &#123; return str.toLowerCase();&#125;)); // hello 콜백 함수는 비동기 처리를 위해 사용하는 일반적인 패턴이다. 주로 이벤트 처리나 Ajax 통신에 많이 이용된다. 또, 고차 함수(Higher-order Function)에서도 사용하는 패턴으로 사용 빈도가 매우 높고 중요한 패턴이다. 12345678910111213// 콜백 함수를 사용하는 고차 함수 mapvar res = [1, 2, 3].map(function (item) &#123; return item * 2;&#125;);console.log(res); // [ 2, 4, 6 ]// 콜백 함수를 사용하는 고차 함수 filterres = [1, 2, 3].filter(function (item) &#123; return item % 2;&#125;);console.log(res); // [ 1, 3 ]","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"https://hyeok999.github.io/tags/function/"}]},{"title":"daily_algorithm10","slug":"daily-algorithm10","date":"2019-10-10T10:20:11.000Z","updated":"2019-11-30T16:50:10.522Z","comments":true,"path":"2019/10/10/daily-algorithm10/","link":"","permalink":"https://hyeok999.github.io/2019/10/10/daily-algorithm10/","excerpt":"","text":"문제 출처 : 프로그래머스 2016년정답을 맞추었으나 너무 코드 가독성이 떨어짐 추후 다시 풀 것.문제 설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요. 제한 조건 2016년은 윤년입니다. 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function solution(a, b) &#123; var answer = ''; var dayOfTheWeek = [ 'FRI','SAT','SUN', 'MON', 'TUE', 'WED', 'THU']; var j = 0; for(var month=1;month&lt;=a;month++)&#123; switch(month)&#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: for(var x=1;x &lt;= 31; x++)&#123; if(month == a &amp;&amp; x == b)&#123; answer = dayOfTheWeek[j]; break; &#125; else&#123; j++; if( j == 7)&#123; j = 0; &#125; &#125; &#125; break; case 4: case 6: case 9: case 11: for(var x=1;x &lt;= 30; x++)&#123; if(month == a &amp;&amp; x == b)&#123; answer = dayOfTheWeek[j]; break; &#125;else &#123; j++; if( j == 7)&#123; j = 0; &#125; &#125; &#125; break; default : for(var x=1; x &lt;= 29; x++)&#123; if(month == a &amp;&amp; x == b)&#123; answer = dayOfTheWeek[j]; break; &#125; else&#123; j++; if( j == 7)&#123; j = 0; &#125; &#125; &#125; break; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-06","slug":"javascript-study-06","date":"2019-10-10T04:30:16.000Z","updated":"2019-11-30T16:29:46.273Z","comments":true,"path":"2019/10/10/javascript-study-06/","link":"","permalink":"https://hyeok999.github.io/2019/10/10/javascript-study-06/","excerpt":"","text":"JavaScript Study 06 용어 단축평가 사용 용도 객체 객체를 만드는 방법 인스턴스 프로퍼티 프로퍼티 접근 방법 프로퍼티 동적 생성 프로퍼티 삭제 ES6 객체 리터럴 확장 기능 프로퍼티 축약 표현 메소드 축약 표현 원시값과 객체의 비교 원시값 const vs var/let Scope ( 변수의 생명주기 - 식별자의 생명주기 ) 문자열과 불변성 유사배열 객체 ( = 문자열 ) 값에 의한 전달 객체 변경 가능한 값 참조에 의한 전달 복사 : 얕은 복사( Shallow Copy ) / 깊은 복사 ( Deep Copy ) 얕은 복사( Shallow Copy ) 깊은 복사 ( Deep Copy ) 용어 - ( 러버덕 ) 원시값 변경 가능한 값 값에 의한 전달 객체 변경 불가능한 값 참조에 의한 전달 단축평가 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 언제나 피연산자 중 어는 한쪽 값을 반환한다. 1'Cat' &amp;&amp; 'Dog' // 'Dog' 어느 쪽 값을 출력할지는 최종 평가 결과를 결정할 피연산자를 출력한다. &amp;&amp; 은 선 피연산자가 true 라면 후 피연산자를 출력한다. 이유는 첫 피연산자가 true라면 후 피연산자를 통해 해당 값이 true 인지 false 인지 최종 결정이 나기 때문이다. 1'문자열' &amp;&amp; 0 // 0 &amp;&amp; 은 선 피연산자가 false 라면 그냥 선 피연산자를 출력한다. 이유는 첫 피연산자가 false라면 어차피 &amp;&amp; 연산을 통해 해당 값이 false 로 최종 결정이 나기 때문이다. 10 &amp;&amp; '문자열' // 0 || 은 선 피연산자가 true 라면 그냥 선 피연산자를 출력한다. 이유는 첫 피연산자가 true라면 어차피 || 연산을 통해 해당 값이 true 로 최종 결정이 나기 때문이다. 1'Cat' || 'Dog' // 'Cat' || 은 선 피연산자가 false 라면 후 피연산자를 출력한다. 이유는 첫 피연산자가 false라면 후 피연산자를 통해 해당 값이 true 인지 false 인지 최종 결정이 나기 때문이다. 1'' || 'Dog' // 'Dog' 사용 용도 객체가 null인지 확일할 때 1234var elem = null;console.log(elem.value); //1번, TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); //2번, null 변수 elem에 null값으로 초기화를 해주었는데 elem에 대한 value프로퍼티를 참조하게 될 경우 1번처럼 error를 유발한다. 1번의 경우, error가 날 경우 개발자 도구를 통해서 알 수 있지만, 브라우저 상에서는 알기가 힘들다. 따라서 2번처럼 에러 확인코드를 추가하여 일어날 수 있는 에러를 방지 해주어야만 한다. 함수 매개변수에 기본값을 설정할 때 12345678910111213141516// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) &#123; str = str || ''; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') &#123; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다. 이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다. 객체 자바스크립트의 객체는 자바처럼 클래스를 필요로 하지 않는다. 객체는 재산( property )을 가지고 있다. 프로퍼티는 콤마 ( , ) 로 구분한다. 그래서 이것을 객체 리터럴이라고 한다. 객체 리터럴은 평가 될 때 할당된다. 1234var person = &#123; name: 'Lee', //재산(프로퍼티) - 객체 리터럴 gender: 'male' //재산(프로퍼티) - 객체 리터럴&#125;; 객체를 선언할 때 사용하는 { } 는 코드 블록이 아니다. 증거 코드 블록이 끝나고서 ; 을 붙인다. 코드 블록 내용에 ;이 들어가지 않는다. 객체의 프로퍼티는 키와 값으로 구성되어 있다. 객체의 프로퍼티 키는 식별자가 아니기 때문에, 식별자 네이밍 규칙을 따르지 않는다. 값은 단순한 숫자, 문자열부터 함수(일급 객체)도 담을 수 있다. ( 7가지의 데이터 타입이 모두 올 수 있다. ) 여기서 프로퍼티의 키와 값을 프로퍼티 ( 정적 : state )(그대로 부름) 프로퍼티의 키와 함수를 메소드 ( 동적 : behavior )라 칭한다. 객체를 만드는 방법들 객체 리터럴 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스 (ES6) 1var o = &#123;&#125;; //객체 리터럴, 생성방법 o는 빈프로퍼티를 가지며 자동 상속을 받는다. 인스턴스 타언어에서 클래스에 의해 생성되어 메모리에 저장된 실체를 의미한다. 하지만 자바스크립트에서는 new혹은 Object 객체로 만들어낸 객체를 인스턴스라고 부른다. 프로퍼티​ 객체는 프로퍼티(Property)들의 집합이며 프로퍼티는 키(key)과 값(value)으로 구성된다. 프로퍼티를 나열할 때는 쉼표(,)로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나 사용해도 좋다. 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값 + 숫자( 강제 문자열 변환 ) 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 여기서 프로퍼티 키 는 식별자 네이밍 규칙을 따를 필요가 없다하지만, 식별자 네이밍 규칙을 따르는 키와 따르지 않는 키는 서로 선언하는데 차이가 있다. 예를들어 보자, 123456var person = &#123; first_name: 'Ung-mo', // 식별자 네이밍 규칙을 따르는 이름 'last-name': 'Lee' // 식별자 네이밍 규칙을 않은 이름&#125;;console.log(person); // &#123;first_name: \"Ung-mo\", last-name: \"Lee\"&#125; 즉, 식별자 네이밍 규칙을 따르지 않는 키는 반드시 &#39;&#39; 로 묶어 주어야 제대로 동작한다. 프로퍼티 접근 방법프로퍼티 접근 방법 마침표 표기법 : 식별자 네이밍 규칙을 준수하는 키만 접근이 가능. ( 추천 ) 대괄호 표기법 : 모두 접근이 가능. 단, [ ] 안에는 반드시 &#39;&#39;가 들어가야 한다. ( 비추천 ) 123456789101112131415161718192021222324var person = &#123; name: 'Lee', 'last-name': 'Hyeok', 1: 10&#125;;// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Lee// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Leeconsole.log(person[name]); // ReferenceError: name is not defined. 에러유발// 식별자 네이밍을 지키지 않은 키에 접근할 때console.log(person.'last-name'); // SyntaxError: Unexpected stringconsole.log(person.last-name); // NaN;console.log(person[last-name]); // ReferenceError: last is not definedconsole.log(person['last-name']); // Hyeok// 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 따옴표를 생략 가능하다.console.log(person.1); // SyntaxError: missing ) after argument listconsole.log(person.'1'); // SyntaxError: Unexpected stringconsole.log(person[1]); // 10 : person[1] -&gt; person['1']console.log(person['1']); // 10 여기서 이 부분에 대해서 더 자세하게 보도록 하겠다. 1234567var person = &#123; 'last-name': 'Hyeok',&#125;;// 식별자 네이밍을 지키지 않은 키에 접근할 때console.log(person.last-name); // NaN;console.log(name); // 아무것도 출력이 안됨. 즉 빈문자열임 왜 NaN이 뜨고 name은 빈문자열이 뜨는걸까? ( 아래 해설 참조 ) 만약 window 객체의 프로터피가 아닌 다른 것을 참조한다면 다음과 같이 뜬다. 12345var person = &#123; 'last-names': 'Lee'&#125;;console.log(person.last-names); // ReferenceError: names is not defined 이유 : names 는 window 객체의 프로퍼티도 아니고 선언조차 되어있지 않는 존재하지 않는 변수이기 때문에 정의 Error를 유발한다. 프로퍼티 동적 생성존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다. 123456789var person = &#123; name: 'Lee'&#125;;// person 객체에는 address 프로퍼티가 존재하지 않는다.// 따라서 person 객체에 address 프로퍼티가 동적으로 생성되고 값이 할당된다.person.address = 'Seoul';console.log(person); // &#123;name: \"Lee\", address: \"Seoul\"&#125; 프로퍼티 삭제delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다. 12345678910111213141516var person = &#123; name: 'Lee'&#125;;// 프로퍼티 동적 추가person.address = 'Seoul';// person 객체에 address 프로퍼티가 존재한다.// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 있다.delete person.address;// person 객체에 age 프로퍼티가 존재하지 않는다.// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.delete person.age;console.log(person); // &#123;name: \"Lee\"&#125; ES6 객체 리터럴 확장 기능프로퍼티 축약 표현객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다. 123456789// ES5var x = 1, y = 2;var obj = &#123; x: x, y: y&#125;;console.log(obj); // &#123;x: 1, y: 2&#125; ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략(Property shorthand)할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다. 1234567// ES6let x = 1, y = 2;// 프로퍼티 축약 표현const obj = &#123; x, y &#125;;console.log(obj); // &#123;x: 1, y: 2&#125; 메소드 축약 표현ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당한다. 123456789// ES5var obj = &#123; name: 'Lee', sayHi: function() &#123; console.log('Hi! ' + this.name); &#125;&#125;;obj.sayHi(); // Hi! Lee ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다. 12345678910// ES6const obj = &#123; name: 'Lee', // 메소드 축약 표현 sayHi() &#123; // &lt;-&gt; sayHi: function() &#123; console.log('Hi! ' + this.name); &#125;&#125;;obj.sayHi(); // Hi! Lee ES6의 메소드 축약 표현으로 정의한 메소드는 프로퍼티에 할당한 함수와 다르게 동작한다. 원시 값과 객체의 비교원시값 원시 타입(primitive type)의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. (read-only) 변수의 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 원시 값의 이러한 특성을 불변성(immutability)이라 한다. 변수는 최대한 재할당을 하지 않고 상수처럼 쓰는 것이 좋다. ( scope - 식별자의 생명주기 ) const VS var/let값을 변경할 수 없다는 것은 재할당을 할 수 없다는 의미인데 변수는 새로운 값을 재할당하는 것으로 변수값을 변경할 수 있다. 변수에 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수이다. 단, 변수는 언제든지 재할당을 통해 변수값을 변경할 수 있지만 상수는 단 한번만 할당이 허용된다. 따라서 상수와 변경 불가능한 값을 동일시하는 것은 곤란하다. Scope(변수의 생명주기 - 식별자의 생명주기)변수는 빨리 써서 버려져야 메모리에 무리가 없기 때문에 변수의 생명주기를 고려하여 함수나 변수가 들어가는 코드 블록은 되도록이면 짧은걸 권장한다. 하지만, 전역변수는 자바스크립트가 실행하는 초반부터 실행되고 자바스크립트가 끝날때까지 소멸되지 않는다. 그러므로 전역변수는 되도록 조금 사용하는걸 권장한다. 문자열과 불변성 문자열은 0개 이상인 문자들의 집합을 말하며 1개의 문자는 2Byte의 메모리 공간에 저장된다. 따라서, 문자열 타입의 값은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 다르다. 숫자는 1도 , 100000000000도 동일한 8byte가 필요하지만 문자열 타입은 1개의 문자로 이루어진 문자열은 2byte , 10개의 문자로 이루어진 문자열은 20byte가 필요하다. 문자열또한 원시값 인것을 명시해야만 한다. 12var str = 'Hello';str = 'World'; 유사 배열 객체 ( = 문자열 ) 유사 배열 객체는 마치 배열처럼 인덱스 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체를 의미한다. 따라서, 문자열은 원시값이면서 유사 배열 객체이다. 유사배열객체는 프로퍼티 키에 length 가 있느냐, 없느냐 로 따라서 체크가 가능하다. 123456789101112// 유사 배열 객체 체크방법var name = \"Kim\";console.log(name.length); // 3var str = 'string';// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.// 하지만 문자열은 원시 타입인 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.str[0] = 'S';console.log(str); // string 값에 의한 전달 변수에 변수를 할당하는 경우, 할당되는 변수(score)가 원시값을 갖는 변수라면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 12345var score = 80;var copy = score;copy = 100;console.log(score); // 80 객체 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. 객체는 변경 가능한 값(mutable value)이다. 이를 참조 값(Reference value)을 갖는다고 한다. 객체는 다른변수에 할당할때 참조에 의한 전달(Pass by reference)을 한다. 객체 리터럴은 평가 될 때 할당된다. 변경 가능한 값​ 원시값은 메모리마다 할당이 되어있기 때문에 값의 변경 유무를 추척하기가 쉽다.반면에 참조값은 실제값의 주소를 참조하고 있기 때문에 값의 변경 유무 추적이 정말 어렵다. 원시 값을 할당한 변수는 재할당을 통해서만 변경이 가능하다.반면에, 변수가 참조하고 있는 객체의 경우, 동적으로 프로퍼티 추가나 변경,삭제 등등 변경할 수 있는 값이다. 1234567891011var person = &#123; name: 'Lee'&#125;;// 프로퍼티 키 name 의 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 추가person.gender = 'male';console.log(person); // &#123;name: \"Kim\", gender: \"male\"&#125; ​ 객체를 변경할 때 마다 원시 값처럼 이전 값을 복사하여 새롭게 생성한다면 명확하고 깔끔하겠지만 객체는 크기가 매우 클 수도 있고 프로퍼티 값이 객체일 수도 있어서 복사(Deep copy)하고 생성하는 비용이 많이 든다. 다시 말해, 메모리의 효율적 소비가 어렵고 퍼포먼스가 나빠진다. 따라서, 객체는 이러한 구조적 단점에 따른 부작용(Side effect)이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. 참조에 의한 전달​ 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 123456var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사var copy = person; 원본 person와 사본 copy 모두 동일한 객체를 가리키고 있다. 이것은 두개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 어떤 한쪽에서 객체를 변경(객체의 프로퍼티 값 변경 또는 추가, 삭제)이 하면 서로 영향을 주고 받는다. 1234567891011121314151617181920var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사. copy와 person은 동일한 객체를 참조한다.var copy = person;// copy와 person은 같은 참조 값을 갖는다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Kim';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 같은 동일한 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125;console.log(copy); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 복사 : 얕은 복사( shallow copy ) / 깊은 복사 ( deep copy )copy에는 두 가지가 있다. shallow copy(얕은 복사)와 deep copy(깊은 복사)이다. shallow copy는 가장 상위 객체만 메모리에 새로 생성되고 내부 객체들은 참조 관계인 경우를 의미한다. deep copy는 내부 객체까지 모두 새로 생성된 것을 의미한다. shallow copyshallow copy의 가장 큰 예는 그냥 객체를 재할당 하는 것이다. 하지만, 그외의 방법에 대해 소개한다. slice 메서드 이용 - Array.prototype.slice.call(변수명) 변수명.slice[0] 혹은 Array.prototype.slice.call(변수명) 을 이용한다 Array.prototype.slice.call(변수명) 대신 변수명.slice(0)을 해도 되지만, arguments 같은 것(유사배열)을 복사할 때를 생각하면 Array.prototype.slice.call로 통일하는 게 좋다. 12345678var array = [&#123; name: 'a' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;];var shallow = Array.prototype.slice.call(array);shallow[0].name = 'd';shallow[1] = 'e';console.log(array); // [&#123; name: 'd' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;]console.log(shallow); // [&#123; name: 'd' &#125;, 'e' , &#123; name: 'c' &#125;] 위 예제를 보면 array 변수를 얕은 복사를 한 shallow라는 변수는 array 변수가 가리키는 객체(배열) 안에 있는 각 객체들 중 첫번째 객체의 name값을 공유하고 있기 때문에 ‘d’라고 변경시 array의 프로퍼티 값은 공유가 되어 변경이 되었다. 하지만 shallow의 두번째 배열 인덱스의 e값을 직접 변경할 경우 메모리에 직접 생성되었기에 array변수와 공유가 되어있지 않다. deep copydeep copy를 하기 위한 가장 기본적인 방법은 객체를 별도로 생성 복사할 객체의 프로퍼티에 각각 접근 (반복문을 이용) 복사 후, 복사할 객체에 프로퍼티를 생성하고 복사. deep copy는 비용이 매우 비싸기 때문에 라이브러리를 쓰는게 좋다. lodash의 cloneDeep( ) 그 중 lodash 의 Library에 있는 deep copy를 사용하는 것을 추천한다. 123456const original = &#123; a : &#123;b : 2&#125;&#125;;let copy = _.cloneDeep(original);copy.a.b = 100;console.log(original.a.b); // 2console.log(copy.a.b); // 100 JSON 객체의 메소드를 이용 123function cloneObject(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; JSON.stringify는 자바스크립트 오브젝트를 스트링 포멧으로 변환하는 메소드이다.JSON.parse는 스트링 포멧을 자바스크립트 오브젝트로 변환하는 메소드이다. 스트링으로 변환하였다가 다시 오브젝트로 변환하기 때문에 이전 객체에 대한 참조가 없어지지만 JSON 메소드 자체가 성능면에서 다른 방법에 비해 굉장히 느리기 때문에 주의해야한다.이 방법은 객체를 깊은 복사(Deep Copy)한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 10강 원시값과 객체의 비교","slug":"javascript-preview-10","date":"2019-10-09T08:31:55.000Z","updated":"2019-11-30T16:43:52.403Z","comments":true,"path":"2019/10/09/javascript-preview-10/","link":"","permalink":"https://hyeok999.github.io/2019/10/09/javascript-preview-10/","excerpt":"","text":"JavaScript 10강 예습 10강 : 원시 값과 객체의 비교 원시값 변경 불가능한 값 문자열과 불변성 유사 배열 객체 값에 의한 전달 객체 (참조값) 변경 가능한 값 참조에 의한 전달 복사 : 얕은 복사( shallow copy ) / 깊은 복사 ( deep copy ) shallow copy deep copy 10강​ 데이터 타입의 구분 12- 원시타입 : 변경 불가능한 값. 원시값 - 숫자, 문자열, 불리언, null, undefined, symbol- 객체타입 : 변경 가능한 값. 참조값 - Object 원시 타입 객체 타입 변경 유무 변경 불가능한 값 변경 가능한 값 값 원시값 참조값 종류 숫자,문자열,불리언,null,undefined,symbo 객체타입( Object) 저장 방법 실제값 저장 참조값이 저장 타 변수 할당 원본의 원식 값이 복사되어 전달(Pass by value) 원본의 참조값이 복사되어 전달(Pass by reference) 원시값 변경 불가능한 값 원시값은 오직 읽을 수 만 있는(Read Only)한 값이므로 변경할 수 없다. ​ 변경 불가능 하다는 것은 변수를 변경이 불가능하다는 것이 아니라 값을 변경 불가능하다는 이야기이다. ( 참고로, 상수는 재할당이 금지된 변수라는 뜻이므로 상수 내부에 있는 객체 프로퍼티의 값은 변경이 가능하다. ) 변수의 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 원시 값의 이러한 특성을 불변성(immutability)이라 한다. 문자열과 불변성 문자열은 0개 이상인 문자들의 집합을 말하며 1개의 문자는 2Byte의 메모리 공간에 저장된다. 따라서, 문자열 타입의 값은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 다르다. 숫자는 1도 , 100000000000도 동일한 8byte가 필요하지만문자열 타입은 1개의 문자로 이루어진 문자열은 2byte , 10개의 문자로 이루어진 문자열은 20byte가 필요하다. 문자열또한 원시값 인것을 명시해야만 한다. 12var str = 'Hello';str = 'World'; 유사 배열 객체 유사 배열 객체는 마치 배열처럼 인덱스 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체를 의미한다. 따라서, 문자열은 원시값이면서 유사 배열 객체이다. 1234567var str = 'string';// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.// 하지만 문자열은 원시 타입인 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.str[0] = 'S';console.log(str); // string 값에 의한 전달 변수에 변수를 할당하는 경우, 할당되는 변수(score)가 원시값을 갖는 변수라면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 1234var score = 80;// 변수 copy에는 변수 score의 원시값 80이 복사되어 할당된다.var copy = score; 객체 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. 자바는 클래스를 통해 미리 프로퍼티의 내용과 값을 지정해두는 방식을 기반하여 객체를 생성한다. 하지만, 자바스크립트의 대부분은 객체의 프로퍼티 값의 위치를 메모리에 저장하기 위해 해시 함수 기반의 유사딕셔너리구조(dictionary-like structure)를 사용한다. 유사 딕셔너리 구조(dictionary-like structure)는 클래스없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메소드를 추가할 수 있다. 이는 비효율적이라서 자바스크립트에서는 자바와 같은 객체 관리 방식처럼 비용을 줄이기 위해 히든 클래스라는 방식을 이용한다. 변경 가능한 값123var person = &#123; name: 'Lee'&#125;; 아래 그림에서 person의 주소 0x000000F2에 저장된 값이 참조값이다. 참조값을 평가하면 참조값에 적힌 메모리주소에 있는 객체를 반환한다. 객체를 할당한 변수를 평가하면 메모리에 저장되어 있는 참조 값을 반환하는 것이 아니라 참조 값을 통해 실제 객체에 접근해 그 객체를 반환한다. 원시 값을 할당한 변수의 경우, “변수는 ◯값을 갖는다.” 또는 “변수의 값은 ◯이다.”라고 표현한다. 객체를 할당한 변수의 경우, “변수는 객체를 참조하고 있다” 또는 “변수는 객체를 가리키고(point) 있다”라고 표현한다. 원시 값을 할당한 변수는 재할당을 통해서만 변경이 가능하다. 반면에, 변수가 참조하고 있는 객체의 경우, 동적으로 프로퍼티 추가나 변경,삭제 등등 변경할 수 있는 값이다. 1234567891011var person = &#123; name: 'Lee'&#125;;// 프로퍼티 키 name 의 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 추가person.gender = 'male';console.log(person); // &#123;name: \"Kim\", gender: \"male\"&#125; 객체를 변경할 때 마다 원시 값처럼 이전 값을 복사하여 새롭게 생성한다면 명확하고 깔끔하겠지만 객체는 크기가 매우 클 수도 있고 프로퍼티 값이 객체일 수도 있어서 복사(Deep copy)하고 생성하는 비용이 많이 든다. 다시 말해, 메모리의 효율적 소비가 어렵고 퍼포먼스가 나빠진다. 따라서, 객체는 이러한 구조적 단점에 따른 부작용(Side effect)이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. 참조에 의한 전달​ 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 123456var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사var copy = person; 원본 person와 사본 copy 모두 동일한 객체를 가리키고 있다. 이것은 두개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 어떤 한쪽에서 객체를 변경(객체의 프로퍼티 값 변경 또는 추가, 삭제)이 하면 서로 영향을 주고 받는다. 1234567891011121314151617181920var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사. copy와 person은 동일한 객체를 참조한다.var copy = person;// copy와 person은 같은 참조 값을 갖는다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Kim';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 같은 동일한 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125;console.log(copy); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 복사 : 얕은 복사( shallow copy ) / 깊은 복사 ( deep copy )copy에는 두 가지가 있다. shallow copy(얕은 복사)와 deep copy(깊은 복사)이다. shallow copy는 가장 상위 객체만 메모리에 새로 생성되고 내부 객체들은 참조 관계인 경우를 의미한다. deep copy는 내부 객체까지 모두 새로 생성된 것을 의미한다. +++객체를 복사하는 방법들 shallow copy1. slice 메서드 이용 - Array.prototype.slice.call(변수명) 변수명.slice[0] 혹은 Array.prototype.slice.call(변수명) 을 이용한다 Array.prototype.slice.call(변수명) 대신 변수명.slice(0)을 해도 되지만, arguments 같은 것(유사배열)을 복사할 때를 생각하면 Array.prototype.slice.call로 통일하는 게 좋다. 123456var array = [&#123; name: 'a' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;];var shallow = Array.prototype.slice.call(array);shallow[0].name = 'd';shallow[1] = 'e';console.log(array); // [&#123; name: 'd' &#125;, &#123; name: 'b' &#125;, &#123; name: 'c' &#125;]console.log(shallow); // [&#123; name: 'd' &#125;, 'e' , &#123; name: 'c' &#125;] 위 예제를 보면 array 변수를 얕은 복사를 한 shallow라는 변수는 array 변수가 가리키는 객체(배열) 안에 있는 각 객체들 중 첫번째 객체의 name값을 공유하고 있기 때문에 ‘d’라고 변경시 array의 프로퍼티 값은 공유가 되어 변경이 되었다. 하지만 shallow의 두번째 배열 인덱스의 e값을 직접 변경할 경우 메모리에 직접 생성되었기에 array변수와 공유가 되어있지 않다. deep copy1. 자바스크립트 재귀 사용 12345678910function cloneObject(obj) &#123; var clone = &#123;&#125;; for(var i in obj) &#123; if(typeof(obj[i])==\"object\" &amp;&amp; obj[i] != null) clone[i] = cloneObject(obj[i]); else clone[i] = obj[i]; &#125; return clone;&#125; 오브젝트의 프로퍼티들을 순회하여 빈 오브젝트에 더한다. 그 과정에서 원본 오브젝트의 프로퍼티가 오브젝트일 경우 재귀적으로 함수를 실행한다.이 방법은 객체를 깊은 복사(Deep Copy)한다. 2. JSON 객체의 메소드를 이용 123function cloneObject(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; JSON.stringify는 자바스크립트 오브젝트를 스트링 포멧으로 변환하는 메소드이다.JSON.parse는 스트링 포멧을 자바스크립트 오브젝트로 변환하는 메소드이다. 스트링으로 변환하였다가 다시 오브젝트로 변환하기 때문에 이전 객체에 대한 참조가 없어지지만 JSON 메소드 자체가 성능면에서 다른 방법에 비해 굉장히 느리기 때문에 주의해야한다.이 방법은 객체를 깊은 복사(Deep Copy)한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Object","slug":"Object","permalink":"https://hyeok999.github.io/tags/Object/"},{"name":"Primary value","slug":"Primary-value","permalink":"https://hyeok999.github.io/tags/Primary-value/"}]},{"title":"daily_algorithm09","slug":"daily-algorithm09","date":"2019-10-09T07:18:21.000Z","updated":"2019-11-30T16:50:16.803Z","comments":true,"path":"2019/10/09/daily-algorithm09/","link":"","permalink":"https://hyeok999.github.io/2019/10/09/daily-algorithm09/","excerpt":"","text":"문제 출처 : 프로그래머스 K번째 수문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 123456789101112131415function solution(array, commands) &#123; var answer = []; let tempArray = []; for (let i = 0; i &lt; commands.length; i++) &#123; tempArray = array.slice((commands[i][0]) - 1, commands[i][1]); console.log(tempArray); tempArray.sort((a, b) =&gt; a - b); // ES5에서 사용될 코드 // tempArray.sort(function(a, b) &#123; return a - b; &#125;); answer.push(tempArray[commands[i][2] - 1]); &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm08","slug":"daily-algorithm08","date":"2019-10-08T07:47:14.000Z","updated":"2019-11-30T16:50:30.102Z","comments":true,"path":"2019/10/08/daily-algorithm08/","link":"","permalink":"https://hyeok999.github.io/2019/10/08/daily-algorithm08/","excerpt":"","text":"문제 출처 : Poiema 1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라123456789101112function problem01() &#123; console.log('1번 문제입니다.'); const i = 15; if (i &gt; 10 &amp;&amp; i &lt; 20) &#123; console.log(i); &#125; console.log('-------------------'); return i;&#125;problem01(); 2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오. 1234567891011function problem02() &#123; console.log('2번 문제입니다.'); for (let i = 0; i &lt; 10; i++) &#123; if (i % 2 === 0) &#123; console.log(i); &#125; &#125; console.log('-------------------');&#125;problem02(); 3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오. 12345678910111213function problem03() &#123; console.log('3번 문제입니다.'); let strNum = []; for (let i = 0; i &lt; 10; i++) &#123; if (i % 2 === 0) &#123; strNum += i; &#125; &#125; console.log(strNum); console.log('-------------------');&#125;problem03(); 4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오. 1234567891011function problem04() &#123; console.log('4번 문제입니다.'); for (let i = 10; i &gt; 0; i--) &#123; if (i % 2 !== 0) &#123; console.log(i); &#125; &#125; console.log('-------------------');&#125;problem04(); 5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오. 1234567891011121314function problem05() &#123; console.log('5번 문제입니다.'); let i = 0; while (i &lt; 10) &#123; if (i % 2 === 0) &#123; console.log(i); &#125; i++; &#125; console.log('-------------------');&#125;problem05(); 6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오. 1234567891011121314function problem06() &#123; console.log('6번 문제입니다.'); let i = 10; while (i &lt;= 10 &amp;&amp; i &gt; 0) &#123; if (i % 2 !== 0) &#123; console.log(i); &#125; i--; &#125; console.log('-------------------');&#125;problem06(); 7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오. (결과 : 45)12345678910111213function problem07() &#123; console.log('7번 문제입니다.'); let sum = 0; for (let i = 0; i &lt; 10; i++) &#123; sum += i; &#125; console.log(sum); console.log('-------------------');&#125;problem07(); 8. 1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오. (결과 : 73)123456789101112131415function problem08() &#123; console.log('8번 문제입니다.'); let sum = 0; for (let i = 1; i &lt; 20; i++) &#123; if (i % 2 !== 0 &amp;&amp; i % 3 !== 0) &#123; sum += i; &#125; &#125; console.log(sum); console.log('-------------------');&#125;problem08(); 9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오. (결과 : 117)123456789101112131415function problem09() &#123; console.log('9번 문제입니다.'); let sum = 0; for (let i = 1; i &lt; 20; i++) &#123; if (i % 2 === 0 || i % 3 === 0) &#123; sum += i; &#125; &#125; console.log(sum); console.log('-------------------');&#125;problem09(); 10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오. 123456789101112131415function problem10() &#123; console.log('10번 문제입니다.'); for (let i = 1; i &lt; 6; i++) &#123; for (let j = 0; j &lt; 6; j++) &#123; if ((i + j) === 6) &#123; console.log(`[ $&#123;i&#125;, $&#123;j&#125; ]`); &#125; &#125; &#125; console.log('-------------------');&#125;problem10(); 11. 삼각형 출력하기 - pattern 1다음을 참고하여 *(별)로 높이가 5인(var line = 5) 삼각형을 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 12345678910111213141516171819202122232425function problem11() &#123; console.log('11번 문제입니다.'); const line = 5; let star = ''; for (let i = 0; i &lt; line; i++) &#123; for (let j = 0; j &lt;= i; j++) &#123; star += '*'; &#125; // 다른 방법 // for (let j = 0; j &lt;= line; j++) &#123; // if (j &lt;= i) &#123; // star += '*'; // &#125; // &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem11(); 12. 삼각형 출력하기 - pattern 2다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 123456789101112131415161718192021222324252627282930313233function problem12() &#123; console.log('12번 문제입니다.'); const line = 5; let star = ''; for (let i = 0; i &lt; line; i++) &#123; // for (let x = 0; x &lt;= i; x++) &#123; // star += ' '; // &#125; // for (let j = i; j &lt; line; j++) &#123; // star += '*'; // &#125; // star += '\\n'; // 다른방법 for (let x = 0; x &lt; line; x++) &#123; if (x &lt; i) &#123; star += ' '; &#125; &#125; for (let j = 0; j &lt; line; j++) &#123; if (j &gt;= i) &#123; star += '*'; &#125; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem12(); 13. 삼각형 출력하기 - pattern 3다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 123456789101112131415161718function problem13() &#123; console.log('13번 문제입니다.'); const line = 5; let star = ''; for (let i = line; i &gt; 0; i--) &#123; for (let j = 1; j &lt;= i; j++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem13(); 14. 삼각형 출력하기 - pattern 4다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 12345678910111213141516171819function problem14() &#123; console.log('14번 문제입니다.'); const line = 5; let star = ''; for (let i = line; i &gt; 0; i--) &#123; for (let j = i - 1; j &gt; 0; j--) &#123; star += ' '; &#125; for (let k = i - 1; k &lt; line; k++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem14(); 15. 정삼각형 출력하기 12345678910111213141516171819function problem15() &#123; console.log('15번 문제입니다.'); const line = 5; let star = ''; for (let i = 0; i &lt; line; i++) &#123; for (let j = 4; j &gt; i; j--) &#123; star += ' '; &#125; for (let k = 0; k &lt; (i * 2) + 1; k++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem15(); 16. 역정삼각형 출력하기 123456789101112131415161718function problem16() &#123; console.log('16번 문제입니다.'); const line = 5; let star = ''; for (let i = line; i &gt; 0; i--) &#123; for (let j = line; j &gt; i; j--) &#123; star += ' '; &#125; for (let k = 0; k &lt; (i * 2) - 1; k++) &#123; star += '*'; &#125; star += '\\n'; &#125; console.log(star); console.log('-------------------');&#125;problem16();","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Poiema","slug":"Poiema","permalink":"https://hyeok999.github.io/tags/Poiema/"}]},{"title":"javascript-study-05","slug":"javascript-study-05","date":"2019-10-08T04:21:55.000Z","updated":"2019-11-30T16:30:08.228Z","comments":true,"path":"2019/10/08/javascript-study-05/","link":"","permalink":"https://hyeok999.github.io/2019/10/08/javascript-study-05/","excerpt":"","text":"JavaScript Study 05 용어 제어문 블록문 조건문 if ~ else , else if switch( ) 반복문 for 문 while 문 do~while 문 break 문 레이블문 continue 문 타입변환 (암묵적) 문자열 타입 변환 (암묵적) 숫자 타입 변환 (암묵적) 불리언 타입 변환 (명시적) 문자열 타입 변환 용어 - ( 러버덕 ) 제어문 예제 ( 16가지 ) 제어문 블록문 0개 이상의 { } 로 묶은 것으로 코드 블록 또는 블록이라고 부른다. ( 하나의 실행단위 ) 조건문 주어진 조건식의 평가 결과에 따라 코드 블럭의 실행을 결정한다. if ... else 문 swith 문 1. if ~ else , else if12345if (조건식) &#123; // 조건식이 참이면 이 코드 블록이 실행된다.&#125; else &#123; // 조건식이 거짓이면 이 코드 블록이 실행된다.&#125; *else if 문과 else 문은 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. * if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다. 2. switch( )12345678910switch (표현식) &#123; case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;&#125; *switch문은 반드시 break; 동반 해야만 한다. * break;가 없다면 맞는 조건이어도 다음 case 표현식으로 넘어가게 된다. default에는 break; 생략이 가능하다. 반복문 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. for ( for-in, for-of ) , while , do~while 1. for문123for (변수 선언문 또는 할당문; 조건식; 증감식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 만약 , 모두 비워있다면 무한 루프가 된다. 123for(;;)&#123; 내용;&#125; 예제, 중첩 for문을 이용한 주사위 눈 합 12345for (var i = 1; i &lt;= 6; i++) &#123; for (var j = 1; j &lt;= 6; j++) &#123; if (i + j === 6) console.log(`[$&#123;i&#125;, $&#123;j&#125;]`); &#125;&#125; 자바스크립트에서 for문 대체 함수들 ​ 실무에서는 반복문 대신 아래 함수들을 더 많이 사용한다. 왠만해서는 가독성이 안좋다는 이유로 인해 반복을 안쓰려한다. 다만, 기본적인 for문을 다룰줄 알아야 아래 기능들에 대해 더 쉽게 이해가 가능하다. forEach map filter find reduce 2. while 문123while (조건식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; while문은 조건식이 true라면 무한루프가 된다. 12// 무한루프while (true) &#123; ... &#125; 무한 루프를 탈출 하기 위해서는 특정조건으로 인한 break; 를 추가하여야 한다. 3. do…while 문123do&#123; 최소 1번은 실행되고 그 후부터는 조건에 맞을 경우 반복 실행된다.&#125; while (조건식); do...while문은 최소 1번은 실행된 뒤 조건을 판별하여 게속해서 반복할지 안할지 유무를 결정한다. break 문 가장 가까운 레이블 문, 반복문( for, for-in, for-of, while, do…while ) 또는 switch문의 코드 블록을 탈출한다. 이외에 문에서 사용시 SyntaxError를 유발한다. 레이블 문이란? 식별자가 붙은 문을 의미한다. 12// foo라는 레이블 식별자가 붙은 레이블 문foo: console.log('foo'); 레이블문은 중첩for문에서 외부for문까지 한번에 빠져나가고자 할 때 이용한다. 12345678910// outer라는 식별자가 붙은 레이블 for 문outer: for (var i = 0; i &lt; 3; i++) &#123; for (var j = 0; j &lt; 3; j++) &#123; // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다. if (i + j === 3) break outer; console.log('inner ' + j); &#125;&#125;console.log('Done!'); continue 문 continue 문은 현재 진행되고 있는 반복문의 증감식을 중단하고 다음 증감식으로 이동한다. break문과 다르게 반복문을 탈출하지 않는다. 문자열자바스크립트의 문자열은 유사 배열이다.객체를 배열처럼 사용하는 것은 유사 배열 이다.배열은 원시값 + 객체이다.문자열(배열)을 만들고서 .을 찍어보면 프로퍼티가 나온다.즉, 문자열은 유사배열이다.따라서 문자열을 for문으로 접근하여 1문자씩 읽어들일 수 있다. 타입 변환 명시적 타입 변환 ( 타입 캐스팅 ) : 개발자에 의도하에 값의 타입을 변환하는 것. 암묵적 타입 변환 ( 강제 타입 변환 ) : 개발자에 의도하는 관계 없이 JS엔진에 의해 타입이 자동으로 변환되는 것. 1234567// 명시적 타입 변환var x = 10;var str = x.toString(); // '10';// 암묵적 타입 변환var x = 10;var str = x + ''; // '10'; 연산자의 부수효과​ 연산자 중 유일하게 피연산자의 값을 변경하는 연산자는 증가 ++ 와 감소 --밖에 없다. 암묵적 타입변환을 예상하는 방법. 어떻게해야 자바스크립트 엔진이 해당 구문을 보고 에러를 내지않을까? 라는 취지로 접근한다. 예 ) 123456789// 피연산자가 모두 문자열 타입이여야 하는 문맥'10' + 2 // '102'// 피연산자가 모두 숫자 타입이여야 하는 문맥5 * '10' // 50// 피연산자 또는 표현식이 불리언 타입이여야 하는 문맥!0 // trueif (1) &#123; &#125; (암묵적) 문자열 타입으로 변환121 + '2' // '12'console.log(`1 + 1 = $&#123;1 + 1&#125;`); // \"1 + 1 = 2\" 문자열 인터폴레이션 $&#123; 표현식 &#125; (암묵적) 숫자 타입으로 변환- * 는 대부분의 문자열을 숫자 타입으로 암묵적 타입변환시킨다. 1231 - '1' // 01 * '10' // 101 / 'one' // NaN + 추가&gt; &lt; = 등의 비교 연산자 또한 숫자타입으로 변환시킬 때도 있다. (다만, 이러한 경우가 최대한 안나오게 해야한다. 안좋은 코드) 1'1' &gt; 0 // true ++추가 단항 연산자를 이용하여 문자열 변환123456789101112131415161718192021222324// 문자열 타입+'' // 0+'0' // 0+'1' // 1+'string' // NaN// 불리언 타입+true // 1+false // 0// null 타입+null // 0// undefined 타입+undefined // NaN// 심볼 타입+Symbol() // TypeError: Cannot convert a Symbol value to a number// 객체 타입+&#123;&#125; // NaN+[] // 0+[10, 20] // NaN+(function()&#123;&#125;) // NaN (암묵적) 불리언 타입으로 변환불리언 값으로 평가되어야 할 문맥에서 false로 평가되는 Falsy 값이다. false undefined null 0, -0 NaN ’’ (빈문자열) (명시적) 문자열 타입으로 변환문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 아래와 같다. String 생성자 함수를 new 연산자 없이 호출하는 방법 ( 실무에서 잘 사용 안함 ) Object.prototype.toString 메소드를 사용하는 방법 ( 실무에서 잘 사용 안함 ) 문자열 연결 연산자를 이용하는 방법 = (암묵적) 경험자 입장에서 제일 가독성이 뛰어남. 1234567891011121314151617181920212223242526// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(Infinity)); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(String(true)); // \"true\"console.log(String(false)); // \"false\"// 2. Object.prototype.toString 메소드를 사용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log((1).toString()); // \"1\"console.log((NaN).toString()); // \"NaN\"console.log((Infinity).toString()); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log((true).toString()); // \"true\"console.log((false).toString()); // \"false\"// 3. 문자열 연결 연산자를 이용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(Infinity + ''); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(true + ''); // \"true\"console.log(false + ''); // \"false\"","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 7강~9강(제어문,타입변환 과 단축평가, 객체리터럴)","slug":"javascript-preview-070809","date":"2019-10-07T15:33:18.000Z","updated":"2019-11-30T16:31:41.626Z","comments":true,"path":"2019/10/08/javascript-preview-070809/","link":"","permalink":"https://hyeok999.github.io/2019/10/08/javascript-preview-070809/","excerpt":"","text":"JavaScript 7강~9강 예습 7강 : 제어문 블록문 이란? 조건문 if문 switch문 반복문 for문 while문 do~while문 break문 label 문 continue문 8강 : 타입 변환과 단축 평가 타입변환이란? 명시적 타입 변환 암묵적 타입 변환 문자열 타입으로 변환 숫자 타입으로 변환 불리언 타입으로 변환 단축 평가 9강 : 객체 리터럴 객체란? 객체 타입 객체 리터럴에 의한 객체 생성 객체 리터럴 프로퍼티 프로퍼티 키, 메소드 프로퍼티 접근 프로퍼티 키 동적생성 프로퍼티 삭제 ES6에서 추가된 기능 객체 리터럴의 확장 기능 프로퍼티 키 동적 생성 메소드 축약표현 7강제어문 블록문 이란? 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 한다. 블록문은 JS에서 하나의 실행단위. 블록문의 끝에는 세미콜론( ; )을 붙이지 않는다. 제어문 혹은 함수선언문에 이용한다. 123456789101112131415161718// 블록문&#123; var foo = 10; console.log(foo);&#125;// 제어문var x = 0;while (x &lt; 10) &#123; x++;&#125;console.log(x); // 10// 함수 선언문function sum(a, b) &#123; return a + b;&#125;console.log(sum(1, 2)); // 3 조건문 주어진 조건식의 평가 결과에 따라 코드 블럭의 실행을 결정한다. if ... else 문 swith 문 1. if ~ else , else if12345if (조건식) &#123; // 조건식이 참이면 이 코드 블록이 실행된다.&#125; else &#123; // 조건식이 거짓이면 이 코드 블록이 실행된다.&#125; *else if 문과 else 문은 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. * if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다. 2. switch( )12345678910switch (표현식) &#123; case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;&#125; *switch문은 반드시 break; 동반 해야만 한다. * break;가 없다면 맞는 조건이어도 다음 case 표현식으로 넘어가게 된다. default에는 break; 생략이 가능하다. 반복문 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. for ( for-in, for-of ) , while , do~while 1. for문123for (변수 선언문 또는 할당문; 조건식; 증감식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 만약 , 모두 비워있다면 무한 루프가 된다. 123for(;;)&#123; 내용;&#125; 예제, 중첩 for문을 이용한 주사위 눈 합 12345for (var i = 1; i &lt;= 6; i++) &#123; for (var j = 1; j &lt;= 6; j++) &#123; if (i + j === 6) console.log(`[$&#123;i&#125;, $&#123;j&#125;]`); &#125;&#125; 2. while 문123while (조건식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; while문은 조건식이 true라면 무한루프가 된다. 12// 무한루프while (true) &#123; ... &#125; 무한 루프를 탈출 하기 위해서는 특정조건으로 인한 break; 를 추가하여야 한다. 예제, count가 3이면 코드 탈출 123456789var count = 0;// 무한루프while (true) &#123; console.log(count); count++; // count가 3이면 코드 블록을 탈출한다. if (count === 3) break;&#125; // 0 1 2 3. do…while 문123do&#123; 최소 1번은 실행되고 그 후부터는 조건에 맞을 경우 반복 실행된다.&#125; while (조건식); do...while문은 최소 1번은 실행된 뒤 조건을 판별하여 게속해서 반복할지 안할지 유무를 결정한다. break 문 가장 가까운 레이블 문, 반복문( for, for-in, for-of, while, do…while ) 또는 switch문의 코드 블록을 탈출한다. 이외에 문에서 사용시 SyntaxError를 유발한다. 레이블 문이란? 식별자가 붙은 문을 의미한다. 12// foo라는 레이블 식별자가 붙은 레이블 문foo: console.log('foo'); 레이블문은 중첩for문에서 외부for문까지 한번에 빠져나가고자 할 때 이용한다. 12345678910// outer라는 식별자가 붙은 레이블 for 문outer: for (var i = 0; i &lt; 3; i++) &#123; for (var j = 0; j &lt; 3; j++) &#123; // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다. if (i + j === 3) break outer; console.log('inner ' + j); &#125;&#125;console.log('Done!'); 예제 : 특정 문자열 찾기 123456789101112var string = 'Hello World';var search = 'l';var index;for(var i = 0; i &lt; String.length; i++) &#123; if(string[i] === search)&#123; index = i; break; &#125;&#125;console.log(index); 위와 똑같이 동작하는 메소드 12345var string = 'Hello World';var search = 'l';var index;console.log(string.indexOf(search)); // 2 continue 문 continue 문은 현재 진행되고 있는 반복문의 증감식을 중단하고 다음 증감식으로 이동한다. break문과 다르게 반복문을 탈출하지 않는다. 1234567891011121314151617181920var string = 'Hello World.';var search = 'l';var count = 0;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) &#123; // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다. if (string[i] !== search) &#123; continue; &#125; count++; // continue 문이 실행되면 이 문은 실행되지 않는다.&#125;console.log(count); // 3// 위 예제의 for 문은 아래와 동일하게 동작한다.for (var i = 0; i &lt; string.length; i++) &#123; // 'l'이면 카운트를 증가시킨다. if (string[i] === search) count++;&#125; 위와 똑같이 동작하는 메소드 123456var string = 'Hello World.';var search = 'l';var count = 0;const regexp = new RegExp(search, 'g');console.log(string.match(regexp).length); // 3 8강타입 변환과 단축 평가 타입 변환이란? 자바스크립트는 값에 타입이 있다. 값의 타입을 개발자의 의도에 의하여 다른 타입으로 변환이 가능하다. 이를 명시적 타입 변환 또는 타입캐스팅 이라 칭한다. 명시적 타입 변환12345var x = 10;// 명시적 타입 변환// 숫자를 문자열로 타입 캐스팅한다.var str = x.toString(); // str은 문자열 '10'을 지니고 있다. 또 반대로 JS엔진을 통하여 개발자의 의도와는 별개로 암묵적으로 타입이 자동 변환 될 수도 있다. 이를 암묵적 타입 변환 또는 타입 강제 변환 이라고 한다. 12345var x = 10;// 암묵적 타입 변환// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.var str = x + ''; 암묵적 타입 변환 과 명시적 타입 변환 둘다 원시값 자체를 변경할 수 없다, 원시값을 바꿀 수 있는 방법은 재할당 뿐이다. 암묵적 타입 변환 자바스크립트 엔진은 표현식을 평가할 때 코드의 문맥을 고려하여 암묵적 타입 변환을 실행한다. 문자열 타입으로 변환 피연산자 중 + 연산자 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 1234567891011121314151617181920212223242526272829// 숫자 타입0 + '' // \"0\"-0 + '' // \"0\"1 + '' // \"1\"-1 + '' // \"-1\"NaN + '' // \"NaN\"Infinity + '' // \"Infinity\"-Infinity + '' // \"-Infinity\"// 불리언 타입true + '' // \"true\"false + '' // \"false\"// null 타입null + '' // \"null\"// undefined 타입undefined + '' // \"undefined\"// 심볼 타입(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string// 객체 타입(&#123;&#125;) + '' // \"[object Object]\"Math + '' // \"[object Math]\"[] + '' // \"\"[10, 20] + '' // \"10,20\"(function()&#123;&#125;) + '' // \"function()&#123;&#125;\"Array + '' // \"function Array() &#123; [native code] &#125;\" 숫자 타입으로 변환 산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 피연산자 와 - * / 의 연산자 경우 하나 이상이 숫자 이므로 숫자 연사자로 동작한다. 1231 - '1' // 01 * '10' // 101 / 'one' // NaN 피연산자를 숫자 타입으로 변환할 수 없는 경우. 산술이 불가능하다. 단항 연산자의 +의 경우까지 숫자 타입으로 변환한다. 123456789101112131415161718192021222324// 문자열 타입+'' // 0+'0' // 0+'1' // 1+'string' // NaN// 불리언 타입+true // 1+false // 0// null 타입+null // 0// undefined 타입+undefined // NaN// 심볼 타입+Symbol() // TypeError: Cannot convert a Symbol value to a number// 객체 타입+&#123;&#125; // NaN+[] // 0+[10, 20] // NaN+(function()&#123;&#125;) // NaN 불리언 타입으로 변환 1234567if ('') console.log('1'); //falseif (true) console.log('2'); //trueif (0) console.log('3'); //falseif ('str') console.log('4'); //trueif (null) console.log('5'); //false// 2 4 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 인식할 값) 또는 Falsy 값(거짓으로 인식할 값)으로 구분한다. Truthy 값은 true로, Falsy 값은 false로 변환. false undefined null 0, -0 NaN ’ ’ (빈문자열) 위 예 들은 모두 false 로 평가되는 Falsy 값이다. 이외의 값들은 모두 Truthy, true로 평가된다. 아래 예제는 Truthy/Falsy 값을 판별하는 함수다. 함수 함수란 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. 123456789101112131415161718192021222324// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.function isFalsy(v) &#123; return !v;&#125;// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.function isTruthy(v) &#123; return !!v;&#125;// 모두 true를 반환한다.console.log(isFalsy(false));console.log(isFalsy(undefined));console.log(isFalsy(null));console.log(isFalsy(0));console.log(isFalsy(NaN));console.log(isFalsy(''));// 모두 true를 반환한다.console.log(isTruthy(true));// 빈 문자열이 아닌 문자열은 Truthy 값이다.console.log(isTruthy('0'));console.log(isTruthy(&#123;&#125;));console.log(isTruthy([])); 단축 평가 단축 평가 표현식 평가 결과 true || anything true false || anything anything true &amp;&amp; anything anything false &amp;&amp; anything false 즉, 결과를 되는 연산을 하였을 값을 출력한다 . 예를들어보자, 123456789// 논리합(||) 연산자'Cat' || 'Dog' // 'Cat' - 캣이 이미 true이므로 연산의 결과는 캣이다.false || 'Dog' // 'Dog' - 도그가 true라면 참이므로 연산의 결과 도그이다.'Cat' || false // 'Cat' - 캣이 이미 true이므로 연산의 결과는 캣이다.// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog' // Dog - 도그가 false라면 틀린값인데 결국 도그가 true이기 때문에 결과는 도그다.false &amp;&amp; 'Dog' // false - 도그가 true여도 이미 false가 존재하기 때문에 false'Cat' &amp;&amp; false // false - 캣이 ture여도 이미 false가 존재하기 때문에 false 단축 평가는 아래와 같은 경우 유용하게 사용된다. 1234var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null 함수를 호출할 때 인수를 전달하지 않을 경우 매개변수는 undefined를 갖게 된다. 12345function test(str)&#123; console.log(`현재 타입은 %&#123;typeof(str)&#125;`);&#125;test(); // 현재 타입은 undefined 입니다. 매개 변수를 전달하지 않았다. 함수 매개변수에 기본값을 설정할 때, 12345678910111213141516// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) &#123; str = str || ''; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') &#123; return str.length;&#125;getStringLength(); // 0getStringLength('hi'); // 2 9강객체 리터럴 객체란? 자바스크립트 객체 기반의 프로그래밍 언어이며 JS를 이루고 있는 거의 모든것이 객체다. 원시 타입을 제외한 나머지 값들(함수, 배열 , 정규표현식 등등)은 모두 객체이다. 객체 타입은 원시타입과 다르게 변경가능한 값이다. 객체타입​ 객체 타입은 다양한 타입의 값(원시 타입의 값 또는 다른 객체)들을 하나의 단위로 구성한 복잡한 자료 구조이다. 자바스크립트에서 사용할 수 있는 모드 값은 프로퍼티 값이 될 수 있다. 자바스크립트에서 함수는 값으로 취급이 가능하다. 프로퍼티 값으로 함수를 사용할 수 있다. (이를, 일반 함수랑 구분하기 위해서 메소드라 한다) 정리하면, 객체는 프로퍼티( 키 , 값 ) 와 메소드로 구성된 집합체. 프로퍼티: 객체의 상태를 나타내는 값(data) 메소드 : 프로퍼티를 참조하고 조작할 수 있는 동작(behavior) 객체와 함수 : 자바스크립트에서 함수로 객체를 생성하기 하며 함수 자체는 곧 객체이다. 객체 리터럴에 의한 객체 생성자바스크립트에 객체 생성 방법. 객체 리터럴 Object 생성자 함수 생성자 함수 (new 연산자) Object.create 메소드 클래스( ES6 ) 객체리터럴​ 객체를 선언하기 위한 가장 일반적인 방법이다.​ 객체 리터럴의 중괄호는 코드 블록을 의미하지 않음에 주의 12345678910111213var empty = &#123;&#125;; // 빈 객체console.log(typeof empty); // object// 할당이 이루어지는 시점에 객체 리터럴이 해석되고 그 결과 객체가 생성된다.var person = &#123; name: 'Lee', sayHello: function () &#123; console.log(`Hello! My name is $&#123;this.name&#125;.`); &#125;&#125;;console.log(typeof person); // objectconsole.log(person); // &#123;name: \"Lee\", sayHello: ƒ&#125; 프로퍼티 객체는 프로퍼티(Property)들 와 메소드의 집합이며 프로퍼티는 키(key)과 값(value)으로 구성된다. 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 프로퍼티 키 프로퍼티의 키는 식별자 네이밍 규칙을 준수할 경우와 준수하지 않을 경우로 나뉜다. 123456var person = &#123; first_name: 'Kim', // 유효한 이름 'last-name': 'Lee' // 유효하지 않은 이름&#125;;console.log(person); // &#123;first_name: \"Kim\", last-name: \"Lee\"&#125; 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표( ‘ )를 사용하여야 한다. 만약, 따옴표를 사용하지 않을 경우 SyntaxError를 일으킨다. 값을 반환하는 표현식을 이용해 프로퍼티 키를 동적으로 생성도 가능하다. 이 경우 사용할 표현식은 [ ]로 묶는다. 123456789var obj = &#123;&#125;;var key = 'hello';// ES5: 프로퍼티 키 동적 생성obj[key] = 'world';// ES6: 프로퍼티 키 동적 생성// var obj = &#123; [key]: 'world' &#125;;console.log(obj); // &#123;hello: \"world\"&#125; ++추가로 빈 문자열 이나 var, function와 같은 예약어를 프로퍼티 키를 사용해도 에러는 발생하지 않지만, 권장하지 않는다. 이미 존재하는 프로퍼티 키를 중복 선언시 나중 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 프로퍼티 키에 문자열이나 symbol값 이외의 값을 쓰면 암묵적으로 문자열이된다. 메소드​ 프로퍼티의 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드( Method )라 부른다. 즉, 메소드는 객체에 제한되어 있는 함수를 의미한다. 12345678910var circle = &#123; radius: 5, // ← 프로퍼티 // 원의 지름 getDiameter: function () &#123; // ← 메소드 return 2 * this.radius; // this는 circle를 가리킨다. &#125;&#125;;console.log(circle.getDiameter()); // 10 프로퍼티 접근 마침표 표기법 대괄호 표기법 프로퍼티 키가 식별자 네이밍 규칙을 따르고 있다면 마침표 표기법과 대괄호 표기법을 모두 사용이 가능하다. 123456789var person = &#123; name: 'Lee'&#125;;// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Lee// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Lee 주의 : 대괄호 표기법을 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 12345var person = &#123; name: 'Lee'&#125;;console.log(person[name]); // ReferenceError: name is not defined 존재 하지 않는 프로퍼티에 접근할 경우, undefined를 반환한다. 12345var person = &#123; name: 'Lee'&#125;;console.log(person.age); // undefined ,ReferenceError가 발생하지 않는다. 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름. 즉 유효하지 않음 이름이라면 반드시 대괄호 표기법을 이용한다. 이는 숫자로만 이루언 프로퍼티 키도 포함이다. 단, 숫자로 이루어진 프로퍼티키는 따옴표를 생략할 수 있다. 123456789101112131415var person = &#123; 'last-name': 'Lee', 1: 10&#125;;console.log(person.'last-name'); // SyntaxError: Unexpected stringconsole.log(person.last-name); // ReferenceError: name is not definedconsole.log(person[last-name]); // ReferenceError: last is not definedconsole.log(person['last-name']); // Lee// 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 따옴표를 생략 가능하다.console.log(person.1); // SyntaxError: missing ) after argument listconsole.log(person.'1'); // SyntaxError: Unexpected stringconsole.log(person[1]); // 10 : person[1] -&gt; person['1']console.log(person['1']); // 10 프로퍼티 키 동적생성123456789var person = &#123; name: 'Lee'&#125;;// person객체에 address 프로퍼티가 존재하지 않는다.// 따라서 person객체에 address 프로퍼티가 동적으로 생성되고 값이 할당된다.person.address = 'Seoul';console.log(person); // &#123;name: \"Lee\", address: \"Seoul\"&#125; 프로퍼티 삭제 delete 연산자 는 객체의 프로퍼티를 삭제한다. 존재하지 앟는 프로퍼티를 삭제하면 아무런 에러없이 무시된다. 12345678910111213141516var person = &#123; name: 'Lee'&#125;;// 프로퍼티 동적 추가person.address = 'Seoul';// person 객체에 address 프로퍼티가 존재한다.// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 있다.delete person.address;// person 객체에 age 프로퍼티가 존재하지 않는다.// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.delete person.age;console.log(person); // &#123;name: \"Lee\"&#125; ES6에서 추가된 기능객체 리터럴의 확장 기능 (ES5 VS ES6)ES5에서는 변수에 선언된 값을 프로퍼티 키의 값에 재할당 해주는 방면으로 이용하였다. 123456789// ES5var x = 1, y = 2;var obj = &#123; x: x, y: y&#125;;console.log(obj); // &#123;x: 1, y: 2&#125; ES6에서는 프로퍼티의 키 명과 변수의 명이 같을 경우 키를 생략하고 대입이 가능하다. 이때, 프로퍼티 키는 변수이름으로도 자동 생성된다. 1234567// ES6let x = 1, y = 2;// 프로퍼티 축약 표현const obj = &#123; x, y &#125;;console.log(obj); // &#123;x: 1, y: 2&#125; 프로퍼티 키 동적 생성 (ES5 VS ES6)​ 문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 단, 이때 표현식은 대괄호를 이용해야하며, 이를 계산된 프로퍼티 이름이라 칭한다. 12345678910// ES5var prefix = 'prop';var i = 0;var obj = &#123;&#125;; obj[prefix + '-' + ++i] = i; obj[prefix + '-' + ++i] = i; obj[prefix + '-' + ++i] = i;console.log(obj) // &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125; 1234567891011// ES6var prefix = 'prop';var i = 0;var obj = &#123; [`$&#123;prefix&#125;-$&#123;++i&#125;`] : i, [`$&#123;prefix&#125;-$&#123;++i&#125;`] : i, [`$&#123;prefix&#125;-$&#123;++i&#125;`] : i&#125;;console.log(obj) // &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125; 메소드 축약 표현 (ES5 VS ES6)123456789// ES5var obj = &#123; name: 'Lee', sayHo: function()&#123; console.log('My Name is ' + this.name); &#125;&#125;obj.sayHo(); //My Name is Lee 12345678910// ES6var obj = &#123; name: 'Lee', // ES6의 메소드 축약표현 sayHo()&#123; console.log('My Name is ' + this.name); &#125;&#125;obj.sayHo(); //My Name is Lee","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript-study-04","slug":"javascript-study-04","date":"2019-10-07T09:05:57.000Z","updated":"2019-11-30T16:30:15.263Z","comments":true,"path":"2019/10/07/javascript-study-04/","link":"","permalink":"https://hyeok999.github.io/2019/10/07/javascript-study-04/","excerpt":"","text":"JavaScript Study 04 용어 변수 명명 데이터 타입의 정의 데이터 타입의 종류 숫자 타입 문자열 타입 불리언 타입 undefined 타입 null 타입 동적 타이밍 연산자 이항 산술 연산자 단항 산술 연산자 문자열 연결 연산자 할당 연산자 비교 연산자 삼항 조건 연산자 논리 조건 연산자 그룹 연산자 typeof 연산자 지수 연산자 용어 - ( 러버덕 ) 네이밍 케이스 데이터 타입 동적 타이핑 변수명명 변수의 이름을 지정할 때에는 항상 고민하고 신중해야만한다. 식별자 이름 : 숫자 , 문자 , 특수기호(_ , $) 규칙1 : 맨 앞자리 숫자 불가능 규칙2 : 예약어는 쓸 수 없다.(var , let, const , function …) 규칙3 : 대소문자를 구별한다. 규칙4 : 단어와 단어의 사이는 특정기법을 이용한다.(카멜케이스같은) 규칙5 : 변수 이름이 전체다 대문자라면 상수다. 주석은 최대한 적게 쓰도록, 변수명을 제대로 적어야만 한다. 특정기법 카멜케이스 : 변수 / 함수 1var firstName; 스네이크케이스 : javascript 에서 잘 사용하지 않는다. 1var first_name; 파스칼 케이스 : 생성자 함수, 클래스 이름 1var FirstName; 헝가리언 케이스 12var strFirstName; // type + identifiervar $elem = $('.myClass') // jQuery 데이터 타입의 정의 값의 종류 데이터 타입을 알아야 메모리 공간을 확보가 가능하다. (타입마다 확보할 메모리공간이 다르다.) 데이터를 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기 를 알 수 있다. 값을 어떻게 해석하는지 알 수 있다. 값을 만들어내는 방법 값 : 리터럴 표기법은 값을 만들어내는 가장 기본적인 방법이다. 표현식 : 평가되어 하나의 값을 만들어낸다. 값 더 이상 평가할 수 없는 최소 표현식(토큰) 자신을 평가시 자신이 나온다면 그것은 값 이다. ( ex : 30을 평가하면 30이다. ) 리터럴 표기법에 의하여 만들어진다. 표현식에 의하여 만들어진다. 평가 표현식 등의 결과를 새로운 값으로 반환한다. 표현식 하나의 값으로 평가될 수 있는 문. 평가되어 하나의 값을 표현하는 방법. (리터럴, 식별자(변수,함수), 연산자, 함수 호출등의 조합) 하나 이상의 리터럴, 하나 이상의 표현식 , 연상자등으로 구성된 문. 식별자도 결국 표현식이다. 123var a = 10;var b = a; // a라는 식별자(표현식)가 평가되어 10이라는 값을 반환하였고 b는 10이라는 값을 가리킨다. 리터럴 변수나 상수를 나타내는 값 자체; 소스 코드 안에서 직접 만들어낸 고정된 값. 리터럴 자체는 표현식이지만, 연산이 들어간 표현식은 리터럴이 될 수 없다.( 10 + 20 ) Symbol 심볼은 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용한다. (추후 다시 공부) 데이터 타입의 종류원시 타입 ( primitive ) - 6가지의 데이터 타입 : 숫자 ,문자열 ,boolean , null, undefined, Symbol ​ boolean : 평가 결과가 true 또는 false를 반환하는 데이터타입 ​ null : 변수에 값이 없다는것을 의도적으로 나타냄. (의도적 부재) ​ undefined : 변수를 선언하고 할당하지 않을 경우. 암묵적으로 javascript엔진에 의하여 초기화되는 값. 객체 타입 : 객체, 함수, 배열 숫자타입 C나 Java의 경우, 정수와 실수를 구분하여 int, long, float, double 등과 같은 다양한 숫자 타입이 존재한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다. 숫자 타입은 추가적으로 3가지 특별한 값들도 표현할 수 있다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not-a-number) 1234// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN - NaN대소문자 주의 ( nan,NAN 등등 다 안됨. ) 문자열 타입 텍스트 데이터를 나타내는데 사용한다. 작은 따옴표(‘’), 큰 따옴표(“”) 또는 백틱(``) 안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다. ++ 추가 ​ : 자바스크립트에서는 개행, 백스페이스 등을 나타낼수있는 이스케이스프 시퀀스를 지원한다. 이스케이프 시퀀스 의미 \\0 Null \\b 백스페이스 \\f 새로운 페이지 \\n 개행(LF, Line Feed) \\r 캐리지 리턴(CR, Carriage Return) \\t 탭(수평) \\v 탭(수직) \\’ 작은 따옴표 \\” 큰 따옴표 \\ 백슬래시 예를 들어, 줄바꿈과 들여쓰기가 적용된 HTML 문자열은 아래와 같이 이스케이프 시퀀스를 사용하여 작성한다. 근데 개행등의 불편함을 막기 위해스 ES6부터는 백틱( ` ) 이 사용이 가능하다. 1234567891011// ES5var template = '&lt;ul class=\"nav-items\"&gt;\\n';template += '\\t&lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt;\\n';template += '\\t&lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;\\n';template += '&lt;/ul&gt;';// ES6 - 백틱const template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`; 문자열 인터폴레이션​ 리터럴 문자열 연산을 더 쉽게 하기 위한 ES6의 새로운 기능. ​ ${ } 는 백틱 안에서만 사용이 가능하다. 1234567var first = 'Ung-mo';var last = 'Lee';// ES5: 문자열 연결console.log('My name is ' + first + ' ' + last + '.');// ES6: String Interpolation 문자열 인터폴레이션console.log(`My name is $&#123;first&#125; $&#123;last&#125;.`); 불리언 타입 불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다. undefined 타입 선언 이후 명시적으로 값을 할당하지 않은 변수는 자바스크립트 엔진의 암묵적 초기화에 의해 undefined 값을 가진다. 선언은 되었지만 아직 값을 할당하지 않은 변수에 접근하면 undefined가 반환된다. 선언 과 정의 자바스크립트의 선언, 식별자가 생성되었지만 값이 아직 할당되지 않은 상태 자바스크립트의 정의, 식별자가 생성되었고 값까지 할당되어 있는 상태를 의미한다. 123456// 변수 선언. 내부적으로 undefined로 정의된다.var foo;// 변수 선언과 정의var bar = 1;// 함수 정의. 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.function baz &#123;&#125; null 타입 null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 Intentional absence)할 때 사용한다. ++추가 : 자바스크립트에서는 null값을 사용하는 것보다, 변수의 생명주기에 대해서 이해하고 사용하는 것이 더 바람직하고 유용하다. Symbol 타입 / 객체 타입 추후 다시 공부 동적 타이핑정적 타입 언어 : 변수 자체에 데이터 타입을 사전에 선언한다. (int num, float num, char c 등등) 동적 타입 언어 : 변수에 데이터 타입을 알리지않는다. 대신 var / let / const등과 같이 키워드로 변수를 선언함만을 알린다.대신, 동적타입 언어는 변수가 아닌 값에 의해 타입이 정해진다. 정적 타입 언어 동적 타입 언어 장점 엄격한 규칙으로 인해 버그 발생률을 줄인다. 유연하다. 사용하기 편리하다. 단점 규칙이 엄격하다. 다루기 불편하다. 코드가 길어질수록 점점 변수에 해당되는 값을 알기가 힘들어진다. 자바스크립트는 동적 타입 언어이다. 동적 타입 언어는 정적처럼 변수에 타입을 지정하지 않기 때문에 버그 발생률을 높이는 치명적인 단점을 가지고 있기에 이를 해결하기 위해 TypeScript가 나타났다. 문 ; 으로 끝나면 모두 문 이다. 하나 이상의 표현식과 키워드의 조합. 변수에 할당할 수 있는 문 : 표현식인 문 변수에 할달할 수 없는 문 : 표현식이 아닌 문 표현식의 역할은 값을 생성하는 것 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것 세미콜론 자동 삽입 기능 ( ASI : automati semicolon insertion ) 자바스크립트 엔진에는 소스 코드를 해석할 때, 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 있다. 하지만, 왠만해서는 세미콜론을 사용하도록 한다. 연산자이항 산술 연산자조건 : 2개의 피연산자 필요. 이항 산술 연산자 의미 부수 효과 + 덧셈 ✕ - 뺄셈 ✕ * 곱셈 ✕ / 나눗셈 ✕ % 나머지 ✕ 단항 산술 연산자조건 : 1개의 연산자 필요. 단항 산술 연산자 의미 부수 효과 ++ 증가 ○ – 감소 ○ + 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. ✕ - 양수를 음수로 음수를 양수로 반전한 값을 반환한다. ✕ 문자열 연결 연산자12345678910111213141516171819// 문자열 연결 연산자'1' + 2; // -&gt; '12'1 + '2'; // -&gt; '12'// 산술 연산자1 + 2; // -&gt; 3// true는 1로 타입 변환된다.1 + true; // -&gt; 2// false는 0으로 타입 변환된다.1 + false; // -&gt; 1// null는 0으로 타입 변환된다.1 + null; // -&gt; 1// undefined는 숫자로 타입 변환되지 않는다.+undefined; // -&gt; NaN1 + undefined; // -&gt; NaN 할당 연산자우항의 피연산자의 결과가 좌항에있는 변수에 할당된다. 할당 연산자 사례 동일 표현 부수 효과 = x = 5 x = 5 ○ += x += 5 x = x + 5 ○ -= x -= 5 x = x - 5 ○ *= x *= 5 x = x * 5 ○ /= x /= 5 x = x / 5 ○ %= x %= 5 x = x % 5 ○ 비교 연산자비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다. 조건 : 피연산자 2개 비교 연산자 의미 사례 설명 부수 효과 == 동등 비교 x == y x와 y의 값이 같음 ✕ === 일치 비교 x === y x와 y의 값과 타입이 같음 ✕ != 부동등 비교 x != y x와 y의 값이 다름 ✕ !== 불일치 비교 x !== y x와 y의 값과 타입이 다름 ✕ 왠만하면 === 을 사용할것. 1234567// 일치 비교5 === 5; // -&gt; true// 암묵적 타입 변환을 하지 않고 값을 비교한다.// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.5 === '5'; // -&gt; false5 == '5' // -&gt; true 예외) NaN은 자신과 비교하면 false가 나온다. 12// NaN은 자신과 일치하지 않는 유일한 값이다.NaN === NaN; // -&gt; false 삼항 조건 연산자 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값 if문을 한줄로 표현이 가능할 때 자주사용한다. 삼항 조건 연산자 if 문 var x = 2;var result = x % 2 ? ‘홀수’ : ‘짝수’;console.log(result); // 짝수 var x = 2;if(x % 2){ var result = “홀수”}else{ var result = “짝수”} x( 2 ) 를 나눈 값의 나머지가 0인데 어째서 결과가 짝수인가? x % 2 = 0이다. 조건에서 0은 false를 의미한다. 논리 연산자 논리 연산자 의미 부수 효과 || 논리합(OR) ✕ &amp;&amp; 논리곱(AND) ✕ ! 부정(NOT) ✕ 123// 암묵적 타입 변환!0; // -&gt; true!'Hello'; // -&gt; false 1'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' - 단축평가 단축평가란? ‘Cat’은 true이고 그 뒤에 나와 있는 결과 값을 통해서 다이렉트로 값을 반환한다. 그룹 연산자​ 우선 순위를 강제로 조절하고자 할 때 사용한다. 123410 * 2 + 3; // -&gt; 23// 그룹 연산자를 사용하여 우선 순위 조절10 * (2 + 3); // -&gt; 50 +보다 *가 높다. typeof 연산자123456789101112typeof '' // -&gt; \"string\"typeof 1 // -&gt; \"number\"typeof NaN // -&gt; \"number\"typeof true // -&gt; \"boolean\"typeof undefined // -&gt; \"undefined\"typeof Symbol() // -&gt; \"symbol\"typeof null // -&gt; \"object\"typeof [] // -&gt; \"object\"typeof &#123;&#125; // -&gt; \"object\"typeof new Date() // -&gt; \"object\"typeof /test/gi // -&gt; \"object\"typeof function () &#123;&#125; // -&gt; \"function\" null 버그 : null의 type을 확인하고 싶다면 ===을 사용할 것. undefined: 선언하지 변수에 대하여 typeof 를 찍어보면 undefined를 반환한다. 지수 연산자 지수연산자 ( ES7 ) Math.pow 함수( ES6 이하 ) 5 ** 2; // -&gt; 255 ** 2.5; // -&gt; 55.901699437494745 ** 0; // -&gt; 15 ** -2; // -&gt; 0.04 Math.pow(5, 2); // -&gt; 25Math.pow(5, 2.5); // -&gt; 55.90169943749474Math.pow(5, 0); // -&gt; 1Math.pow(5, -2); // -&gt; 0.04 음수를 지수화 할 때는 반드시 ( ) 를 쳐야만 한다. 123-5 ** 2;// -&gt; SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence(-5) ** 2; // -&gt; 25 123456// 지수 연산자는 할당 연산자와 같이 사용이 가능하다.var num = 5;num **= 2; // -&gt; 25// 지수 연산자는 이항 연산자보다 우선순위가 높다.2 * 5 ** 2; // -&gt; 50","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_algorithm07","slug":"daily-algorithm07","date":"2019-10-07T03:56:27.000Z","updated":"2019-11-30T16:50:37.061Z","comments":true,"path":"2019/10/07/daily-algorithm07/","link":"","permalink":"https://hyeok999.github.io/2019/10/07/daily-algorithm07/","excerpt":"","text":"문제 출처 : 프로그래머스 모의고사문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명입출력 예 #1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041function solution(answers) &#123; let answer = []; let student = &#123; s1: [1, 2, 3, 4, 5], s2: [2, 1, 2, 3, 2, 4, 2, 5], s3: [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] &#125;; let answerNum = [0, 0, 0]; let maxNum = 0; let arrayNum = 0; let i = 0; let j = 0; let keysArr; for (arrayNum = 0; arrayNum &lt; 3; arrayNum++) &#123; keysArr = Object.keys(student)[arrayNum]; for (i = 0; i &lt; answers.length; i++) &#123; if (j === student[keysArr].length) &#123; j = 0; &#125; if (answers[i] === student[keysArr][j]) &#123; answerNum[arrayNum]++; &#125; j++; &#125; j = 0; &#125; maxNum = Math.max.apply(null, answerNum); for (i = 0; i &lt; 3; i++) &#123; if (answerNum[i] === maxNum) &#123; answer.push(i + 1); &#125; &#125; answer.sort(); return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"daily_algorithm06","slug":"daily-algorithm06","date":"2019-10-05T08:35:27.000Z","updated":"2019-11-30T16:50:43.604Z","comments":true,"path":"2019/10/05/daily-algorithm06/","link":"","permalink":"https://hyeok999.github.io/2019/10/05/daily-algorithm06/","excerpt":"","text":"문제 출처 : 프로그래머스 해당 문제 효율성(시간)이 너무 떨어져 재도전하였음. 완주하지 못한 선수문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 입출력 예 설명예제 #1leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 12345678910111213141516171819202122function solution(participant, completion) &#123; var answer = ''; participant.sort(); completion.sort(); /* //for in 구문을 자주 사용하지 말라는 MDN 통계가 있었음. for(var i in participant)&#123; if(participant[i] != completion[i])&#123; return answer = participant[i]; &#125; &#125; */ for(var i=0;i&lt;participant.length;i++)&#123; if(participant[i] != completion[i])&#123; return answer = participant[i]; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"VSCode 설정","slug":"VSCode-Settings","date":"2019-10-05T07:25:56.000Z","updated":"2019-11-30T16:25:04.015Z","comments":true,"path":"2019/10/05/VSCode-Settings/","link":"","permalink":"https://hyeok999.github.io/2019/10/05/VSCode-Settings/","excerpt":"","text":"VS CODE에서 자바스크립트 즉석 실행하기 ( Extention 설치 ) Code.Runner : 브라우저 나 노드에서 굳이 사용하지 않고 js파일을 실행할수있다. ctrl + option + n (단, 코드러너는 노드환경에서 실행되기 때문에 DOMAPI등은 못읽는다.) Quokka.js 시작 : cmd + shift + p - quokka.js : start on current file Quokka.js 종료 : stop all (current) VS CODE , 전역 Setting 하기 ( settings.json 파일 수정 )123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"editor.tabSize\": 2, // Fira code \"editor.fontFamily\": \"'Fira Code'\", \"editor.fontLigatures\": true, // \"editor.fontWeight\": \"normal\", // \"editor.fontWeight\": \"bold\", // \"editor.formatOnPaste\": true, \"editor.scrollBeyondLastLine\": false, // Theme \"workbench.colorTheme\": \"Atom One Light\", \"workbench.iconTheme\": \"material-icon-theme\", // LiveServer \"liveServer.settings.port\": 0, \"liveServer.settings.donotShowInfoMsg\": true, \"liveServer.settings.donotVerifyTags\": true, \"emmet.variables\": &#123; \"lang\": \"ko\" &#125;, \"files.exclude\": &#123; \"**/.git\": false &#125;, \"files.trimTrailingWhitespace\": true, \"window.zoomLevel\": 1, \"material-icon-theme.showUpdateMessage\": false, // ESLINT \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\" ], \"breadcrumbs.enabled\": true, // DOM 기반 terminal \"terminal.integrated.rendererType\": \"dom\", \"workbench.fontAliasing\": \"antialiased\", \"editor.multiCursorModifier\": \"alt\", // Type Safe JavaScript with JSDoc // \"javascript.implicitProjectConfig.checkJs\": true, \"editor.minimap.enabled\": false, \"editor.suggestSelection\": \"first\", \"vsintellicode.modify.editor.suggestSelection\": \"automaticallyOverrodeDefaultValue\", \"C_Cpp.updateChannel\": \"Insiders\", \"vsicons.projectDetection.disableDetect\": true, \"vsicons.dontShowNewVersionMessage\": true&#125; Fira Code 추가하기 구글 폰트 접속 Fira Code 검색 다운로드 압축해제 Fira Code 폴더 -&gt; static -&gt; 모든 .ttf 서체 더블클릭해서 추가(Mac 기준)","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"https://hyeok999.github.io/categories/Develop/Tips/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"VisualStudio Code","slug":"VisualStudio-Code","permalink":"https://hyeok999.github.io/tags/VisualStudio-Code/"},{"name":"VSCode","slug":"VSCode","permalink":"https://hyeok999.github.io/tags/VSCode/"}]},{"title":"daily_algorithm05","slug":"daily-algorithm05","date":"2019-10-05T07:03:00.000Z","updated":"2019-11-30T16:50:54.932Z","comments":true,"path":"2019/10/05/daily-algorithm05/","link":"","permalink":"https://hyeok999.github.io/2019/10/05/daily-algorithm05/","excerpt":"","text":"문제 출처 : 프로그래머스 *Dayil 01에서 풀었으나, 테스트 케이스 대부분 실패해서 다시 풀음 * 체육복문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function solution(n, lost, reserve) &#123; var answer = 0; var array = []; for(var i=0;i&lt;n;i++)&#123; array[i] = 1; &#125; for(var i=0;i&lt;reserve.length;i++)&#123; array[reserve[i]-1]++; &#125; for(var i=0;i&lt;lost.length;i++)&#123; array[lost[i]-1]--; &#125; for(var i=0;i&lt;n;i++)&#123; if(array[i] == 0)&#123; if(array[i-1] == 2)&#123; array[i-1] = 1; array[i] = 1; continue; &#125; if(array[i+1] == 2)&#123; array[i+1] = 1; array[i] = 1; continue; &#125; &#125; &#125; for(var i=0;i&lt;array.length;i++)&#123; if(array[i] == 2)&#123; array[i] = 1; &#125; answer = answer + array[i]; &#125; return answer; // test 12 Error!// var answer = n - lost.length;// for(var i=0; i&lt;lost.length; i++)&#123;// if(reserve.includes(lost[i]))&#123;// reserve.splice(reserve.indexOf(lost[i]),1)// answer++;// continue;// &#125;// else if(reserve.includes(lost[i]-1))&#123;// reserve.splice(reserve.indexOf(lost[i]-1),1);// answer++;// continue;// &#125;// else if(reserve.includes(lost[i]+1))&#123;// reserve.splice(reserve.indexOf(lost[i]+1),1)// answer++;// continue;// &#125;// &#125;// return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-03","slug":"javascript-study-03","date":"2019-10-04T13:49:35.000Z","updated":"2019-11-30T16:30:22.762Z","comments":true,"path":"2019/10/04/javascript-study-03/","link":"","permalink":"https://hyeok999.github.io/2019/10/04/javascript-study-03/","excerpt":"","text":"JavaScript Study 03 용어 변수 식별자란? 평가란? 할당 참조 변수 선언 호이스팅 변수와 메모리의 관계 용어 - ( 러버덕 ) 키워드 식별자 변수 메모리와 메모리 주소 할당 호이스팅 변수 값을 저장하는 메커니즘. 메모리에 접근하기 위해 메모리의 주소에 이름을 부여하는 것. 메모리 공간 그 자체. 메모리 공간에 부여한 이름. 메모리 : 기억하는 영역메모리 셀 : 메모리를 이루는 공간. 1byte (8bit) 크기로 이루어져있음. 각 셀마다 주소를 가지고 있다.자바스크립트는 메모리의 주소를 알려주지않는다. 이유 : 각 메모리의 주소가 어디서 쓰고있는지 모르기에 변경을 했다거나 지웠다거나 하는 일이 생길 경우 큰 에러를 발생시킬수 있기 때문이다. 따라서 각 메모리의 주소를 기억하게 하는 매커니즘(변수)을 사용한다. 변수의 이름 : 메모리 공간의 주소 위치를 별칭으로 참조한 것. 변수는 하나의 값만을 저장할 수 있다. (예외, 배열 / 객체) 변수의 명명은 1번 명명하면 해당 주소의 이름은 바꿀 수 없기 때문에, 변수의 이름을 지을때는 항상 고민하고 고민해야한다. 값이란? : 컴퓨터가 인식할 수 있는 데이터의 종류. 메모리에 들어가는 대상. 자바스크립트 엔진은 변수를 찾아갈 수 있다. 변수를 이용할 수 있다. 변수가 여러 값을 저장하기 위한 방법 자료구조 이용 객체 배열 식별자란? 메모리 주소를 가리키는 고유한 변수 이름. 메모리에 들어간 값을 구별해낼수 있는 고유한 이름을 식별자라 칭한다. ( 변수한정이 아니다. 함수도, 클래스도 식별자가 될 수 있다. ) 평가란? 값을 연산하는 과정 var는 자바스크립트엔진에게 내리는 키워드이며,var 뒤에 변수이름을 적어야한다. CPU : 계산(연산)하는 영역. 메모리는 한정된 영역이기 때문에 자바스크린트 엔진에 내장된 Garbage Collector가 해당 메모리 주소가 사용이 되는지 안되는지를 게속 감시한다. 만약 해당 메모리 주소가 사용되지 않고 있다면 주소를 비워준다. 할당 변수에 값을 저장하는 행위 (=대입 , =저장) 참조 변수에 저장된 값을 읽어드리는 행위 변수선언 값을 할당하기 위한 메모리 공간을 확보하여 값을 저장하기 위한 준비를 하는 것. 변수를 선언하기 위해서는 var / let / const 키워드를 이용한다. 선언문 : 식별자를 만드는 것. 변수를 사용할 때는 반드시 선언을 하고 할당을 해야만 한다. 변수 이름의 등록처 : 실행컨텍스트 var키워드 변수선언시 최초로 undefined가 할당된다. 자바스크립트 엔진은 변수 선언을 아래의 2단계를 거쳐 수행한다. 선언 단계(Declaration phase) : 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. undefined는 원시타입이며, 원시타입은 메모리에 등록된 순간 변경이 불가능하다. ​ 만약, 변수에 재할당을 해서 변경했다면 그것은 걸려있던 메모리 주소를 옮긴 것이지 undefined를 지운것이 아니다. 호이스팅 자바스크립트 코드는 인터프리터가 한줄한줄 실행하기 앞서, 먼저 선언문들만 골라내서 먼저 실행한다. 123console.log(score); // undefinedvar score; // 변수 선언(문) 123456789console.log(score); // undefinedscore = 80; // 값의 할당var score; // 변수 선언console.log(score); // 80// var score은 호이스팅 되어 처음에 undefined가 할당이 되었고// score는 다시 80값으로 재할당되었다. 그 뒤에 나오는 var score; 구문은 이미 호이스팅하여 읽었으므로 다시 읽지 않고 넘어간다. 값의 교환 12345678var x = 1;var y = 2;var temp = x;x = y;y = temp;console.log(x, y); // 2 1 변수와 메모리의 관계 var result 로 특정 메모리 공간에 변수 선언 및 초기화를 한다. ( 메모리에는 undefined가 생성됨. ) result 변수에 100이라는 숫자 타입의 값을 재할당한다. ( 따라서 undefined라고 적힌 메모리에 걸려있는 링크를 끊고 새 메모리에 100값과 함께 링크를 건다.) ( undefined는 안쓰기때문에 가비지컬렉터에 의해 관리된다. ) result 변수에 200이라는 숫자 타입의 값을 재할당한다 ( 따라서 100 이라고 적힌 메모리에 걸려있는 링크를 끊고 새 메모리에 200값과 함께 링크를 건다. ) ( 100이 적힌 메모리 공간은 안쓰기때문에 가비지컬렉터에 의해 관리된다. ) VS CODE에서 자바스크립트 즉석 실행하기 Code.Runner : 브라우저 나 노드에서 굳이 사용하지 않고 js파일을 실행할수있다. ctrl + option + n (단, 코드러너는 노드환경에서 실행되기 때문에 DOMAPI등은 못읽는다.) quokka.js 시작 : cmd + shift + p - quokka.js : start on current file quokka.js 종료 : stop all (current)","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"browser_operation","slug":"browser-operation","date":"2019-10-04T04:31:53.000Z","updated":"2019-11-30T16:52:29.746Z","comments":true,"path":"2019/10/04/browser-operation/","link":"","permalink":"https://hyeok999.github.io/2019/10/04/browser-operation/","excerpt":"","text":"웹 브라우저의 동작 원리 클라이언트는 네이버에 접속을 시도한다. 네이버에 접속하기 위해서 인터넷 브라우저 주소창에 www.naver.com 을 입력한다. www.naver.com에 대한 IP 주소를 알기 위해서 DNS서버에 먼저 접속한 후DNS서버에게 www.naver.com에 해당되는 IP주소를 요청한다. DNS서버는 www.naver.com에 해당되는 IP주소를 응답한다. IP주소를 알게 된 브라우저는 다시 해당 IP주소를 통해서 네이버 서버에 접근하게 된다. 클라이언트는 서버에게 해당 페이지에 대한 접속과 .html 파일을 요청한다. 서버는 네이버 메인 페이지에 대한 화면 요소 정보가 담긴 index.html파일을 응답한다. 브라우저의 렌더링 엔진의 html파서는 index.html파일을 로드하고 파싱을 시작한다. 파싱중 &lt;link&gt; 를 만나게 된다. &lt;link&gt;에는 .css파일이 적혀있었다. html파서는 파싱을 중지한후 클라이언트는 다시 서버에게 .css파일을 요청한다. 서버는 .css파일을 응답한다. 클라이언트의 렌더링 엔진의 html파서는 제어권을 css파서에게 넘겨준다. css파서는 .css파일을 로드하고 파싱을 시작한다. 파싱이 완료되고 CSSOM트리가 완성된다. css파서는 제어권을 다시 html파서에게 넘겨준다. 중지되었던 html 파싱을 재 시작한다. 파싱하던중 &lt;script&gt; 를 만나게 된다. &lt;script&gt;에는 .js파일이 적혀있었다. html파서는 파싱을 중지한 후 클라이언트는 다시 서버에게 .js 파일을 요청한다. 서버는 .js파일을 응답한다. html파서는 .js파일을 읽을 수 없기 때문에 제어권을 브라우저에 탑재된 자바스크립트 엔진에게 넘겨준다. 제어권을 넘겨받은 자바스크립트 엔진은 DOM api를 이용하여 .js파일을 로드한다. 로드된 .js파일을 토크나이즈 하여 소스코드를 어휘분석하여 의미를 갖는 최소단위인 토큰으로 분리한다. 분리된 토큰을 구문분석하여 문법의 의미와 구조를 반영한 트리인 AST를 생성한다. AST는 자바스크립트 엔진의 인터프리터가 읽을 수 없기 때문에 인터프리터가 실행할 수 있는 중간코드인 바이트코드로 변환되고 실행된다. 실행된 후 제어권을 다시 렌더링엔진의 html파서에게 전달한다. 제어권을 돌려받은 html파서는 중지되었던 파싱을 재 실행한다. 파싱이 완료되어 DOM트리가 형성된다. 전에 만들어진 CSSOM트리와 DOM트리를 합쳐 RENDER트리로 만든다. RENDER트리를 기반으로 클라이언트의 화면에 표출한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"https://hyeok999.github.io/categories/Develop/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"browser","slug":"browser","permalink":"https://hyeok999.github.io/tags/browser/"},{"name":"browser operation","slug":"browser-operation","permalink":"https://hyeok999.github.io/tags/browser-operation/"}]},{"title":"daily_algorithm04","slug":"daily-algorithm04","date":"2019-10-03T13:38:45.000Z","updated":"2019-11-30T16:51:02.374Z","comments":true,"path":"2019/10/03/daily-algorithm04/","link":"","permalink":"https://hyeok999.github.io/2019/10/03/daily-algorithm04/","excerpt":"","text":"문제 출처 : 프로그래머스 완주하지 못한 선수문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 입출력 예 설명예제 #1leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 1234567891011121314151617181920212223function solution(participant, completion) &#123; var answer = ''; var completion_array = []; completion_array = completion; var num = 0; for(var i=0;i&lt;participant.length;i++)&#123; for(var j=0;j&lt;completion_array.length;j++)&#123; if(participant[i] == completion_array[j])&#123; completion_array[j] = null; num = 0; break; &#125; num = 1; &#125; if(num == 1)&#123; answer = participant[i]; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript 5강~6강(데이터타입, 연산자)","slug":"javascript-preview-0506","date":"2019-10-03T06:46:38.000Z","updated":"2019-11-30T16:33:05.818Z","comments":true,"path":"2019/10/03/javascript-preview-0506/","link":"","permalink":"https://hyeok999.github.io/2019/10/03/javascript-preview-0506/","excerpt":"","text":"JavaScript 5강~6강 예습 5강 : 데이터 타입 데이터 타입이란? 메모리 공간 확보 데이터 타입이 필요한 이유 값 값의 생성 데이터 타입의 분류(종류) 동적 타이밍 6강 : 연산자 표현식 과 연산자 문 문 vs 표현식 표현식인 문 vs 표현식이 아닌 문 완료값 연산자 산술연산자 문자열 연결 연산자 할당연산자 비교연산자 대소 관계 연산자 삼항 조건 연산자 논리 연산자 쉼표 연산자 typeof 연산자 지수 연산자 5강데이터타입 데이터타입 이란? 값의 종류를 의미하며, 자바스크립트의 모든 값은 데이터 타입을 지닌다. 메모리 공간 확보​ 자바스크립트 엔진은 데이터타입, 즉 값의 종류에 따라 적절한 크기의 메모리 공간을 지닌다. 예를들면 다음과 같다. ( 데이터타입에 따라 확보되는 메모리공간의 크기는 브라우저 제조사마다 다를 수 있다. ) 12var score = 100;// 위와 같이 숫자를 입력할 경우 자바스크립트 엔진은 데이터타입을 숫자로 인식하고 메모리 공간을 8byte 내주게된다. 데이터 타입이 필요한 이유 값을 저장할 때 필요한 메모리 공간의 크기를 결정하기 위함 값을 참조할 때 한번에 읽어들일 메모리 공간의 크기를 결정하기 위함 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위함 값 더 이상 평가할 수 없는 하나의 표현식 실제 메모리 공간에 저장되는 최소 단위 1210 + 20// 10 + 20은 표현식이고 이로 인해 나온 결과 30은 더이상 평가할 수 없는 값이다. 값의 생성 리터럴 표기법 표현식으로 생성. 리터럴 소스 코드 내에서 직접 만들어 낸 고정된 값 자체. 사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령 리터럴 - 정수 리터럴 / 부동 소숫점 리터럴 100 / 10.5 2진수(0b) / 8진수 리터럴(ES 6도입, 0o) / 16진수 리터럴(ES 6도입, 0x) 0b01000001 / 0o101 / 0x41 문자열 리터럴 ‘Hello’ , “World” 불리언 리터럴 true , false null 리터럴 / undefined 리터럴 null / undefined 정규표현식 리터럴 ab+c 객체 리터럴 { name: ‘Lee’, age : 20 } 배열 리터럴 [ 1, 2, 3 ] 함수 리털럴 function( ){ } 표현식 값을 생성하는 다양한 방법 리터럴, 식별자(변수 혹은 함수 등), 연산자, 함수 호출등의 조합 하나의 값으로 평가될 수 있는 문(식) 1234567891011121314151617// 리터럴 표현식10'Hello'// 식별자 표현식(선언이 이미 존재한다고 가정)sumperson.namearr[1]// 연산자 표현식10 + 20sum = 10sum !== 10// 함수/메소드 호출 표현식(선언이 이미 존재한다고 가정)square()person.getName() 데이터 타입의 분류(종류) 원시타입 숫자(number) 타입: 숫자 (정수, 실수) 문자열(string) 타입: 문자열 불리언(boolean) 타입: 논리적 참(true)과 거짓(false) undefined 타입: 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입: ES6에서 새롭게 추가된 7번째 타입 객체 타입 / 참조 타입(object/reference type): 객체, 함수, 배열 등 숫자(number) 타입 자바스크립트는 Java , C처럼 정밀하게 숫자들을 나눠 놓은 형식은 없다. 모든 숫자들은 실수로 처리를 하여 표현한다. ( 정수만을 위한 특별한 타입은 존재하지 않는다. ) 모든 숫자(정수, 실수, 음의정수, 2진수, 8진, 16진수)는 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 2진수, 8진수, 16진수를 별도로 제공을 안하기 때문에 이 값들을 참조하면 모두 10진수로 해석한다. 1234// 숫자 타입은 모두 실수로 처리된다.console.log(1 === 1.0); // trueconsole.log(4 / 2); // 2console.log(3 / 2); // 1.5 + 추가로숫자 타입은 3가지 특별한 값들도 표현이 가능하다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not a number) 1234567// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN//+ 자바스크립트는 대소문자 구별을 하기에 NaN을 NAN, nan, Nan등으로 적으면 에러가 발생한다.var x = nan; // ReferenceError: nan is not defined 문자열 타입 텍스트 데이터를 나타내는데 사용한다. 16bit 유니코드 문자들의 집합으로 전세계 대부분의 문자가 표현이 가능하다. 작은 따옴표(‘’), 큰따옴표(“”), 백틱(`) 안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 이용한다. 문자열은 원시타입이며 변경 불가능한 값이다. 문자열은 한번 생성되면, 그 문자열은 변경할 수 없다는 것을 의미한다. 템플릿 리터럴 ES6 생긴 새로운 무자열 표기법. 백틱 문자 ` 를 사용한다. 특징1 : 일반적인 문자열에서는 줄바꿈이 허용되 않는다. 공백을 표현하기 위해서는 \\로 시작하는 이스케이프 시퀀스를 이용해야만하는데 템플릿 리터럴은 여러줄에 걸쳐 문자열을 작성시 공백을 있는 그대로 출력해준다. 12345678onst template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;console.log(template); 특징2 : 문자열은 문자열 연산자를 사용해 연결한다. 하지만 템플릿 리터럴은 연산자 없이도 문자열 삽입기능을 제공 하며 이를 문자열 인터폴레이션 이라 한다. $ { 표현식 } : 이에 대한 평가 결과는 강제로 문자열이 된다 12345678910// 기본적인 문자열 연산자를 이용한 문자열 연결console.log('나이는 : ' + 25 + '살 입니다.' );//문자열 인터폴레이션var age = \"나이는\";var num = 25;console.log('$&#123;age&#125; $&#123;num&#125; 살 입니다.');console.log(`1 + 1 = $&#123;1 + 1&#125;`); // 1 + 1 = 2 강제 문자열 불리언 타입 불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다. undefined 타입 선언은 되어있지만 아직 값을 할당하지 않는 변수에 접근할 경우 undefined가 반환된다. 이는 자바스크립트 엔진의 암묵적 초기화에 의한 것이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 ‘할당된 적인 없는 변수라는 것’ 을 개발자는 간파가 가능하다. 개발자가 의도적으로 변수에 undefined를 할당한다면 혼란을 줄 수 있으므로 권장하지 않는다. 자바스크립트의 정의와 선언의 차이 자바스크립트에서 선언은 식별자가 생성되었지만 값이 아직 할당되지 않은 상태를 말한다. 자바스크립트에서 정의는 식별자가 생성되었고 값까지 할당되어 있는 상태를 의미한다. 123456// 변수 선언. 내부적으로 undefined로 정의된다.var foo;// 변수 선언과 정의var bar = 1;// 함수 정의. 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.function baz &#123; &#125; null 타입 변수에 값이 없다는 것을 의도적으로 명시 할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미. 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 Null, NULL등과 다르다. (반드시 null로 써야한다.) 123456&lt;script&gt; var element = document.querySelector('.myElem'); // HTML 문서에 myElem 클래스를 갖는 요소가 없다면 null을 반환한다. console.log(element); // null &lt;/script&gt; document.querySelector 메소드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우, 에러 대신 null을 반환. 변수에 null을 할당하게 되면, 이는 더 이상 해당 변수의 값을 참조하지 않겠다는 것을 의미. 따라서 자바스크립트 엔진은 누구도 참조하지 않는 해당 변수의 메모리공간에 대해서 가비지 콜렉션을 수행할 것이다. symbol 타입 ES6에서 새롭게 추가된 7번째 타입. 변경 불가능한 원시 타입의 값. 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위함 사용방법 : Symbol 함수를 호출해 사용한다. 12345678910111213/// 심볼 값 생성var key = Symbol('key');console.log(typeof key); // symbol// 객체 생성var obj = &#123;&#125;;// 심볼 key를 이름의 충돌 위험이 없는 유일한 프로퍼티 키로 사용한다.obj[key] = 'value';console.log(obj[key]); // valueobj[\"key\"] = \"value\";console.log(obj); 똑같은 key : value라는 이름의 키와 값을 객체에 넣었는데 전혀 충돌이 나지 않고있다. 또한 Object.keys(obj) 를 찍어보면 Symbol은 나타나지 않고 일반적인 키와 값만 출력한다. 객체 타입 자바스크립트의 6가지 데이터 타입 이외에 모든 것은 전부 객체 타입이다. 객체타입은 추후에 마져 공부한다. 동적 타이밍 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 12345678// JAVA , C의 경우. int라는 키워드를 통해 이미 정수라는 타입이 결정되었음.int a;// javascript , var때문이 아닌 값이 5 라는것을 통해 숫자 타입이라는 것을 알게됨.var a = 5;// + 추가로 javascript는 언제든지 동적으로 값에 의해 변수의 타입이 변할수있다.var a = \"hello world\"; // a는 숫자 타입에서 \"hello world\" 라는 문자열 타입으로 변경되었다. 이러한 편리한 구조속에 동적 타이밍은 다음과 같은 단점을 지니고있다. 동적으로 변화하는 데이터 타입을 추척하기 어려울 수 있다. (즉, 확인하기 전까지는 데이터 타입의 값을 확신하기 힘들다.) 동적 타입 언어는 유연성(flexibility)은 높지만, 신뢰성(reliability)이 떨어진다. 따라 안정적인 프로그램 개발을 위해서는 데이터 타입을 체크해야하는 경우가 있는데 이러한 방식은 코드량의 증가를 야기한다. 코드량의 증가는 결국 버그발생률을 높이게 되며, 테스트 분량 또한 증가시킨다. 따라서 다음과 같은 변수 사용 주의사항이 있다. 변수 사용 주의사항 변수의 사용을 적극적으로 줄인다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 전역 변수는 사용하지 않는다. 변수의 생명주기를 최대한 짧게 만든다. 변수보다는 상수를 사용해 값의 변경을 억제한다. 변수 이름은 변수의 존재 이유를 파악할 수 있도록 명명한다. 6강표현식과 연산자 표현식이란? 리터럴 , 식별자(변수 혹은 함수의 이름) , 연산자, 함수호출등의 조합 표현식은 평가되어 하나의 값을 만든다. 12var x = 10;x + 30; // 40 위 예제에서 x+30이 표현식이다. + 연사자는 좌항과 우항의 값을 연산하는 연산자이고 좌항과 우항에는 숫자값이 위치해야한다. 우항은 30이라는 리터럴 표현식 이 좌항에는 x라는 식별자 표현식이 와있고 이 두개의 조합으로이해 40이라는 값을 낼수있다. 문(statement) 문이란? 하나 이상의 표현식과 키워드 조합으로 구서된 자바스크립트 엔진에게 내리는 명령 문의 집합으로 이루어진 것이 프로그램이며 문을 작성하고 나열하는 것이 프로그래밍이다. 문은 코드블록( {내용} )을 제외하고는 ; 으로 끝나야만 한다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식은 그 자체로 문이 될수도 있지만, 반대로 문은 표현식이 될수는 없다. 문 vs 표현식표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. 문은 선언문과 같이 var, let, const, function, class와 같은 선언 키워드를 사용하여 변수나 함수, 클래스를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다. 결론적으로, 표현식의 역할은 값을 생성하는 것. 문의 역할은 표현식으로 생성한 값을 사용해 JS엔진에게 명령을 내리는 것. 표현식인 문 / 표현식이 아닌 문 표현식인 문은 값으로 평가가 가능하다. 표현식이 아닌 문은 값으로 평가가 불가능하다. 12var x; // 변수 선언문. -&gt; 값으로 평가가 불가능하다.x = 300; // 할당문. x는 300이라는 값으로 평가가 가능하다. 완료값 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라 한다. 완료 값은 다른 값과 같이 변수에 할당할 수 없다. 연산자 연산자란? 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입연산등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자라 칭한다. 산술 연산자 피연산자를 대상으로 수학적 계산을 하여 새로운 숫자 값을 만든다. 연산이 불가능할 경우에는 NaN을 출력한다. 부수효과 : 피연산자의 값은 변경하는 것. 이항 산술 연산자 ( ex - var a = 1+2; ) : 피연산자끼리 계산을 하여 새로운 값을 만든다. 이항 산술 연산자 의미 부수 효과 + 덧셈 X - 뺄셈 X * 곱셈 X / 나눗셈 X % 나머지 X 단항 산술 연산자 ( ex - var a = 0; a++; ) 단항 산술 연산자 의미 부수 효과 ++ 증가 O – 감소 O + 숫자 타입이 아닌 피연산자를 숫자타입으로 변환. X - 양수를 음수로 음수를 양수로 반전화 시킨다. X 단항 산술 연산자의 ++ , –는 어느 위치냐에 따라 피연산자에 대한 값의 증가 및 감소처리의 로직이 달라질수 있다. 1234567891011121314151617var x = 5, result;// 선할당 후증가 (Postfix increment operator)result = x++;console.log(result, x); // 5 6// 선증가 후할당 (Prefix increment operator)result = ++x;console.log(result, x); // 7 7// 선할당 후감소 (Postfix decrement operator)result = x--;console.log(result, x); // 7 6// 선감소 후할당 (Prefix decrement operator)result = --x;console.log(result, x); // 5 5 + 단항 연산자는 숫자 타입의 피연산자에게 어떠한 영향도 주지 않는다. 숫자타입이 아닌 피연산자에게 적용시 강제로 숫자타입으로 반환 해준다. 1234567891011// 문자열을 숫자로 타입 변환한다.+'10'; // -&gt; 10// 불리언 값을 숫자로 타입 변환한다.+true; // -&gt; 1// 불리언 값을 숫자로 타입 변환한다.+false; // -&gt; 0// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.+'Hello'; // -&gt; NaN - 단항 연산자는 양수의 숫자타입을 음수로 바꾸거나, + 단항 연사자처럼 숫자타입이 아닌 피연사자를 강제로 음수 숫자타입으로 바꾸어 반환해준다. 1234567891011// 부호를 반전한다.-(-10); // -&gt; 10// 문자열을 숫자로 타입 변환한다.-'10'; // -&gt; -10// 불리언 값을 숫자로 타입 변환한다.-true; // -&gt; -1// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.-'Hello'; // -&gt; NaN 문자열 연결 연산자 + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 1234561 + 2 // 3'1' + 2 // '12'1 + true // 2 true : 11 + false // 1 false : 01 + null // 1 null : 01 + undefined // NaN : undefined 는 숫자로 타입 변환되지 않는다. true / false / null 등은 강제로 숫자타입으로 변환 후 연산을 실행한 것을 알 수 있다. 이를 암묵적 타입 변환 혹은 타입 강제 변환이라고 한다. 할당 연산자 할당 연산자 예 동일 표현 부수 효과 = x = 5 x = 5 O += x += 5 x = x + 5 O -= x -= 5 x = x - 5 O *= x *= 5 x = x * 5 O /= x /= 5 x = x / 5 O %= x %= 5 x = x % 5 O 물론 문자열도 할당 연산자를 적용시킬 수 있다. 123456var str = 'My name is ';// 문자열 연결 연산자str += 'Lee'; // str = str + 'Lee';console.log(str); // 'My name is Lee' 비교 연산자비교연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 boolean 값으로 반환한다. 비교연산자 의미 사례 설명 부수효과 == 동등 비교 x == y x와 y의 값이 같다. X === 일치 비교 x === y x와 y의 값과 타입이 같다. X != 부동등 비교 x != y x와 y의 값이 다르다. X !== 불일치 비교 x !== y x와 y의 값과 타입이 다르다. X 동등 비교와 부동등 비교의 경우 피연산자끼리 비교할 때, 타입이 다른 경우 암묵적인 타입 변환을 통해 타입을 일치 시킨 후에 값이 같은지 비교를 한다. 따라서 타입이 다른 경우에도 true를 반환 할 수 도 있다. 반면에 일치비교와 불일치비교는 타입 과 값이 모두 비교를 하기에 좀 더 예측하기가 쉽다. 일치비교의 주의점 : NaN === NaN // false : NaN은 자신과 일치하지 않은 유일한 값 NaN을 조사할 때에는 빌트인 함수 inNaN을 사용해야한다. 123isNaN(NaN); // trueisNaN(10); // falseisNaN(10 + undefined); // true 대소 관계 비교 연산자조건문 이나 반복문에서 자주 사용되는 연산자로 boolean 값을 반환한다. 12345// 대소 관계 비교5 &gt; 0; // -&gt; true5 &gt; 5; // -&gt; false5 &gt;= 5; // -&gt; true5 &lt;= 5; // -&gt; true 삼항 조건 연산자삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 자바스크립트의 유일한 삼항 연산자이며 부수효과는 없다. 마치 조건문을 짧게 줄여놓은 형식이다. 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일 때 반환할 값 ? 앞에 나오는 조건식은 불리언 타입의 값으로 평가가 된다. (즉 (ture)1인지 (false)0인지 본다는 뜻 ) 만약 조건식 평가 결과가 불리언 값이 아니라면 불리언 값으로 암묵적 타입 변환을 실행한다. 123456var x = 2;// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 논리 연산자 논리 연산자는 항상 불리언 값을 반환한다. 피연산자는 불리언 타입으로 암묵적 타입 변환을 한다. 논리 연산자 의미 부수효과 || 논리합( OR ) X &amp;&amp; 논리곱( AND ) X ! 부정( NOT ) X &lt;주의&gt; 논리합 연산자( || ) 와 논리곱 연산자( &amp;&amp; ) 의 결과가 항상 불리언 값이 아닐수도 있다. 12// 단축 평가'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' 쉼표 연산자 쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. 12var x, y, z;x = 1, y = 2, z = 3; // 3 typeof 연산자 typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. 종류는 총 7개다 string number boolean undefined symbol object function 123456789101112typeof '' // -&gt; \"string\"typeof 1 // -&gt; \"number\"typeof NaN // -&gt; \"number\"typeof true // -&gt; \"boolean\"typeof undefined // -&gt; \"undefined\"typeof Symbol() // -&gt; \"symbol\"typeof null // -&gt; \"object\"typeof [] // -&gt; \"object\"typeof &#123;&#125; // -&gt; \"object\"typeof new Date() // -&gt; \"object\"typeof /test/gi // -&gt; \"object\"typeof function () &#123;&#125; // -&gt; \"function\" 주의점 NaN은 number로 반환한다. null값을 object로 반환한다. ( JavaScript의 첫 버그 ) 2번째 주의점인 null 타입 확인은 typeof 대신에 일치연산자 ( === ) 을 사용한다. 1234var foo = null;typeof foo === null; // -&gt; falsefoo === null; // -&gt; true 지수연산자 ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 지수 연산자가 도입 전에는 Math.pow 함수를 이용하였다. 지수연산자 Math.pow(a,b) 5 ** 2 ; //25 Math.pow(5, 2); //25 5 ** 2.5; // 55.901699~ Math.pow(5, 2.5); // 55.901699~ 5 ** 0 // 1 Math.pow(5, 0); // 1 5 ** -2 // 0.04 Math.pow(5, -2); // 0.04 음수를 거듭제곱의 밑으로 계산하려면 괄호로 묶어야 한다. 123-5 ** 2;// -&gt; SyntaxError(-5) ** 2; // -&gt; 25 지수 연산자는 할당 연산자와 함께 이용이 가능하며, 모든 이항 연산자보다 우선순위가 높다. 123456// 할당 연산자와 함께 사용이 가능하다.var num = 5;num **= 2; // -&gt; 25// num ** 2를 행한 값과 * 4를 한다.4 * num ** 2; // -&gt; 100","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript 3강~4강(개발환경, 실행환경, 변수)","slug":"javascript-preview-0304","date":"2019-10-02T19:23:49.000Z","updated":"2019-11-30T16:37:04.268Z","comments":true,"path":"2019/10/03/javascript-preview-0304/","link":"","permalink":"https://hyeok999.github.io/2019/10/03/javascript-preview-0304/","excerpt":"","text":"JavaScript 3강~4강 예습 3강 : 자바스크립트 개발 환경과 실행 방법 자바스크립트 실행 환경 웹브라우저의 동작 방식 script 코드를 하단에 두어야 하는 이유 DOM이란? 4강 : 변수 변수란? 식별자 변수선언 변수 선언의 실행 시점과 변수 호스팅 값의 할당 값의 재할당 값의 교환 식별자 네이밍 규칙 자바스크립트 실행 환경 모든 브라우저는 자바스크립트을 실행하고 해석하기 위해서 자바스크립트 엔진을 내장하고 있다. 브라우저뿐만 아니라 Node.js도 자바스크립트 엔진을 내장하고 있다. 따라서 브라우저와 Node.js 둘다 자바스크립트의 코어인 ECMAScript를 실행할수는 있지만, ECMAScript 이외에 추가적인 기능은 호환되지 않는다. 브라우저에서의 자바스크립트 실행 환경 Node.js DOM API를 지원. File 시스템 (create / delete / read / update)를 지원. 클라이언트 사이드 Web API + ECMAScript Node.js 고유 API + ECMAScript 웹 어플리케이션의 자바스크립트는 사용자 컴퓨터의 브라우저에서 동작한다.(보안상 이유: Web API에서는 File 시스템을 미제공) 웹 어플리케이션의 자바스크립트는 브라우저에서 HTML,CSS와 함꼐 실행된다. 웹 브라우저의 동작 방식브라우저의 핵심 기능 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리하며, HTML파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해서 DOM 생성 프로세서를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 컴파일러 인터프리터 컴파일 타임에 소스 코드 전체를 한번에 CPU가 바로 실행할 수 기계어)로 변환한 후 실행한다. 런타임에 문 단위로 한 줄씩 중간 코드인 바이트 코드 특정한 하드웨어가 아니라 가상 머신에서 실행하도록 만든 바이너리 코드)로 변환한 후 실행한다. 실행 파일을 생성한다. 실행 파일을 생성하지 않는다. 컴파일 단계와 실행 단계가 분리되어 있다. 명시적인 컴파일 단계를 거쳐서 명시적으로 실행 파일을 실행한다. 인터프리트 단계와 실행 단계가 분리되어 있지 않다. 인터프리터는 한 줄씩 바이트 코드로 변환하고 즉시 실행한다. 실행에 앞서 컴파일은 단 한번 수행된다. 코드가 실행될 때마다 인터프리트 과정이 반복 수행된다. 컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠르다. 인터프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다. 토크나이징(Tokenizing) 단순한 문자열인 소스 코드를 어휘 분석(Lexical analysis)하여 의미를 갖는 코드의 최소 단위인 토큰(Token)들로 분리. 파싱(Parsing) 토큰들의 집합을 구문 분석(Syntactic analysis)하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성 AST는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료 구조 코드 실행 생성된 AST는 인터프리터가 실행할 수 있는 바이트 코드(bytecode)로 변환되고 인터프리터에 의해 실행. 결론 JS 소스 코드 + 어휘 분석 + 최소단위로 나누어 토큰으로 만듬 : 토크나이즈 토큰 + 구문분석 = 토큰에 문법적 의미 및 구조 반역 = AST 생성 : 파싱 AST를 인터프리터가 실행하도록 바이트코드로 변환하여 실행. script 코드를 하단에 두어야 하는 이유 HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다. DOM이란? Document Object Model (문서 객체 모델)- HTML, XML 문서의 프로그래밍 interface 로컬에서 작성된 코드가 브라우저에 의해 파싱되면 DOM으로 변환. JavaScript는 브라우저가 읽고 어떤 작업을 할 수 있는 언어이고 DOM은 이 작업이 이루어지는 장소이다. 어떠한 요소에 click이벤트가 일어나는지 감시하도록 JavaScript을 사용한 기능이 구현됬다. 하지만 이 요소는 DOM 노드이다. 여기서 DOM에 있는 property를 통해서 listener를 붙여 놓은 것 뿐임. DOM은 HTML요소이고, DOM API는 JavaScript에서 HTML에 DOM요소를 다루기 위한 JavaScript의 기본 함수. Node.js 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경. NPM node package manager의 약자. 자바스크립트 패키지 매니저이다. Node.js에서 사용할 수 있는 모듈들을 패키지화 하여 모아둔 장소 역할 과 패키지 설치 및 관리를 위한 CLI를 제공. 변수란? 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 / 또는 메모리 공간 자체. 데이터를 관리하기 위한 핵심 개념. 배열 혹은 객체와 같은 자료구조를 이용하면 하나의 변수에 여러개의 값을 그룹화하여 사용이 가능하다. 12345678910111213var userName = 'Lee';var userRole = 'Admin';// 객체나 배열과 같은 자료 구조를 사용하면 여러 개의 값을 하나로 그룹화하여 하나의 값처럼 사용할 수 있다.var user = &#123; name: 'Lee', role: 'Admin'&#125;;var users = [ &#123; name: 'Lee', role: 'Admin' &#125;, &#123; name: 'Kim', role: 'Developer' &#125;]; 변수에 값을 저장하는 행동 : 할당 변수에 저장된 값을 읽는 행동 : 참조 식별자 어떤 값을 구별하여 식별해낼 수 있는 이름 메모리 상에 존재하는 어떤 값을 구별하여 식별해낼 수 있어야 한다. 변수 , 함수 , 클래스등의 이름과 같은 식별자는 네이밍 규칙을 준수 해야만 한다. 선언에 의하여 자바스크립트 엔진에 식별자의 존재를 알린다. 변수 선언 변수 이름을 자바스크립트 엔진에 알려 등록하고 변수 값을 저장하기 위한 메모리 영역의 확보를 명령하는것. ( - 즉, 변수를 생성하는 것) 변수는 선언과 동시에 특정 값으로 초기화를 안하면 undefined라는 값이 암묵적으로 할당되어 초기화가 된다. 변수를 사용하려면 반드시 선언이 필요하다. 만약 선언 없이 변수(식별자)에 접근하면 ReferenceError가 발생한다. (이는 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 참조 에러다.) ES5 VS ES6 의 변수 선언 차이점 ES5의 변수 선언 키워드 ES6의 변수 선언 키워드 var let , const 123456// var 키워드의 최대 단점 : 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다.var a; //undefineda = 10;for(var a=0;a&lt;5;a++)&#123;&#125;console.log(a); 위는 var 키워드의 단점을 설명해주는 가장 큰 예이다. a의 결과값은 10이 아닌 5이다. 이유는 for는 { } 밖에 존재하기 때문이다. 실행 컨텍스트 자바스크립트 엔진이 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. 모든 식별자는 실행 컨텍스트에 등록된다. 자바스크립트는 실행 컨텏스트를 통해 식별자와 스코프를 관리한다. 실행 컨텍스트 내에 KEY / VALUE 형씩인 객체로 등록되어 관리된다. 변수 선언의 실행 시점과 변수 호이스팅 변수 선언은 소스 코드가 순차적으로 실해되는 시점에서 실해되 않는다. 구문 분석 단계에서 먼저 실행된다. 따라서 아래와 같은 코드가 참조 에러가 안나는것이다. 12console.log(score); // undefinedvar score; // 변수 선언(변수 선언문) 변수호이스팅 자바스크립트는 변수 선언문을 코드의 선두로 끌어 올려진 것처럼 동작하게 보인다. 이와 같은 고유의 특징을 변수 호이스팅이라고 한다. 추가로 사실 호이스팅은 변수 선언 뿐만이 아니라 var, let, const, function, function*, class 키워드를 사용하여 선언된 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. 모든 선언문은 런타임 이전인 구문 분석 단계에 먼저 실행되기 때문이다. 값의 할당 변수에 값을 할당할 때는 할당 연산자(=) 을 사용한다. ( 우변의 값을 좌변에 ) 변수 선언과 동시에 값을 할당하는 따로 선언후 구문을 나눠서 할당을 하든, 자바스크립트는 런타임 이전에 변수선언을 실행하고, 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다. 변수에 값을 할당 할 때 undefined가 적혀진 메모리 공간을 지우고 그곳에 값을 다시 저장하는게 아니라 새로운 메모리 공간을 확보하고 확보된 공간에 값을 할당한다. 123456console.log(score); // undefinedscore = 80; // 값의 할당var score; // 변수 선언console.log(score); // ?? 결과는 undefined / 80 이 출력된다. 이유 : var score는 구문 분석때 실행되어 undefined로 메모리 공간에 저장이 되어서 첫 score 값에 undefined 값이 저장이 되고 그 후 score는 80이라는 값이 할당이 되어 새로운 메모리 영역에 공간이 할당되고 80이라는 값이 저장된다. 따라서 2번째 값은 80이다. 값의 재할당 var 키워드로 선언한 변수는 값을 재할당이 가능하다. 재할당이 불가능한 식별자를 만들고 싶다면 const키워드를 이용한다. (즉 상수) 재할당이 끝나면 그 전에 할당되었던 값들은 필요가 없어진다. 이러한 쓰레기값들은 Garbage Collector에 의하여 메모리에서 자동 해제된다. 값의 교환123456789var x = 1;var y = 2;// do somethigvar temp = x;x = y;y = temp;console.log(x, y); // 2 1 식별자 네이밍 규칙 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러기호( $ ) 를 포함할 수 있다. 식별자는 문자 , underscore( _ ) , 달러기호( $ ) 로 시작해야 한다. 숫자 및 특수문자로 시작할 수 없다. 예약어는 식별자의 네이밍으로 사용이 불가능하다. 대소문자를 구별한다. (var firstName , Fristname, FIRSTNAME; // 모두 각각 다른 변수 ) 예약어 await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* Switch this throw true try typeof var void while with yield* 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다. 좋은 변수 이름은 코드의 가독성이 높인다. 하나 이상의 영어 단어로 구성된 식별자를 네이밍할때는 아래와 같은 네이밍 컨벤션을 이용한다. 123456789101112// 카멜 케이스 (camelCase)var firstName;// 스네이크 케이스 (snake_case)var first_name;// 파스칼 케이스 (PascalCase)var FirstName;// 헝가리언 케이스 (typeHungarianCase)var strFirstName; // type + identifiervar $elem = $('.myClass'); // jQuery 가장 일반적인 것 : 코드 전체의 가독성을 높이기 위해서 2가지 네이밍 컨벤션이 많이 쓰이고 있다. 변수명 / 함수명 -&gt; 카멜케이스 생성자 함수명 / 클래스명 -&gt; 파스칼케이스 ECMAScript 사양에 정의된 표준 객체(String, Number 등등)와 전역 함수들도 카멜케이스와 파스칼 케이스 네이밍 컨벤션이 사용되고 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"https://hyeok999.github.io/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"javascript-study-02","slug":"javascript-study-02","date":"2019-10-02T19:19:54.000Z","updated":"2019-11-30T16:30:29.120Z","comments":true,"path":"2019/10/03/javascript-study-02/","link":"","permalink":"https://hyeok999.github.io/2019/10/03/javascript-study-02/","excerpt":"","text":"JavaScript Study 02 자바스크립트 특징 자바스크립트 엔진 자바스크립트 실행환경 웹 브라우저는 어떻게 동작하는가? 웹 브라우저 동작 과정 브라우저의 핵심 역할 서버의 핵심 역할 ESLint 자바스크립트 특징 웹 브라우저에서 동작하는 유일한 프로그래밍 언어 프로토타입 기반의 객체 지향 언어 ( 다른 언어에서 함수는 구문이지만 JS는 값) 값은 주고 받을 수가 있다. (함수형 프로그래밍) JS 는 절차지향(명령형), 객체지향, 함수형이 모두 가능한 멀티 패러다임 프로그래밍 언어 자바스크립트 엔진자바스크립트를 실행할 수 있는 환경으로 브라우저에 내장되어있다. 내부적으로 사용율이 높은 것은 컴파일을 하는 특징을 지니고 있으며 인터프리터와 컴파일러를 결합해서 작동한다. 현재 IE를 제외한 대부분의 브라우저는 ES6 까지 지원이 되고있다. (자바스크립트는 인터프리터언어라고는 하지만 그 기준이 위와 같은 잣대로 인해 모호해지고 있다.) 자바스크립트 실행환경&lt;head&gt; 안에는 기본적으로 &lt;meta ~ &gt;가 들어간다 시멘틱 문법상 &lt;head&gt;는 눈에 보이지 않는 데이터들을 모아놓은 집합이다. 따라서 script파일은 &lt;haed&gt;안에 들어가야 맞다. 하지만 인터프리터는 위에서 한줄 할줄 읽는다. 만약 script 가 head에 들어갈 경우 script에 정의된 변수나 객체들이 html에 랜더링 되어야 값들을 참조 못할 수 있다. 따라서 body 태그 최하단에 넣어주는 것이 바람직하며 시맨틱적인 표준을 지키고 싶다면 async defer 와 같은 옵션을 이용한다. 웹 브라우저는 어떻게 동작하는가? 클라이언트 : 서비스를 받는 입장 ( 요청하는 입장 ) 서버 : 서비스를 하는 입장 ( 응답하는 입장) 도메인 : ip를 식별하는 이름. 암묵적인 룰 : 웹서버는 root로 요청이 오면 index.html를 주도록 되어있다. ex) www.naver.com 웹 브라우저 동작 과정 클라이언트는 네이버에 접속을 시도한다. 네이버에 접속하기 위해서 인터넷 브라우저 주소창에 www.naver.com 을 입력한다. www.naver.com에 대한 IP 주소를 알기 위해서 DNS서버에 먼저 접속한 후DNS서버에게 www.naver.com에 해당되는 IP주소를 요청한다. DNS서버는 www.naver.com에 해당되는 IP주소를 응답한다. IP주소를 알게 된 브라우저는 다시 해당 IP주소를 통해서 네이버 서버에 접근하게 된다. 클라이언트는 서버에게 해당 페이지에 대한 접속과 .html 파일을 요청한다. 서버는 네이버 메인 페이지에 대한 화면 요소 정보가 담긴 index.html파일을 응답한다. 브라우저의 렌더링 엔진의 html파서는 index.html파일을 로드하고 파싱을 시작한다. 파싱중 &lt;link&gt; 를 만나게 된다. &lt;link&gt;에는 .css파일이 적혀있었다. html파서는 파싱을 중지한후 클라이언트는 다시 서버에게 .css파일을 요청한다. 서버는 .css파일을 응답한다. 클라이언트의 렌더링 엔진의 html파서는 제어권을 css파서에게 넘겨준다. css파서는 .css파일을 로드하고 파싱을 시작한다. 파싱이 완료되고 CSSOM트리가 완성된다. css파서는 제어권을 다시 html파서에게 넘겨준다. 중지되었던 html 파싱을 재 시작한다. 파싱하던중 &lt;script&gt; 를 만나게 된다. &lt;script&gt;에는 .js파일이 적혀있었다. html파서는 파싱을 중지한 후 클라이언트는 다시 서버에게 .js 파일을 요청한다. 서버는 .js파일을 응답한다. html파서는 .js파일을 읽을 수 없기 때문에 제어권을 브라우저에 탑재된 자바스크립트 엔진에게 넘겨준다. 제어권을 넘겨받은 자바스크립트 엔진은 DOM api를 이용하여 .js파일을 로드한다. 로드된 .js파일을 토크나이즈 하여 소스코드를 어휘분석하여 의미를 갖는 최소단위인 토큰으로 분리한다. 분리된 토큰을 구문분석하여 문법의 의미와 구조를 반영한 트리인 AST를 생성한다. AST는 자바스크립트 엔진의 인터프리터가 읽을 수 없기 때문에 인터프리터가 실행할 수 있는 중간코드인 바이트코드로 변환되고 실행된다. 실행된 후 제어권을 다시 렌더링엔진의 html파서에게 전달한다. 제어권을 돌려받은 html파서는 중지되었던 파싱을 재 실행한다. 파싱이 완료되어 DOM트리가 형성된다. 전에 만들어진 CSSOM트리와 DOM트리를 합쳐 RENDER트리로 만든다. RENDER트리를 기반으로 클라이언트의 화면에 표출한다. 브라우저의 핵심적인 역할 : 서버에 HTML, CSS , Javascript를 요청 (request) 서버로부터 받아온 HTML , CSS , Javascript를 파싱하는 역할. 서버의 역할 무한 대기 ( 리퀘스트를 받기 위해서 ) 요청에 대한 응답 (response) 응답받은 파일(html, css)은 메모리상에 올린다. 이를 Read 라 한다. 그 후 Rendering Engine이 실행할 수 있는 형식으로 만들어 준다. 이를 Parsing 이라 한다. Parsing이 완료되면 Tree가 만들어지는데 이를 DOM tree ( CSS라면 CSSOM tree)가 만들어진다. tree : 자료구조의 하나로 거슬로 올라가고 / 따라서 내려가기 편한 형태의 자료구조. Dom이 완성되기 전에 자바스크립트가 실행이 된다. 자바스크립트 엔진은 AST라는 트리를 만든다. 실행이 종료되면 돔을 만드는 작업을 마저한다. 중요단어 파싱, 돔트리, 렌더트리, CSSOM트리 검사창을 통해 테스트 하는 방법 console.log 디버깅이란? 논리적인 오류를 검출하여 제거하는 과정. 디버깅하는법 : 검사창을 통해 에러 확인 . Sources 탭에서 에러부분에 밑줄이 쳐있다. break 거는법은 의심가는 줄을 선택한다. 선탹된 소스부분은 디버깅시 넘어가지 않고 멈춘다. ESLint 코드 Linting 이란? 특정 스타일 규칙을 준수하지 않는 문제가 있는 소스코드를 찾는데 사용되는 방식 Linter는 이러한 Linting을 수행하는 도구를 의미. ESLint는 특정 스타일 규칙을 제한하거나 새롭게 개정까지 가능하다. 대부분의 프로그래밍 언어에는 컴파일하는 과정이 있어서 컴파일시 수행되는 Linter가 내장되어있다. 하지만, Javascript는 컴파일하는 언어가 아니기 때문에 이러한 오류를 잡기 위해 ESLint 와 같은 프로그램을 적극적으로 이용하여 실행하지 않고 기본적인 코드 오류, 구문 오류, 잘못된 규칙등을 발견할 수 있다. ESLint 사용 2가지 방식 JavaScript 개발시 사용되는 에디터에 플러그인을 추가하는 방식 Webpack에 번들링 하여 사용하는 방식. ESLint 설치 및 설정 폴더 생성 후 npm 초기화 및 npm으로 eslint 관련파일 설치 eslint eslint-config-airbnb-base : arirbnb 에서 제정된 코드 스타일 규칙은 좋기로 유명하다. eslint-plugin-import eslint-plugin-html 아래 명령 실행 $ cd &lt;project-folder&gt;$ npm init -y $ npm install eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-html --save-dev - 주의 : ESLint는 가급적이면 해당 폴더에서만 사용할 수 있도록 설치 하는것이 좋다. 전역설치는 매번 추가 설정이 필요로 한다. node_modules 폴더 package-lock.json (없을 수도 있다.) package.json VSCode에 extention 설치 사용중인 폴더에 .eslintrc.js 파일 생성 후 아래 코드 넣기 1234567891011121314151617181920212223module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) \"no-console\": \"warn\", \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"] &#125;&#125;; ESLint 사용처 명시하기 (맥OS 기준) - 설정 탭 접근 - 오른쪽 상단 아이콘 클릭 - 아래 코드 추가 12345\"eslint.validate\" : [ \"javascript\", \"javascriptreact\", \"html\"] ESLint 사용하기 ESLint 가 정상적으로 적용이 완료되었다면 위와 같이 전혀 문제 없어보이는 코드에도 에러, 경고등을 표시한다. 마우스를 살포시 올려보면 무엇이 에러인지 적혀있다. 위 예제에서는 “ var를 쓰지말고 let 이나 const를 써라 “라고 경고하고 있다. ESLint 규칙 설정하기 (.eslintrc.js) 위와 같이 마우스를 올릴 경우 나오는 에러 혹은 경고등을 .eslintrc.js 파일에서 설정이 가능하다. off : 0 warn : 1 error : 2","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"eslint-description","slug":"eslint-description","date":"2019-10-02T11:32:57.000Z","updated":"2019-11-30T16:46:07.041Z","comments":true,"path":"2019/10/02/eslint-description/","link":"","permalink":"https://hyeok999.github.io/2019/10/02/eslint-description/","excerpt":"","text":"ESLint 코드 Linting 이란? 특정 스타일 규칙을 준수하지 않는 문제가 있는 소스코드를 찾는데 사용되는 방식 Linter는 이러한 Linting을 수행하는 도구를 의미. ESLint는 특정 스타일 규칙을 제한하거나 새롭게 개정까지 가능하다. 대부분의 프로그래밍 언어에는 컴파일하는 과정이 있어서 컴파일시 수행되는 Linter가 내장되어있다. 하지만, Javascript는 컴파일하는 언어가 아니기 때문에 이러한 오류를 잡기 위해 ESLint 와 같은 프로그램을 적극적으로 이용하여 실행하지 않고 기본적인 코드 오류, 구문 오류, 잘못된 규칙등을 발견할 수 있다. ESLint 사용 2가지 방식 JavaScript 개발시 사용되는 에디터에 플러그인을 추가하는 방식 Webpack에 번들링 하여 사용하는 방식. ESLint 설치 및 설정 폴더 생성 후 npm 초기화 및 npm으로 eslint 관련파일 설치 eslint eslint-config-airbnb-base : arirbnb 에서 제정된 코드 스타일 규칙은 좋기로 유명하다. eslint-plugin-import eslint-plugin-html 아래 명령 실행 $ cd &lt;project-folder&gt;$ npm init -y $ npm install eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-html --save-dev - 주의 : ESLint는 가급적이면 해당 폴더에서만 사용할 수 있도록 설치 하는것이 좋다. 전역설치는 매번 추가 설정이 필요로 한다. node_modules 폴더 package-lock.json (없을 수도 있다.) package.json VSCode에 extention 설치 사용중인 폴더에 .eslintrc.js 파일 생성 후 아래 코드 넣기 1234567891011121314151617181920212223module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) \"no-console\": \"warn\", \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"] &#125;&#125;; ESLint 사용처 명시하기 (맥OS 기준) - 설정 탭 접근 - 오른쪽 상단 아이콘 클릭 - 아래 코드 추가 12345\"eslint.validate\" : [ \"javascript\", \"javascriptreact\", \"html\"] ESLint 사용하기 ESLint 가 정상적으로 적용이 완료되었다면 위와 같이 전혀 문제 없어보이는 코드에도 에러, 경고등을 표시한다. 마우스를 살포시 올려보면 무엇이 에러인지 적혀있다. 위 예제에서는 “ var를 쓰지말고 let 이나 const를 써라 “라고 경고하고 있다. ESLint 규칙 설정하기 (.eslintrc.js) 위와 같이 마우스를 올릴 경우 나오는 에러 혹은 경고등을 .eslintrc.js 파일에서 설정이 가능하다. off : 0 warn : 1 error : 2","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"https://hyeok999.github.io/categories/Develop/Tips/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"VSCode","slug":"VSCode","permalink":"https://hyeok999.github.io/tags/VSCode/"},{"name":"ESLint","slug":"ESLint","permalink":"https://hyeok999.github.io/tags/ESLint/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://hyeok999.github.io/tags/JavaScript/"}]},{"title":"daily_algorithm03","slug":"daily-algorithm03","date":"2019-10-02T00:39:36.000Z","updated":"2019-11-30T16:51:08.733Z","comments":true,"path":"2019/10/02/daily-algorithm03/","link":"","permalink":"https://hyeok999.github.io/2019/10/02/daily-algorithm03/","excerpt":"","text":"문제 출처 : 프로그래머스 수박수박수박수박수박수?문제 설명길이가 n이고, 수박수박수박수….와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 수박수박을 리턴하고 3이라면 수박수를 리턴하면 됩니다. 제한 조건 n은 길이 10,000이하인 자연수입니다. 입출력 예 n return 3 수박수 4 수박수박 1234567891011121314151617function solution(n) &#123; var answer = ''; var su = \"수\"; var bak = \"박\"; var i = 0; for(i=1;i&lt;=n;i++)&#123; if(i%2==0)&#123; answer = answer + bak; &#125; else if(i%2!=0)&#123; answer = answer + su; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"javascript-study-01","slug":"javascript-study-01","date":"2019-10-01T05:56:40.000Z","updated":"2019-11-30T16:30:34.525Z","comments":true,"path":"2019/10/01/javascript-study-01/","link":"","permalink":"https://hyeok999.github.io/2019/10/01/javascript-study-01/","excerpt":"","text":"JavaScript Study 01 용어 OT 프론트 엔드 개발자가 하는 일 웹페이지 vs 웹어플리케이션 프론트엔드 개발에 필요한 기술 초심자가 경험하는 3가지 개발의 어려움 프로그래밍이란 아스키코드 , 유니코드 컴파일러 interpreter Syntax , Semantics 자바스크립트 용어 - ( 러버덕 ) 플랫폼 : 어플리케이션이 동작하는 환경. 아스키 코드 유니 코드 컴파일러 인터프리터 JavaScript VS ECMAScript OT 프론트 엔드 개발자가 하는 일 애플리케이션을 사용하는 사람( 유저 )이 애플리케이션과 소통하기 위한 창구( User-Interface )를 사용하기 좋게 구현한다. UI는 상태는 정보를 서버로 전송하기도 하고 서버의 데이터를 가져와서 UI에 표시한다. 웹 어플리케이션은 웹 브라우저에서 작동됨. 브라우저가 직접 실행하는 언어는 JavaScript가 유일하다. 디자이너, 백엔드 개발자와의 협업. ( Tool의 학습이 중요하다. ) 웹페이지 vs 웹어플리케이션 웹페이지 : 정적 , 단순 정보제공. 웹어플리케이션 : 동적 , 정보제공 과 더불어 데이터흐름이 이루어진다. 프론트엔드 개발에 필요한 기술 HTML : tags &amp; attributes, Sementic web CSS : Layout(float , flex , grid), transition/animation, 반응형 웹 , Preprocessor(Sass, Less, Stylus, PostCSS), CSS방법론, CSS 프레임워크 크로스브라우징 JavaScript : ES5 , ES6 , ES Next , 클라이언트 사이드 웹 API( DOM/Event , Ajax ), 동작원리(브라우저, 자바스크립트 엔진), node.js HTTP Tools : Git / Webpack / Babel / ESLint / npm … Library / Framework : SPA(Angular, React, Vue.js), TypeScript, jQuery, Lodash, Axios… TDD(Test Driven Development) : karma / jasmins, mocha, chai 알고리즘 / 자료구조 초심자가 경험하는 3가지 개발의 어려움. 개발자가 하는 말을 이해하기가 힘들다. -&gt; 배경지식 : 기본적인 Computer Sience 지식 / 용어에 대한 이해 / 기본상식 어떻게 만들어야 할 지 감조차 오지 않는다. -&gt; 문제해결 능력 : 문제가 무엇인지 알아채야함. 알고리즘 자료경험. 어떻게 만들어야 할 지는 알겠는데 막상 코딩이 안된다. -&gt; 공부부족. 프로그래밍이란? 프로그래머가 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션 아스키 코드 , 유니코드 아스키코드 : 0과 1의 조합으로 사람이 이해할 수 있는 문자와 숫자의 조합. 1Byte / 경우의수 256개 유니코드 : 2Byte / 국제표준 컴파일러 사람의 언어를 컴퓨터가 이해할 수 있도록 변형 시켜주는 일종의 번역기. 전체적인 코드를 한번에 번역해준다. 컴파일이라는 과정을 필요로 한다. interpreter 사람의 언어를 컴퓨터가 이해할 수 있도록 변형 시켜주는 일종의 번역기. 사람이 적어놓은 코드 내용을 한줄, 한줄씩 컴퓨터가 이해하도록 동시 통역한다. 자바스크립트는 interpreter이다. 즉, 우리가 짠 코드를 브라우저한테 주면 브라우저가 한줄 한줄씩 통역해줄 것이다. 컴파일러보다는 느리다. 단 컴파일 과정이 별도로 필요하지 않다. Syntax &amp; Semantics Syntax : 프로그래밍 문법. Semantics : 말 그대로 문장의 의미. 프로그래밍 문법을 잘 안다고하여 코딩을 잘 하는 것이 아니다. 반드시 문법(Syntax) 와 의미(Semantics) 을 맞게 구성하여야 한다. 예를 들어보자. 123const number = 'string';console.log(number * number); // NaN 위는 문법(Syntax)에는 전혀 문제가 없다. 하지만 의미상으로는 매우 이상하다. number라는 의미의 변수에는 누가보아도 숫자가 들어갈 것이라고 예상했지만, 이상하게 문자열이 들어가있으며 심지어 그 문자열을 서로 곱하는 연산을 취하고 있다. 정말로 이상한 의미를 지니고 있다. 위와 같은 예제로 보아 문법과 더불어 의미를 지켜가며 코딩을 해야만 한다. 자바스크립트 브랜던 아이크가 개발한 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량의 프로그래밍 언어. 컴파일이 실행되는 언어가 아닌 브라우저에서 즉시 통역하는 인터프리터 언어이다. 브라우저들만의 특징을 이용하여 인터프리터의 단점인 느린속도를 조금이나마 보안하였고, 명령형, 함수형, 프로토기반 객체지향 프로그램을 내포하는 멀티 패러다임 프로그래밍 언어(프로토타입 기반의 객체 지향 언어) 자바스크립트 와 ECMAScript자바스크립트는 ECMAScript보다 더 큰 개념이다. ECMAScript에서 설계되어있는 모든 문법 규정들을 포함한 언어를 JavaScript 라고 한다. ECMAScript는 스크립트 언어가 준수해야 하는 규칙, 세부 사항 및 지침을 제공한다. 자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대(core)를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, Ajax 자바스크립트를 이용해서 서버와 브라우저가 비동기적으로 데이터를 교환할 수 있는 통신기능. 이전의 웹 페이지는 서버로부터 HTML을 전달받아서 웹페이지를 전체적으로 렌더링 하는 방식이었다. 따라서 화면 내부에 있는 사소한 움직임까지도 전부 서버로부터 HTML에게 전달받아서 웹페이지를 다시 렌더링해야되는 정말로 불편한 구조였다. Ajax의 등장은 이러한 부분을 크게 해소하였다. 페이지 전체를 렌더링하지 않고 필요한 부분만 다시 그리는 방식이 가능해진것이다. 또한 데스크탑 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환까지 가능하게되면서 기존의 패러다임을 크게 부셔주는 역할을 하였고 이는 자바스크립트에 대한 인식을 바꿔주는 큰 계기가 되었다. jQuery DOM 을 보다 쉽게 제어가 가능하고 , 크로스 브라우징을 해결해주는 라이브러리. 등장 당시에는 크로스브라우징 이슈 , 자바스크립트의 러닝 난이도 해소등의 이유로 인해 정말로 많이 사용되었던 기술이지만, 현재는 점점 사용률이 줄어들고 있는 추세이다. 이유는 예전에는 HTML이 바뀌게 되면 javascript가 영향을 받게되었는데 현재에는 HTML이 바뀌게 되면 javascript가 영향을 받지 않게되었다. ( Component Based Development 방법론 ) 하지만, CBD방법론은 보통 대규모 프로젝트나 큰 프레임워크( React.js , Vue.js , Angular.js )를 이용할때 사용하게된다. 따라서 소규모 프로젝트나 경험으로 해보기에는 매우 좋은 라이브러리. V8 자바스크립트 엔진 자바스크립트로 웹 애플리케이션을 구축하려는 시도가 늘어가면서 보다 빠르게 동작하는 자바스크립트 엔진이 요구됨. 따라서 구축된 것이 구글에서 개발한 V8 자바스크립트 엔진. Node.js 자바스크립트는 원래 웹 브라우저에서 작동을 한다. Node.js는 자바스크립트가 웹브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되게 하는 범용 프로그래밍 언어. SPA 프레임워크 Single Page Application 의 줄임말, 진짜 말그대로 .html 페이지가 단 1개만 존재하며 필요한 구성부분을 모두 Component로 제작하여 사용한다. 이는 재사용성에 큰 기여를 한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"https://hyeok999.github.io/categories/TIL/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"}]},{"title":"daily_algorithm02","slug":"daily-algorithm02","date":"2019-10-01T05:56:06.000Z","updated":"2019-11-30T16:51:15.727Z","comments":true,"path":"2019/10/01/daily-algorithm02/","link":"","permalink":"https://hyeok999.github.io/2019/10/01/daily-algorithm02/","excerpt":"","text":"문제 출처 : 프로그래머스 서울에서 김서방 찾기문제 설명String형 배열 seoul의 element중 Kim의 위치 x를 찾아, 김서방은 x에 있다는 String을 반환하는 함수, solution을 완성하세요. seoul에 Kim은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다. 제한 사항 seoul은 길이 1 이상, 1000 이하인 배열입니다. seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다. Kim은 반드시 seoul 안에 포함되어 있습니다. 입출력 예 seoul return [Jane, Kim] 1234567891011121314function solution(seoul) &#123; var answer = ''; var seoul_array_num = 0; for(var i=0;i&lt;seoul.length;i++)&#123; if(seoul[i] == \"Kim\")&#123; seoul_array_num = i; break; &#125; &#125; answer = \"김서방은 \" + seoul_array_num + \"에 있다\" return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"limrim 쇼핑몰 클론하기","slug":"pinkjelly","date":"2019-09-30T14:08:50.000Z","updated":"2019-11-30T17:15:15.401Z","comments":true,"path":"2019/09/30/pinkjelly/","link":"","permalink":"https://hyeok999.github.io/2019/09/30/pinkjelly/","excerpt":"","text":"PinkJelly Projectlimrim 쇼핑몰 사이트 클론하기. 1. 팀 소개 팀명 : 개발바닥 ( PinkJelly ) 팀장 : 김준혁 팀원 : 권은비, 박홍빈 2. 팀 주제limrim 쇼핑몰 사이트 클론 3. 주제 선정 이유 평소에 쇼핑몰 사이트를 자주 봐왔고, HTML 와 CSS 학습을 위해서 실제 구현되고 서비스 중인 쇼핑몰을 클론 해보는 것은 어떨까? 라는 생각에 의해 시작 됨. 4. 프로젝트 요구 사항 W3C에서 제공한 MarkUp Validation Service 에서 이상이 없을 것. 최대한 시멘틱 하게 작성할 것. html , css 적인 요소를 구현하는 JS를 최대한 사용하지 말 것. 5. 구현 기술 HTML CSS Javascript 6. 구현 내용 캐러셀 애니메이션 슬라이드 hover 애니메이션 grid시스템, flex배치 드롭다운 애니메이션 Top-Bottom 버튼 광고배너 absolute 등등.. 7. 프로젝트 구현 영상 7. 한계점 및 보완점한계점 : 캐러셀 슬라이드를 JS 없이 구성하기 위해서 시멘틱하지 못한 마크업을 하게되었음. (label , input 남발) 보안점 : JS가 필요한 부분은 JS 혹은 라이브러리를 이용 한다. View Project Sourceby GitHub","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Project","slug":"Develop/Project","permalink":"https://hyeok999.github.io/categories/Develop/Project/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"Project","slug":"Project","permalink":"https://hyeok999.github.io/tags/Project/"},{"name":"Web Clone","slug":"Web-Clone","permalink":"https://hyeok999.github.io/tags/Web-Clone/"}]},{"title":"daily_algorithm01","slug":"daily-algorithm01","date":"2019-09-30T10:38:58.000Z","updated":"2019-11-30T15:51:43.134Z","comments":true,"path":"2019/09/30/daily-algorithm01/","link":"","permalink":"https://hyeok999.github.io/2019/09/30/daily-algorithm01/","excerpt":"","text":"문제 출처 : 프로그래머스 체육복문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 123456789101112131415161718192021222324252627function solution(n, lost, reserve) &#123; var answer = n-lost.length; var temp_value = 0; var lost_value = 0; for(var i=0;i&lt;reserve.length;i++)&#123; for(var j=0;j&lt;lost.length;j++)&#123; if(reserve[j]-1 == lost[i])&#123; lost_value++; temp_value++; break; &#125; if(reserve[j]+1 == lost[i])&#123; lost_value++; temp_value++; break; &#125; &#125; if(temp_value==lost.length)&#123; break; &#125; &#125; answer = answer + lost_value; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"javascript","slug":"javascript","permalink":"https://hyeok999.github.io/tags/javascript/"},{"name":"Programmers","slug":"Programmers","permalink":"https://hyeok999.github.io/tags/Programmers/"}]},{"title":"리눅스 스터디 03","slug":"linux-study-03","date":"2019-09-30T10:26:04.000Z","updated":"2019-11-30T15:45:05.541Z","comments":true,"path":"2019/09/30/linux-study-03/","link":"","permalink":"https://hyeok999.github.io/2019/09/30/linux-study-03/","excerpt":"","text":"프로세스 cpu - processor (process X) ram - memory hdd, sdd - storage *각 특징 : * Storage : 가격이 싸고, 용량이 크다. 속도가 느리다 Memory : 가격이 비싸고 , 용량이 작다. 속도가 빠르다 processor : 기격이 매우비싸고, 용량이 매우작고, 속도가 매우빠르다 프로세스 관련 명령어 프로세스 리스트를 확인하는 명령어 : ps 백그라운드에서도 돌아가는 ps까지 확인하는 방법 : ps aux 이 중 특정 이름의 프로그램을 찾고싶다 -&gt; : ps aux | grep apache 프로세스를 끄는 방법 sudo kill [process-ID] 프로세스 리스트를 확인하는 명령어1 : top 프로세스 리스트를 확인하는 명령어2 : htop (별도 설치해야됨) 그 외 명령어 및 개념멀티 태스킹 : 여러개의 일을 하나의 화면에서 할 수 있다. 백그라운드로 멈추어서 보내는법 : ctrl + z 백그라운드에 실행되는 상태로 보내는법 : 명령어 맨뒤에 &amp;를 넣어준다. ex) ls -la &amp; 포그라운드로 가져오는법 : fg jobs : 백그라운드에서 실행 중인 프로그램 확인. +표시 : 백그라운드로 물러나있다가 포그라운드로 들어오는 프로그램 -표시 : +로 된 백그라운드가 끝나고나서 실행될 프로그램 백그라운드 종료 : kill %[번호] 백그라운드 강제 종료 : kill -9 %[번호] 항상 실행 - DemonWeb server = Demon 데몬은 /etc/init.d에 위치해 있다. 데몬을 키는방법은 sudo service [파일명] start ex) sudo service apache2 start 데몬을 끄는방법은 sudo service [파일명] stop ex) sudo service apache2 stop 데몬이 자동으로 실행되는 경우를 확인하는방법 아래 위치의 폴더에서 확인 가능하다. /etc/rc3.d -&gt; CLI방식 /etc/rc5.d -&gt; GUI방식 rc3.d로 cd S02apache2 S는 리눅스가 실행되면 실행된다. 는 것을 의미. 02는 우선순위 자동 데몬을 만들려면 실행시키고 싶은 프로그램을 rc3.d 혹은 rc5.d 폴더에 규칙대로 파일명을 생성하고 링크를 걸어준다. CRONCRON : 정기적으로 실행시키는 도구 crontab -e: 하고자 하는 일을 정의. [실행되는 분의주기 */1 = 1분에 한번 ] [실행되는 시간 *=상관없음] [실행되는 일] [실행되는 월] [실행되는 요일] [실행될 명령어] date &gt;&gt; date.log = 현재시각을 게속 저장함 crontab -e */1 * * * * date &gt;&gt; date.log 2&gt;&amp; 의미 : 1분마다 date라는 명령어의 결과를 date.log에 저장하는데 만약 에러가 나면 표준출력으로 redirection나게한다. 쉘이 실행될때 /bin/bash/.bashrc라는 파일을 실행되도록 설정되어있음. 따라서 쉘이 시작할때 무언가를 하고싶다면 .bashrc 안에서 설정해주면됨. 다중사용자명령어 id -&gt; 나는 누구인가? 명령어 who -&gt; 현재 시스템에 누가 접속해있는가? 유닉스의 계열의 2가지형태의 사용자 super(root) user 일반 user super(root) user sudo는 슈퍼유저의 권한을 빌려오는것 $표시 현재 사용자가 일반유저라는것을 의미, 슈퍼유저는 # *명령어 su * su - root : 슈퍼 유저로 사용자 변경 슈퍼유저에서 빠져나가는법 exit. sudo passwd -u root : root에 대해 lock을 풀어버림. sudo passwd -l root : root에 대해 lock을 걸어버림. cd : 최상위 디렉토리 cd /root : 최상위 디렉토리 안에 있는 root디렉토리 사용자 추가useradd -m 사용자명 : 처음, 사용자를 추가하면 passwd를 설정해야함. sudo passwd 사용자명 sudo usermod -a -G sudo 사용자명 권한 변경하는법chmod o-r 파일명 : other에 대한 파일권한중 읽기를 뼴 chmod o+r 파일명 : other에 대한 파일권한중 읽기를 추가해줌. chmod o+w 파일명 : other에 대한 파일권한 쓰기를 추가해줌. chmod u-r 파일명 : 소유자에 대한 읽기권한을 뺴버림. directory 권한r = 해당 폴더의 내용을 확인 w = 해당 폴더의 내용물에 파일생성등등 x = 해당 폴더의 접근.(cd) chmod -R o+w [폴더명] : 해당 폴더와 폴더내에잇는 모든 파일들 권한을 변경함. 숫자 변경법chmod 444 perm.txt : perm.txt에 대한 권한을 모두 read로 변경 사칙연산법chmod a=rwx perm.txt : perm.txt에 대한 모든 사용권한을 오픈함.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"https://hyeok999.github.io/categories/TIL/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hyeok999.github.io/tags/linux/"},{"name":"OS","slug":"OS","permalink":"https://hyeok999.github.io/tags/OS/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"unix","slug":"unix","permalink":"https://hyeok999.github.io/tags/unix/"}]},{"title":"리눅스 스터디 02","slug":"linux-study-02","date":"2019-09-30T08:23:37.000Z","updated":"2019-11-30T15:44:53.494Z","comments":true,"path":"2019/09/30/linux-study-02/","link":"","permalink":"https://hyeok999.github.io/2019/09/30/linux-study-02/","excerpt":"","text":"[Input/Output] IO Redirection Output : 출력 redirection -&gt; 출력위치를 변경할 수 있다. (보통은 모니터)​ 예) ls -l &gt; result.txt = ls -l의 결과(Standard Output)를 result.txt에 저장한다. ​ 총 2가지의 Output 이 존재한다. Success : 성공했을 경우의 Output Error : 실패했을 경우의 Output Standard Output으로 redirection 하는 방법 : 1&gt; Error Output으로 redirection 하는 방법 : 2&gt; ex) rm rename2.tex 1&gt;result.txt 2&gt;result.txt Input : 입력 redirectionStandard Input : keyboard 예) hello.txt 안에는 hello 라는 텍스트가 저장되어있다. 만약에 hello.txt파일 안의 내용을 cat으로 출력하고 싶다면 다음과 같이 작성한다. cat &lt; hello.txt cat hello.txt IO Redirection Ouput Appendls -al &gt; result.txt 할 경우 result.txt로 결과가 저장된다. 그 후 ls -a &gt; result.txt할 경우 result.txt로 결과가 덮어씌우게 된다 만약 추가를 하고 싶다면 다음과 같이 사용해야만 한다. ls -al &gt;&gt; result.txt","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"https://hyeok999.github.io/categories/TIL/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hyeok999.github.io/tags/linux/"},{"name":"OS","slug":"OS","permalink":"https://hyeok999.github.io/tags/OS/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"unix","slug":"unix","permalink":"https://hyeok999.github.io/tags/unix/"}]},{"title":"리눅스 스터디 01","slug":"linux-study-01","date":"2019-09-30T06:44:47.000Z","updated":"2019-11-30T15:44:43.288Z","comments":true,"path":"2019/09/30/linux-study-01/","link":"","permalink":"https://hyeok999.github.io/2019/09/30/linux-study-01/","excerpt":"","text":"리눅스 명령어 리눅스의 특징 : command line interface ls : 파일보기 ​ 옵션 -l : 파일권한, 소유자,생성시간등의 자세한 정보를 추가로 나열해준다. pwd : 현재 놓여있는 디렉토리를 파악한다. mkdir : 폴더생성 touch [파일명] : 파일생성 cd [디렉토리명] : 현재 디렉토리 위치 변경 ​ 디렉토리 변경시 2가지 방법이 있다. 절대경로 예) cd /home/ubuntu. =&gt; / : root를 의미한다. 상대경로 예) cd .. =&gt; 상대경로는 내 위치에 따라서 위치를 조정하는것. rm [파일 명] : 파일 삭제 명령어 rm -r [파일명] : 폴더 삭제 명령어 모든 명령어 뒤 –version : 해당 명령어의 버전을 알려준다. 모든 명령어 뒤 –help : 명령에 무슨 옵션이 있는지, 어떠한 기능을 하는지 설명 도움말을 보여준다. man [명령어명] : 예) man ls man 내부 상세 단어 검색 : 예) /sort : sort라는 단어 검색 -&gt; 넘기는 방법은 n키 누르면 됨. 돌아가는 방법은 b키 누르면 됨. man과 –help의 차이 : help는 간결하게 명령어의 기능및 옵션 / man은 상세하게 보여준다. mkdir -p [파일명] : 예) mkdir -p dir1/dir2/dir3/dir4 -&gt; 부모 디렉토리를 만들수 있다. 옵션 -는 축약형 –는 기본형 ex) mkdir -p / mkdir –parent 숨긴파일은 파일명 앞에 . 이 붙는다. 숨긴파일을 보는 방법은 ls -a / ls –all 옵션으로 보면 된다. mv [원본파일] [이동위치 또는 변경할 파일명] cp [원본파일] [대상위치] 명령어 검색방법구글에서 검색한다. 예) 구글에서 create a directory in linux sudo : 임시로 권리자 권한을 빌려온다. sudo는 super user do 의 약자로 권리자 권한을 의미함. 제일 심각한 명령어 : sudo rm -rf / =&gt; 묻지도 따지지않고 루트디렉토리 전부 삭제 sudo [command] 권한만 빌림. su - : root계정으로 전환함. Package manager ( 리눅스 apt / yum)​ 보통 권한이 필요하기 때문에 sudo를 사용해야만 한다. sudo apt-get update : 현재 사용할 수 있는 패키지들의 목록을 최신상태로 업데이트한다. sudo apt-get install [패키지명] : 패키지를 다운로드 받는다. sudo apt-get upgrade [패키지명] : 패키지를 최신상태로 업데이트 한다. 패키지명 생략시 모든 패키지를 업데이트 한다. sudo apt-get remove [패키지명]: 패키지를 삭제한다. sudo apt-cache search [패키지명]: [패키지명]와 관련된 패키지 목록을 보여준다. homebrew ( 맥용 )​ 맥에서 주로 사용하는 패키지 매니저 brew search [패키지명] : [패키지명]과 관련된 패키지 목록을 보여준다. brew install [패키지명] : [패키지명]과 관련된 패키지를 다운받는다. brew list : 로컬에서 homebrew를 통해 설치한 패키지목록을 표시해준다. brew uninstall [패키지명] : [패키지명]을 삭제한다. brew upgrade [패키지명] : [패키지명]을 업데이트한다. brew update : homebrew로 사용가능한 패키지들의 목록을 업데이트한다. 리눅스 명령어 기반에서 다운로드 받는 방법 : wget​ 다운로드 받을 프로그램이 필요하다. ( wget 이용 ) wget url주소 : 파일명 그대로 받게됨. wget -O [파일명] url주소 오픈소스 다운로드 방법 : git​ 맘에 드는 git 주소 들어가서 git clone~","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"https://hyeok999.github.io/categories/TIL/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hyeok999.github.io/tags/linux/"},{"name":"OS","slug":"OS","permalink":"https://hyeok999.github.io/tags/OS/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"unix","slug":"unix","permalink":"https://hyeok999.github.io/tags/unix/"}]},{"title":"VSCode-hotkey","slug":"VSCode-hotkey","date":"2019-09-30T06:44:10.000Z","updated":"2019-11-30T15:41:17.569Z","comments":true,"path":"2019/09/30/VSCode-hotkey/","link":"","permalink":"https://hyeok999.github.io/2019/09/30/VSCode-hotkey/","excerpt":"","text":"VS 단축키(MAC은 command = ctrl / option = alt) shift + option + f : 전체 줄 정리 option + command + 화살표 : 다중 커서 라인 생성 option + command + g : 개별 약어 랩핑 ctrl + n : 파일 생성 ctrl + s : 저장 ctrl + b : 사이드 바 열기 ctrl + p : 시작 팔레트 ctrl + shift + P : 명령 팔레트 ctrl + shift + k : 그 줄 삭제 ctrl + F : 찾기(검색) ctrl + H : 찾기(검색)/바꾸기(대체) ctrl + / : 주석 Alt + Up : 해당 코드 줄 위로 이동 Alt + Down : 해당 코드 줄 아래로 이동 shift + alt + DownArrow : 아래 줄 복사 tab : 들여쓰기 shift + tab : 내어쓰기 ctrl + PageUp : 이전 편집기 열기(좌측 창으로 전환) ctrl + PageDown : 다음 편집기 열기 (우측 창으로 전환) ctrl + \\ : 편집기 분할(백슬래쉬) ctrl + 숫자 : 숫자 번째 분할된 편집기 그룹에 포커스 ctrl + W : 편집기 닫기 ! + enter : 기본적인 HTML","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"https://hyeok999.github.io/categories/Develop/Tips/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"VisualStudio Code","slug":"VisualStudio-Code","permalink":"https://hyeok999.github.io/tags/VisualStudio-Code/"},{"name":"VSCode","slug":"VSCode","permalink":"https://hyeok999.github.io/tags/VSCode/"},{"name":"HotKey","slug":"HotKey","permalink":"https://hyeok999.github.io/tags/HotKey/"}]},{"title":"CSS 인라인 블록","slug":"CSS-inline-block","date":"2019-09-30T06:43:15.000Z","updated":"2019-11-30T16:54:45.258Z","comments":true,"path":"2019/09/30/CSS-inline-block/","link":"","permalink":"https://hyeok999.github.io/2019/09/30/CSS-inline-block/","excerpt":"","text":"inline-block 특징 inline-block 끼리 나열할 경우 문제가 없다. 또한 inline-block은 서로간에 약간의 틈이 존재한다. 1234567891011121314151617&lt;style&gt; .test1&#123; display: inline-block; background: gold; width: 300px; height: 300px; &#125; .test2&#123; display: inline-block; background: silver; width: 300px; height: 300px; &#125;&lt;/style&gt;&lt;div class=\"test1\"&gt;&lt;/div&gt;&lt;div class=\"test2\"&gt;&lt;/div&gt; inline-block 끼리 나열 중 한 요소안에 또 다른 inline-block 요소가 나오면 레이아웃이 깨져버린다. 1234567891011121314151617181920212223242526272829&lt;/style&gt; .test1&#123; display: inline-block; background: gold; width: 300px; height: 300px; &#125; .test2&#123; display: inline-block; background: silver; width: 300px; height: 300px; &#125; .test2-test&#123; display: inline-block; background:lime; width: 20px; height: 100px; &#125;&lt;/style&gt; &lt;div class=\"test1\"&gt;&lt;/div&gt; &lt;div class=\"test2\"&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;/div&gt; 이럴 경우 각 부모 div에게 vertical-align 속성을 주어야 해결이 가능하다. 123.test1, .test2 &#123; vertical-align: top; &#125;","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"CSS","slug":"Develop/CSS","permalink":"https://hyeok999.github.io/categories/Develop/CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"inline-block","slug":"inline-block","permalink":"https://hyeok999.github.io/tags/inline-block/"}]},{"title":"html-css-study-13","slug":"html-css-study-13","date":"2019-09-28T08:01:51.000Z","updated":"2019-11-30T15:46:41.774Z","comments":true,"path":"2019/09/28/html-css-study-13/","link":"","permalink":"https://hyeok999.github.io/2019/09/28/html-css-study-13/","excerpt":"","text":"HTML Study 13 css : filter ( 흑백처리 , blur 효과 등등 ) tab-index margin 겹침 현상 background size 중앙 정렬 처리하는 방법 (수직 정렬등) aria-label , aria-labelby ( vs title ) aria-expended , aria-haspopup iframe 사용시 주의점 fr 단위 반응형 디자인을 할때는 px보다는 em, rem같은 단위를 써야 유연해지기에 좋다. grid에서는 fr단위로 쉽게 조절이 가능하다. 수직중앙정렬시 translateY : -50%를 이용한다. iframe은 퍼올때부터 대부분 사이즈가 지정이 되어있으므로 유동적인 사이즈를 맞추려면 div로 한번더 감싼다. css : filter ( 흑백처리 , blur 효과 등등 ) filter 기능은 이미지를 흑백처리하거나 blur, 반전, 밝기 조절등의 효과를 넣는 것을 말한다. 포토샵만큼 디테일하게 효과를 줄 수는 없으나, CSS로 간단한 효과정도는 줄 수 있다. 12345678910/* 사용 방법 : 선택자 &#123;filter:효과이름(값)&#125; */ .blur &#123;filter:blur(20px);-webkit-filter:blur(20px);&#125; .grayscale &#123;filter:grayscale(100%);-webkit-filter:grayscale(100%);&#125; .sepia &#123;filter:sepia(100%);-webkit-filter:sepia(100%);&#125; .saturate &#123;filter:saturate(10);-webkit-filter:saturate(10);&#125; .hue-rotate &#123;filter:hue-rotate(100deg);-webkit-filter:hue-rotate(100deg);&#125; .invert &#123;filter:invert(10);-webkit-filter:invert(10);&#125; .opacity &#123;filter:opacity(0.5);-webkit-filter:opacity(0.5);&#125; .brightness &#123;filter:brightness(5);-webkit-filter:brightness(5);&#125; tab-index 처리 div, span 와 같은 focus 초점을 받지 못하는 요소나 혹은 foucs를 받는 요소에게 fouc를 빼앗는 역할을 부여 할 수 있다. tabindex=”1” : 문서 안에서 가장 먼저 초점을 받게 할 수 있다. (주의점 : 마크업 순서를 거스르기 때문에, autofocusr가 더 적합) tabindex=”0” : 키보드 초점을 받지 못하는 요소들( div, span 등등) 도 초점을 받도록 해준다. tabindex=”-1” : 키보드 초점을 받는 요소에게서 초점을 받지 못하도록 만든다. 123&lt;div class=\"test\" tabindex=\"0\"&gt; 초점을 받을 수 있게 된다.&lt;/div margin 겹침 현상 기본적으로 형제 사이에서 일어난다. (이 현상은 오직 세로 margin값에서 일어난다.) 부모 ~ 자식 간에서도 겹침 현상이 발생한다. (둘 중 하나 이상 inline block일때는 겹치지 않는다.) 이를 가장 쉽게 해결하는 방법은 부모에게 글자추가, border 혹은 padding,와 같은 시각적효과를 적용하면 해결된다. position:absolute / float / grid 와 같은 레이아웃 작업은 margin이 발생하지 않는다. background-size​ background에 url 형태로 이미지를 불러들였을 경우, 만약 이미지 크기가 맞지 않다면 background-size를 상자 크기에 맞게 조절하면 된다. ( 보통 100% 로 조절. ) 중앙 정렬 처리하는 방법가로 정렬은 보통 text-align , vertical-align 등을 통해 쉽게 배치가 가능하다. 하지만 가운데 정렬은 배치를 하기 위해서는 padding 값이나 margin값을 정적으로 계산해야만 한다. 하지만 위와 같은 방법을 이용한다면 쉽게 배치가 가능하다. 보통 absolute를 이용하여 많이 배치한다. 12345.header&#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; aria-label / aria-labelledbyaria-label 속성은 값에 ‘간결한’ 설명(string)을 직접 제공한다. 마치 해당 태그가 무슨 역할을 하는지 설명하듯 설명문을 적어주는것과 같다. 예를들면 다음과 같다. 12345&lt;!-- O: 참조할 설명이 없는 경우 --&gt;&lt;form&gt; &lt;input type=\"search\" aria-label=\"웹툰 검색\"&gt; &lt;button&gt;검색&lt;/button&gt;&lt;/form&gt; aria-labelledby 속성은 ID(s) 값을 이용하여 ‘간결한’ 내용을 참조(연결)하는 방식으로 설명한다. 보통 h1, h2, h3, h4, h5, h6, a, button 요소를 참조하면 적절하다. aria-label 속성과 함께 선언하는 경우 aria-labelledby 속성이 우선순위가 높기 때문에 보조기기는 aria-labelledby 속성을 설명한다. 예를들면 다음과 같다. 123456789101112&lt;!-- O: 설명 참조 --&gt;&lt;section aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;h2 id=\"LZ-PATH\"&gt;레진패스란?&lt;/h2&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/section&gt;&lt;!-- O: 잘못된 참조 --&gt;&lt;a id=\"LZ-PATH\" href=\"#LZ-PATH-TEXT\"&gt;레진패스란?&lt;/a&gt;&lt;!-- 숨긴처리된 설명은 참조해서는 안된다. --&gt;&lt;div id=\"LZ-PATH-TEXT\" aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/div&gt; aria-labelledby 속성으로 숨김 처리한 설명을 참조하면 안 됩니다. 참조가 불가능한 설명은 aria-label 속성을 사용한다. 자세한 설명을 참조하면 안 된다다. 자세한 설명은 aria-descibedby 속성을 사용. aria-expanded 애플리케이션에서 제공되는 메뉴가 하위 메뉴를 포함하고 있 을 경우 현재 하위 메뉴가 접힌 상태인지 펼쳐진 상태인지 스크린리더 사용자에게 정보를 제공 해야 할 경우가 있다. 이때 aria-expanded 속성을 사용하여 접힌 상태라면 false 값을 펼쳐진 상태라면 true 값을 지정할 수 있다. aria-haspopup레진 블로그 설명 aria-haspopup 속성은 요소에 연결되어 있는 팝업(메뉴, 대화상자 등) 정보를 제공한다. 팝업은 다른 내용 위에 표시하는 블럭을 의미한다. iframe 사용시 주의점 iframe 태그는 하나의 html 로 생각해야만 한다. 따라서 iframe 태그 자체를 width, height등을 이용해 유연한 배치를 할 수 없다. 만약에 iframe 의 크기를 조절하고 싶다면 div태그로 1번더 감싸야만 한다. 그리고서 해당 div에 absolute를 거는 방식을 이용한다. 12345678910111213141516171819202122232425&lt;style&gt; .responsive-container&#123; position: relative; width: 100%; height: 0 !important; &#125; .responsive-iframe&#123; position: absolute; top:0; left:0; width: 100%; height: 100%; border: 0 none; &#125; .responsive-iframe-43&#123; padding-top: 75%; &#125; .responsive-iframe-169&#123; padding-top: 56.25%; &#125;&lt;/style&gt;&lt;div class=\"responsive-container responsive-iframe-169\"&gt; &lt;iframe aria-labelledby=\"video-subject\" class=\"responsive-iframe\" src=\"https://www.youtube.com/embed/umfaXctbqOs\"allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt; fr 단위fr이란 유연한 크기를 갖는 단위이다.grid 컨테이너 내의 공간 비율을 분수(fraction)로 나타낸다. 다만, 지원 브라우저가 낮다. 사용자가 계산해야 할 부분을 fr을 통해서 쉽고 유연하게 사용할 수 있다. 1234.grid &#123; display: grid; grid-template-columns: auto 100px 1fr 2fr;&#125; 1번 열은 auto를 사용한다. 해당 Element 내부 콘텐츠에 맞게 사이즈가 조정된다. 2번 열은 100px을 할당한다. 100픽셀 크기만큼의 폭을 차지한다. 3번 열은 1fr 크기를 할당한다. 1fr이란 남은 자유 공간의 1/3(총fr)만큼의 크기를 할당한다. 4번 열은 2fr 크기를 할당한다. 2fr이란 남은 자유 공간의 2/3(총fr)만큼의 크기를 할당한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-12","slug":"html-css-study-12","date":"2019-09-24T16:56:09.000Z","updated":"2019-11-30T15:46:55.932Z","comments":true,"path":"2019/09/25/html-css-study-12/","link":"","permalink":"https://hyeok999.github.io/2019/09/25/html-css-study-12/","excerpt":"","text":"HTML Study 12 webfont 정리 flex 재정리 white-space 속성 - pre , pre-wrap, pre-line 프로젝트 하면서 느낀점 9월 24일 webfont 정리 웹폰트를 사용하기 위해서는 다음과 같은 코드들이 일부 필요하다. 123456789101112131415@font-face &#123; font-family: NanumSquareWeb; src: local(NanumSquareR), local(NanumSquare), url(NanumSquareR.eot?#iefix) format('embedded-opentype'), url(NanumSquareR.woff) format('woff'), url(NanumSquareR.ttf) format('truetype'); font-style: normal; font-weight: normal; unicode-range: U+0-10FFFF;&#125;h1 &#123; font-family: NanumSquareWeb, sans-serif;&#125; 내가 사용할 웹폰트 패밀리명을 NanumSquareWeb으로 하겠다. 라고 선언한 예이다. 반드시는 아니지만, font-family 명과 사용할 폰트명을 동일시하게 하는 것 이 좋다. 로컬에 이미 설치 된 폰트의 경로를 적는 local() 속성과 다운로드 할 웹폰트의 주소를 적는 url() 속성이다. 위 코드는 local(NanumSquareR) → local(NanumSquare) → url(NanumSquareR.eot) → url(NanumSquareR.woff) → url(NanumSquareR.ttf) 순으로 폰트를 찾는다. format 속성을 사용하면 브라우저에서 지원 가능한 파일만 다운로드 받을 수 있습니다. 사용할 유니코드의 범위를 정한다. flex 재정리 (TCP 스쿨 내용 재정리)flex-direction 속성flex-direction 속성은 플렉스 컨테이너 안에서 플렉스 요소가 배치될 방향을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. row : 기본 설정으로, 플렉스 요소는 왼쪽에서 오른쪽으로, 그리고 위쪽에서 아래쪽으로 배치됩니다. row-reverse : 만약에 direction 속성값이 ltr(left-to-right)이면, 플렉스 요소는 반대로 오른쪽에서 왼쪽으로 배치됩니다. column : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 위쪽에서 아래쪽으로 배치됩니다. column-reverse : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 아래쪽에서 위쪽으로 배치됩니다. justify-content 속성justify-content 속성은 플렉스 요소의 수평 방향 정렬 방식을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. flex-start : 기본 설정으로, 플렉스 요소는 플렉스 컨테이너의 앞쪽에서부터 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 뒤쪽에서부터 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에서부터 배치됩니다. space-between : 플렉스 요소는 요소들 사이에만 여유 공간을 두고 배치됩니다. space-around : 플렉스 요소는 앞, 뒤, 그리고 요소들 사이에도 모두 여유 공간을 두고 배치됩니다. align-items 속성align-items 속성은 플렉스 요소의 수직 방향 정렬 방식을 설정합니다. 이 속성은 한 줄만을 가지는 플렉스 박스에서는 효과가 없으며, 두 줄 이상을 가지는 플렉스 박스에서만 효과가 있습니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 요소의 높이가 플렉스 컨테이너의 높이와 같게 변경된 뒤 연이어 배치됩니다. flex-start : 플렉스 요소는 플렉스 컨테이너의 위쪽에 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 아래쪽에 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에 배치됩니다. baseline : 플렉스 요소는 플렉스 컨테이너의 기준선(baseline)에 배치됩니다. flex-wrap 속성flex-wrap 속성은 플렉스 라인에 더 이상의 여유 공간이 없을 때, 플렉스 요소의 위치를 다음 줄로 넘길지를 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. nowrap : 기본 설정으로, 플렉스 요소가 다음 줄로 넘어가지 않습니다. 대신에 플렉스 요소의 너비를 줄여서 한 줄에 모두 배치시킵니다. wrap : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. wrap-reverse : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. 단, 아래쪽이 아닌 위쪽으로 넘어갑니다. align-content 속성align-content 속성은 flex-wrap 속성의 동작을 변경할 수 있습니다. 이 속성은 align-items 속성과 비슷한 동작을 하지만, 플렉스 요소를 정렬하는 대신에 플렉스 라인을 정렬합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 라인의 높이가 남는 공간을 전부 차지하게 됩니다. flex-start : 플렉스 라인은 플렉스 컨테이너의 앞쪽에 뭉치게 됩니다. flex-end : 플렉스 라인은 플렉스 컨테이너의 뒤쪽에 뭉치게 됩니다. center : 플렉스 라인은 플렉스 컨테이너의 가운데에 뭉치게 됩니다. space-between : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. space-around : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. 단, 양쪽 끝에 약간의 공간을 남겨둡니다. 플렉스 요소(flex item)의 flex 속성flex 속성을 이용하면 같은 플렉스 컨테이너 안에 있는 플렉스 요소의 너비를 상대적으로 설정할 수 있습니다. 다음 예제에서 첫 번째 플렉스 요소는 전체 너비의 3/5을 차지하며, 나머지 두 요소는 각각 전체 너비의 1/5씩을 차지하게 됩니다. 123.item:nth-child(1) &#123; -webkit-flex: 3; flex: 3; &#125;.item:nth-child(2) &#123; -webkit-flex: 1; flex: 1; &#125;.item:nth-child(3) &#123; -webkit-flex: 1; flex: 1; &#125; white-space 속성 - pre , pre-wrap, pre-line normal : 기본값. 공백을 여러개 넣어도 공백 1개만 인정. 자동줄바꿈. nowrap : 공백 1개만 인정. 텍스트가 길어도 줄바꿈이 안됨. pre : 공백을 마크업 그대로 표시. 코드에 줄바꿈이 없다면 줄바꿈이 안됨. pre-wrap : 공백을 마크업 그대로 표시함. 코드에 줄바꿈이 없어서 코드따라 줄바꿈됨. pre-line : 공백을 여러개 넣어도 1개만 표시. 코드에 불바꿈이 없어도 자동 줄바꿈이 됨. 프로젝트 하면서 느낀점 9월 24일 내가 모르는 태그들이 정말로 많다. layout 작업시 큰 틀에 대한 width를 전부 지정해주어야한다. 작은 틀을 맞추고 싶다면 width값을 100%로 큰틀에 대해 맞춘다. 최대한 그려가면서 레이아웃 작업을 진행해야 될 것 같음. 조언을 아끼지 말아라. (구하는 조언도, 모르는 조언도) 남들보다 1개더 안다면 1개더 배풀고 더 모른다면 알 때까지 노력할 것. 암기보다 이해가 먼저고 이해가 정 안될 경우 암기한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-11","slug":"html-css-study-11","date":"2019-09-23T17:25:10.000Z","updated":"2019-11-30T15:47:04.980Z","comments":true,"path":"2019/09/24/html-css-study-11/","link":"","permalink":"https://hyeok999.github.io/2019/09/24/html-css-study-11/","excerpt":"","text":"HTML Study 11 fontello 사용법 letter, word spacing transition 사용 주의점 프로젝트 하면서 느낀점 9월 23일 fontello 사용법 fontello 사용법 fontello 접속 마음에 드는 fontello 아이콘들 선택(라이센스 주의) 다운로드 다운로드 된 압출파일을 해제 해제된 폴더를 프로젝트에 붙여넣는다.(가급적이면 폴더 네임수정 - 지저분함) CSS파일에 다음과 같이 넣어준다. 12345678@import url('./fontello/css/fontello.css'); /*import*//*사용 방법*/.header::after&#123; content: '\\e805'; font-family: \"fontello\";&#125; letter , word spacing 글자 사이의 간격은 letter-spacing으로, 단어 사이의 간격은 word-spacing으로 정한다. 값이 커지면 간격이 커진다. 값에는 음수를 넣을 수 있다. ( 마이크로소프트 엣지나 인터넷 익스플로러에서는 단어 사이의 간격을 음수로 정해도 글자가 겹치지 않을 정도로만 간격이 줄어든다.) 음수를 값으로 하는 경우 글자가 겹칠 수 있다. 글자 사이의 간격을 변화시키면 단어 사이의 간격도 변한다. 단어 사이의 간격을 변화시켜도 글자 사이의 간격은 변하지 않는다. transition 사용 주의점​ transition 사용시 초(s) 단위를 붙일 경우, 0일때 s를 생략하면 작동을 안한다. ​ 꼭 유의 하고 사용할 것. 프로젝트 하면서 느낀점 막히면 차분히 무엇이 문제인지 돌아보고 꼭 구조적으로 해결하기 보다는 작은부분부터 수정해 나가기. 개발 도중 정적이니 동적이니 반응형이니 고정형이니 생각하지 말고 현재 주어진 디자인만 생각하기. 레이아웃 설계는 가능한 그리면서 진행하기. (나중에 레이아웃을 뒤엎는 경우가 생긴다.) flex , float , absolute , grid 특성에 대해서 다시 한번 공부하기","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"CSS 선택자 정리","slug":"CSS-Selector-Organize","date":"2019-09-22T16:12:32.000Z","updated":"2019-11-30T16:54:38.746Z","comments":true,"path":"2019/09/23/CSS-Selector-Organize/","link":"","permalink":"https://hyeok999.github.io/2019/09/23/CSS-Selector-Organize/","excerpt":"","text":"CSS 선택자 정리 Etc 참고 : CSS 선택자 총 정리 사이트","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"CSS","slug":"Develop/CSS","permalink":"https://hyeok999.github.io/categories/Develop/CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"https://hyeok999.github.io/tags/Selector/"}]},{"title":"html-css-study-10","slug":"html-css-study-10","date":"2019-09-21T10:58:02.000Z","updated":"2019-11-30T15:47:11.007Z","comments":true,"path":"2019/09/21/html-css-study-10/","link":"","permalink":"https://hyeok999.github.io/2019/09/21/html-css-study-10/","excerpt":"","text":"HTML Study 10 viewport VS % calc flex-basis 반응형 웹페이지 flex 이용 반응형 콘텐츠 -&gt; 이미지&amp;비디오 , iframe grid 이용 오늘의 학습 깨달음 레이아웃 구성 시 여라가지 flex 나 grid시스템을 사용할 수 있지만, 브라우저의 지원 유형을 잘 생각해보아야 한다. padding의 %는 width 기준이다. 즉, 가로의 %기준 만큼 패딩이 늘어난다. iframe은 이미지처럼 max-width 옵션이 작동안한다. 최대 넓이가 1600px 이상 넘어갔을 경우 화면 중앙으로 오게하는 방법 12max-width: 1600px;margin: 0 auto; viewport VS % viewport 는 화면대비 %비율이라 생각하면 편하고, %는 부모영역대비의 %비율이라 생각하면 편하다. 한, 예로 %는 부모영역보다 크게 %를 주어도 부모영역을 벗어날수는 없지만 viewport는 자식요소에 더 큰 viewport값을 줄 경우 부모요소를 넘어갈 수 있다. 초록색 영역이 %비율이고, 보라색 영역이 viewport 이다. calc 단순하게 생각하여, 사칙연산을 실행하고 계산값을 돌려주는 함수이다. calc(100vh - 100px); 와 같이 사용한다. flex-basis flex item이 된 컨텐츠들에게 적용할 수 있는 flex속성이다. flex-basis각 적용될 경우 기본 width값은 무의미하다. flex item이 적용된 width , height를 사용하고 싶다면 flex:auto 를 지정해주어야한다. flex-basis를 생략해면 flex-basis:auto 가 된다. flex-basis:0 과 flex-basis:auto의 차이는 auto는 width 만큼 item을 관리하며, flex-basis는 진짜 item 사이즈를 0으로 만든다. 단, 텍스트같은 콘텐츠가 있을 경우 콘텐츠 크기 만큼 줄게된다. flex-grow는 기본값이 0 / flex-shrink는 기본값이 1이다. 반응형 웹페이지 반응형 웹페이지는 말 그대로 유동적으로 변화가 가능한 웹페이지를 의미한다. 현재 시대는 모바일 , 테블릿 , 데스크탑 과 같은 여러가지 화면을 다루고 있기 때문에 유동적으로 각 기기에 맞는 화면을 송출할 줄 알아야만 한다. 반응형 웹페이지 제작시 주로 다음과 같이 이용한다. @media screen and (길이){ ​ 변할값 } 123456@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; width : 850px; &#125;&#125; 위 웹페이지의 fontsize가 16px이라 가정을 지었을 경우. 799px에서 800px로 넘어가는 순간 header 부분의 width가 850px로 넘어간다. 보통의 웹페이지는 flex,grid같은 시스템을 이용하여 min-width:800px (50em) / min-width:1024px (64em) / min-width:1600px (100em) [font-size : 16px기준] 로 설정해서 반응형을 많이 구축한다. flex 이용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* 모바일 스타일 */ /* 모바일 헤더 */ .header&#123; /* grow shrink basis */ flex-basis: 100%; height: 50px; &#125; /* 모바일 네비게이션 */ .navigation&#123; height: 50px; flex-basis: 100%; &#125; /* 모바일 메인 콘텐츠 */ .main-content&#123; height: calc(100vh - 200px); flex-basis: 100%; &#125; /* 모바일 광고 */ .ad&#123; flex-basis: 100%; height: 50px; &#125; /* 모바일 푸터 */ .footer&#123; flex-basis:100%; height: 50px; &#125;/* 테블릿 스타일 *//* 50em -&gt; 50글자까지 , 폰트사이즈 16px일경우 800px까지 */@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; flex-basis: 70%; &#125; /* 800 네비게이션 */ .navigation&#123; flex-basis:30%; &#125; /* 800 메인 콘텐츠 */ .main-content&#123; flex-basis:100%; height: calc(100vh - 150px); &#125; /* Tablet 레이아웃 순서 */ .header, .navigation, .ad&#123; order: -1; &#125;&#125;/* 랩탑 스타일 */@media screen and (min-width:64em)&#123; /* 랩탑 순서 */ .navigation&#123; order: -2; &#125; /* 랩탑 헤더 */ .header&#123; flex-basis: 100%; &#125; /* Laptop 내비게이션 */ .navigation&#123; flex-basis: 100%; &#125; /* 랩탑 메인 콘텐츠 */ .main-content&#123; flex-basis: 70%; &#125; /* 랩탑 광고 */ .ad&#123; flex-basis: 30%; height: calc(100vh - 150px); &#125;&#125;/* 와이드 랩탑 스타일 */@media screen and (min-width:100em)&#123; /* 와이드 랩탑 헤더 */ .navigation, .ad&#123; order: 0; &#125; .navigation, .main-content, .ad&#123; height: calc(100vh - 100px); &#125; /* 와이드 네비게이션 */ .navigation&#123; flex-basis: 30%; &#125; /* wide 메인 콘텐츠 */ .main-content&#123; flex-basis: 50%; &#125; /* wide 광고 */ .ad&#123; flex-basis: 20%; &#125;&#125; 반응형 콘텐츠 : 이미지&amp;비디오이미지 소스(비디오도 동작방식은 같다.) 1234567891011121314151617181920@charset \"utf-8\";/* 반응형 이미지 */.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; flex-basis: 50%; border: 10px solid #aaa; box-sizing: border-box; margin: 0; padding: 0;&#125;.rwd-img&#123; max-width: 100%; height: auto;&#125; 반응형 콘텐츠 : iframeiframe은 비디오와는 다르게 화면 비율에 대해 신경을 써주어야만 한다. 1234567891011121314151617181920212223242526 &lt;div class=\"container\"&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rNDmpbs4JTc\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\"width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nSHs3241p7E\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Vtj-T2c6jf0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/G-12mgNUwh0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233@charset \"utf-8\";.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; border: 10px solid teal; box-sizing: border-box; margin: 0; padding : 0; flex-basis: 30%; flex-grow : 1;&#125;.rwd-iframe-container&#123; width: 100%; padding-top: 56.25%; height: 0 !important; background: yellow; position: relative;&#125;.rwd-iframe&#123; /* iframe은 이미지처럼 max-width 옵션이 작동안한다. */ max-width: 100%; height: auto; position: absolute; top : 0; left : 0; width: 100%; height: 100%;&#125; grid 이용grid시스템 이용시 Chrome 보다는 firefox에서 확인한는게 더 편한다. 부모요소에서 display: grid; 를 쓰면서 시작할 수 있다. repeat함수 -&gt; repaet(반복할횟수, 크기[1 2) 크기 1개만 적을시 1개만 횟수만큼, 크기 1 2 다적을 시 배열식으로 적용한다.fr = fraction 분수단위 grid에서 순서를 지정해주고 싶다면 order를 쓰면 된다. 모든 기본 order값은 0이다. grid-auto-rows : 크기 / 콘텐츠 갯수만큼 자동적으로 적은 크기의 행을 만들어준다. grid-template-columns : 크기 / 크기 갯수만큼 적어 열을 생성한다. grid-template-rows : 크기 / 크기 갯수만큼 적어 행을 생성한다. grid-column-gap: 크기 / 각 콘텐츠 사이에 적은 크기의 마진을 발생시킨다. 라인 넘버 지정방법. 123456789101112131415.container&#123; display: grid grid-template-columns: 1fr 3fr 1fr; /* 3개의 열을 각각 5분의 1,3,1크기로 선언한다. */ grid-template-rows: repeat(3, 50px); /* 3개의 행을 50px크기로 선언한다.*/ &#125; .header&#123; /* grid-row : 1/2; grid-column : 1/4; */ /* row시작점 column시작점 row끝나는점 column끝나는점*/ grid-area: 1/1/2/4; &#125; /* 위에 구문은 병합 span으로도 아래처럼 사용이 가능하다. */.header&#123; grid-ared : 1/1/span 1/span 3; &#125; area 지정방법. 123456789101112131415161718192021222324252627282930313233343536@media screen and (min-width:50em)&#123; .container&#123; margin : 0 auto; max-width: 1600px; grid-template-columns: 1fr 3fr 1fr; grid-auto-rows: minmax(50px,auto); /* 최소 높이 50px이고 글자(텍스트 -콘텐츠)가 늘어남에 따라 auto로 상자가 늘어남. */ /* 아래에서 grid-area: 이름 ; 으로 지정한 것을 grid-template-areas에 각각 넣어준다. */ grid-template-areas: \"header header header\" \"navigation content ad\" \"footer footer footer\"; &#125;&#125; .container&#123; display: grid;&#125;.header&#123; grid-area: header;&#125;.navigation&#123; grid-area: navigation;&#125;.content&#123; grid-area: content;&#125;.ad&#123; grid-area: ad;&#125;.footer&#123; grid-area: footer;&#125; gird 시스템 이용시 짧게 사용할 경우 area:이름 기법이 훨씬 간편하지만, 열과 행이 많을 경우에는 line기법이 수월하다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-09","slug":"html-css-study-09","date":"2019-09-19T17:38:10.000Z","updated":"2019-11-30T15:47:17.190Z","comments":true,"path":"2019/09/20/html-css-study-09/","link":"","permalink":"https://hyeok999.github.io/2019/09/20/html-css-study-09/","excerpt":"","text":"HTML Study 09 q , blockqueto 태그 + cite 속성 small 태그 address 태그 flex 속기법 + order, grow , shrink flex-basis aside 태그 CSS animation : transition background 속기법 태그들이 공통으로 사용가능한 속성 오늘의 학습 깨달음 의미없는 구분자들은 마크업 하지 않는다. 만약 의미없는 img 태그들을 사용해야할 경우 alt값은 비워둔다 ( alt = “” ) img 태그를 사용할 것인지, 일반적인 태그를 이용하고 SEO적인 내용을 붙인 후 CSS 배경처리를 할 지 고민이 필요함. 사이트를 마무리하는 영역인 footer에서는 heading 태그를 사용하지 않는다. header 태그의 대신 역할 role=”banner” 와 footer 태그의 대신 역할 role=”content-info”등은 article 태그나 section태그 내에서 사용하면 안된다!!!! 반드시, body 태그의 직계 자식 요소로 사용되는 태그들의 역할 모델이 되어야만 한다. button 태그 사이의 띄어쓰기는 요소검사로 잡기 힘드니 button 태그가 나란히 사용되었을 때, 간격이 있다면 확인할 것. 레이아웃 작업 시, 가능한 노말플로우를 유지하라. 레이아웃 작업 시, 더 간단하고 쉽게 적용가능한 방법들을 모색하라. q , blockqueto 태그 인용임을 나타내는 태그에는 q와 blockquote가 있다. q는 문단 안에서 인용할 때 사용하는 인라인 요소이고, blockquote는 새로운 문단에서 인용하는 블록 요소 이다. 12345678q&#123; quotes: \"[[\" \"]]\"; &#125; /* 사용한 태그의 앞과 뒤에 [[ 과 ]] 이 생긴다.*//*혹은 한쪽만 선택하고 싶을경우 다음처럼도 이용함.*/q::after&#123; content: \"\";&#125; 인용문 출처는 cite 속성 을 이용한다. 1&lt;q cite=\"https://www.codingfactory.net/\"&gt;consectetur adipiscing&lt;/q&gt; small 태그 small 태그는 저작권, 면책조항, 주의사항, 법적 제한 사항, 주석표시에 사용한다. small 태그는 부가 정보를 나타내는 주석표시이므로, 여러 단락이나 광범위한 텍스트가 포함된 섹션에서는 사용하지 않는다. 1&lt;small class=\"copyright\"&gt; Copyright since &amp;copy; 2010 by Web Cafe &lt;/small&gt; address 태그 address는 소유자 또는 작성자의 연락처를 나타내는 태그. body 태그 안에 있으면 문서의 소유자 또는 작성자의 연락처를 나타냄. article 태그 안에 있으면 기사의 소유자 또는 작성자의 연락처를 나타냄. 기본 모양은 기울임꼴. 12345&lt;address class=\"address\"&gt; &lt;span&gt;서울시 강남구 성수동 &lt;/span&gt; &lt;span&gt;전화 : 02-1234-5678 &lt;/span&gt; &lt;span&gt;email : iasg2004@gmail.com&lt;/span&gt;&lt;/address&gt; &lt;!-- span을 준 이유 : 간격을 관리가 편해서 --&gt; flex 속기법 + order, grow , shrink flex : flex-grow flex-shrink flex-basis Flex 한국어 정리 사이트 order Item의 순서를 설정.Item에 숫자를 지정하고 숫자가 클수록 순서가 밀린다.음수가 허용. flex-grow Item의 증가 너비 비율을 설정.숫자가 크면 더 많은 너비를 가짐.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-shrink Item이 감소하는 너비의 비율을 설정.숫자가 크면 더 많은 너비가 감소.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-basisItem의 (공간 배분 전) 기본 너비를 설정.값이 auto일 경우 width, height 등의 속성으로 Item의 너비를 설정할 수 있다.하지만 단위 값이 주어질 경우 설정할 수 없다. 값 의미 기본값 auto 가변 Item과 같은 너비 auto 단위 px, em, cm 등 단위로 지정 flex 속성에서 설명한 것 같이 단축 속성 내에서 flex-basis를 생략하면 값이 0이 되는 것을 주의합시다. aside 태그&lt;aside&gt; 컨텐츠는 추가되어야 할 요소이지만, 메인 컨텐츠를 이해하기 위해 필수적인 것은 아니다. 예를 들어, 각주는 추가적인 정보를 제공하지만 필수적이지 않다. 그리고 발췌문은 필수적인 컨텐츠인 반면, 메인 컨텐츠에서 인용된 카피 문구이다. 하지만, &lt;aside&gt;는 관련성이 있어야 한다는 사실을 명심해야 한다. 사이트의 사이드바를 &lt;body&gt;의 자식요소로&lt;aside&gt;에 넣는 것은 좋다. 하지만 사이트 전반에 걸친 정보를 &lt;article&gt;의 자식요소로서 &lt;aside&gt; 안에 보여져서는 안되는 것. 그리고 &lt;aside&gt; 요소가 그 부모 섹셔닝 요소에 관련만 있으면, 광고에도 적합하다. 123456789&lt;aside&gt; &lt;p&gt; &lt;em&gt;섹셔닝 루트&lt;/em&gt; 요소에는 &lt;blockquote&gt;, &lt;body&gt;, &lt;details&gt;, &lt;fieldset&gt;, &lt;figure&gt;,&lt;td&gt;가 있다. &lt;/p&gt; &lt;/aside&gt; &lt;p&gt; &lt;header&gt;와 &lt;footer&gt;는 현재 속해 있는 섹셔닝 요소 또는 '섹셔닝 루트' 요소에만 적용된다.&lt;/p&gt; CSS animation : transition​ CSS transition은 :hover , :focus 와 같은 이벤트에 CSS 장면전환을 주기 위한 옵션이다. 12345678910.list&#123; transition : height 3s 0s, padding 3s 0s, background 2s 3s; /* 속성 지속시간 딜레이 */&#125;.list:hover, .list:focus&#123; padding : 10px; background: yellow; height : 100px;&#125; 위 구문은 list 클래스에 마우스가 올라가거나 , 키보드로 선택이 되었을 경우 3초에 동안 높이가 100픽셀 , 패딩이 10픽셀 늘어난다. 3초 기다린 후 2초동안 점점 노란색으로 배경색이 변경된다. background 속기법123456789101112/* background-image background-position [/background-size] repeat-style attachement box background-color */ h1 &#123; background: url('img.jpg') 0 50% /8em no-repeat fixed border-box blue; &#125;/* background-image repeat-style background-position attachement */ h2&#123; background: url(./images/bg_flower.png) no-repeat 50% 0 fixed, #eee linear-gradient(#ccc,#eee,#fff) repeat 0 0 fixed;&#125; /* 배경 이중 중첩, 먼저 나온 배경이 위로.*/ 태그들이 공통으로 사용이 가능한 속성 title id style class lang data-*","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-08","slug":"html-css-study-08","date":"2019-09-18T17:58:58.000Z","updated":"2019-11-30T15:47:24.943Z","comments":true,"path":"2019/09/19/html-css-study-08/","link":"","permalink":"https://hyeok999.github.io/2019/09/19/html-css-study-08/","excerpt":"","text":"HTML Study 08 position : sticky / fixed counter cursor : pointer calc( ) 함수 tabindex 일자로 요소를 나열하는 4가지 방법( 크게 ) position : sticky / fixed레진 fixed/sticky 참고 sticky sticky는 평소에는 기본 상태였다가 스크롤을 내리면서 임계점에 다했을 시 fixed처럼 요소가 게속 남아있는 형태를 말한다. 필수로 top, right, bottom, left 속성이 필수이다. fixed fixed는 스크롤 유무에 관계의 상관없이 뷰포트에 고정을 하는 것이다. 다만, sticky는 브라우저의 제한이 걸려있다.(아래참조) sticky와 fixed의 차이점은 fixed는 스크롤의 상관없이 뷰포트 자리 고정!, sticky는 스크롤이 다야 적용이된다는 것이다. counter​ css로 요소에 일일이 접근하지 않고 연속적인 리스트등에게 일렬번호등을 붙일 수 있다. 예를들어보자, 1234567891011ol&#123; counter-reset: chapter 0; /* counter-reset으로 초가화 : 카운터명 증가값(생략시 1씩 증가,0도 1씩증가)*/&#125;ol li&#123; counter-increment : chapter;&#125;ol li::before&#123; content : counter(chapter);&#125; cursor여러가지 커서 모양들 cursor : pointer는 마우스가 올라갈시 a링크를 hover한것처럼 마우스 커서가 손가락 표시 모양으로 바뀌게 된다. 그외 추가적인 커서 모양들은 위 링크를 참조하라. calc( ) 함수calc( ) 관련 블로그 CSS3에 새롭게 추가된 기능 중 calc()라는 것이 있다. 계산을 해주는 속성인데 기존에 자바스크립트로 하던 계산을 상당 부분 덜어준다. 예를 들어, 모든 문단을 “100% 너비에서 20픽셀(px)만큼 뺀 너비”로 설정하고 싶다면 다음과 같이 작성한다. 123456p &#123; width : 95%; /* 구식 브라우저를 위한 대비책(fallback) */ width : -webkit-calc(100% - 20px); /* for Chrome, Safari */ width : -moz-calc(100% - 20px); /* for Firefox */ width : calc(100% - 20px); /* for IE */&#125; calc() 내부에 입력할 수 있는 표현식은 +, -, *, / 등의 사칙 연산이 가능하다. 주의할 부분은 사칙 연산시 + 또는 - 는 반드시 기호 양쪽으로 공백을 삽입해야 한다는 것. 속성에 따라 값이 - 로 내려갈 수도 없는 경우가 있다.( width : calc(5px - 10px); = width: 0px; ) tabindex어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법이다. 어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법으로 사용된다. 크게 3가지 속성값을 이용할 수 있다. 0 값 - tabindex=”0” 양수 - tabindex=”1~32768” 음수 - tabindex=”-1” 속성 값이 0인 경우는 탭을 눌렀을 때 포커스가 가지 않는 엘리먼트에게 포커스를 줄 수 있다. 예를 들어, div영역에도 포커스를 줄 수 있다는 의미이다. 속성 값이 -1인 경우는 반대로 탭을 눌렀을 때 포커스가 가는 엘리먼트에게 포커스를 잃게 할 수 있다. 예를 들어, 링크 엘리먼트에 포커스를 잃게 한다는 의미다. 속성 값이 양수인 경우에는 우선순위를 지정해주는 것이다. 예를들어 , h3 tabindex=”6” 이라는 태그가 h3 tabindex=”3” 보다 먼저 나왔어도 키보드 탭 포커스는 3을 먼저 보여주고, 6을 보여줄 것이다. 일자로 요소를 나열하는 4가지 방법( 크게 )123456&lt;ol class=\"favorite-list\"&gt; &lt;li class=\"no1\"&gt; &lt;a href=\"#\"&gt;W3C&lt;/a&gt; &lt;em class=\"up\"&gt;상승&lt;/em&gt; &lt;/li&gt; &lt;/ol&gt; 위 그림과 같이 일자로 구성된 요소가 있다고 가정했을 때. 만드는 방법은 크게 4가지가 존재한다. 1. flex flex는 가장 쉬운 방법이다. 다만, 브라우저 지원을 잘 확인해야만 한다. 12345678910.favorite-list li&#123; display : flex; align-items: center; /*y축 중간 매치*/ &#125;.favorite-list em &#123; margin-left: auto; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/&#125; 2. float float의 단점은 일자로 나열하고 하는 요소들의 높이가 모두 같다면 크게 문제가 없지만 높이의 차이가 존재한다면 억지로 높이를 맞춰주어야만 한다. 12345678910.favorite-list li::before&#123; float : left;&#125;.favorite-list a&#123; float : left;&#125;.favorite-list em &#123; float : right;&#125; /* 높이의 차이 때문에 억지로 크게를 맞춰주어야한다.*/ 3. position 부모요소에 relative를 주고 왼쪽부터 작성되는 html 특성을 고려하여 가장 오른쪽 상승,하락 그림만 absolute를 이용하여 오른쪽에 배치하는 기법이다. 12345678910111213141516171819.favorite-list li&#123; position: relative;&#125;.favorite-list li::before&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list a&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list em &#123; position : absolute; margin-top : -5px; /*absolute를 이용함으로서 상승,수직 이미지를 오른쪽으로 붙어버린다.*/ top : 50%; /* top과 margin은 글씨가 많아서 칸이 넘어가도 상승 좌표도 덩달아 움직이게 하기 위함이다.*/ right : 0;&#125; 4. inline-block inline-block에서 margin-left를 이용하여 em요소를 오른쪽으로 보내버리는 방법이다. inline-block에서의 특징은 반드시 정렬하고자는 요소들은 모두 width값들이 명시가 되어야만 한다. 그래야 컴퓨터가 maring-left : auto 값을 계산하여 em요소를 오른쪽에 배치시킬수 있다. 1234567891011121314151617.favorite-list li::before&#123; display: inline-block; vertical-align: middle; width: 20px;&#125;.favorite-list a&#123; display: inline-block; width: 120px; vertical-align: middle;&#125;.favorite-list em &#123; display: inline-block; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/ margin-left: auto; vertical-align: middle;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-07","slug":"html-css-study-07","date":"2019-09-16T18:12:39.000Z","updated":"2019-11-30T15:47:31.304Z","comments":true,"path":"2019/09/17/html-css-study-07/","link":"","permalink":"https://hyeok999.github.io/2019/09/17/html-css-study-07/","excerpt":"","text":"HTML Study 07 article태그 강조 태그 ( em , strong ) font weight 가중치 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 agent-style 시 확인해야할 점들. float 대신에 inline-block 사용시 주의점. 밑줄 gradient 만드는 방법들. 애니메이션 방법들 article 태그 article 요소는 독립적이고 재배포하며 재사용 가능한 , 홀로 설 수 있는 내용들을 위주로 담는다. article 내부에는 header태그,footer등을 삽입할 수 있다. 주로 블로그 글, 포럼 글, 뉴스 기사, RSS피드 등이 article에 해당된다. 강조 태그 강조하는 태그 em em보다 더 큰 강조를 하는 strong 의미없이 글자크기만 굵게 하는 b태그 의미없이 기울이는 i태그 주로, 작품명(그림명, 책명, 영화명 등)을 표시하거나 인용할 때 사용 시멘틱점 관점으로 strong이 em보다 강조도가 높다. 디자인적 요소로는 em은 기울임, b와 strong은 굵게 표시한다. cite태그는 작품명 ,인용시 사용한다. b태그는 단순히 의미는없고 굵게만 표시한다. i태그는 단순히 의미없고 기울이게만 표시한다. font-weight 가중치웹 폰트 파헤치기 웹 폰트는 그룹화가 가능하다. 예를 들어보면, 다음과 같다. 12345678910111213141516171819@font-face &#123; font-family: Ngothic-Regular; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Bold; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-ExtraBold; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 나눔고딕 보통, 굵게 , 아주굵게, 이탤릭 을 사용한다고 가정시 보통 웹폰트의 이름을 모두 다르게 붙이고 필요에 따라 각 스타일을 호출한다. 이와 같이 같은 나눔고딕들을 묶어서 사용하는 방법이 바로 font-weight 다. 다음 코드를 보자. 123456789101112131415161718192021222324@font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 700; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 800; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; font-style: italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 위와 같이 font-family는 나눔고딕이라는 그룹으로 맺고 각 weight와 style을 통해 각 글꼴을 선택할 수 있게된다. 123456body &#123; font-family: \"Nanum Gothic\" &#125; h1 &#123; font-weight: 400 &#125; /* NanumGothic-Regular.woff */h2 &#123; font-weight: 700 &#125; /* NanumGothic-Bold.woff */h3 &#123; font-weight: 800 &#125; /* NanumGothic-ExtraBold.woff */h4 &#123; font-weight: 400; font-style: italic &#125; /* NanumGothic-Italic.woff */ 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 글자 위에 이미지로 해당 글자를 가려야 할 경우. 사용하는 기법들. 글자를 안사용하고 바로 이미지만 넣을 수는 있으나 SEO관점에서 불리하다. 따라서 글자는 적되 이미지를 특정기법을 이용하여 덮음으로써 SEO관점과 시각적 요소 모두 챙긴다. padding을 활용한 IR 기법 기본적인 방법. 높이를 0으로 줘서 그림 아래로 텍스트를 내려버린다. 그 후 overflow:hidden 속성을 이용하여 텍스트를 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 12345678910111213@charset \"utf-8\";/* padding을 활용한 IR 기법 */.brand1&#123; background:yellow url(../images/title.png) no-repeat; height: 0; width: 290px; padding-top: 195px; overflow: hidden;&#125;/* 위 2가지 트릭의 단점 -&gt; 네트워크의 오류로 인해 이미지가 안날라올경우 문제가 있다. */ text-indent를 이용한 IR 기법 넓이를 지정해놓고 , 들여쓰기를 넓이만큼 준다. 개행 금지 속성을 이용하여 텍스트가 다음 줄로 못내려가게 막고 화면을 넘어가버린 텍스트는 overflow:hidden 속성을 통해 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 123456789/* text-indent 트릭을 이용한 IR 기법 */.brand2&#123; background:pink url(../images/title.png) no-repeat; height: 195px; width: 290px; text-indent: 290px; white-space: nowrap; overflow: hidden;&#125; position 트릭 가상요소를 이용하여 텍스트는 자리 그대로 유지하고 absolute한 가상요소 이미지로 덮어씌운다. 네트워크 에러시 이미지가 안날라와도 가려져있던 텍스트가 보이게 됨으로써 무슨 텍스트인지 유추가 가능하다. 123456789101112131415161718192021222324/* 한줄일때만 이용 가능한 트릭. position트릭. 네트워크 오류로 이미지가 안날라올경우 가상요소는 안보이고 덮어쓰기 전의 내용이 보인다. */.brand3&#123; background: lime; height: 195px; line-height: 195px; width: 290px; text-align: center; font-size : 16px; font-weight: 400; position : relative;&#125;.brand3::after&#123; content: \"\"; position: absolute; background: orange url(../images/title.png); width: 100%; height : 100%; top: 0; left : 0;&#125; agent-style 시 확인해야할 점들. box 모델 겹침 문제 오타 상속 이슈 레이아웃 (margin, padding, position , display , float …) inline-block 으로 레이아웃 작업시 문제점들 inline-block으로 레이아웃시 다음과 같은 문제가 발생한다. 주의 깊게 봐야되는 점은 묻고답하기 오른쪽에 존재하는 Border 선과의 사아아알짝 떨어진 여백이다. 보통 li태그를 일자로 나열하는 방법으로 inline-block으로 지정하고서 구분선을 주기 위해 border를 주게되면 위와 같은 여백이 생기게 된다. 이 부분을 아래와 같이 margin값을 -로 주면서 해결을 할 수 있다. 1margin-left: -6px; /*극단적이게 큰 값을 줌.*/ 웬만해서는 float형태나 다른 레이아웃을 권장한다. 밑줄 gradient 만드는 방법들. 가상 요소 absolute 를 이용한 방법. 밑줄을 그리고 싶은 곳에 가상요소를 하나 띄우고 absolute화 한후 높이와 넓이를 맞춰서 대치하는 방법. 123456789.news::before&#123; content: \"\"; background: red linear-gradient(to right,#aaa,#fff); position : absolute; top : 30px; left : 0; width: 80%; height: 1px;&#125; border 선 자체에 gradient를 설정 하는 방법 123456789101112.news-heading&#123; margin : 20px 0; padding : 0 0 15px 0; width : 80%; font-size : 1.5rem; color: #bb7b13; border-style: solid; border-image: linear-gradient(to right, rgb(168, 167, 167), rgb(228, 228, 228)); border-image-slice: 0 0 1 0; border-image-width: 0 0 1px 0; border-left: none;&#125; 애니메이션 방법들 CSS 애니메이션 사용하기 참고 123456789101112131415161718192021/* 1번 Fade Slide In From Top */ @keyframes fade-slide-in-from-top &#123; 0% &#123; transform: translateY(-4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.app-header &#123; opacity: 0; animation: fade-slide-in-from-top 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 2번 Fade Slide In From Left */@keyframes fade-slide-in-from-left &#123; 0% &#123; transform: translateX(-4rem); /*right는 transform: translatxX(4rem);*/ opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.brand &#123; opacity: 0; animation: fade-slide-in-from-left 0.35s 0.4s ease-out forwards; &#125; 12345678910111213141516171819202122232425262728293031323334353637/* 3번 Fade In &amp; out */@keyframes fade-in &#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;button[title=\"메뉴 열기\"] &#123; opacity: 0; animation: fade-in /* name */ 0.35s /* duration */ 0.4s /* delay */ ease-out /* timing function */ forwards; /* fill mode */&#125;@keyframes fade-out &#123; 0% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125;.button[title=\"메뉴 열기\"] &#123; animation: fade-out 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 4번 Fade Slide In From Bottom */@keyframes fade-slide-in-from-bottom &#123; 0% &#123; transform: translateY(4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.ediya-menu__item &#123; opacity: 0; animation: fade-slide-in-from-bottom 0.35s 0.4s ease-out forwards; &#125; 1234567891011121314/* 5번 Motion Sequnce Animation */.ediya-menu__item &#123; /* 0% */ opacity: 0; transform: translateY(4rem); /* 100% */ animation: transform-none 0.3s 0.85s cubic-bezier(0.6, 0.01, 0.16, 1) forwards;&#125; /* 시간 차 애니메이션 */.ediya-menu__item:nth-child(1) &#123; animation-duration: 0.8s &#125;.ediya-menu__item:nth-child(2) &#123; animation-duration: 1.2s &#125;.ediya-menu__item:nth-child(3) &#123; animation-duration: 1.6s &#125;.ediya-menu__item:nth-child(4) &#123; animation-duration: 2.0s &#125; 그외 사이트 참조 Effective Management 애니메이션 코드 수 줄이고 관리하기. Text Sequencing Motion Stop &amp; Play Animation for Everyone (애니메이션 껏다 켜기 버튼기능)","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"자바 팁 2","slug":"java-tips02","date":"2019-09-13T16:12:50.000Z","updated":"2019-11-30T15:43:48.846Z","comments":true,"path":"2019/09/14/java-tips02/","link":"","permalink":"https://hyeok999.github.io/2019/09/14/java-tips02/","excerpt":"","text":"####1. String == 와 equals의 차이점 String으로 = =을 비교시 주소를 비교하는것이다. 따라서 내부 값을 비교하기 위해서는 equals를 쓰도록한다. 참고로 문자열말고 문자는 그냥 ==으로 하여도 무방함. ex) char A == ‘6’; 123456789101112131415// 둘다 똑같은 값을 가지고 있으니까 참 new String(\"test\").equals(\"test\") // --&gt; true // new String으로 새로운 객체를 생성하고 \"test\"는 다른 객체여서 falsenew String(\"test\") == \"test\" // --&gt; false // \"test\"라는 값을 가진 객체를 둘다 각자 생성해서 falsenew String(\"test\") == new String(\"test\") // --&gt; false // \"test\" \"test\"를 컴파일러는 같은 객체로 봐서 참 \"test\" == \"test\" // --&gt; true // checks for nulls and calls .equals()Objects.equals(\"test\", new String(\"test\")) // --&gt; trueObjects.equals(null, \"test\") // --&gt; false 02. charAt() , toCharArray() charAt() : 문자열타입에 저장된 값들을 배열형태로 인식하여 반환하는 함수. to.CharArray() : 문자열에 있는 모든 내용을 문자배열로 반환하는 함수. 12345678910111213141516 String a=\"001100111\";char[] x = a.toCharArray();for(int i=0;i&lt;a.length();i++)&#123;if(a.charAt(i)=='0')&#123; System.out.print(\"영\");&#125;else&#123; System.out.print(\"일\");&#125;&#125;System.out.println();for(int i=0;i&lt;a.length();i++)&#123;System.out.print(x[i]);&#125; System.out.println(); 03_1. 형변환 (요약) Integer.parseInt( ) -&gt; 문자열 -&gt; 정수 String.valueOf( ) -&gt; 정수 -&gt; 문자열 12345int a = 0;String s = \"55\";int a = Integer.parseInt(s); //a=55String s = String.valueOf(a+10); //s=\"65\" 03_2. 형변환 (목록) ①. 문자열에서 정수형으로 변환 (String to int) - int i = Integer.parseInt(String str); ②. 정수형을 문자열로 변환 (int to String) - String str = Integer.toString(int i); - String str = String.valueOf(int i); ③. 형식에 맞춰서 변수들을 문자열로 변환 (c언어의 printf 동일) - int i; float f; String str = String.format(“%d %f”,i,f); ④. 문자열에서 다른 숫자형태로 변환 - float f = Float.parseFloat(String str); // String to float - double d = Double.parseDouble(String str); // String to double - byte b = Byte.parseByte(String str); // String to byte - long l = Long.parseLong(String str); // String to long - short s = Short.parseShort(String str); // String to short ⑤. 다른 숫자형태에서 문자열로 변환 - String str = String.valueOf(boolean b); // true 또는 false가 str에 저장됨. - String str = String.valueOf(char c); // char to String - String str = String.valueOf(char[] data); // char array to String - String str = String.valueOf(double d); // double to String - String str = String.valueOf(float f); // float to String - String str = String.valueOf(long l); // long to String - String str = String.valueOf(Object o); // Object to String , o == null이면 “null” 이 되고 o!= null이면 o.toString()함수의 반환값은 str - String str = String.valueOf(char[] data, int offset, int count); // offset 의 index부터 count 개의 문자로 부분문자열 생성","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"https://hyeok999.github.io/categories/Develop/Java/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"}]},{"title":"자바 팁 1","slug":"java-tips01","date":"2019-09-13T16:06:51.000Z","updated":"2019-11-30T15:44:17.003Z","comments":true,"path":"2019/09/14/java-tips01/","link":"","permalink":"https://hyeok999.github.io/2019/09/14/java-tips01/","excerpt":"","text":"####1. charAt(i) charAt(i)는 문자열(String)을 대상으로 한다. 문자열의 i-1번째에 위치한 문자열을 char형으로 반환한다 12String n = \"abcda\";n.charAt(0) // char형으로 a를 의미. 즉, 'a'을 반환. 2. indexOf(문자열) indexOf(“문자열” || ‘문자’)은 문자열(String)을 대상으로 한다. (“문자열” || ‘문자’)가 해당 문자열(String)내에 존재할 경우 존재하는 위치를 값으로 반환한다. 만약 존재하지 않을 경우 -1을 반환한다. *주의점 1 : 첫 위치만 반환한다. *주의점 2 : 문자열을 대상으로한다. char형은 대상이 아니다. *주의점 3 : 매개변수는 문자(char형)도 가능하다. 12String n = \"abcda\";n.indexOf(\"a\") // 0을 반환한다. 4번째에도 a가 있지만 처음에 있는 위치만 반환한다. 3. replace(),replaceAll(), replaceFirst() replace 관련 함수를 이용하여 치환 혹은 제거가 가능하다. replace(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거 replaceAll(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거. replace와 다른 점은 정규식도 사용 가능. repaceFirst(“찾는 문자열”,”바꿀 문자열”) -&gt; 조건에 있는 첫 문자열을 치환 혹은 제거. * 주의점 1 : 바꿀 문자열을 “”으로 줄 경우 제거가 됨. * 주의점 2 : 반드시 반환 대상이 있어야 됨. 자기 자신으로라도 반환을 해주어야함.(당연한 것) 12345678910111213141516171819202122String s = \"봉숭아 학당! 봉숭아 학당!\"; // 원본 문자열String s2; // (1) s2 = s.replace(\"숭아\", \"맹구\"); System.out.println(\"치환(1): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (2) s2 = s.replaceFirst(\"숭아\", \"맹구\"); System.out.println(\"치환(2): \" + s2); // 출력 결과: 봉맹구 학당! 봉숭아 학당! // (3) s2 = s.replaceAll(\"숭아\", \"맹구\"); System.out.println(\"치환(3): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (4) s2 = s.replace(\"숭아\", \"\"); System.out.println(\"치환(4): \" + s2);// 출력 결과: 봉 학당! 봉 학당! 04. char형 아스키코드를 이용한 알파벳배열 초기화. 아스키 코드를 이용하여 알파벳 배열을 만들 수 있다. 이런식으로 아스키코드를 이용한 조건을 만들 수도 있다. 123456char[] alphabet = new char[25];for(int i=0;i&lt;25;i++)&#123; alphabet[i] = (char) (i+65);&#125; // A - 65System.out.println(alphabet[0]); //'A' 출력됨.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"https://hyeok999.github.io/categories/Develop/Java/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"}]},{"title":"HTML 마크업 연습하기","slug":"html-markup01","date":"2019-09-12T16:01:04.000Z","updated":"2019-11-30T15:46:06.619Z","comments":true,"path":"2019/09/13/html-markup01/","link":"","permalink":"https://hyeok999.github.io/2019/09/13/html-markup01/","excerpt":"","text":"123456789101112131415161718192021&lt;section class=\"news\"&gt; &lt;h2 class=\"news-heading\"&gt; 새소식 &lt;/h2&gt; &lt;a href=\"#\" class=\"news-link\"&gt; &lt;dl class=\"news-list\"&gt; &lt;dt class=\"news-title\"&gt; &lt;span&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/span&gt; &lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; &lt;/dt&gt; &lt;dd class=\"news-description\"&gt; 디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다. &lt;/dd&gt; &lt;/dl&gt; &lt;figure class=\"news-thumbnail\"&gt; &lt;img class=\"news-thumbnail-image\" src=\"./images/news.gif\" alt=\"W3C 리뉴얼\"&gt; &lt;figcation class=\"news-thumbnail-title\"&gt;W3C 리뉴얼&lt;/figcation&gt; &lt;/figure&gt; &lt;/a&gt; &lt;a href=\"#\" class=\"icon-plus news-more\" title=\"새소식 더보기\" aria-labelledby=\"news-link\"&gt;더보기&lt;/a&gt;&lt;/section&gt; webcafe.html 부분 새소식 영역 마크업 및 html 구성","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"MarkUP","slug":"MarkUP","permalink":"https://hyeok999.github.io/tags/MarkUP/"}]},{"title":"html-css-study-06","slug":"html-css-study-06","date":"2019-09-12T13:15:38.000Z","updated":"2019-11-30T15:47:36.731Z","comments":true,"path":"2019/09/12/html-css-study-06/","link":"","permalink":"https://hyeok999.github.io/2019/09/12/html-css-study-06/","excerpt":"","text":"HTML Study 06 MarkUp 짤 때 고민해야하는 점. fieldset 태그의 버그 button태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?) vertical-align / text-align time 태그 block 태그 안에서 여백을 주는 여러가지 방법들. 글자 수 숨기기 (… 처리하기) fontello aria-labelledby MarkUp 짤 때 고민해야하는 점.​ MarkUp시 너무 많은 버튼에 대한 고민을 해야만 한다. 예를들어보자, 위와 같은 공지사항과 자료실에 대한 게시물 리스트를 모아놓은 영역을 마크업 해야할 때, 보통의 경우라면, 다음과 같이 생각할것 같다. 공지사항 , 자료실은 서로 다른 영역이다. 게시물 목록을 나열한다. 더보기 버튼을 나눈다. 결론적으로, 공지사항 - 목록 - 더보기 | 자료실 - 목록 - 더보기 구성이 되겠다. 문제는 이와같은 구성시 너무 많은 탭을 요구하게 된다. 비장애의 영역에서는 시각을 통해 여러가지 정보를 한번에 확인을 할 수 있지만, 장애 또는 봇의 영역에서는 눈대신 청각에 의존해야한다. 스크린 리더기가 모든 게시물 제목을 하나하나 전부 읽는다는 것은 너무 힘들고 듣는다는것도 힘들것이다. ! 해결법은 무엇인가?​ 해결법이야 여러가지 방법이 존재하겠지만, 그 중 대표적인 예를 들어보면 - 공지사항,자료실 같은 수많은 포커스가 되는 영역에서는 방향키 화살표를 통해 읽고 싶은 요소만 선택하게 하는것이다. 공지사항 자료실 세션 1 목록 더보기 세션2 목록 더보기 [이를 적용한 대한항공 사이트] https://www.koreanair.com/content/koreanair/global/en.html/ fieldset 태그의 버그​ fieldset 태그는 보통 form 태그 내부에서 쓰인다. form - fieldset + legend + label + input 형식으로 많이 사용하는데, 여기서 fieldset 태그에 flex를 주게 될 경우, 크롬에서는 버그를 일으키게된다. ( 보통, form태그에 display:flex를 주면 크롬은 flex가 적용이 안되는 버그를 일으킨다. ) 해결법으로는 form - fieldset + legend + label + input 과 같은 형식에서 form - fieldset - div + legend + label + input 과 같이 태그로 1번더 그룹핑한다. 그리고 div에 flex관련 css 스타일을 주면 해결할 수 있다. [flex 관련 이슈] https://naradesign.github.io/article/flex-browser-compatibility.html button 태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?)​ button 태그는 브라우저마다 padding , margin 영역이 다른 특성을 가지고 있다. 따라서 a 태그와 WAI-ARIA를 이용하고 role=”button” 을 주어 이 부분을 해결할 수 있다. vertical-align / text-align vertical-align 은 inline 요소를 수직으로 정렬해주는 기능을 담고 있다. text-align 은 block 요소를 정렬해주는 기능으로 block 요소 안에있는 inline 요소들(텍스트나 이미지)등도 같이 정렬해준다. inline 관련 태그에 직접 text-align 속성을 지정해줘도 작동하지 않는다. time 태그​ 이 태그의 용도는 문서 내용 안에 어떤 날짜나 시간을 나타내는 표현이 있을 때 그 부분에 사용하여 알맞은 날짜나 시간을 컴퓨터가 인식할 수 있게 의미적으로 나타내는 데 사용한다. 1&lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; block 태그 안에서 여백을 주는 여러가지 방법들.​ 여백을 주는 각 방법들마다 차이가 있으니 확인하고 써야 할 것. 특히 %, auto , 정적px에 대한 차이를 이해하는것이 중요하다. padding ?%; ?px; margin ?%; ?px; width : ?px; width : ?%; margin : auto; calc -&gt; 반응형 글자 수 숨기기 (… 처리하기)​ block 박스에서 글자수가 일정 이상 넘어가서 …을 처리하고 싶다먼 아래 style을 모두 구성해주어야한다. 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; fontello​ 이전에 설명한 fontello를 html문서에서 class 형태로 주어 icon이미지를 생성하면 그 태그 앞에 가상클래스를 자동으로 만들어주고 이미지를 넣게된다. 12&lt;li class=\"icon-dot-circled\"&gt; &lt;!-- li클래스 앞에 가상클래스를 만들고 이미지를 넣는것을 자동으로 해줌. --&gt; ​ fontello.css 에 있는 내용 중… 1.icon-dot-circled:before &#123; content: '\\f192'; &#125; aria-labelledby1 &lt;a href=\"#\" class=\"icon-plus notice-more more\" title=\"공지사항\" aria-labelledby=\"notice\"&gt;더보기&lt;/a&gt; 위 a링크는 aria-labelledby=”notice” 로 인해 id가 “notice”인것을 연결해준다. 1&lt;a href=\"#\" class=\"tab\" role=\"button\" id=\"notice\"&gt;공지사항&lt;/a&gt; JavaScript 맛보기[defer 및 async] https://blog.asamaru.net/2017/05/04/script-async-defer/ 12&lt;script src=\"./js/jquery.min.js\" defer&gt;&lt;/script&gt;&lt;script src=\"./js/webcafe.js\" defer&gt;&lt;/script&gt; 1234567891011var section = $('.board section'); //jqeury lib에서 지원하는 선택 객체var tab = $('.tab');// .on('이벤트명')// tab.on('click keyup',function(e)&#123;tab.on('click', function(e)&#123; e.preventDefault();// 기본 이벤트를 취소함. 예를들면 a의 속성 href의 이벤트를 취소함. // if((e.type === 'keyup' &amp;&amp; e.keyCode === 13) || e.type === 'click')&#123; section.removeClass('tab-act'); $(this).parent().parent().addClass('tab-act');&#125;)//멀티 이벤트 바인딩 예-&gt; 클릭, 마우스온 등 다양한 환경 대응 board라는 이름을 가진 클래스의 section태그의 내용을 section이라는 이름의 변수로 선언. tab이라는 이름을 가진 클래스의 정보를 tab이라는 이름의 변수로 선언. tab이 클릭 되었을 때, 다음과 같은 기능을 수행한다. tab이라는 이름을 가진 클래스의 태그가 가진 기본적인 이벤트 기능을 모두 취소(제거) 한다. board라는 이름을 가진 클래스의 section태그 내부에서 tab-act라고 불리는 클래스를 제거한다. tab이라는 이름을 가진 클래스의 태그의 부모의 부모에게 tab-act라는 클래스네임을 붙여준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-05","slug":"html-css-study-05","date":"2019-09-10T16:48:58.000Z","updated":"2019-11-30T15:47:42.044Z","comments":true,"path":"2019/09/11/html-css-study-05/","link":"","permalink":"https://hyeok999.github.io/2019/09/11/html-css-study-05/","excerpt":"","text":"HTML Study 05 MarkUp 짜기 로그인창 HTML ~CSS 구성해보기 form 태그 dt dl dd 태그 a태그의 속성 들여쓰기 방법들 line-height 마크업시 생각나는 고민들!div -&gt; 의미없는 정보 section -&gt; 1장 1절 같은 정보 , header 태그가 없으면 경고를 띄운다. article -&gt; 독립된 완결된 정보, RSS , header 태그가 없으면 경고를 띄운다. margin은 겹침현상이 발생한다. box-shadow 도 인접 태그의 margin에 영향을 주지 않는다.(즉, 겹친다.) title은 id, class, style같은 대표속성이며 태그에 사용시 마우스를 올렸을 경우 글박스를 띄운다. text-indent 는 첫줄 들여쓰기를 넣어주는 속성이며, 박스에 영향을 주지않는다. 단, 개행시 유효하지 않은 속성이 된다. 반응형 이미지들은 반드시 등으로 랩핑하는것이 좋다. 이유 : 이미지가 유동적으로 커짐과 줄어듬 MarkUp 짜기​ 간단해보이지만 HTML중 가장 어려운 구간이다. 어떠한 태그를 좋게 사용하느냐, 논리적인 순서를 지켰느냐의 위주로 짜야하며 반드시 디자인적 관점으로 구성하면 안된다! 논리적 순서를 가려낸다. 시멘틱하게 이름 정하기 코드 짜기 대표적인 네이버의 로그인창 예제. 보통 마크업 순서라면 아이디 -&gt; 비밀번호 -&gt; 로그인 -&gt; 로그인 상태 유지 일것이다. 하지만! 논리적으로 계산해보면 로그인 하기전에 로그인상태유지 버튼을 체크하거나 해제하는것이 맞지 않을까? 로그인창 HTML ~CSS 구성해보기 form 태그form 관련 요소 -&gt; 정보를 보내고 받는 값들의 입력 서식을 모아놓은 모음들. https://formspree.io/ : form 정보를 내 이메일로 보내게끔 서비스하는 사이트 . 무료,유료 나뉜다. form , fieldset, legend ==&gt; XHTML 관점에서 다 있어야만 한다. HTML4에서는 form만 있어도 되고 HTML5에서는 둘다 허용이된다. 따라서 form, fieldset , legend, label, input 모두 사용하는 것이 좋다. fieldset은 폼서식을 그룹화하는 것. legend는 그룹화한 폼서식에 대한 제목이다. 하나의 form안에 fieldset은 여러개 들어가도 상관없다. required -&gt; 논리적 검사 예 ) input 태그 안에 required를 적게 되면 이메일 값을 안적을 경우 경고창을 띄운다. form 안 에서 값을 그냥 입력하면 안되고 반드시 1:1로 값을 대입해줘여한다. 아이디 은 입력서식에 대한 이름 이고 는 정보를 입력받는 창이다. placeholder 속성은 입력서식에 대한 예시다. dl dt dd 태그용어를 설명하는 정의형 목록을 만든다. dt -&gt; 용어의 제목을 의미하며 dd는 용어를 설명하는 내용이다. dl dt dd는 정의형 목록을 의미하며 각 태그당 한개씩만 사용하는것이 좋다. dl 안에 태그를 삽입해도 되지만, 아래와 같은 유형만 추천한다. 1234567&lt;dl&gt; &lt;div&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/div&gt;&lt;/dl&gt; &lt;!--가능한 구문. 단, div가 dt나 dd쪽에 들어가서는 안된다.--&gt; a태그하이퍼링크를 걸어주는 태그. 1&lt;a href=\"#\" target=\"_self | _blank | _parent | _top | 프레임명\" &gt;&lt;/a&gt; self -&gt; 기본값 생략가능. target=”_blank”. -&gt; 새창을 열음 parent -&gt; 부모페이지로, iframe에서 사용. top -&gt; 최상위페이지로, iframe에서 사용. 프레임명 : 직접 명시 들여쓰기 방법들 padding margin text-indent line-height1line-height: normal | length | number | percentage | initial | inherit | 숫자값 normal : 웹브라우저에서 정한 기본값. 보통 1.2 length : 길이로 줄 높이를 정한다. number : 글자 크기의 몇 배인지로 줄 높이를 정한다. percentage : 글자 크기의 몇 %로 줄 높이로 정한다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 예) 글자크기가 40px일 때 line-height의 값을 1.5로 하면, 줄 높이는 40의 1.5배인 60px가 된다. 줄 높이는 60px인데 글자 크기는 40px이므로, 글자 위와 아래에 각각 10px의 여백이 생긴다. 줄 높이가 글자 크기보다 작으면 세로 방향으로 글자가 겹치게 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-04","slug":"html-css-study-04","date":"2019-09-09T11:33:31.000Z","updated":"2019-11-30T15:47:48.497Z","comments":true,"path":"2019/09/09/html-css-study-04/","link":"","permalink":"https://hyeok999.github.io/2019/09/09/html-css-study-04/","excerpt":"","text":"HTML Study 04 HTML5 콘텐츠 모델 CSS 셀렉터 html5 표준확인 CSS 구체성점수 Shadow Entity list opcacity 시나리오 작성 z-index background 애니메이션( @keyframes, + 곡선도 ) position, float 다시 정리 float 객체에 강제로 높이 를 알려주는법(overflow, 가상요소 clear:both) float, position:absolute -&gt; display를 block화 시킨다. 오늘의 팁 position : absolute , float는 강제로 display:block 화시킨다. 1에서 한 absolute의 경우 display는 block이 맞지만 마치 inline 형태의 display를 띄고 있으며, absolute 선언 시, block 레벨 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정해야만 하며, 부조 또는 조상요소가 static일 경우, 최종으로는 document의 body태그를 기준으로 위치하게된다. 태그의 링크 클릭 반경을 넓히고 싶다면 padding 을 늘려야 한다. 간단하게 여백을 주는 방법으로는 대표적으로 margin, padding 등이 있다. float화 된 상태에서 부모의 자식들 요소가 모두 float화 되었다면 그 부모요소는 높이를 잃어버리게 된다. 이에 잃어버린 높이를 찾는 3가지 방법이 있다. height = 45px : 높이를 직접 입력 [비추천] &lt;부모&gt; overflow:hidden/auto : overflow 자체는 흘러넘치는 콘텐츠를 다루는 태그지만 overflow태그는 잠재적으로 잃어버린 높이를 일깨워주는 역할을 하기 때문에 사용할 수 있다. clear:both : 가장 좋은 방법. float화된 요소 마지막에 가상자식요소를 생성하여 clear:both를 선언. clear:both는 float요소 중에 높이가 제일 긴 것을 찾아서 강제로 margin을 추가하여 높이가 늘어나 잃어버린 높이를 찾아낸다. 123456.menu::after&#123; content:\"\"; clear: both; /* clear는 display:block 에서만 사용 가능. right, left 등도 있다. */ display: block; &#125; display 숨김처리 12345678910.a11y-hidden &#123; background-color: red; position: absolute; width: 1px; height: 1px; overflow: hidden; margin: -1px; clip: rect(0,0,0,0); white-space: nowrap;&#125; HTML5 콘텐츠 모델 CSS 셀렉터​ 대표적으로 id 셀렉터인 # , 클래스 셀렉터인 점(.) , 전체 선택자인 * 외에도 수많음 셀렉터가 있다. 자세한 내용은 아래 블로그가 정리를 정말 잘 해놓았기에 링크로 남겨둔다. https://code.tutsplus.com/ko/tutorials/the-30-css-selectors-you-must-memorize--net-16048 html 5 표준확인 google에 html w3c 검색 [html5 mulder21c : 블로그] https://mulder21c.github.io/html/ [html5 한글명세서] https://mulder21c.github.io/html/ CSS 구체성 점수​ css 셀렉터에 id, class, tag 이름이 갖는 점수를 계산하여 점수가 높은 selector가 우선순위를 갖는 가상 개념. 대표적으로 id &gt; class &gt; tag 순이며, 제일 높은 html 태그 내부에 적용하는 css가 제일 높은 우선순위를 지닌다. 착각하면 안되는 것!! -&gt; class가 10개 쓰인다고 해서 id보다 높을 수 없다. 체급차이가 다르다고 생각하면됨. 123&lt;div style=\"padding : 20px\"&gt; 이것은 div 태그에 style이 적용된 예입니다.&lt;/div&gt; 추가 important 1234&gt; .menu-act .btn-menu&#123;&gt; color:yellow important;&gt; &#125;&gt; important는 우선순위를 무력화시킬 수 있다. 즉, important 는 지정한 스타일이 안먹는다고 생각햇을때. 추적할때. 파악용도 클래스가 동적으로 추가될 가능성이 있을때; 다른 사람이 수정해서 내 소스의 상속이 깨질 우려가 있을 경우. Shadow 그림자를 나타내는 태그는 크게 박스와 텍스트가 있다. 1box-shadow: none | x-position y-position blur spread color | inset | initial | inherit; none : 그림자 효과를 없앤다.. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어진다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어진다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려짐. spread : 양수면 그림자를 확장하고, 음수면 축소. color : 그림자 색을 정한다, inset : 그림자를 요소의 안쪽에 만든다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 1text-shadow: offset-x offset-y blur-radius color | none | initial | inherit offset-x : 그림자의 수평 거리를 정한다. (필수) offset-y : 그림자의 수직 거리를 정한다. (필수) blur-radius : 흐림 정도를 정한다. (선택 : 값을 정하지 않으면 0) color : 색을 정한다. (선택 : 값을 정하지 않으면 브라우저 기본값) none : 글림자 효과를 없앤다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. Entity list​ CSS에서 사용할 수 있는 특수문자 리스트. html에서 &amp;&amp;를 그냥 입력하면 안되기 때문에 아래의 리스트를 이용한다. [사용가능한 특수문자 코드 리스트] https://www.w3schools.com/cssref/css_entities.asp Opacity1opacity: number | initial | inherit number : 0.0부터 1.0까지의 수를 넣는다. (투명도 0 -&gt; 불투명 / 1-&gt; 투명) initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 시나리오 작성 CSS의 style을 작성할 때, 시나리오를 작성하며 차근차근 하는것을 익숙해지도록 한다. 예) 글씨가 왼쪽 -&gt; 오른쪽으로 날라옴. : 이동효과 [padding, margin, position-relative, position-absolute] 글자의 투명도를 추가 해야함 . [color: rgba 또는 opacity] 글자 크기의 번화 [font-size] z-index요소들의 배치가 자유로워지면서, 때때로 서로의 위치를 겹치게 하는 경우가 생긴다. 그 때 사용하는것이 z-index. z-index 값을 지정하기 위해서는 해당 요소의 position 속성이 relative, absolute, fixed 중 하나여야만 한다. [z-index 를 잘 설명한 블로그] http://dev.epiloum.net/904 backgroundbackground-color : yellow 같은 기본 코드 외에도, background는 말 그대로 배경에 대한 색 , 이미지등의 콘텐츠를 다루는 요소 css이다. 123456789/*background-image : url로 2개의 이미지를 불러낸다. */background-image: url('./images/ani_flower_01.png'),url('./images/ani_flower_02.png');/*해당 이미지들은 처음에는 일정 간격마다 반복 되어있기에 반복을 제거한다.*/background-repeat : no-repeat;/*해당 이미지들에 대한 위치값을 지정해준다.*/background-position: 0 -10px, 670px 0; /*x축 y축을 의미*//*위 내용 한꺼번에 입력하기. */background : url('./images//ani_flower_01.png') no-repeat 0 -10px, url('./images/ani_flower_02.png') no-repeat 670px 0; 애니메이션[애니메이션 정리 잘된 블로그] https://brunch.co.kr/@99-life/3 애니 메이션을 사용하기 위해서는 먼저 2가지 조건을 충족시켜야 한다. animation-name : 키프레임 이름 *필수 animation-duration : 시간(s,ms 등등) *필수 animation-fill-mode : forwards; 먼저 keyframes를 선언한다12345678910111213141516171819@keyframes text-ani&#123; 0%&#123; font-size: 12px; color : rgba(0,0,0,0); transform: translate(0,0); /* top: 0; left: 0; *//* margin : 0; *//* padddig : 75px 0 0 400px */ &#125; /* from */ 100%&#123; font-size : 24px; color : rgba(0,0,0,1); transform: translate(400px,75px) /* top : 75px; left:400px; *//*padding:75px 0 0 400px*//*margin:75px 0 0 400px; */ &#125; /* to */&#125;@keyframes bg-ani&#123; 0%&#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125; transform 은 좌표공간을 변형함으로써 일반적인 문서 흐름을 방해하지 않고 콘텐츠의 형태와 위치를 바꾼다. 그 중, transform : translate는 요소의 위치를 이동 시키는 함수이다. 구버전의 browser는 사용이 안된다. ### animation-duration지속성을 의미한다. 필수조건. 기본적으로 s , ms단위의 시간을 입력한다. 1animation-duration: 5s; animation-fill-mode 속성 및 내용1animation-fill-mode: none | forwards | backwards | both | inherit; none 애니메이션이 끝난 후 상태를 설정하지 않습니다. forwards 애니메이션이 끝난 후 그 지점에 그대로 있습니다. backwards 애니메이션이 끝난 후 시작점으로 돌아옵니다. both 애니메이션이의 앞 뒤 결과를 조합하여 설정합니다. inherit 애니메이션의 상태를 상위 요소한테 상속받습니다. 추가내용 123456789101112/*animation-name: bg-ani;animation-duration: 2000ms;animation-iteration-count: infinite;animation-direction: alternate;animation-timing-function: paused;*//* 위 내용을 짧게 줄인 short 표기법 *//* short표기법 : 이름 듀레이션 딜레이 반복 방향 반복곡선도 */animation: bg-ani 2000ms 1000ms infinite alternate ease-in-out; animation-timing-function에 관한 내용 중 cubic-bezier 에 관한 내용 https://kutar37.tistory.com/entry/CSS-cubic-bezier%EB%9E%80 cubic-bezier 설정하는 곳 https://cubic-bezier.com/#.17,.67,.83,.67","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"Git Repo 가져오기","slug":"20190902-start-git","date":"2019-09-07T12:52:11.000Z","updated":"2019-11-30T15:56:35.546Z","comments":true,"path":"2019/09/07/20190902-start-git/","link":"","permalink":"https://hyeok999.github.io/2019/09/07/20190902-start-git/","excerpt":"","text":"GIT 시작하기✸ git 개발은 항상 끊어서 커밋 해야만 한다. 그리고 영어로 쓰는 것을 습관화들여라!Git CLI 기본 설정. ( 설정이 완료되있다면 git 시작하기 1 or 2부터 시작 ) ✸ git config –list ( git 설저한 내용 확인 ) git config –global user.name “HYEOK999”. git config –list (위에서 입력한 내용 확인). git config –global user.email “iasg2004@naver.com“. git config –global editor “vim”. git 시작하기1 ( local -&gt; remote ) 가장 중요한 명령어 : 현재 상태 확인 git status 폴더생성 및 폴더 진입 git init git diff git status(현재 상태) 파일 생성 및 내용 작성 git add 파일명.확장자 github 계정 페이지에 접속 후 레파지토리에서 new를 누르고 저장소를 만든다. 저장소 명은 폴더명과 같게끔 설정할것. 만든후 주소 복사. git remote add [origin] 주소복붙 등록 확인 -&gt; git remote git commit 편집모드( i ) 들어가서 첫줄이 제목 (엔터치기 전까지) 다음줄이 내용! commit 제목은 현재형 구나 절로 적는다! / 내용은 자세하게 적는다. feat : 협업 docs : 문서작업 bugfix : 버그를 수정했을 때 hotfix : 빠르게, 급하게 수정했을 때 release : 개발 git push -u [origin] master -u : 로컬 브랜치를 새로 만든 후 원격저장소에 해당 브랜치를 push하고자 할 때 처음 이후의 Git Commit 파일 및 폴더 내용 수정 및 추가 git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용 “ git push [origin] master git 시작하기2 ( remote -&gt; local ) 가장 중요한 명령어 : 현재 상태 확인 git status 저장소 생성 ( public , gitignore:Node , LICENSE:MIT ). 저장소 주소 복사 git clone 주소복붙. 파일 및 폴더 내용 수정 및 추가. git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용” git push [origin] master.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"https://hyeok999.github.io/categories/Develop/GIT/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"}]},{"title":"html-css-study-03","slug":"html-css-study-03","date":"2019-09-07T12:52:07.000Z","updated":"2019-11-30T15:47:54.716Z","comments":true,"path":"2019/09/07/html-css-study-03/","link":"","permalink":"https://hyeok999.github.io/2019/09/07/html-css-study-03/","excerpt":"","text":"HTML Study 03 가상 요소 nth:child WAI-ARIA a11y-hidden / aria-hidden : 태그 숨김처리 role Web Font - 이미지 아이콘 CSS 단위 float 그림자 gradiunt CSS 색상값 단위 {참고} 가상 요소[가상요소] https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements 가상 요소는 존재하지 않는 요소를 존재하는 것처럼 부여하여 문서의 특정부분을 선택하게 할 수 있다. 대표적인 가상 요소 ::before -&gt; 해당 css의 요소박스 전에 같은 형식의 태그요소를 가상으로 만든다. ::after -&gt; 해당 css의 요소박스 후에 같은 형식의 태그요소를 가상으로 만든다. nth:child[nth:child] http://nthmaster.com/ nth-child는 형제 요소 중에서 특정 순서 요소를 선택하고 싶을 때 사용한다. 1234567.member li:nth-child(n+2)::before&#123;content: '\\f142'; /*가상요소 before 와 after에게 필수*/font-family:'fontello';width: 1em;&#125;/* nth-child를 이용하여 member 하위의 &lt;li&gt;중 2번째 요소부터 끝까지 각 요소 앞에 가상 요소를 생성하고 내용은 '\\f142'를 입력하고 font 와 width를 적용한다.*/ WAI-ARIA [설명] https://www.biew.co.kr/36 WAI-ARIA는 ‘Web-Accessibility Initiative’의 약자로 W3C에서 웹 접근성을 담당하는 조직. ARIA는 리치 인터넷을 위한 W3C의 접근 명세. [W3C에서 제공하는 명세서를 보기 좋게 기술로 변화시킨 레진의 ARIA] https://tech.lezhin.com/2018/04/20/wai-aria a11y-hidden / aria-hidden : 태그 숨김처리a11y-hidden 화면상에서는 안보이나 스크린 리더기 혹은 보조기등에서 보이게 끔 하기 위하여 개안된 CSS스타일. 헷갈리면 안되는것이 WAI-ARIA 에서 재정된 aria-hidden은 클래스명이 아니라 하나의 속성이다! 결국 다른거임. 추가로 off-screen / readable-hidden 등도 있다. aria-hidden 시각장애인, 검색봇, 스크린리더 사용자가 홈페이지에 더 쉽게 접근하기 위해서 읽을 필요없는 요소나 내용을 감춰준다. 외에도 여러가지 태그 숨긴 방법이 있지만, 대표적으로 위와 같은 형태를 권장한다. display:none , visibilitty , hidden 은 비권장. 1234567891011121314/* a11y-hidden */.a11y-hidden&#123; position: absolute; width: 1px; height: 1px; margin: -1px; overflow: hidden; /* 넘치는 부분을 감쳐준다 */ clip: rect(0,0,0,0); /* 선행조건 : position:absolute 해당 화면을 잘라내서 보여줌 */ white-space: nowrap; /* 줄바꿈을 하지않음. */ opacity: 0; /* 투명도 */&#125;/* aria-hidden */&lt;span class=\"line\" aria-hidden=\"true\"&gt;내용&lt;/span&gt; role​ 다른태그에 role로 규정한 태그의 역할? 혹은 기능을 넣을 수 있다. 역시 WAI-ARIA에저 정의한 기술로 https://webdir.tistory.com/89 에 정리가 되어있다. 대표적인 예로는 button이 있으며 , 시멘틱 관점에서도 중요한 역할을 지닌다. role = header,main,contentinfo 는 각각 를 의미한다. 1&lt;a href=\"#\" class=\"btn-menu\" role=\"button\"&gt;CSS에 대해&lt;/a&gt; Web Font - 이미지 아이콘 로컬에 있는 폰트를 쓰는게 아닌 웹에서 폰트를 받았다가 사용함. 저작권에 주의 대표적 : [Font Awesome] https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use [Fontello] http://fontello.com/ Fontello 적용 방법. 다운받은 압축파일을 해제하고 들어가보면 font폴더와 css폴더가 존재한다. 다운받은 font폴더에서 모두 복사하여 하고있는 프로젝트 font폴더에 붙여넣기를 한다.(단, css내부의 font폴더가 아니다.) 다운받은 css폴더에서 fontello.css를 복사하여 하고있는 프로젝트 css폴더에 붙여넣기를 한다. import 시키기 12/* css 파일 */@import url('./fontello.css'); 사용방법은 html 내부 , css 내부 가 있다. 123456789101112&lt;!-- html 내부 --&gt;&lt;!-- class 명으로 선언하여 사용하는 방법. class 명은 다운받은 css폴더에서 확인이 가능하다. --&gt;&lt;a href=\"#\"&gt;&lt;span class=\"icon-ellipsis-vert\"&gt;로그인&lt;/span&gt; &lt;style&gt;/* 사용하고자 하는곳에서 숫자값과 font-family를 선언. 숫자값은 css폴더에서 확인이 가능하다. */ .member li:nth-child(n+2)::before&#123; content: '\\f142'; font-family:'fontello'; width: 1em; &#125;&lt;/style&gt; CSS 단위https://github.com/HYEOK999/TIL/blob/master/HTML-CSS/study01/CSS-7%EA%B0%80%EC%A7%80-%EB%8B%A8%EC%9C%84.md float float는 css에서 정렬하기 위해 사용되는 속성이다. 떠잇다는 의미로 float태그 걸려있는 요소를 띄워서 표시한다. float는 display:block 형태의 태그에만 적요이 가능하다. … float는 글씨가 겹칠수 없는 속성을 가지고 있는 float가 정의된 요소가 공중에 뜬다면 그 다음 글씨는 옆으로 밀어낸다. 만약 float가 정의된 모든 요소가 공중에 떳을 경우, 해당 요소는 크기를 잃기때문에 그 다음 태그 이어지게 보일 수 있다. 따라서 강제적으로 크기를 주거나 overflow:hidden 같은 기능을 이용하여 height 값을 간접적으로 알려줘야만한다. 1234567891011121314151617.box&#123; background-color: lime; /* height: 50px; --- 강제로 높이를 주어 float로 잃어버린 높이를 깨워넴(안쓰는게 좋음) overflow:hidden 은 원래 넘치는 content를 감추는 역할인데 이 속성은 잊혀진 높이등을 일깨워 준다.따라서 float로 잃어버린 높이를 일깨워서 heading3를 밑으로 내린다. */ overflow: hidden; /*넘치는 값을 지워주세요.*/ &#125; .box2&#123; position: relative; top:10px; &#125; .box [class^=\"box\"]&#123; /* border: 1px solid red; */ float: left; &#125; float 는 position: relative와는 겹칠수 있으나 absolute선언시 float는 자동으로 none 값이 된다. clear : both , left , right 각각 float가 걸려있는 요소의 양쪽, 왼쪽, 오른쪽에 있는 요소들에게 clear값을 취소하는것. 이는 반드시 display : block이여만 한다. 그림자 box-shadow: none | x-position y-position blur spread color | inset | initial | inherit none : 그림자 효과를 없앱니다. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어집니다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어집니다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려집니다. spread : 양수면 그림자를 확장하고, 음수면 축소합니다. color : 그림자 색을 정합니다. inset : 그림자를 요소의 안쪽에 만듭니다. initial : 기본값으로 설정합니다. inherit : 부모 요소의 속성값을 상속받습니다. 12 text-shadow: 1px 0 0 black, -1px 0 0 black, 0 1px 0 black, 0px -1px 0 black;/* 그림자를 각각 위 아래 오른쪽 왼쪽 을 줌으로서 글씨 주변으로 박스 쳐진것처럼 보이게 할수 있다. */ gradient[gradient 가공 사이트] “https://www.colorzilla.com/gradient-editor/&quot; 123456789/* gradient 적용하기- 위 사이트에서 그라디언트 만든 후 복사 후 적용. 단, background를 background-image로 수정.*/.menu&#123;background-image: linear-gradient(to bottom, #f4c730 0%,#f7aa2e 35%,#f7aa2e 70%,#f4c730 100%);/* background-image: linear-gradient(to bottom, red, green,red); 시작 빨간색,끝 - 녹색 */&#125; [++ 추가 사이트] “https://codepen.io/FelixRilling/pen/qzfoc&quot; CSS 색상값 단위 (참고)[CSS 색상 값단위] https://aboooks.tistory.com/279","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"Git 생활코딩 스터디 2","slug":"git-gui-study02","date":"2019-09-06T14:38:43.000Z","updated":"2019-11-30T15:48:56.769Z","comments":true,"path":"2019/09/06/git-gui-study02/","link":"","permalink":"https://hyeok999.github.io/2019/09/06/git-gui-study02/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 - GIT Hubhttp://github.com Build software better, togetherGitHub is where people build software. More than 28 million people use GitHub to discover, fork, and contribute to over 85 million projects.github.com ▷ 버전관리 시스템인 Git을 이용하는 프로젝트들을 위한 원격저장소를 제공하는 서비스▷ 오픈소스는 무료, 비공개 프로젝트는 유료 정책▷ 저장소 크기의 제한이 없다.▷ 로컬 버전관리 시스템이 없이도 많은 작업을 웹상에서 할 수 있으며 따로 설치가 필요없다.▷ 사람 중심의 서비스 구성이기 때문에 특정 저장소에 접근하려면 ‘아이디/저장소명’으로 해야 한다.EX) HYEOK999/TEST01 Git 사용하기1 ( 저장소 생성 , 첫 버전파일 생성 ) ▷ Source Tree를 처음 실행하여 계정 등록의 절차를 걸치고 난 후에 뜨는 화면입니다.▷ 1번 Local 현재 자신의 pc 저장소를 의미합니다.▷ 2번 Remote는 원격저장소를 의미합니다.SourceTree에 타 원격저장소 Git HUB , Git lab등과 같은 저장소를 이용할때 사용되는 탭입니다.▷ 3번은 클론저장소 입니다.협업 프로젝트 진행 할 때 개발되어진 소스를 처음에 전부 가지고와야될 경우 사용합니다.▷ 4번은 자신의 PC에 이미 생성된 저장소를 불러올경우 사용되는 탭입니다.Git으로 인해 버전관리가 되어진 폴더의 경우에만 사용이 가능합니다.▷ 5번은 버전관리에 사용될 저장소를 생성합니다. ▷ 5번 탭에서 새로운 버전관리 저장소를 만듭니다.test_git 이라는 새로운 폴더를 만들어주고 해당 폴더에 간단한 html문서를 하나 생성하고test01.html 이라고 저장을 하도록 하겠습니다. 그럴경우 소스트리에서 변화가 생겼습니다.우선 왼쪽 상단의 파일 상태 탭을 보면 2가지 창으로 분류 되어있는 것을 볼수 있습니다.아래쪽의 창을 Working Copy 라고 부르고위쪽의 창을 Staging Area 혹은 Index라고 부릅니다. 그리고 Working Copy를 자세히 볼 경우? 라고 되어 있는 곳에 아까 생성한 html 파일명이 있는 것을 확인할 수 있습니다.우선 ? 라는 표시의 의미는 git이 모르는 파일 .즉, 관리가 안되고 있는 파일 혹은 관리를 처음으로 시작해야하는 파일을 의미합니다.해당 파일을 Stage selected 나 all을 누를경우 스테이징 에어리어에 test01.html 파일이 올라갑니다.그리고나면 왼쪽의 아이콘은 +로 바뀌는데 이것은 해당 파일을 버전관리에 추가함을 의미합니다. 그 후 코멘트를 작성 한 후 Commit을 누를경우 처음으로 버전관리가 되어집니다.여기서 코멘트는 무조건 작성해야 합니다. 만약 작성을 안할경우 Commit이 불가능합니다.왜냐하면 버전관리의 의도는 해당 버전이 무엇인 변경되었는지 어떠한 코드가 추가되었는지알 수 있도록 해야하기 위함이기 때문입니다. Commit을 누를 경우 왼쪽에서 Branches 라는 탭을 보면 master라고 뜨면서 오른쪽 창에는제가 적은 코멘트와 함께 버전이 올아와있습니다.여기서 master는 저 자신 즉, 본인을 의미하고 왼쪽하단에는 코멘트와 날짜와 같은 정보,오른쪽 하단에는 추가된 내용이 있습니다. \\2. Git 사용하기2 ( 추가 버전 생성 ) 이제 다시 HTML 로 돌아와서 간단하게 내용을 추가하도록 하겠습니다. 태그 안에 ‘Git 테스트 공부!’ 라는 내용을 추가하고 저장을 하겠습니다. 그럴경우 master BRANCHES에서 변화가 생깁니다.Uncommitted changes라는 문구와 함께 새로운 버전이 올라와 있습니다.왼쪽에 나타난 쿠키모양의 아이콘은 버전관리중인 파일을 의미합니다. 그리고 하단을 보면 Working copy와 Staging Area 창이 보입니다.Working copy에 있는 파일을 눌러보면 오른쪽창에 무엇이 변경되었는지 확인할 수 있습니다.해당 파일을 Staging Area에 올려놓도록 하겠습니다. 해당 파일을 Staging Area에 올려놓고 오른쪽 클릭을 하면 Commit이 있습니다.해당 버튼을 클릭하면 오른쪽 그림처럼 코멘트를 입력할 수 있는 창이 뜨게 됩니다.해당 창에 ‘ 태그 내용 추가’라고 입력하고 Commit하도록 하겠습니다. 그러면 최종적으로 이제 새로운 버전이 추가된 것을 알 수 있습니다.","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"https://hyeok999.github.io/categories/Develop/GIT/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"SourceTree","slug":"SourceTree","permalink":"https://hyeok999.github.io/tags/SourceTree/"},{"name":"Git GUI","slug":"Git-GUI","permalink":"https://hyeok999.github.io/tags/Git-GUI/"}]},{"title":"Git 생활코딩 스터디 1","slug":"git-gui-study01","date":"2019-09-06T14:36:10.000Z","updated":"2019-11-30T15:49:06.672Z","comments":true,"path":"2019/09/06/git-gui-study01/","link":"","permalink":"https://hyeok999.github.io/2019/09/06/git-gui-study01/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 - 1. Git의 개요 GIT이란? 프로젝트를 실행하면서 문제가 생길경우 문제를 찾기 위해 해매거나 수시로 과거의 파일을 뒤지면서 결국 예전 상태로 돌아가려는 행위를 한적이 있을 것이다. Git은 문제가 발생하여 프로젝트에 이상이 생길 경우 과거의 상태로 쉽게 돌아가게 해준다. 결과적으로서 실패에 대한 부담감이 확연히 줄어들고(그냥 과거로 백하면 되기때문) 이것저것 시도를 할 수 있게 해주는 효과를 제공한다. 현재 Git은 버전관리, 백업, 협업과 같은 중대한 장점을 제공한다. 2. Git 설치 www.git-scm.com여기서 git을 받을 수 있다. GitAbout The advantages of Git compared to other source control systems. Documentation Command reference pages, Pro Git book content, videos and other material. Downloads GUI clients and binary releases for all major platforms. Community Get involved! Bug reporting, mailing list, chat, development andwww.git-scm.com △Git 다운로드 완료시 시작버튼에 Git에 관련된 아이콘들이 추가되어 있는 것을 확인 할 수 있다.▽Git Bash를 실행시키고 “git” 이라고 입력시 제대로 설치되었는지 확인할 수 있다. 이 Bash 창을 통해 Git을 유닉스 나 리눅스의 환경처럼 다룰수도 있고 명령어를 이용한 관리가 가능하다. 3. Git을 GUI 형태로 이용할 Source Tree( 소스트리 )설치 Git은 원래 명령어를 가지고 이용을 하는 버전관리 프로그램이다.하지만 이 기능이 너무 어렵고 GUI에 익숙해진 우리들로서는 너무너무 불편하다!따라서 GUI 기능을 가진 SW인 소스트리를 추가적으로 설치하자. 설치는 이곳에서 가능하다.https://www.sourcetreeapp.com/그 외 설치방법은 이 블로그의 포스트를 참조하자.http://codedragon.tistory.com/4907 Sourcetree | Free Git GUI for Mac and WindowsA Git GUI that offers a visual representation of your repositories. Sourcetree is a free Git client for Windows and Mac.www.sourcetreeapp.com SourceTree(소스트리) 설치하기SourceTree(소스트리) 설치파일 다운받기 http://codedragon.tistory.com/4906 SourceTree(소스트리) 설치하기 다운받은 설치파일을 실행합니다. [계속] 계정이 이미 있다면 [Use an existing account] 클릭 o..codedragon.tistory.com 다운로드 완료시 SourceTree 실행화면","categories":[{"name":"Develop","slug":"Develop","permalink":"https://hyeok999.github.io/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"https://hyeok999.github.io/categories/Develop/GIT/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hyeok999.github.io/tags/git/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"SourceTree","slug":"SourceTree","permalink":"https://hyeok999.github.io/tags/SourceTree/"},{"name":"Git GUI","slug":"Git-GUI","permalink":"https://hyeok999.github.io/tags/Git-GUI/"}]},{"title":"html-css-study-02","slug":"html-css-study-02","date":"2019-09-05T16:15:15.000Z","updated":"2019-11-30T15:48:02.941Z","comments":true,"path":"2019/09/06/html-css-study-02/","link":"","permalink":"https://hyeok999.github.io/2019/09/06/html-css-study-02/","excerpt":"","text":"HTML Study 02 display flex layout a 태그 position font css 개발 방법론 외부 css 적용 방법 ( reset CSS 와 normalize CSS ) 오늘의 중요점!css 문제가 생길시 홈페이지를 열어서 검사를 하고 항상 작은 단위부터 큰단위로 확인하다.( 특히 상속,겹침,우선순위 ) box-sizing 방식은 통일하는게 나중의 유지보수에 좋다. 123456&gt; *, *::before, *::after&#123;&gt;&gt; box-sizing: border-box;&gt;&gt; &#125; /*import 바로 아래*/&gt; 부모가 css box 레이아웃을 결정하면 자식도 그것을 따라감.(상속 - 무조건은 아니다. margin , padding 등등) display 요소(즉 태그)는 inline과 block 요소로 나뉜다. inline : 줄 속에 넣는 요소. 줄바꿈이 되지 않고 글자수에 따라 크기 자체가 줄고 늘어난다. block : 좀 더 넓은 범위를 지정할 때 사용하는 요소. 가로화면을 100% 다차지. 줄바꿈이 됨. display : inline - block과 다르게 줄바꿈이 안되고, width와 height가 적용되지 않는다. 오로지 적용된 글자 수에 따라서 크기가 결정된다. display : block - 가로 화면을 다 차지함. 줄바꿈 O display : none - 박스 생성x, 공간 차지x display : flex - 새로 생긴 display. 따라서 특정 버전이 낮은 브라우저에서는 실행X Flex layout flex 모델은 크기 수치를 잘못입력하여도 레이아웃이 크게 깨지지 않는다. 이유는 전체길이에 대해서 비율로 따져서 스스로 값을 정해주기 때문. display: flexIE 10 or 그 이상 버전에서 사용 가능. flex 설정된 노드의 자식도 flex item을 가지고 모두 flex display가 된다. flex-direction (부모노드)flex-direction은 flex설정시 어떤 방향으로 제기 될것인가를 나열한다. 기본 flex-direction=row 이다. x축 , y축 으로 기준을 나눈다. row = x축 column = y축 flex-basis (자식 노드)flex-item의 크기를 결정합니다. 각 축에 해당하는 (width / height) 의 값을 설정. JUSTIFY-CONTENT: 메인 축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 space-between , flex-item들의 사이를 동일하게 비워줌. space-around, flex-item들의 사이를 비워줌. space-evenly : 익스플로러 지원x ALIGN-ITEMS: 교차축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 order : item 간에 순서를 지정합니다. flex-grow : item들 끼리 크기에 대한 비율을 결정합니다. ex) a-1 b-2 c-1 flex-shrink : flex-item의 크기가 flex-container보다 클때 다른 items의 크기들을 축소시키고 그만큼 해당 item크기를 확대 시킨다. a 태그1&gt; 하이퍼링크 태그인 &lt;a&gt; 는 상황에 따른 css 스타일을 지정할 수 있다. 1234a:link&#123; &#125; /* 선택 안했을 때의 css */a:visited&#123; &#125; /* 선택해서 들어갔을때 */a:hover&#123; &#125; /* 마우스 올라갔을때 글자색 변경 */a:active&#123; &#125; /* 마우스로 클릭한 순간의 상태 */ position static : MarkUp 순서대로 배치, top-bottom-left-right 의 속성값이 적용되지 않는다. absolute : 상위 요소(상위는 반드시 static이 아닌 다른 값)를 기준으로 위치를 설정. relative : 상위 요소(상위는 반드시 static)를 기준으로 위치를 설정. fixed : 요소의 위치를 사용자의 브라우저 기준으로 설정. ( 광고, 상단바, 하단바 등등) font em : 상위요소의 크기에 대해서 비율로 계산한다. rem : 최상위 요소(root)의 크기에 대해서 비율로 계산한다. line-height : 1.15 추천 SpoqaHanSans-kr 본고딕 ( 어도비 배포 ) 1@import url('https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css'); Noto Sans KR 본고딕( 구글 배포 ) 12345&lt;link href=\"https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap\" rel=\"stylesheet\"&gt;&lt;style&gt;@import url('https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap');&lt;/style&gt; CSS 개발 방법론 쉬운 유지보수 코드의 재사용 확장 가능 직관적인 네이밍 BEM OOCSS SMACSS [ CSS 개발 방법론 ] https://gomdoreepooh.github.io/notes/smacss-bem-oocss 외부 CSS 적용 방법 대표적 외부 CSS normalize CSS : 개발 초기 필요한 정도만 초기화 후 사용. Reset CSS : 개발 초기 불필요한 margin, padding 같은 크기들을 모두 초기화. ​ [nomalize css] https://github.com/necolas/normalize.css/ ​ [Reset css] https://meyerweb.com/eric/tools/css/reset/ 적용방법 ( 예 - nomalize ) 123456&lt;link rel=\"stylesheet\"href=\"https://necolas.github.io/normalize.css/latest/normalize.css\"&gt;&lt;style&gt;@import url('https://necolas.github.io/normalize.css/latest/normalize.css');&lt;/style&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"html-css-study-01","slug":"html-css-study-01","date":"2019-09-04T12:47:07.000Z","updated":"2019-11-30T15:48:08.731Z","comments":true,"path":"2019/09/04/html-css-study-01/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/html-css-study-01/","excerpt":"","text":"HTML Study 01 DTD 소개 및 사용 방법 html 영역의 언어 선택 head 영역 안 인코딩 선언 타이틀 요소를 이용한 좋은 제목을 만드는 방법 HTML의 구조 설계 CSS 레이아웃 박스 모델 WEB은 디자인관점이 아닌 콘텐츠 관점으로 보아야 한다.SEO 관점으로 페이지를 작성해야만 한다.문서와 구조와 표현을 분리 해놓는 것이 중요하다.DTD 소개 및 사용 방법 문서타입을 정의 한다. 브라우져에게 해당 HTML이 어떤 표준에 따른 것인지를 알려주는 것을 DTD(Document Type Definition)이라고 한다.DTD는 문서의 제일 위에 위치한다. &lt;! DOCTYPE html&gt; html 영역의 언어 선택 속성 lang=”언어” 식으로 한다. (영어 en, 한국 ko-KR) 언어를 지정해주는 이유는 SEO관점으로서 브라우저에서 검색엔진에 따른 효율성을 높이기 위함이다. head 영역 안 인코딩 선언 meta 태그는 빈요소이다. meta의 속성 charset은 인코딩 형식을 지원한다. 반드시 타이틀보다 먼저 등장해야만 한다. 1&lt;meta charset=\"UTF-8\"&gt; meta의 속성 http-equiv=”X-UA-Compatible” content=”ie=edge” 는 브라우저 사용자 호환성 모드를 의미한다. ( 예, 지원하는 렌더링 모드가 11인데 깔려있는 브라우저 렌더링 버전이 8일경우 11의 렌더링을 8로 호환하여 열어준다.) content는 기본 호환성 브라우저 렌더링 모드를 지정할수있다. 사용자의 브라우저가 edge브라우저를 지원한다면 해당 모드로 연다. 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; 타이틀 요소를 이용한 좋은 제목을 만드는 방법​ SEO 관점에 따라 타이틀 요소를 제대로 적는 것이 중요하다.​​ &gt; 검색 엔진 최적화 (영어: search engine optimization, SEO)는 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다.​​ 12​ &lt;title&gt;웹카페-HTML5,CSS3,웹표준,웹접근성&lt;/title&gt;​ ​​ ###​​​​ ### HTML의 구조 설계​​​​ ## 웹페이지 분석 -&gt; Mark Up -&gt; Naming​​ #### 분석 : 웹페이지는 주로 삼단 구조를 가진다.​​ &gt; 머리말(헤더)​ &gt;​ &gt; 본문(콘텐츠)​ &gt;​ &gt; 꼬리말(푸터)​​​​ #### Web. Cafe. 페이지 분석(삼단 ++)​​ &gt;머리말(헤더)​ &gt;​ &gt;+비주얼(광고등으로 활용가능성)​ &gt;​ &gt;본문(콘텐츠)​ &gt;​ &gt;+슬로건 (커피잔 , 명언)​ &gt;​ &gt;꼬리말(푸터)​​​​ #### Mark Up 단계​​ &gt; body 태그 안​ &gt;​ &gt; ​ header - 머리말​ &gt;​ &gt; ​ div - 비주얼​ &gt;​ &gt; ​ main - 본문​ &gt;​ &gt; ​ article - RSS, 슬로건​ &gt;​ &gt; ​ footer - 꼬리말​​​​ #### Naming 단계 ( Naming : 컴퓨터가 이해할 수 있도록 이름을 지어준다. )​​ &gt; ### { top , bottom 같은 위치 기반 이름은 정말로 안좋음!!! }​ &gt;​ &gt; 이름 주는 방법​ &gt;​ &gt; class : 여러번 사용가능.​ &gt;​ &gt; id : 고유하게 정할 때 사용.​​​​ ### CSS 레이아웃​​ &gt; 정통방식 : float , position, display:inline, display:inline-block​ &gt;​ &gt; 모던방식 : display:inline, display:inline-block, flex, glid​​ ### 박스 모델​​ 12​ box-sizing: content-box | border-box | initial | inherit​ ​​ - content-box : 콘텐트 영역을 기준으로 크기를 정합니다.​ - border-box : 테두리를 기준으로 크기를 정합니다.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"https://hyeok999.github.io/categories/TIL/HTML-CSS/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"HTML","slug":"HTML","permalink":"https://hyeok999.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://hyeok999.github.io/tags/CSS/"}]},{"title":"백준 TEST07_문자열 사용하기","slug":"Algorism-for-java07","date":"2019-09-04T10:26:52.000Z","updated":"2019-11-30T15:52:22.946Z","comments":true,"path":"2019/09/04/Algorism-for-java07/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/Algorism-for-java07/","excerpt":"","text":"백준 TEST07_문자열 사용하기필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 아스키코드1234567891011121314class TEST07_01&#123; public TEST07_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int a = n.charAt(0); // n에 담겨진 첫번째 문자(0번쨰)를 캐릭터형으로 변환후 다시 정수형으로 변환. bw.write(a +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (이클립스 상 답이 맞지만 어째서인지 오답처리됨.)123456789101112131415161718192021222324252627282930313233343536373839404142434445class TEST07_02_t&#123; public TEST07_02_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; int null_num = -1; String S = null; String str = \"abcdefghijklmnopqrstuvwxyz\"; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(int i=0;i&lt;str.length();i++)&#123; int a = 0; for(int j=0;j&lt;S.length();j++)&#123; if(j &gt;= 1 &amp;&amp; S.charAt(j-1) == S.charAt(j))&#123; continue; &#125; if(str.charAt(i) == S.charAt(j))&#123; bw.write(j + \" \"); a++; &#125; &#125; if(a==0)&#123; bw.write(null_num + \" \"); &#125; &#125; bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (정답)123456789101112131415161718192021222324252627282930class TEST07_02_A&#123; public TEST07_02_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; String S = null; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(char alphabet = 'a'; alphabet &lt;= 'z'; alphabet++) &#123; bw.write(S.indexOf(alphabet) + \" \"); &#125; //String.indexOf() 메소드는 원하는 값을 문자열 내에서 원하는 값을 찾아 인덱스 값을 반환한다. 단, 원하는 값이 없으면 -1 을 반환한다. bw.flush(); bw.close(); &#125;&#125; 문자열 반복123456789101112131415161718192021222324class TEST07_03&#123; public TEST07_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = Integer.parseInt(br.readLine()); String a = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\$%*+-./:\"; int b = 0; for(int i=0;i&lt;n;i++)&#123; String xx = br.readLine(); for(int z=2;z&lt;xx.length();z++)&#123; for(int j=0;j&lt;Integer.parseInt(xx.substring(0, 1));j++)&#123; bw.write(xx.charAt(z)); &#125; &#125; bw.write(\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (시간초과 ㅜㅜㅜㅜㅜㅜㅜㅜ)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class TEST07_04_t&#123; public TEST07_04_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String a = null; String A = null; ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); int[] num; while(true)&#123; int count = 0; a = br.readLine(); A = a.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 num = new int[A.length()]; //입력받은 문자의 갯수만큼 정수형 배열을 생성. if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! array.add(String.valueOf(chrInput)); &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end //각각 자신의 개수를 비교하기 시작. for (int i = 0; i &lt; A.length()-1; i++) &#123; for(int j=i+1;j&lt;A.length();j++)&#123; if(array.get(i).equals(array.get(j)))&#123; num[i]++; &#125;//if end &#125;//for-2 end &#125;//for-1 end int temp = 0; String chr_tmp = \"\"; for(int i=0;i&lt;A.length()-1;i++)&#123; for(int j=i+1;j&lt;A.length();j++) if(num[i]&gt;num[j])&#123; temp = num[i]; chr_tmp = array.get(i); num[i] = num[j]; array.set(i,array.get(j)); num[j] = temp; array.set(j,chr_tmp); &#125; &#125; /* for(int i=0;i&lt;A.length();i++)&#123; bw.write(array.get(i)+\" \"); &#125; bw.write(\"\\n\\n\"); for(int i=0;i&lt;A.length();i++)&#123; bw.write(num[i]+\" \"); &#125; bw.write(\"\\n\\n\"); */ if(num.length == 1)&#123; bw.write(array.get(0)); &#125; else if(num[A.length()-1] == num[A.length()-2])&#123; bw.write(\"?\\n\"); &#125; else&#123; bw.write(array.get(A.length()-1)); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (정답)123456789101112131415161718192021222324252627282930313233343536373839404142class TEST07_04_A&#123; public TEST07_04_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String A = null; int[] num = new int[26]; int max = 0; char answer = 0; while(true)&#123; int count = 0; A = br.readLine(); A = A.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end for(int i=0;i&lt;A.length();i++)&#123; num[A.charAt(i)-65]++; if(num[A.charAt(i)-65]&gt;max)&#123; //최초 max는 0 answer = A.charAt(i); max = num[A.charAt(i)-65]; //max값이 증가한다. &#125; else if((num[A.charAt(i)-65]==max))&#123; answer = '?'; &#125; &#125; bw.write(answer); bw.flush(); bw.close(); &#125;&#125; 그룹 단어 체커1234567891011121314151617181920212223242526272829303132333435363738394041class TEST07_05&#123; public TEST07_05()throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String str = null; int count = 0; // a-97 z-122 while(true)&#123; int n = Integer.parseInt(br.readLine()); count = n; int i=0; if(n&lt;=100)&#123; for(i=0;i&lt;n;i++)&#123; int[] num = new int[26]; str = br.readLine(); num[str.charAt(0)-97] = -1; //맨 처음 문자 값은 -1 if(str.length()&gt;1) &#123; for(int j=1;j&lt;str.length();j++)&#123; if(num[str.charAt(j)-97] == -1 &amp;&amp; str.charAt(j) != str.charAt(j-1))&#123; count--; //초기값으로 -1을 지정하였고 그 다음에는 서로 붙어있는지 비교함. 만약 안 붙어있다면 카운트-- break; &#125;//if end num[str.charAt(j) - 97] = -1; // 초기값을 -1로 초기화 시켜나감. &#125;//for-j end &#125;//if end &#125;//for-i end bw.write(count+\"\"); &#125;//if end if(i == n) &#123; break; &#125; &#125;//while end bw.flush(); bw.close(); &#125;&#125; 6단계 - 1차원배열 사용하기 1번문제 임. (전 포스팅 참조)상수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class TEST07_07&#123; public TEST07_07() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] num; while(true)&#123; num = br.readLine().split(\" \"); int w_count = 0; if(num[0].length() &gt; 3 &amp;&amp; num[0].length() &lt; 0)&#123; continue; &#125; if(num[1].length() &gt; 3 &amp;&amp; num[1].length() &lt; 0)&#123; continue; &#125; for(int i=0;i&lt;2;i++)&#123; w_count = 0; for(int j=0;j&lt;num[i].length();j++) if(num[i].charAt(j) == '0')&#123; w_count++; break; &#125; &#125; if(w_count &gt;= 1 )&#123; continue; &#125; int A = Integer.parseInt(num[0]); int B = Integer.parseInt(num[1]); if(A != B)&#123; break; &#125; &#125; int a = 0; int[] sum = new int[2]; for(int i=0;i&lt;2;i++)&#123; for(int j=2;j&gt;=0;j--)&#123; switch(j)&#123; case 2 : a = num[i].charAt(j) - '0'; a = a*100; break; case 1 : a = num[i].charAt(j) - '0'; a = a*10; break; case 0 : a = num[i].charAt(j) - '0'; break; &#125;// charAt(i) - '0' -&gt; char형을 int형으로 변환 sum[i] = sum[i] + a; &#125; &#125; if(sum[0] &gt; sum[1])&#123; bw.write(sum[0] + \"\"); &#125; else&#123; bw.write(sum[1] + \"\"); &#125; bw.flush(); bw.close(); &#125;&#125; 다이얼1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST07_08&#123; public TEST07_08() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String num; int count = 0; while(true)&#123; num = br.readLine(); int w_count = 0; if(num.length()&lt;2 &amp;&amp; num.length()&gt;15)&#123; continue; &#125; for(int i=0;i&lt;num.length();i++)&#123; if(num.charAt(i) &lt; 64 &amp;&amp; num.charAt(i) &gt; 91)&#123; w_count++; break; &#125; &#125;//대문자로만 입력 if(w_count == 0)&#123; break; &#125; &#125; for(int i=0;i&lt;num.length();i++)&#123; switch(num.charAt(i))&#123; case 'A': case 'B': case 'C' : count += 3; break; case 'D': case 'E': case 'F' : count += 4; break; case 'G': case 'H': case 'I' : count += 5; break; case 'J': case 'K': case 'L' : count += 6; break; case 'M': case 'N': case 'O' : count += 7; break; case 'P': case 'Q': case 'R' : case 'S' : count += 8; break; case 'T': case 'U': case 'V' : count += 9; break; case 'W': case 'X': case 'Y' : case 'Z' : count += 10; break; &#125; &#125; bw.write(count + \"\"); bw.flush(); bw.close(); &#125;&#125; 크로아티아 알파벳12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TEST07_09&#123; public TEST07_09() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String c_alpha2[] = &#123;\"c=\",\"c-\",\"d-\",\"lj\",\"nj\",\"s=\",\"z=\"&#125;; String c_alpha3 = \"dz=\"; String croa; while(true)&#123; croa = br.readLine(); int w_count = 0; if(croa.length()&lt;1 &amp;&amp; croa.length()&gt;100)&#123; continue; &#125; for(int i=0;i&lt;croa.length();i++)&#123; if(croa.charAt(i) &lt; 97 || croa.charAt(i) &gt; 122)&#123; if (croa.charAt(i) == '-'|| croa.charAt(i) == '=' )&#123; continue; &#125; w_count++; break; &#125; //소문자 혹은 '-' '=' 가 아닐경우 무한반복 &#125; if(w_count == 0)&#123; break; &#125; &#125; int count = croa.length(); while(true)&#123; if(croa.indexOf(c_alpha3) &gt; -1)&#123; count = count - 2; croa = croa.replaceFirst(c_alpha3,\" \"); &#125; else&#123; break; &#125; &#125;//\"dz=\" 이라는 문자가 존재시 해당 문자를 빼머리고 전체값에서 -2 후 공백으로 변환. for(int k=0;k&lt;7;k++)&#123; while(true)&#123; if(croa.indexOf(c_alpha2[k]) &gt; -1)&#123; count = count - 1; croa = croa.replaceFirst(c_alpha2[k],\" \"); &#125; else&#123; break; &#125; &#125; &#125;//for-k end bw.write(count + \" \"); bw.flush(); bw.close(); &#125;&#125; Main123456789101112131415public class TEST07 &#123; //Main&#123; public static void main(String[] args) throws IOException&#123; // TEST07_01 test07_01 = new TEST07_01(); // TEST07_02_t test07_02_t = new TEST07_02_t(); // TEST07_02_A test07_02_A = new TEST07_02_A(); // TEST07_03 test07_03 = new TEST07_03(); // TEST07_04_t test07_04_t = new TEST07_04_t(); //시간초과 // TEST07_04_A test07_04_A = new TEST07_04_A(); //정답 // TEST07_05 test07_05 = new TEST07_05(); //6번 문제는 1차원배열사용하기 - 1번문제 // TEST07_07 test07_07 = new TEST07_07(); // TEST07_08 test07_08 = new TEST07_08(); TEST07_09 test07_09 = new TEST07_09(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"BAEKJOON","slug":"BAEKJOON","permalink":"https://hyeok999.github.io/tags/BAEKJOON/"}]},{"title":"백준 TEST06_1차원 배열 사용하기","slug":"Algorism-for-java06","date":"2019-09-04T10:26:50.000Z","updated":"2019-11-30T15:52:17.875Z","comments":true,"path":"2019/09/04/Algorism-for-java06/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/Algorism-for-java06/","excerpt":"","text":"백준 TEST06_1차원 배열 사용하기 필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 단어의개수123456789101112131415161718192021222324252627282930313233class TEST06_01 &#123; public TEST06_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int count=1; for(int i=0;i&lt;n.length();i++)&#123; char chrInput = n.charAt(i); if(n.charAt(i) ==' ')&#123; count++; &#125; if (chrInput &lt; 0x61 &amp;&amp; chrInput &gt; 0x7A) &#123; break; &#125; // 영문(소문자)가 아닐경우 무한 반복! else if (chrInput &lt; 0x41 &amp;&amp; chrInput &gt; 0x5A) &#123; break; &#125; // 영문(대문자)가 아닐 경우 무한 반복! &#125;// for end //count++; if(n.charAt(0)==' ' &amp;&amp; n.charAt(n.length()-1)==' ')&#123; count--; count--; &#125; else if(n.charAt(0)==' ' || n.charAt(n.length()-1)==' ')&#123; count--; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 숫자의 개수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TEST06_02&#123; public TEST06_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int[] num = new int[10]; int A = Integer.parseInt(br.readLine()); int B = Integer.parseInt(br.readLine()); int C = Integer.parseInt(br.readLine()); //bw.write( A * B * C +\"\\n\"); String sum = A * B * C +\"\"; //bw.write(sum); char[] a = sum.toCharArray(); for(int i=0;i&lt;a.length;i++)&#123; switch(a[i])&#123; case '0' : num[0]++; break; case '1' : num[1]++; break; case '2' : num[2]++; break; case '3' : num[3]++; break; case '4' : num[4]++; break; case '5' : num[5]++; break; case '6' : num[6]++; break; case '7' : num[7]++; break; case '8' : num[8]++; break; case '9' : num[9]++; break; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; bw.write(num[i]+\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; OX퀴즈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST06_03&#123; public TEST06_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int t_case = Integer.parseInt(br.readLine()); int[] num = new int[t_case]; String[] ox = new String[t_case]; // O- 0x4F X-0x58 while(true)&#123; int i = 0; for(i=0;i&lt;t_case;i++)&#123; int j = 0; ox[i] = br.readLine(); char[] chrInput= ox[i].toCharArray(); if(ox[i].length() &gt; 80 || ox[i].length() &lt; 0)&#123; break; //MAIN FOR BREAK &#125; for(j=0;j&lt;ox[i].length();j++)&#123; if(chrInput[j] == 'O' ||chrInput[j] == 'X') continue; else break; //SUB FOR BREAK &#125; if(j!=ox[i].length()) break; //MAIN FOR BREAK &#125; if(i==t_case) break; //O혹은 X가 아닐경우 처음 부터 다시 &#125;//while end for(int i=0;i&lt;t_case;i++)&#123; char[] sub = ox[i].toCharArray(); int score = 0; for(int j=0;j&lt;ox[i].length();j++)&#123; if(sub[j] == 'O')&#123; score++; num[i] += score; &#125; else score = 0; &#125;// for - j end bw.write(num[i] + \"\\n\"); &#125;//for - i end bw.flush(); bw.close(); &#125;&#125; 음계1234567891011121314151617181920212223242526272829303132333435363738class TEST06_04&#123; public TEST06_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] m = br.readLine().split(\" \"); String[] x = new String[8]; String[] y = new String[8]; int count = 0 ; for(int i=0;i&lt;m.length;i++)&#123; x[i] = String.valueOf(i+1); y[i] = String.valueOf(8-i); if(x[i].equals(m[i]))&#123; count++; &#125; if(y[i].equals(m[i]))&#123; count--; &#125; &#125; // bw.write(m.length+\"\\n\"); // bw.write(x[3]+\"\\n\"); if(m[0].equals(\"1\") &amp;&amp; count == 8)&#123; bw.write(\"ascending\"); &#125; else if(m[0].equals(\"8\") &amp;&amp; count == -8)&#123; bw.write(\"descending\"); &#125; else&#123; bw.write(\"mixed\"); &#125; bw.flush(); bw.close(); &#125;&#125; 평균 점수12345678910111213141516171819202122232425262728class TEST06_05&#123; public TEST06_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int sum = 0; while(true)&#123; int i=0; for(i=0;i&lt;5;i++)&#123; int n = Integer.parseInt(br.readLine()); if(n&lt;0 || n%5!=0)&#123; break; &#125; if(n&lt;40) n=40; sum += n; &#125;//main for end if(i==5)&#123; break; &#125; &#125;//while end bw.write(sum/5 +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; Main123456789public class TEST06 &#123; public static void main(String[] args) throws IOException&#123; // TEST06_01 test06_01 = new TEST06_01(); // TEST06_02 test06_02 = new TEST06_02(); // TEST06_03 test06_03 = new TEST06_03(); // TEST06_04 test06_04 = new TEST06_04(); TEST06_05 test06_05 = new TEST06_05(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"BAEKJOON","slug":"BAEKJOON","permalink":"https://hyeok999.github.io/tags/BAEKJOON/"}]},{"title":"백준 TEST05_함수 사용하기","slug":"Algorism-for-java05","date":"2019-09-04T10:26:48.000Z","updated":"2019-11-30T15:52:38.836Z","comments":true,"path":"2019/09/04/Algorism-for-java05/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/Algorism-for-java05/","excerpt":"","text":"## 필요 패키지 및 외부 클래스 123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 셀프넘버12345678910111213141516171819202122232425262728293031323334class hamsu&#123; public int d(int num)&#123; int xxxx = num/1000; int xxx = (num/100)%10; int xx = (num/10)%10; int x = num%10; num = num + xxxx + xxx + xx + x; return num; &#125;&#125;class TEST05_01 extends hamsu&#123; public TEST05_01()&#123;// ArrayList array = new ArrayList(); int i = 0; int[] fin = new int[10000]; //배열 10000개 선언 알아서 0으로 초기화함. for(i=0;i&lt;10000;i++)&#123; if(d(i)&lt;10000)&#123; fin[d(i)] = 1; &#125; if(fin[i] == 0)&#123; System.out.println(i); &#125; &#125; &#125; &#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_01 test05_01 = new TEST05_01(); &#125;&#125; 한수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST05_02 &#123; public TEST05_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int count = 0; int xxxx,xxx,xx,x = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000)&#123; break; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i&lt;100)&#123; count++; &#125; if(i&gt;=100)&#123; xxx = i/100; xx = (i/10)%10; x = i%10; if(xx-x==xxx-xx)&#123; count++; &#125; &#125; if(i&gt;=1000)&#123; xxxx = i/1000; xxx = (i/100)%10; xx = (i/10)%10; x = i%10; if(xxxx-xxx == xxx-xx) if(xx-x == xxx-xx)&#123; count++; &#125; &#125; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_02 test05_02 = new TEST05_02(); &#125;&#125; 별찍기 - 11 별찍기에 대해서 초반에 어떻게 문제를 풀어야하는지 감이 너무 오질 않았다. 따라서 강의를 보면서 이해하는 형식으로 진행하였다. 해당 강의는 C를 기반으로 진행하였으므로 나는 자바의 형식에 맞게 수정을 해주었다. https://youtu.be/WjmEVp-Lgns 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class TEST05_03 &#123; static char[][] arr; public TEST05_03() throws IOException&#123; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = input_num(); arr = new char[n][2*n-1]; //예제 y축 24칸, x축 47칸임(맨 아래 밑변). //배열 선언은 while문 아래가 될 수 없다. for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;2*n-1; j++) &#123; arr[i][j] = ' '; &#125; &#125;//초기화 구문, 자바에서 미선언시 char은 널값으로 초기화됨. 따라서 모두 공백으로 미리 초기화. solution(n,n-1,0);// n은 몇층까지 를 의미, n-1은 첫 시작의 별 위치 -&gt; x축, 0은 첫줄을 의미한다. -&gt;y축 for(int i=0; i&lt;n; i++) &#123; bw.write(arr[i]); bw.write('\\n'); &#125; //이차원배열로 선언되었기 때문에 a[i]번째 줄에 저장된 모든 값을 출력. bw.flush(); bw.close(); &#125; public int input_num() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = 0; int count = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); for(int k=0;k&lt;=10;k++)&#123; if(n==3*(Math.pow(2, k)))&#123; count = 1; &#125; //제대로 된 수를 입력할 때 까지 무한반복 N은 3*2^k승. &#125; if(count == 1) break; &#125; return n; &#125; // 제대로된 n값을 입력하였느지 확인. 제대로된 값이 아니라면 무한반복. public void solution(int n,int x,int y)&#123; if (n == 3) &#123; arr[y][x] = '*'; //첫 별 * arr[y + 1][x - 1] = '*'; //두번 째 별 1 * * arr[y + 1][x + 1] = '*'; //두번째 별 2 arr[y + 2][x - 2] = '*'; //세번째 별 1 ***** arr[y + 2][x - 1] = '*'; //세번째 별 2 ***** arr[y + 2][x] = '*'; //세번째 별 3 ***** arr[y + 2][x + 1] = '*'; //세번째 별 4 ***** arr[y + 2][x + 2] = '*'; //세번째 별 5 ***** return; &#125; //n이 3일때 별을 그려주는 로직 시작. // n이 3이 최소임. solution(n/2, x, y); // 첫 큰 삼각형 solution(n/2, x-(n/2) , y+(n/2)); // 왼쪽 큰 삼각형 solution(n/2, x+(n/2) , y+(n/2)); // 오른쪽 큰 삼각형 &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_03 test05_03 = new TEST05_03(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"BAEKJOON","slug":"BAEKJOON","permalink":"https://hyeok999.github.io/tags/BAEKJOON/"}]},{"title":"백준 TEST04_if문 사용해보기","slug":"Algorism-for-java04","date":"2019-09-04T10:26:47.000Z","updated":"2019-11-30T15:52:47.900Z","comments":true,"path":"2019/09/04/Algorism-for-java04/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/Algorism-for-java04/","excerpt":"","text":"백준 TEST04_if문 사용해보기 기본 필요 패키지 및 외부클래스123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 시험성적1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST04_01&#123; public TEST04_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&gt;= 0 &amp;&amp; n&lt;101)&#123; break; &#125; &#125; switch (n/10) &#123; case 10 : case 9 : bw.write(\"A\\n\"); bw.flush(); break; case 8 : bw.write(\"B\\n\"); bw.flush(); break; case 7 : bw.write(\"C\\n\"); bw.flush(); break; case 6 : bw.write(\"D\\n\"); bw.flush(); break; default : bw.write(\"F\\n\"); bw.flush(); break; &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_01 test04_01 = new TEST04_01(); &#125;&#125; 세 수 - 버전112345678910111213141516171819202122232425262728293031323334class TEST04_02_01&#123; public TEST04_02_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); if ((A&gt;=B)&amp;&amp;(A&lt;=C)||(A&gt;=C)&amp;&amp;(A&lt;=B))&#123; bw.write(A+\"\\n\"); bw.flush(); bw.close(); &#125; else if((B&gt;=C)&amp;&amp;(B&lt;=A)||(B&gt;=A)&amp;&amp;(B&lt;=C))&#123; bw.write(B+\"\\n\"); bw.flush(); bw.close(); &#125; else&#123; bw.write(C+\"\\n\"); bw.flush(); bw.close(); &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_01 test04_02_01 = new TEST04_02_01(); &#125;&#125; 세 수 - 버전2 (정렬이용)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TEST04_02_02&#123; public TEST04_02_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; int tmp; ArrayList&lt;Integer&gt; num = new ArrayList&lt;&gt;(); String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); num.add(A); num.add(B); num.add(C); //버블정렬 for(int i=1;i&lt;num.size();i++)&#123; for(int j=0;j&lt;num.size()-i;j++)&#123; if(num.get(j)&gt;=num.get(j+1))&#123; //num.get(1);//확인. num.set(1,temp);//수정. tmp = num.get(j); num.set(j, num.get(j+1)); num.set(j+1, tmp); &#125; &#125; &#125; /* //선택정렬 for(int i=0;i&lt;num.size()-1;i++)&#123; for(int j=i+1;j&lt;num.size();j++)&#123; if(num.get(i) &gt;= num.get(j)) &#123; tmp = num.get(j); num.set(j,num.get(i)); num.set(i,tmp); &#125; &#125; &#125; */ bw.write(num.get(1)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_02 test04_02_02 = new TEST04_02_02(); &#125;&#125; X보다 작은 수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST04_03&#123; public TEST04_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int i = 0; int x = 0; while(true)&#123; String[] a = br.readLine().split(\" \"); n = Integer.parseInt(a[0]); x = Integer.parseInt(a[1]); if(x&gt;=1 &amp;&amp; x&lt;=10000 &amp;&amp; n&gt;=1 &amp;&amp; n&lt;=10000)&#123; break; &#125; &#125; String[] A = br.readLine().split(\" \"); while(true)&#123; for(i=0;i&lt;n;i++)&#123; int y = Integer.parseInt(A[i]); if(y&lt;=0 &amp;&amp; y&gt;=10000)&#123; break; &#125; if(y&lt;x)&#123; bw.write(y+\" \"); &#125; &#125; if(i==n)&#123; break; &#125; &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_03 test04_03 = new TEST04_03(); &#125;&#125; 평균1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TEST04_04&#123; public TEST04_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); //정수형을 값을 저장할 리스트 공간 int n,i,tmp = 0; //n은 과목수 , i는 조건을 위한 수 , tmp는 임시저장소 , sum 최종합 double sum = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000) break; &#125; while(true)&#123; String[] a = br.readLine().split(\" \"); for(i=0;i&lt;n;i++)&#123; tmp = Integer.parseInt(a[i]); array.add(Integer.parseInt(a[i])); if(tmp&gt;100 &amp;&amp; tmp&lt;=0)&#123; break; &#125; &#125; if(i==n)&#123; break; &#125; &#125; for(i=0;i&lt;array.size()-1;i++)&#123; for(int j=i+1;j&lt;array.size();j++)&#123; if(array.get(i)&gt;array.get(j))&#123; tmp = array.get(i); array.set(i, array.get(j)); array.set(j,tmp); &#125; &#125; &#125;//선택정렬 이용 for(i = 0;i&lt;array.size();i++)&#123; sum += array.get(i); &#125; bw.write((double)(sum/array.size()/array.get(array.size()-1)*100.0)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_04 test04_04 = new TEST04_04(); &#125;&#125; 텍스트 추가 \\05. 평균은 넘겠지 텍스트 추가 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TEST04_05&#123; public TEST04_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Double&gt; number = new ArrayList&lt;&gt;(); int C = Integer.parseInt(br.readLine()); int j = 0; double hap = 0; while(true)&#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); double num = 0; int sum = 0; double avg = 0; String[] x = br.readLine().split(\" \"); if(Integer.parseInt(x[0])&lt;1 &amp;&amp; Integer.parseInt(x[0])&gt;1000)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); for(int i=0;i&lt;=Integer.parseInt(x[0]);i++)&#123; array.add(Integer.parseInt(x[i])); if(Integer.parseInt(x[i])&lt;0 &amp;&amp; Integer.parseInt(x[i])&gt;100)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); &#125; sum = 0; for(int i=1;i&lt;array.size();i++)&#123; sum = sum + array.get(i); &#125; avg = sum/array.get(0); for(int i=1;i&lt;array.size();i++)&#123; if(array.get(i)&gt;avg)&#123; num++; &#125; &#125; hap = num/array.get(0); number.add((num/array.get(0))*100); j++; if(j==C)&#123; break; &#125; &#125; for(int i=0;i&lt;C;i++)&#123; System.out.printf(\"%.3f\",number.get(i)); System.out.println(\"%\"); &#125; /* for(int i=0;i&lt;C;i++)&#123; bw.write(number.get(i)+\"%\"+\"\\n\"); &#125; bw.flush(); bw.close(); */ &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_05 test04_05 = new TEST04_05(); &#125;&#125; 더하기 사이클123456789101112131415161718192021222324252627282930313233343536373839404142class TEST04_06&#123; public TEST04_06() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int xx = 0; int x = 0; int fin = 0; int cycle_num = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); fin = n; if(n&gt;=0 &amp;&amp; n&lt;=99)&#123; break; &#125;// 아닐경우 무한반복 &#125; while(true)&#123; xx = n/10; x = n%10; n = (xx + x)%10; n = (x*10)+n; cycle_num++; if(fin == n)&#123; break; &#125; &#125; bw.write(cycle_num+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_06 test04_06 = new TEST04_06(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"BAEKJOON","slug":"BAEKJOON","permalink":"https://hyeok999.github.io/tags/BAEKJOON/"}]},{"title":"백준 TEST03_for문 사용해보기","slug":"Algorism-for-java03","date":"2019-09-04T10:26:45.000Z","updated":"2019-11-30T15:52:57.315Z","comments":true,"path":"2019/09/04/Algorism-for-java03/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/Algorism-for-java03/","excerpt":"","text":"백준_TEST03_for문 사용해보기N찍기123456789101112131415161718192021import java.util.*;class TEST03_01&#123; public TEST03_01()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_01 test03_01 = new TEST03_01(); &#125;&#125; 기찍 N123456789101112131415161718192021import java.util.*;class TEST03_02&#123; public TEST03_02()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=N;i&gt;=1;i--)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_02 test03_02 = new TEST03_02(); &#125;&#125; 구구단12345678910111213141516171819202122import java.util.*;class TEST03_03&#123; public TEST03_03()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=9;i++)&#123; System.out.println(N+\" * \"+i+\" = \"+N*i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_03 test03_03 = new TEST03_03(); &#125;&#125; 별찍기-1123456789101112131415161718192021222324import java.util.*;class TEST03_04&#123; public TEST03_04()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_04 test03_04 = new TEST03_04(); &#125;&#125; 별찍기-21234567891011121314151617181920212223242526272829303132333435import java.util.*;class TEST03_05&#123; public TEST03_05()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); // int K = N-1; for(int i=1;i&lt;=N;i++)&#123; /* for(int x=K;x&gt;=1;x--)&#123; System.out.print(\" \"); &#125; */ for(int j=1;j&lt;=N-i;j++)&#123; System.out.print(\" \") ; &#125; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; //K--; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_05 test03_05 = new TEST03_05(); &#125;&#125; 별찍기-3123456789101112131415161718192021222324252627import java.util.*;class TEST03_06&#123; public TEST03_06()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=N-i+1;j&gt;=1;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_06 test03_06 = new TEST03_06(); &#125;&#125; 별찍기-4123456789101112131415161718192021222324252627import java.util.*;class TEST03_07&#123; public TEST03_07()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;i;j++)&#123; System.out.print(\" \"); &#125; for(int j=N-i;j&gt;0;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_07 test03_07 = new TEST03_07(); &#125;&#125; ###2007년 -&gt; 해결은 하였으나 더 간단하게 푸는 방법이 존재함. -&gt; 1번=직접 해결한 소스. 2번=해답 소스 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1번import java.util.*;class TEST03_08&#123; public TEST03_08()&#123; Scanner scan = new Scanner(System.in); int x,y,z = 0; //z는 일주일 7을 의미. while(true)&#123; x = scan.nextInt(); if(x&gt;=1 &amp;&amp; x&lt;=12)&#123; break; &#125; &#125; while(true)&#123; y = scan.nextInt(); if(y&gt;=1 &amp;&amp; y&lt;=31)&#123; break; &#125; &#125; // x = 월, y = 일을 입력받는다. //ArrayList&lt;String&gt; month = new ArrayList&lt;&gt;(); //month.add(\"SUN\");month.add(\"MON\"); //한개씩은 위처럼 한번에는 아래처럼 이용. Array.asList ArrayList&lt;String&gt; week = new ArrayList&lt;&gt;(Arrays.asList(\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\",\"SUN\")); for(int i=1;i&lt;=12;i++)&#123; if(i==1 || i==3 || i==5|| i==7 || i==8 || i==10 || i==12)&#123; for(int j=1;j&lt;=31;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 1,3,5,7,8,10,11,12 월 for문 end &#125; else if(i==2)&#123; for(int j=1;j&lt;=28;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 2월 for문 end &#125; else&#123; for(int j=1;j&lt;=30;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 4,6,9,11 월 for문 end &#125; // if end &#125;//for-i end &#125; &#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_08 test03_08 = new TEST03_08(); &#125;&#125; 12345678910111213141516171819202122//2번 - 해답import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int month = sc.nextInt(); int day = sc.nextInt(); sc.close(); int[] daysInMonth = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; String[] dayOfTheWeeks = &#123;\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"&#125;; int totalDays = day; for (int i = 0; i &lt; month - 1; ++i) &#123; totalDays += daysInMonth[i]; &#125; System.out.println(dayOfTheWeeks[totalDays % 7]); &#125;&#125; 합123456789101112131415161718192021import java.util.*;class TEST03_09&#123; public TEST03_09()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int sum = 0; for(int i=1;i&lt;=n;i++)&#123; sum += i; &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_09 test03_09 = new TEST03_09(); &#125;&#125; 숫자의 합 &lt;미해결&gt;-&gt; 미해결한 이유 : Scanner 메서드로는 숫자를 1개씩 입력 받는건 불가능하다. 123456789101112131415161718192021222324252627import java.util.*;class TEST03_10_1&#123; public TEST03_10_1()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int a = 0; int sum = 0; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=n;i++)&#123; a = scan.nextInt(); array.add(a); &#125; for(int i=1;i&lt;=n;i++)&#123; sum += array.get(i-1); &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_1 test03_10_1 = new TEST03_10_1(); &#125;&#125; 숫자의 합 &lt;해결&gt;-&gt; 해결법 : 문자열로 받아서 끊어서 하나하나 더하거나 아스키코드를 이용한다. -&gt; 여기서는 끊어서 사용하는 substring() 함수를 이용. 12345678910111213141516171819202122232425import java.util.*;class TEST03_10_2&#123; public TEST03_10_2()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); String a = scan.next(); scan.close(); int sum = 0; for(int i=0;i&lt;n;i++)&#123; sum += Integer.parseInt(a.substring(i, i + 1)); &#125; //Integer.parseInt() 인트형으로 형변환 메서드 //substring(a,b); a=현재위치 b=까지 System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_2 test03_10_2 = new TEST03_10_2(); &#125;&#125; 열 개씩 끊어 출력하기1234567891011121314151617181920212223import java.util.*;class TEST03_11&#123; public TEST03_11()&#123; Scanner scan = new Scanner(System.in); String n = scan.next(); scan.close(); for(int i=1;i&lt;=n.length();i++)&#123; System.out.print(n.charAt(i-1)); if(i%10==0)&#123; System.out.println(\"\"); &#125; &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_11 test03_11 = new TEST03_11(); &#125;&#125; 빠른 A+B (BufferedReader , BufferedWriter)1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;class TEST03_12&#123; public TEST03_12() throws IOException&#123; //버퍼드리더와 버퍼드라이터를 쓰기 위한 조건 : throws NumberFormatException, IOException BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));//선언 int test_case = Integer.parseInt(br.readLine()); // 몇개 입력? //readline은 버퍼에 입력하는것. for(int i=0; i&lt;test_case;i++) &#123; //ex) 5개라 입력했으면 총 5줄의 입력을 받음. String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. bw.write(\"현재 입려숫자는 각각\"+a[0]+\" \"+a[1]+\"\\n\"); int answer = Integer.parseInt(a[0]) + Integer.parseInt(a[1]); bw.write(answer+\"\\n\"); // write는 버퍼에 해당 값을 저장하는것. // flush는 버퍼에 있는 내용을 printf하는것이다. // 여기서 한번 flush를 해버리면 버퍼의 내용을 출력과 동시에 비운다. &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_12 test03_12 = new TEST03_12(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"BAEKJOON","slug":"BAEKJOON","permalink":"https://hyeok999.github.io/tags/BAEKJOON/"}]},{"title":"백준_TEST02_사칙연산 도전하기","slug":"Algorism-for-java02","date":"2019-09-04T10:26:42.000Z","updated":"2019-11-30T15:53:03.274Z","comments":true,"path":"2019/09/04/Algorism-for-java02/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/Algorism-for-java02/","excerpt":"","text":"백준 TEST02_사칙연산 도전하기A*B123456789101112131415161718192021import java.util.*;//1번 2번은 TEST01단계에서 해결했음. A+B , A-Bclass TEST02_03&#123; public TEST02_03()&#123; // 생성자 Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.println(a*b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_03 test02_03 = new TEST02_03(); &#125;&#125; A / B (오차범위 10-9까지)1234567891011121314151617181920import java.util.*;class TEST02_04&#123; public TEST02_04()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.printf(\"%.9f\",a/b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자// TEST02_03 test02_03 = new TEST02_03(); TEST02_04 test02_04 = new TEST02_04(); &#125;&#125; 사칙연산1234567891011121314151617181920212223import java.util.*;class TEST02_05&#123; public TEST02_05()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;=1 &amp;&amp; b&lt;=10000)&#123; System.out.println((int)a+(int)b); System.out.println((int)a-(int)b); System.out.println((int)a*(int)b); System.out.println((int)a/(int)b); System.out.println((int)a%(int)b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_05 test02_05 = new TEST02_05(); &#125;&#125; 나머지1234567891011121314151617181920212223import java.util.*;class TEST02_06&#123; public TEST02_06()&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); int c = scan.nextInt(); if(a&gt;=2 &amp;&amp; a&lt;=10000 &amp;&amp; b&gt;=2 &amp;&amp; b&lt;=10000 &amp;&amp; c&gt;=2 &amp;&amp; c&lt;=10000)&#123; System.out.println((a+b)%c); System.out.println((a%c + b%c)%c); System.out.println((a*b)%c); System.out.println((a%c * b%c)%c); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_06 test02_06 = new TEST02_06(); &#125;&#125; A+B-2 백준 TEST01 단계의 A+B 동일 문제. 따라서 넘어감. 설탕 배달 알고리즘1234567891011121314151617181920212223242526272829303132import java.util.*;class TEST02_08&#123; public TEST02_08()&#123; Scanner scan = new Scanner(System.in); int box = 0 ; int sugar_kg = scan.nextInt(); if(sugar_kg &gt;=3 &amp;&amp; sugar_kg &lt;= 5000)&#123; if(sugar_kg/5 != 0)&#123; for(box = sugar_kg/5;box&gt;=0;box--)&#123; if((sugar_kg - box*5)%3==0)&#123; box += (sugar_kg - box*5)/3; break; &#125; &#125; &#125; else if(sugar_kg == 3)&#123; box = 1; &#125; else&#123; box = -1; &#125; &#125; System.out.println(box); &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_08 test02_08 = new TEST02_08(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"BAEKJOON","slug":"BAEKJOON","permalink":"https://hyeok999.github.io/tags/BAEKJOON/"}]},{"title":"백준 TEST01_입/출력 받아보기","slug":"Algorism-for-java01","date":"2019-09-04T10:26:38.000Z","updated":"2019-11-30T15:53:10.522Z","comments":true,"path":"2019/09/04/Algorism-for-java01/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/Algorism-for-java01/","excerpt":"","text":"# # 백준 TEST01_입/출력 받아보기 Hello World12345public class TEST01_01 &#123; public static void main(String args[])&#123; System.out.println(\"Hellow World\"); &#125;&#125; A+B12345678910import java.util.*;public class TEST01_02&#123; public static void main(String args[])&#123; Scanner scan = new Scanner(System.in); int a, b; a = scan.nextInt(); b = scan.nextInt(); System.out.println(a + b); &#125;&#125; A-B1234567891011import java.util.*;public class TEST01_03 &#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); System.out.println(a-b); &#125;&#125; 등록텍스트 추가 123456public class TEST01_04 &#123; public static void main(String[] args)&#123; System.out.println(\"맞은갯수\"); System.out.println(\"아이디명\"); &#125;&#125; 개텍스트 추가 1234567891011public class TEST01_05 &#123; public static void main(String[] args)&#123; System.out.println(\"|\\\\_/|\"); //역슬래쉬를 print로 표시하고 싶으면 \\\\로 사용. System.out.println(\"|q p| /&#125;\"); System.out.println(\"( 0 )\\\"\\\"\\\"\\\\\"); //따옴표를 print로 표시하고 싶으면 \\\"로 사용. System.out.println(\"|\\\"^\\\"` |\"); System.out.println(\"||_/=\\\\\\\\__|\"); &#125;&#125; We love kriii12345public class TEST01_06 &#123; public static void main(String[] args)&#123; System.out.printf(\"강한친구 대한육군\\n강한친구 대한육군\\n\"); &#125;&#125; 그대로 출력하기 (연습)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. charAt(i) =&gt; str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. substring(i,j) =&gt; i부터 j-1까지. 문제점 -&gt; 0~100줄까지 전부 입력을 해야하는데 빈줄이 주어지지않는다. 라는 점에서 문제가 있다고 생각함. 만족 조건은 입력 최대 100줄과 각 줄이 100줄을 넘을 경우 잘라내는 기능 까지만 구현이 완료됬음. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;public class TEST01_07 &#123; public static boolean checkInputOnlyNumberAndAlphabet(String str) &#123; char chrInput = str.charAt(0); for (int i = 0; i &lt; str.length(); i++) &#123; chrInput = str.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 // charAt(i) = str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; // 영문(소문자) OK! &#125; else if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; // 영문(대문자) OK! &#125; else if (chrInput &gt;= 0x30 &amp;&amp; chrInput &lt;= 0x39) &#123; // 숫자 OK! &#125; else &#123; return false; // 영문자도 아니고 숫자도 아님! &#125; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); for (int n = 0; n &lt; 100; n++) &#123; String str = scan.nextLine(); if (str.length() &gt; 100) &#123; str = str.substring(0, 100); &#125; // substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. // substring(i,j) =&gt; i부터 j-1까지. if (checkInputOnlyNumberAndAlphabet(str)) &#123; System.out.println(str); &#125;//줄에 영문,숫자를 제외한 다른글자가 포함되어있을 경우 출력을 안함. &#125; // for문 끝 &#125; &#125; 그대로 출력하기 (답)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. 고친점 : 너무 어렵게 생각하고 있었음. 굳이 함수를 따로 생성하지 않고 hasNextLine()을 이용해 엔터를 치면서 게속해서 글을 작성하도록 변경 그 외 함수를 추가적으로 이용하였음. ArryList에 제네릭을 이용하여 String만 받기로 함. -함수-각 줄은 100글자를 넘지 않으며: word.length() &gt; 100 빈 줄은 주어지지 않는다: word.isEmpty() 각 줄은 공백으로 시작하지 않고: word.startsWith(“ “) 공백으로 끝나지 않는다: word.endsWith(“ “) 1234567891011121314151617181920212223242526272829303132333435import java.util.*; public class TEST01_07_ANS &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.startsWith(\" \") || word.endsWith(\" \") || word.length()&gt;100 || word.isEmpty()) &#123; break; &#125; array.add(word); &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); &#125; &#125; &#125; /*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break빈 줄은 주어지지 않는다: word.isEmpty()-&gt; 빈줄일경우 break각 줄은 공백으로 시작하지 않고: word.startsWith(\" \")-&gt; 첫글자가 공백 일경우 break공백으로 끝나지 않는다: word.endsWith(\" \")-&gt; 마지막 글자가 공백 일 경우 break */ 그대로 출력하기2* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄이 있을 수도 있다. * 각 줄은 공백으로 시작할수도 있고, 공백으로 끝날수도 있다. 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Scanner;public class TEST01_08 &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.length()&gt;100 ) &#123; break; &#125; if(word.equals(\"BYE\"))&#123; //BYE를 입력해서 WHILE 탈출 break; &#125; array.add(word); //현재 줄의 입력내용을 Array배열에 추가. &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); // 각 Array배열의 내용을 출력. &#125; &#125;&#125;/*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break*/","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"Algorithm & Quiz","slug":"TIL/Algorithm-Quiz","permalink":"https://hyeok999.github.io/categories/TIL/Algorithm-Quiz/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hyeok999.github.io/tags/JAVA/"},{"name":"algorithm","slug":"algorithm","permalink":"https://hyeok999.github.io/tags/algorithm/"},{"name":"BAEKJOON","slug":"BAEKJOON","permalink":"https://hyeok999.github.io/tags/BAEKJOON/"}]},{"title":"HEXO 설정","slug":"ETC-test","date":"2019-09-04T05:04:06.000Z","updated":"2019-12-19T12:10:17.861Z","comments":true,"path":"2019/09/04/ETC-test/","link":"","permalink":"https://hyeok999.github.io/2019/09/04/ETC-test/","excerpt":"","text":"2019/12/19일 기준 scaffolds 설정 12345678910111213141516171819202122232425262728293031323334title: &#123;&#123;title&#125;&#125;categories: - CSS - GIT - IT Event - Java - Javascript - Project - React - Tips - TIL - Algorithm &amp; Quiz - HTML&amp;CSS - Javascript - Javascript-Preview - React - React-Preview - linux - etctags: - git - Web - coding - develop - HTML - CSS - TIL - algorithm - javascript - React - Programmersdate: &#123;&#123;date&#125;&#125;thumbnail:-----------------------------------------------------------------------------------------------","categories":[{"name":"etc","slug":"etc","permalink":"https://hyeok999.github.io/categories/etc/"}],"tags":[{"name":"test","slug":"test","permalink":"https://hyeok999.github.io/tags/test/"},{"name":"hexo","slug":"hexo","permalink":"https://hyeok999.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-03T13:04:58.334Z","updated":"2019-09-03T13:08:10.424Z","comments":true,"path":"2019/09/03/hello-world/","link":"","permalink":"https://hyeok999.github.io/2019/09/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"20190903-personal-study-html","slug":"20190903-personal-study-html","date":"2019-09-03T12:54:57.000Z","updated":"2019-11-30T15:53:44.109Z","comments":true,"path":"2019/09/03/20190903-personal-study-html/","link":"","permalink":"https://hyeok999.github.io/2019/09/03/20190903-personal-study-html/","excerpt":"","text":"20190903-Test-web-page Study파일 구조 style.css1234567891011121314151617181920212223242526272829303132body&#123;overflow: hidden;&#125;.image&#123;position:relative;float: left;height: 200px;width:300px;margin : 2px;border: 1px solid white;z-index:0;&#125;.image-selected&#123; border: 1px solid black;background-color:white;&#125;.image-selected &gt; img&#123;opacity: 0.5;&#125;.image &gt; img&#123;height:100%;&#125;.image-magnified&#123;z-index:1;&#125;.image-magnified &gt; img&#123;height:400px;width:600px;margin-left:-150px;margin-top:-100px;opacity:0.95;&#125; image_list.json1234567891011121314[\"./images/1.jpg\",\"./images/2.jpg\",\"./images/3.jpg\",\"./images/4.jpg\",\"./images/5.jpg\",\"./images/6.jpg\",\"./images/7.jpg\",\"./images/8.jpg\",\"./images/9.jpg\",\"./images/10.jpg\",\"./images/11.jpg\",\"./images/12.jpg\"] index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;title&gt;Select the Gallery&lt;/title&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Show\" onclick=\"slideShow(this)\"&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; script.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var req = new XMLHttpRequest();req.open(\"GET\", \"./json/image_list.json\");req.onreadystatechange = function()&#123;if(this.readyState == 4)&#123;var data = JSON.parse(this.response);for(var i= 0; i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125;div.onmouseover = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000);&#125;div.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125;var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);&#125;&#125;&#125;req.send();function selectAll(btn)&#123;var img = document.getElementsByClassName(\"image\");for(var i=0; i&lt;img.length; i++)&#123;if(btn.value == \"UnSelect All\")&#123;img[i].classList.remove(\"image-selected\");&#125;else&#123;img[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"UnSelect All\")&#123;btn.value = \"Select All\";&#125;else&#123;btn.value = \"UnSelect All\";&#125;&#125;function slideShow(btn)&#123;var img = document.getElementsByClassName(\"image\");var index = 0;img[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;img[index].classList.remove(\"image-magnified\");index ++;if(index &lt; img.length)&#123;img[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝낫습니다.\");&#125;&#125;,1000);&#125; 프로젝트에 images 폴더 추가 프로젝트에 json 폴더 추가 프로젝트에 css 파일 추가 script 파일 생성 html 태그 안에 script 파일 및 css 파일 연결 1234&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt; script 파일 작성 시작 1 Ajax 사용하여 비동기방식으로 json 데이터를 요청하고 응답한 값을 가지고 것 임. 123456789101112131415161718192021222324252627var req = new XMLHttpRequest(); // 1. Ajax를 이용하기 위한 객체를 생성req.open(\"GET\",\"./json/image_list.json\"); // 2. 요청방식과 URL 설정// 3. onreadystatechange : 서버로부터 응답시 할 행동을 작성req.onreadystatechange = function()&#123; // 4. 4번 -&gt; 모든 응답이 제대로 받았을 겅우를 의미if(this.readyState == 4)&#123; // 5. 응답데이터(문자열)를 javascript 객체로 변환하고 div태그를 생성하여 데이터를 대입해줍니다.// div 태그의 속성은 class = \"image\" 로 설정합니다.var data = JSON.parse(this.response); for(var i=0;i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");// 6. img 태그를 생성하고 각 데이터를 img태그에 넣습니다. // img 태그는 div태그의 자손으로, div태그는 dody태그의 자손으로 삽입합니다.var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);//밑에서 추가 진행함&#125; &#125; &#125;req.send(); // 요청합니다. script 파일 작성 시작 2 생성된 div 태그에 기능을 추가합니다. 기능은 총 3가지입니다. 클릭 (onclick) 1234567891011121314// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성// 1. 생성된 태그에 클릭 이벤트를 넣어줍니다. // 선택 및 취소 했을 경우 스타일 달리지도록 만듭니다.// 선택시 image-selected , 미선택시 imagediv.setAttribute(\"class\",\"image\");div.onclick = function()&#123;if(this.getAttribute(\"class\").indexOf(\"image-selected\") == -1)&#123;this.setAttribute(\"class\",\"image image-selected\");&#125;else&#123;this.setAttribute(\"class\",\"image\");&#125;&#125; 위 문의 if문과 else 문은 classList 함수를 이용하여 짧게 가능.1234// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125; 마우스 오버 (onmouseover) 123456789// 2. 생성된 태그에 마우스오버 이벤트를 넣어줍니다.// div 위에 마우스가 올라갈 경우 시간만큼 스타일이 달라지도록 만듭니다.// 사용할 css style : image-magnifieddiv.onmouseove = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000); //1초&#125; 마우스 아웃 (onmouseout) 12345678// 3. 생성된 태그에 마우스아웃 이벤트를 넣어줍니다.// div 위에 마우스가 빠져나갈 경우 적용된 스타일을 제거하고 시간을 초기화 하도록 만듭니다.// 제거할 css style : image-magnifieddiv.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125; html 파일 안 태그 안에 2개의 버튼을 생성하고 click 이벤트를 연결합니다. 모두 선택 및 해제 기능 각 이미지가 1번씩 크게 보여지는 슬라이드 쇼 기능 123456&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Slidshow\" onclick=\"slideShow(this)\"&gt; &lt;!-- 사용될 함수에서 해당 button 객체의 value값을 이용하기 위해 인자로 this를 넘겨줍니다. --&gt;&lt;hr&gt; &lt;!-- 한줄 띄어줍니다. --&gt;&lt;/body&gt; script 파일 작성 : 모두 선택 기능 추가. 1234567891011121314151617function selectAll(btn)&#123;var images = document.getElementsByClassName(\"image\"); //div class명이 image입니다.for(var i=0; i&lt;images.length ; i++)&#123;if(btn.value == \"Unselect All\")&#123;images[i].classList.remove(\"image-selected\");&#125;else&#123;images[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"Unselect All\")&#123;btn.value = \"Selcet All\";&#125;else&#123;btn.value = \"Unselect All\";&#125;&#125; script 파일 작성 : 슬라이드쇼 기능 추가. 12345678910111213141516function slideShow(btn)&#123;var images = document.getElementsByClassName(\"image\");var index = 0;images[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;images[index].classList.remove(\"image-magnified\");index++;if(index &lt; images.length)&#123;images[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝났습니다.\");&#125;&#125;,1000);","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://hyeok999.github.io/tags/Web/"},{"name":"coding","slug":"coding","permalink":"https://hyeok999.github.io/tags/coding/"},{"name":"develop","slug":"develop","permalink":"https://hyeok999.github.io/tags/develop/"},{"name":"test","slug":"test","permalink":"https://hyeok999.github.io/tags/test/"}]},{"title":"20190902-study-terminal","slug":"20190902-study-terminal","date":"2019-09-02T12:52:11.000Z","updated":"2019-11-30T15:54:24.768Z","comments":true,"path":"2019/09/02/20190902-study-terminal/","link":"","permalink":"https://hyeok999.github.io/2019/09/02/20190902-study-terminal/","excerpt":"","text":"20190902-study-termianl 기본적인 리눅스 리눅스 : 커널 또는 GNU를 포함한 라오픈 라이브러리와 도구가 포함된 운영체제. 여러종류의 쉘을 제공함. Shell : 운영체제의 커널과 사용자를 이어주는 소프트웨어 CLI . ( Shell 사용할 경우 GUI보다 효율성이 높다. )Kenal : 컴퓨터와 소프트웨어를 이어 주는 시스템소프트웨어 터미널 리눅스(유닉스) 명령어 명령어 의미 예 ctr+c키 명령어 취소 ~ 접속시 나오는 폴더를 의미 ls 현재 폴더에서 접속가능한 폴더 리스트를 나열함. -a 숨긴파일도 표시 -l 파일의 추가정보를 나열하며 한줄씩 표시 cd Change Directory 의 약자. 폴더 이동 .. 상위 폴더를 의미 mkdir MaKe DIRectory 의 약자. 폴더 생성 mv {1} {2} MoVe의 약자.{1}을 {2}로 이동 mv {1} {2} (같은 위치에 있을경우) {1}을 {2}로 이름바꾸기 cp {1} {2} CoPy의 약자. {1}을 {2}로 이동 rm {1} ReMove의 약자. 파일을 삭제. rm -r {1} {1}이 폴더 일 경우. 폴더를 삭제. touch 파일 생성 ( 생성할때 파일명 앞에 . 을 붙이면 히든파일생성) chmod {권한} {폴더 및 파일} {폴더 및 파일}을 {권한}으로 권한 레벨 변경. chmod 555 study.html Vim 명령어 vi {1} : {1}을 vim으로 열기. (vim은 에디트)ext : 어떠한 모드에서 기본모드로 돌아감. 모드 3가지 ( 기본, I , : )기본 명령어 의미 예 Y 커서가 놓인 줄 복사 P 커서가 놓인 줄 아래에 붙여넣기 dd 커서가 놓인 줄 잘라내기 x 커서놓인 곳 한글자 삭제. i 커서가 놓은 곳 앞에 i 모드 돌입. o 커서가 놓인 줄 아래에 i 모드 돌입. O 커서 놓은 줄 위에 i 모드 돌입. Insert 편집 모드 ( key - i ) 명령어 의미 예 exc키 노멀모드로 돌아감. 명령어 모드 ( key - : ) 명령어 의미 예 q quit의 약자. vim 편집기를 나감. !q 저정하지않고 나감. wq 저장하면서 나감. exc키 가본 모드로 돌아감.","categories":[{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"https://hyeok999.github.io/categories/TIL/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hyeok999.github.io/tags/linux/"},{"name":"terminal","slug":"terminal","permalink":"https://hyeok999.github.io/tags/terminal/"},{"name":"OS","slug":"OS","permalink":"https://hyeok999.github.io/tags/OS/"},{"name":"TIL","slug":"TIL","permalink":"https://hyeok999.github.io/tags/TIL/"},{"name":"linux command","slug":"linux-command","permalink":"https://hyeok999.github.io/tags/linux-command/"}]}]}