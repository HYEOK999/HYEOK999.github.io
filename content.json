{"meta":{"title":"HYEOK999's Blog","subtitle":"HYEOK999's Daily Develop","description":null,"author":"Jun Hyeok Kim","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"javascript-study-03","slug":"javascript-study-03","date":"2019-10-04T13:49:35.000Z","updated":"2019-10-04T13:49:35.078Z","comments":true,"path":"2019/10/04/javascript-study-03/","link":"","permalink":"http://yoursite.com/2019/10/04/javascript-study-03/","excerpt":"","text":"","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"TIL","slug":"Develop/TIL","permalink":"http://yoursite.com/categories/Develop/TIL/"},{"name":"Algorithm","slug":"Develop/TIL/Algorithm","permalink":"http://yoursite.com/categories/Develop/TIL/Algorithm/"},{"name":"HTML","slug":"Develop/TIL/Algorithm/HTML","permalink":"http://yoursite.com/categories/Develop/TIL/Algorithm/HTML/"},{"name":"CSS","slug":"Develop/TIL/Algorithm/HTML/CSS","permalink":"http://yoursite.com/categories/Develop/TIL/Algorithm/HTML/CSS/"},{"name":"HTML&CSS","slug":"Develop/TIL/Algorithm/HTML/CSS/HTML-CSS","permalink":"http://yoursite.com/categories/Develop/TIL/Algorithm/HTML/CSS/HTML-CSS/"},{"name":"Javascript","slug":"Develop/TIL/Algorithm/HTML/CSS/HTML-CSS/Javascript","permalink":"http://yoursite.com/categories/Develop/TIL/Algorithm/HTML/CSS/HTML-CSS/Javascript/"},{"name":"Javascript-Preview","slug":"Develop/TIL/Algorithm/HTML/CSS/HTML-CSS/Javascript/Javascript-Preview","permalink":"http://yoursite.com/categories/Develop/TIL/Algorithm/HTML/CSS/HTML-CSS/Javascript/Javascript-Preview/"},{"name":"etc","slug":"Develop/TIL/Algorithm/HTML/CSS/HTML-CSS/Javascript/Javascript-Preview/etc","permalink":"http://yoursite.com/categories/Develop/TIL/Algorithm/HTML/CSS/HTML-CSS/Javascript/Javascript-Preview/etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"browser_operation","slug":"browser-operation","date":"2019-10-04T04:31:53.000Z","updated":"2019-10-04T04:34:03.235Z","comments":true,"path":"2019/10/04/browser-operation/","link":"","permalink":"http://yoursite.com/2019/10/04/browser-operation/","excerpt":"","text":"웹 브라우저의 동작 원리 클라이언트는 네이버에 접속을 시도한다. 네이버에 접속하기 위해서 인터넷 브라우저 주소창에 www.naver.com 을 입력한다. www.naver.com에 대한 IP 주소를 알기 위해서 DNS서버에 먼저 접속한 후DNS서버에게 www.naver.com에 해당되는 IP주소를 요청한다. DNS서버는 www.naver.com에 해당되는 IP주소를 응답한다. IP주소를 알게 된 브라우저는 다시 해당 IP주소를 통해서 네이버 서버에 접근하게 된다. 클라이언트는 서버에게 해당 페이지에 대한 접속과 .html 파일을 요청한다. 서버는 네이버 메인 페이지에 대한 화면 요소 정보가 담긴 index.html파일을 응답한다. 브라우저의 렌더링 엔진의 html파서는 index.html파일을 로드하고 파싱을 시작한다. 파싱중 &lt;link&gt; 를 만나게 된다. &lt;link&gt;에는 .css파일이 적혀있었다. html파서는 파싱을 중지한후 클라이언트는 다시 서버에게 .css파일을 요청한다. 서버는 .css파일을 응답한다. 클라이언트의 렌더링 엔진의 html파서는 제어권을 css파서에게 넘겨준다. css파서는 .css파일을 로드하고 파싱을 시작한다. 파싱이 완료되고 CSSOM트리가 완성된다. css파서는 제어권을 다시 html파서에게 넘겨준다. 중지되었던 html 파싱을 재 시작한다. 파싱하던중 &lt;script&gt; 를 만나게 된다. &lt;script&gt;에는 .js파일이 적혀있었다. html파서는 파싱을 중지한 후 클라이언트는 다시 서버에게 .js 파일을 요청한다. 서버는 .js파일을 응답한다. html파서는 .js파일을 읽을 수 없기 때문에 제어권을 브라우저에 탑재된 자바스크립트 엔진에게 넘겨준다. 제어권을 넘겨받은 자바스크립트 엔진은 DOM api를 이용하여 .js파일을 로드한다. 로드된 .js파일을 토크나이즈 하여 소스코드를 어휘분석하여 의미를 갖는 최소단위인 토큰으로 분리한다. 분리된 토큰을 구문분석하여 문법의 의미와 구조를 반영한 트리인 AST를 생성한다. AST는 자바스크립트 엔진의 인터프리터가 읽을 수 없기 때문에 인터프리터가 실행할 수 있는 중간코드인 바이트코드로 변환되고 실행된다. 실행된 후 제어권을 다시 렌더링엔진의 html파서에게 전달한다. 제어권을 돌려받은 html파서는 중지되었던 파싱을 재 실행한다. 파싱이 완료되어 DOM트리가 형성된다. 전에 만들어진 CSSOM트리와 DOM트리를 합쳐 RENDER트리로 만든다. RENDER트리를 기반으로 클라이언트의 화면에 표출한다.","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Javascript","slug":"Develop/Javascript","permalink":"http://yoursite.com/categories/Develop/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm04","slug":"daily-algorithm04","date":"2019-10-03T13:38:45.000Z","updated":"2019-10-03T13:39:12.429Z","comments":true,"path":"2019/10/03/daily-algorithm04/","link":"","permalink":"http://yoursite.com/2019/10/03/daily-algorithm04/","excerpt":"","text":"문제 출저 : 프로그래머스 완주하지 못한 선수문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 입출력 예 설명예제 #1leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 1234567891011121314151617181920212223function solution(participant, completion) &#123; var answer = ''; var completion_array = []; completion_array = completion; var num = 0; for(var i=0;i&lt;participant.length;i++)&#123; for(var j=0;j&lt;completion_array.length;j++)&#123; if(participant[i] == completion_array[j])&#123; completion_array[j] = null; num = 0; break; &#125; num = 1; &#125; if(num == 1)&#123; answer = participant[i]; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-0506","slug":"javascript-preview-0506","date":"2019-10-03T06:46:38.000Z","updated":"2019-10-03T12:32:27.954Z","comments":true,"path":"2019/10/03/javascript-preview-0506/","link":"","permalink":"http://yoursite.com/2019/10/03/javascript-preview-0506/","excerpt":"","text":"JacaScript 5강~6강 예습 5강 : 데이터 타입 데이터 타입이란? 메모리 공간 확보 데이터 타입이 필요한 이유 값 값의 생성 데이터 타입의 분류(종류) 동적 타이밍 6강 : 연산자 표현식 과 연산자 문 문 vs 표현식 표현식인 문 vs 표현식이 아닌 문 완료값 연산자 산술연산자 문자열 연결 연산자 할당연산자 비교연산자 대소 관계 연산자 삼항 조건 연산자 논리 연산자 쉼표 연산자 typeof 연산자 지수 연산자 5강데이터타입 데이터타입 이란? 값의 종류를 의미하며, 자바스크립트의 모든 값은 데이터 타입을 지닌다. 메모리 공간 확보​ 자바스크립트 엔진은 데이터타입, 즉 값의 종류에 따라 적절한 크기의 메모리 공간을 지닌다. 예를들면 다음과 같다. ( 데이터타입에 따라 확보되는 메모리공간의 크기는 브라우저 제조사마다 다를 수 있다. ) 12var score = 100;// 위와 같이 숫자를 입력할 경우 자바스크립트 엔진은 데이터타입을 숫자로 인식하고 메모리 공간을 8byte 내주게된다. 데이터 타입이 필요한 이유 값을 저장할 떄 필요한 메모리 공간의 크기를 결정하기 위함 값을 참조할 떄 한번에 읽어들일 메모리 공간의 크기를 결정하기 위함 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위함 값 더 이상 평가할 수 없는 하나의 표현식 실제 메모리 공간에 저장되는 최소 단위 1210 + 20 // 10 + 20은 표현식이고 이로 인해 나온 결과 30은 더이상 평가할 수 없는 값이다. 값의 생성 리터럴 표기법 표현식으로 생성. 리터럴 소스 코드 내에서 직접 만들어 낸 고정된 값 자체. 사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령 리터럴 - 정수 리터럴 / 부동 소숫점 리터럴 100 / 10.5 2진수(0b) / 8진수 리터럴(ES 6도입, 0o) / 16진수 리터럴(ES 6도입, 0x) 0b01000001 / 0o101 / 0x41 문자열 리터럴 ‘Hello’ , “World” 불리언 리터럴 true , false null 리터럴 / undefined 리터럴 null / undefined 정규표현식 리터럴 ab+c 객체 리터럴 { name: ‘Lee’, age : 20 } 배열 리터럴 [ 1, 2, 3 ] 함수 리털럴 function( ){ } 표현식 값을 생성하는 다양한 방법 리터럴, 식별자(변수 혹은 함수 등), 연산자, 함수 호출등의 조합 하나의 값으로 평가될 수 있는 문(식) 1234567891011121314151617// 리터럴 표현식10'Hello'// 식별자 표현식(선언이 이미 존재한다고 가정)sumperson.namearr[1]// 연산자 표현식10 + 20sum = 10sum !== 10// 함수/메소드 호출 표현식(선언이 이미 존재한다고 가정)square()person.getName() 데이터 타입의 분류(종류) 원시타입 숫자(number) 타입: 숫자 (정수, 실수) 문자열(string) 타입: 문자열 불리언(boolean) 타입: 논리적 참(true)과 거짓(false) undefined 타입: 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입: ES6에서 새롭게 추가된 7번째 타입 객체 타입 / 참조 타입(object/reference type): 객체, 함수, 배열 등 숫자(number) 타입 자바스크립트는 Java , C처럼 정밀하게 숫자들을 나눠 놓은 형식은 없다. 모든 숫자들은 실수로 처리를 하여 표현한다. ( 정수만을 위한 특별한 타입은 존재하지 않는다. ) 모든 숫자(정수, 실수, 음의정수, 2진수, 8진, 16진수)는 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 2진수, 8진수, 16진수를 별도로 제공을 안하기 때문에 이 값들을 참조하면 모두 10진수로 해석한다. 1234// 숫자 타입은 모두 실수로 처리된다.console.log(1 === 1.0); // trueconsole.log(4 / 2); // 2console.log(3 / 2); // 1.5 + 추가로숫자 타입은 3가지 특별한 값들도 표현이 가능하다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not a number) 1234567// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN//+ 자바스크립트는 대소문자 구별을 하기에 NaN을 NAN, nan, Nan등으로 적으면 에러가 발생한다.var x = nan; // ReferenceError: nan is not defined 문자열 타입 텍스트 데이터를 나타내는데 사용한다. 16bit 유니코드 문자들의 집합으로 전세계 대부분의 문자가 표현이 가능하다. 작은 따옴표(‘’), 큰따옴표(“”), 백틱(`) 안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 이용한다. 문자열은 원시타입이며 변경 불가능한 값이다. 문자열은 한번 생성되면, 그 문자열은 변경할 수 없다는 것을 의미한다. 템플릿 리터럴 ES6 생긴 새로운 무자열 표기법. 백틱 문자 ` 를 사용한다. 특징1 : 일반적인 문자열에서는 줄바꿈이 허용되 않는다. 공백을 표현하기 위해서는 \\로 시작하는 이스케이프 시퀀스를 이용해야만하는데 템플릿 리터럴은 여러줄에 걸쳐 문자열을 작성시 공백을 있는 그대로 출력해준다. 12345678onst template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;console.log(template); 특징2 : 문자열은 문자열 연산자를 사용해 연결한다. 하지만 템플릿 리터럴은 연산자 없이도 문자열 삽입기능을 제공 하며 이를 문자열 인터폴레이션 이라 한다. $ { 표현식 } : 이에 대한 평가 결과는 강제로 문자열이 된다 12345678910// 기본적인 문자열 연산자를 이용한 문자열 연결console.log('나이는 : ' + 25 + '살 입니다.' );//문자열 인터폴레이션var age = \"나이는\";var num = 25;console.log('$&#123;age&#125; $&#123;num&#125; 살 입니다.');console.log(`1 + 1 = $&#123;1 + 1&#125;`); // 1 + 1 = 2 강제 문자열 불리언 타입 불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다. undefined 타입 선언은 되어있지만 아직 값을 할당하지 않는 변수에 접근할 경우 undefined가 반환된다. 이는 자바스크립트 엔진의 암묵적 초기화에 의한 것이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 ‘할당된 적인 없는 변수라는 것’ 을 개발자는 간파가 가능하다. 개발자가 의도적으로 변수에 undefined를 할당한다면 혼란을 줄 수 있으므로 권장하지 않는다. 자바스크립트의 정의와 선언의 차이 자바스크립트에서 선언은 식별자가 생성되었지만 값이 아직 할당되지 않은 상태를 말한다. 자바스크립트에서 정의는 식별자가 생성되었고 값까지 할당되어 있는 상태를 의미한다. 123456// 변수 선언. 내부적으로 undefined로 정의된다.var foo;// 변수 선언과 정의var bar = 1;// 함수 정의. 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.function baz &#123; &#125; null 타입 변수에 값이 없다는 것을 의도적으로 명시 할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미. 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 Null, NULL등과 다르다. (반드시 null로 써야한다.) 123456&lt;script&gt; var element = document.querySelector('.myElem'); // HTML 문서에 myElem 클래스를 갖는 요소가 없다면 null을 반환한다. console.log(element); // null &lt;/script&gt; document.querySelector 메소드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우, 에러 대신 null을 반환. 변수에 null을 할당하게 되면, 이는 더 이상 해당 변수의 값을 참조하지 않겠다는 것을 의미. 따라서 자바스크립트 엔진은 누구도 참조하지 않는 해당 변수의 메모리공간에 대해서 가비지 콜렉션을 수행할 것이다. symbol 타입 ES6에서 새롭게 추가된 7번째 타입. 변경 불가능한 원시 타입의 값. 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위함 사용방법 : Symbol 함수를 호출해 사용한다. 12345678910111213/// 심볼 값 생성var key = Symbol('key');console.log(typeof key); // symbol// 객체 생성var obj = &#123;&#125;;// 심볼 key를 이름의 충돌 위험이 없는 유일한 프로퍼티 키로 사용한다.obj[key] = 'value';console.log(obj[key]); // valueobj[\"key\"] = \"value\";console.log(obj); 똑같은 key : value라는 이름의 키와 값을 객체에 넣었는데 전혀 충돌이 나지 않고있다. 또한 Object.keys(obj) 를 찍어보면 Symbol은 나타나지 않고 일반적인 키와 값만 출력한다. 객체 타입 자바스크립트의 6가지 데이터 타입 이외에 모든 것은 전부 객체 타입이다. 객체타입은 추후에 마져 공부한다. 동적 타이밍 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 12345678// JAVA , C의 경우. int라는 키워드를 통해 이미 정수라는 타입이 결정되었음.int a;// javascript , var때문이 아닌 값이 5 라는것을 통해 숫자 타입이라는 것을 알게됨. var a = 5;// + 추가로 javascript는 언제든지 동적으로 값에 의해 변수의 타입이 변할수있다.var a = \"hello world\"; // a는 숫자 타입에서 \"hello world\" 라는 문자열 타입으로 변경되었다. 이러한 편리한 구조속에 동적 타이밍은 다음과 같은 단점을 지니고있다. 동적으로 변화하는 데이터 타입을 추척하기 어려울 수 있다. (즉, 확인하기 전까지는 데이터 타입의 값을 확신하기 힘들다.) 동적 타입 언어는 유연성(flexibility)은 높지만, 신뢰성(reliability)이 떨어진다. 따라 안정적인 프로그램 개발을 위해서는 데이터 타입을 체크해야하는 경우가 있는데 이러한 방식은 코드량의 증가를 야기한다. 코드량의 증가는 결국 버그발생률을 높이게 되며, 테스트 분량 또한 증가시킨다. 따라서 다음과 같은 변수 사용 주의사항이 있다. 변수 사용 주의사항 변수의 사용을 적극적으로 줄인다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 전역 변수는 사용하지 않는다. 변수의 생명주기를 최대한 짧게 만든다. 변수보다는 상수를 사용해 값의 변경을 억제한다. 변수 이름은 변수의 존재 이유를 파악할 수 있도록 명명한다. 6강표현식과 연산자 표현식이란? 리터럴 , 식별자(변수 혹은 함수의 이름) , 연산자, 함수호출등의 조합 표현식은 평가되어 하나의 값을 만든다. 12var x = 10;x + 30; // 40 위 예제에서 x+30이 표현식이다. + 연사자는 좌항과 우항의 값을 연산하는 연산자이고 좌항과 우항에는 숫자값이 위치해야한다. 우항은 30이라는 리터럴 표현식 이 좌항에는 x라는 식별자 표현식이 와있고 이 두개의 조합으로이해 40이라는 값을 낼수있다. 문(statement) 문이란? 하나 이상의 표현식과 키워드 조합으로 구서된 자바스크립트 엔진에게 내리는 명령 문의 집합으로 이루어진 것이 프로그램이며 문을 작성하고 나열하는 것이 프로그래밍이다. 문은 코드블록( {내용} )을 제외하고는 ; 으로 끝나야만 한다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식은 그 자체로 문이 될수도 있지만, 반대로 문은 표현식이 될수는 없다. 문 vs 표현식표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. 문은 선언문과 같이 var, let, const, function, class와 같은 선언 키워드를 사용하여 변수나 함수, 클래스를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다. 결론적으로, 표현식의 역할은 값을 생성하는 것. 문의 역할은 표현식으로 생성한 값을 사용해 JS엔진에게 명령을 내리는 것. 표현식인 문 / 표현식이 아닌 문 표현식인 문은 값으로 평가가 가능하다. 표현식이 아닌 문은 값으로 평가가 불가능하다. 12var x; // 변수 선언문. -&gt; 값으로 평가가 불가능하다.x = 300; // 할당문. x는 300이라는 값으로 평가가 가능하다. 완료값 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라 한다. 완료 값은 다른 값과 같이 변수에 할당할 수 없다. 연산자 연산자란? 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입연산등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자라 칭한다. 산술 연산자 피연산자를 대상으로 수학적 계산을 하여 새로운 숫자 값을 만든다. 연산이 불가능할 경우에는 NaN을 출력한다. 부수효과 : 피연산자의 값은 변경하는 것. 이항 산술 연산자 ( ex - var a = 1+2; ) : 피연산자끼리 계산을 하여 새로운 값을 만든다. 이항 산술 연산자 의미 부수 효과 + 덧셈 X - 뺄셈 X * 곱셈 X / 나눗셈 X % 나머지 X 단항 산술 연산자 ( ex - var a = 0; a++; ) 단항 산술 연산자 의미 부수 효과 ++ 증가 O – 감소 O + 숫자 타입이 아닌 피연산자를 숫자타입으로 변환. X - 양수를 음수로 음수를 양수로 반전화 시킨다. X 단항 산술 연산자의 ++ , –는 어느 위치냐에 따라 피연산자에 대한 값의 증가 및 감소처리의 로직이 달라질수 있다. 1234567891011121314151617var x = 5, result;// 선할당 후증가 (Postfix increment operator)result = x++;console.log(result, x); // 5 6// 선증가 후할당 (Prefix increment operator)result = ++x;console.log(result, x); // 7 7// 선할당 후감소 (Postfix decrement operator)result = x--;console.log(result, x); // 7 6// 선감소 후할당 (Prefix decrement operator)result = --x;console.log(result, x); // 5 5 + 단항 연산자는 숫자 타입의 피연산자에게 어떠한 영향도 주지 않는다. 숫자타입이 아닌 피연산자에게 적용시 강제로 숫자타입으로 반환 해준다. 1234567891011// 문자열을 숫자로 타입 변환한다.+'10'; // -&gt; 10// 불리언 값을 숫자로 타입 변환한다.+true; // -&gt; 1// 불리언 값을 숫자로 타입 변환한다.+false; // -&gt; 0// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.+'Hello'; // -&gt; NaN - 단항 연산자는 양수의 숫자타입을 음수로 바꾸거나, + 단항 연사자처럼 숫자타입이 아닌 피연사자를 강제로 음수 숫자타입으로 바꾸어 반환해준다. 1234567891011// 부호를 반전한다.-(-10); // -&gt; 10// 문자열을 숫자로 타입 변환한다.-'10'; // -&gt; -10// 불리언 값을 숫자로 타입 변환한다.-true; // -&gt; -1// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.-'Hello'; // -&gt; NaN 문자열 연결 연산자 + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 1234561 + 2 // 3'1' + 2 // '12'1 + true // 2 true : 11 + false // 1 false : 01 + null // 1 null : 01 + undefined // NaN : undefined 는 숫자로 타입 변환되지 않는다. true / false / null 등은 강제로 숫자타입으로 변환 후 연산을 실행한 것을 알 수 있다. 이를 암묵적 타입 변환 혹은 타입 강제 변환이라고 한다. 할당 연산자 할당 연산자 예 동일 표현 부수 효과 = x = 5 x = 5 O += x += 5 x = x + 5 O -= x -= 5 x = x - 5 O *= x *= 5 x = x * 5 O /= x /= 5 x = x / 5 O %= x %= 5 x = x % 5 O 물론 문자열도 할당 연산자를 적용시킬 수 있다. 123456var str = 'My name is ';// 문자열 연결 연산자str += 'Lee'; // str = str + 'Lee';console.log(str); // 'My name is Lee' 비교 연산자비교연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 boolean 값으로 반환한다. 비교연산자 의미 사례 설명 부수효과 == 동등 비교 x == y x와 y의 값이 같다. X === 일치 비교 x === y x와 y의 값과 타입이 같다. X != 부동등 비교 x != y x와 y의 값이 다르다. X !== 불일치 비교 x !== y x와 y의 값과 타입이 다르다. X 동등 비교와 부동등 비교의 경우 피연산자끼리 비교할 떄, 타입이 다른 경우 암묵적인 타입 변환을 통해 타입을 일치 시킨 후에 값이 같은지 비교를 한다. 따라서 타입이 다른 경우에도 true를 반환 할 수 도 있다. 반면에 일치비교와 불일치비교는 타입 과 값이 모두 비교를 하기에 좀 더 예측하기가 쉽다. 일치비교의 주의점 : NaN === NaN // false : NaN은 자신과 일치하지 않은 유일한 값 NaN을 조사할 때에는 빌트인 함수 inNaN을 사용해야한다. 123isNaN(NaN); // trueisNaN(10); // falseisNaN(10 + undefined); // true 대소 관계 비교 연산자조건문 이나 반복문에서 자주 사용되는 연산자로 boolean 값을 반환한다. 12345// 대소 관계 비교5 &gt; 0; // -&gt; true5 &gt; 5; // -&gt; false5 &gt;= 5; // -&gt; true5 &lt;= 5; // -&gt; true 삼항 조건 연산자삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 자바스크립트의 유일한 삼항 연산자이며 부수효과는 없다. 마치 조건문을 짧게 줄여놓은 형식이다. 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일 때 반환할 값 ? 앞에 나오는 조건식은 불리언 타입의 값으로 평가가 된다. (즉 (ture)1인지 (false)0인지 본다는 뜻 ) 만약 조건식 평가 결과가 불리언 값이 아니라면 불리언 값으로 암묵적 타입 변환을 실행한다. 123456var x = 2;// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 논리 연산자 논리 연산자는 항상 불리언 값을 반환한다. 피연산자는 불리언 타입으로 암묵적 타입 변환을 한다. 논리 연산자 의미 부수효과 || 논리합( OR ) X &amp;&amp; 논리곱( AND ) X ! 부정( NOT ) X &lt;주의&gt; 논리합 연산자( || ) 와 논리곱 연산자( &amp;&amp; ) 의 결과가 항상 불리언 값이 아닐수도 있다. 12// 단축 평가'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' 쉼표 연산자 쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. 12var x, y, z;x = 1, y = 2, z = 3; // 3 typeof 연산자 typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. 종류는 총 7개다 string number boolean undefined symbol object function 123456789101112typeof '' // -&gt; \"string\"typeof 1 // -&gt; \"number\"typeof NaN // -&gt; \"number\"typeof true // -&gt; \"boolean\"typeof undefined // -&gt; \"undefined\"typeof Symbol() // -&gt; \"symbol\"typeof null // -&gt; \"object\"typeof [] // -&gt; \"object\"typeof &#123;&#125; // -&gt; \"object\"typeof new Date() // -&gt; \"object\"typeof /test/gi // -&gt; \"object\"typeof function () &#123;&#125; // -&gt; \"function\" 주의점 NaN은 number로 반환한다. null값을 object로 반환한다. ( JavaScript의 첫 버그 ) 2번째 주의점인 null 타입 확인은 typeof 대신에 일치연산자 ( === ) 을 사용한다. 1234var foo = null;typeof foo === null; // -&gt; falsefoo === null; // -&gt; true 지수연산자 ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 지수 연산자가 도입 전에는 Math.pow 함수를 이용하였다. 지수연산자 Math.pow(a,b) 5 ** 2 ; //25 Math.pow(5, 2); //25 5 ** 2.5; // 55.901699~ Math.pow(5, 2.5); // 55.901699~ 5 ** 0 // 1 Math.pow(5, 0); // 1 5 ** -2 // 0.04 Math.pow(5, -2); // 0.04 음수를 거듭제곱의 밑으로 계산하려면 괄호로 묶어야 한다. 123-5 ** 2;// -&gt; SyntaxError(-5) ** 2; // -&gt; 25 지수 연산자는 할당 연산자와 함께 이용이 가능하며, 모든 이항 연산자보다 우선순위가 높다. 123456// 할당 연산자와 함께 사용이 가능하다.var num = 5;num **= 2; // -&gt; 25// num ** 2를 행한 값과 * 4를 한다.4 * num ** 2; // -&gt; 100","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-preview-0304","slug":"javascript-preview-0304","date":"2019-10-02T19:23:49.000Z","updated":"2019-10-03T06:45:54.257Z","comments":true,"path":"2019/10/03/javascript-preview-0304/","link":"","permalink":"http://yoursite.com/2019/10/03/javascript-preview-0304/","excerpt":"","text":"JacaScript 3강~4강 예습 3강 : 자바스크립트 개발 환경과 실행 방법 자바스크립트 실행 환경 웹브라우저의 동작 방식 script 코드를 하단에 두어야 하는 이유 DOM이란? 4강 : 변수 변수란? 식별자 변수선언 변수 선언의 실행 시점과 변수 호스팅 값의 할당 값의 재할당 값의 교환 식별자 네이밍 규칙 자바스크립트 실행 환경 모든 브라우저는 자바스크립트을 실행하고 해석하기 위해서 자바스크립트 엔진을 내장하고 있다. 브라우저뿐만 아니라 Node.js도 자바스크립트 엔진을 내장하고 있다. 따라서 브라우저와 Node.js 둘다 자바스크립트의 코어인 ECMAScript를 실행할수는 있지만, ECMAScript 이외에 추가적인 기능은 호환되지 않는다. 브라우저에서의 자바스크립트 실행 환경 Node.js DOM API를 지원. File 시스템 (create / delete / read / update)를 지원. 클라이언트 사이드 Web API + ECMAScript Node.js 고유 API + ECMAScript 웹 어플리케이션의 자바스크립트는 사용자 컴퓨터의 브라우저에서 동작한다.(보안상 이유: Web API에서는 File 시스템을 미제공) 웹 어플리케이션의 자바스크립트는 브라우저에서 HTML,CSS와 함꼐 실행된다. 웹 브라우저의 동작 방식브라우저의 핵심 기능 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리하며, HTML파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해서 DOM 생성 프로세서를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 컴파일러 인터프리터 컴파일 타임에 소스 코드 전체를 한번에 CPU가 바로 실행할 수 기계어)로 변환한 후 실행한다. 런타임에 문 단위로 한 줄씩 중간 코드인 바이트 코드 특정한 하드웨어가 아니라 가상 머신에서 실행하도록 만든 바이너리 코드)로 변환한 후 실행한다. 실행 파일을 생성한다. 실행 파일을 생성하지 않는다. 컴파일 단계와 실행 단계가 분리되어 있다. 명시적인 컴파일 단계를 거쳐서 명시적으로 실행 파일을 실행한다. 인터프리트 단계와 실행 단계가 분리되어 있지 않다. 인터프리터는 한 줄씩 바이트 코드로 변환하고 즉시 실행한다. 실행에 앞서 컴파일은 단 한번 수행된다. 코드가 실행될 때마다 인터프리트 과정이 반복 수행된다. 컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠르다. 인터프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다. 토크나이징(Tokenizing) 단순한 문자열인 소스 코드를 어휘 분석(Lexical analysis)하여 의미를 갖는 코드의 최소 단위인 토큰(Token)들로 분리. 파싱(Parsing) 토큰들의 집합을 구문 분석(Syntactic analysis)하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성 AST는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료 구조 코드 실행 생성된 AST는 인터프리터가 실행할 수 있는 바이트 코드(bytecode)로 변환되고 인터프리터에 의해 실행. 결론 JS 소스 코드 + 어휘 분석 + 최소단위로 나누어 토큰으로 만듬 : 토크나이즈 토큰 + 구문분석 = 토큰에 문법적 의미 및 구조 반역 = AST 생성 : 파싱 AST를 인터프리터가 실행하도록 바이트코드로 변환하여 실행. script 코드를 하단에 두어야 하는 이유 HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다. DOM이란? Document Object Model (문서 객체 모델)- HTML, XML 문서의 프로그래밍 interface 로컬에서 작성된 코드가 브라우저에 의해 파싱되면 DOM으로 변환. JavaScript는 브라우저가 읽고 어떤 작업을 할 수 있는 언어이고 DOM은 이 작업이 이루어지는 장소이다. 어떠한 요소에 click이벤트가 일어나는지 감시하도록 JavaScript을 사용한 기능이 구현됬다. 하지만 이 요소는 DOM 노드이다. 여기서 DOM에 있는 property를 통해서 listener를 붙여 놓은 것 뿐임. DOM은 HTML요소이고, DOM API는 JavaScript에서 HTML에 DOM요소를 다루기 위한 JavaScript의 기본 함수. Node.js 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경. NPM node package manager의 약자. 자바스크립트 패키지 매니저이다. Node.js에서 사용할 수 있는 모듈들을 패키지화 하여 모아둔 장소 역할 과 패키지 설치 및 관리를 위한 CLI를 제공. 변수란? 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 / 또는 메모리 공간 자체. 데이터를 관리하기 위한 핵심 개념. 배열 혹은 객체와 같은 자료구조를 이용하면 하나의 변수에 여러개의 값을 그룹화하여 사용이 가능하다. 12345678910111213var userName = 'Lee';var userRole = 'Admin';// 객체나 배열과 같은 자료 구조를 사용하면 여러 개의 값을 하나로 그룹화하여 하나의 값처럼 사용할 수 있다.var user = &#123; name: 'Lee', role: 'Admin'&#125;;var users = [ &#123; name: 'Lee', role: 'Admin' &#125;, &#123; name: 'Kim', role: 'Developer' &#125;]; 변수에 값을 저장하는 행동 : 할당 변수에 저장된 값을 읽는 행동 : 참조 식별자 어떤 값을 구별하여 식별해낼 수 있는 이름 메모리 상에 존재하는 어떤 값을 구별하여 식별해낼 수 있어야 한다. 변수 , 함수 , 클래스등의 이름과 같은 식별자는 네이밍 규칙을 준수 해야만 한다. 선언에 의하여 자바스크립트 엔진에 식별자의 존재를 알린다. 변수 선언 변수 이름을 자바스크립트 엔진에 알려 등록하고 변수 값을 저장하기 위한 메모리 영역의 확보를 명령하는것. ( - 즉, 변수를 생성하는 것) 변수는 선언과 동시에 특정 값으로 초기화를 안하면 undefined라는 값이 암묵적으로 할당되어 초기화가 된다. 변수를 사용하려면 반드시 선언이 필요하다. 만약 선언 없이 변수(식별자)에 접근하면 ReferenceError가 발생한다. (이는 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 참조 에러다.) ES5 VS ES6 의 변수 선언 차이점 ES5의 변수 선언 키워드 ES6의 변수 선언 키워드 var let , const 123456// var 키워드의 최대 단점 : 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다.var a; //undefineda = 10;for(var a=0;a&lt;5;a++)&#123;&#125;console.log(a); 위는 var 키워드의 단점을 설명해주는 가장 큰 예이다. a의 결과값은 10이 아닌 5이다. 이유는 for는 { } 밖에 존재하기 때문이다. 실행 컨텍스트 자바스크립트 엔진이 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. 모든 식별자는 실행 컨텍스트에 등록된다. 자바스크립트는 실행 컨텏스트를 통해 식별자와 스코프를 관리한다. 실행 컨텍스트 내에 KEY / VALUE 형씩인 객체로 등록되어 관리된다. 변수 선언의 실행 시점과 변수 호이스팅 변수 선언은 소스 코드가 순차적으로 실해되는 시점에서 실해되 않는다. 구문 분석 단계에서 먼저 실행된다. 따라서 아래와 같은 코드가 참조 에러가 안나는것이다. 12console.log(score); // undefinedvar score; // 변수 선언(변수 선언문) 변수호이스팅 자바스크립트는 변수 선언문을 코드의 선두로 끌어 올려진 것처럼 동작하게 보인다. 이와 같은 고유의 특징을 변수 호이스팅이라고 한다. 추가로 사실 호이스팅은 변수 선언 뿐만이 아니라 var, let, const, function, function*, class 키워드를 사용하여 선언된 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. 모든 선언문은 런타임 이전인 구문 분석 단계에 먼저 실행되기 때문이다. 값의 할당 변수에 값을 할당할 때는 할당 연산자(=) 을 사용한다. ( 우변의 값을 좌변에 ) 변수 선언과 동시에 값을 할당하는 따로 선언후 구문을 나눠서 할당을 하든, 자바스크립트는 런타임 이전에 변수선언을 실행하고, 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다. 변수에 값을 할당 할 때 undefined가 적혀진 메모리 공간을 지우고 그곳에 값을 다시 저장하는게 아니라 새로운 메모리 공간을 확보하고 확보된 공간에 값을 할당한다. 123456console.log(score); // undefinedscore = 80; // 값의 할당var score; // 변수 선언console.log(score); // ?? 결과는 undefined / 80 이 출력된다. 이유 : var score는 구문 분석때 실행되어 undefined로 메모리 공간에 저장이 되어서 첫 score 값에 undefined 값이 저장이 되고 그 후 score는 80이라는 값이 할당이 되어 새로운 메모리 영역에 공간이 할당되고 80이라는 값이 저장된다. 따라서 2번째 값은 80이다. 값의 재할당 var 키워드로 선언한 변수는 값을 재할당이 가능하다. 재할당이 불가능한 식별자를 만들고 싶다면 const키워드를 이용한다. (즉 상수) 재할당이 끝나면 그 전에 할당되었던 값들은 필요가 없어진다. 이러한 쓰레기값들은 Garbage Collector에 의하여 메모리에서 자동 해제된다. 값의 교환123456789var x = 1;var y = 2;// do somethigvar temp = x;x = y;y = temp;console.log(x, y); // 2 1 식별자 네이밍 규칙 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러기호( $ ) 를 포함할 수 있다. 식별자는 문자 , underscore( _ ) , 달러기호( $ ) 로 시작해야 한다. 숫자 및 특수문자로 시작할 수 없다. 예약어는 식별자의 네이밍으로 사용이 불가능하다. 대소문자를 구별한다. (var firstName , Fristname, FIRSTNAME; // 모두 각각 다른 변수 ) 예약어 await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* Switch this throw true try typeof var void while with yield* 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다. 좋은 변수 이름은 코드의 가독성이 높인다. 하나 이상의 영어 단어로 구성된 식별자를 네이밍할때는 아래와 같은 네이밍 컨벤션을 이용한다. 123456789101112// 카멜 케이스 (camelCase)var firstName;// 스네이크 케이스 (snake_case)var first_name;// 파스칼 케이스 (PascalCase)var FirstName;// 헝가리언 케이스 (typeHungarianCase)var strFirstName; // type + identifiervar $elem = $('.myClass'); // jQuery 가장 일반적인 것 : 코드 전체의 가독성을 높이기 위해서 2가지 네이밍 컨벤션이 많이 쓰이고 있다. 변수명 / 함수명 -&gt; 카멜케이스 생성자 함수명 / 클래스명 -&gt; 파스칼케이스 ECMAScript 사양에 정의된 표준 객체(String, Number 등등)와 전역 함수들도 카멜케이스와 파스칼 케이스 네이밍 컨벤션이 사용되고 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript-Preview","slug":"TIL/Javascript-Preview","permalink":"http://yoursite.com/categories/TIL/Javascript-Preview/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-02","slug":"javascript-study-02","date":"2019-10-02T19:19:54.000Z","updated":"2019-10-02T19:20:49.334Z","comments":true,"path":"2019/10/03/javascript-study-02/","link":"","permalink":"http://yoursite.com/2019/10/03/javascript-study-02/","excerpt":"","text":"JavaScript Study 02 자바스크립트 특징 자바스크립트 엔진 자바스크립트 실행환경 웹 브라우저는 어떻게 동작하는가? 브라우저의 핵심 역할 서버의 핵심 역할 ESLint 자바스크립트 특징 웹 브라우저에서 동작하는 유일한 프로그래밍 언어 프로토타입 기반의 객체 지향 언어 ( 다른 언어에서 함수는 구문이지만 JS는 값) 값은 주고 받을 수가 있다. (함수형 프로그래밍) JS 는 절차지향(명령형), 객체지향, 함수형이 모두 가능한 멀티 패러다임 프로그래밍 언어 자바스크립트 엔진자바스크립트를 실행할 수 있는 환경으로 브라우저에 내장되어있다. 내부적으로 사용율이 높은 것은 컴파일을 하는 특징을 지니고 있으며 인터프리터와 컴파일러를 결합해서 작동한다. 현재 IE를 제외한 대부분의 브라우저는 ES6 까지 지원이 되고있다. (자바스크립트는 인터프리터언어라고는 하지만 그 기준이 위와 같은 잣대로 인해 모호해지고 있다.) 자바스크립트 실행환경&lt;head&gt; 안에는 기본적으로 &lt;meta ~ &gt;가 들어간다 시멘틱 문법상 &lt;head&gt;는 눈에 보이지 않는 데이터들을 모아놓은 집합이다. 따라서 script파일은 &lt;haed&gt;안에 들어가야 맞다. 하지만 인터프리터는 위에서 한줄 할줄 읽는다. 만약 script 가 head에 들어갈 경우 script에 정의된 변수나 객체들이 html에 랜더링 되어야 값들을 참조 못할 수 있다. 따라서 body 태그 최하단에 넣어주는 것이 바람직하며 시맨틱적인 표준을 지키고 싶다면 async defer 와 같은 옵션을 이용한다. 웹 브라우저는 어떻게 동작하는가? 클라이언트 : 서비스를 받는 입장 ( 요청하는 입장 ) 서버 : 서비스를 하는 입장 ( 응답하는 입장) 도메인 : ip를 식별하는 이름. 암묵적인 룰 : 웹서버는 root로 요청이 오면 index.html를 주도록 되어있다. ex) www.naver.com 브라우저의 핵심적인 역할 : 서버에 HTML, CSS , Javascript를 요청 (request) 서버로부터 받아온 HTML , CSS , Javascript를 파싱하는 역할. 서버의 역할 무한 대기 ( 리퀘스트를 받기 위해서 ) 요청에 대한 응답 (response) 응답받은 파일(html, css)은 메모리상에 올린다. 이를 Read 라 한다. 그 후 Rendering Engine이 실행할 수 있는 형식으로 만들어 준다. 이를 Parsing 이라 한다. Parsing이 완료되면 Tree가 만들어지는데 이를 DOM tree ( CSS라면 CSSOM tree)가 만들어진다. tree : 자료구조의 하나로 거슬로 올라가고 / 따라서 내려가기 편한 형태의 자료구조. Dom이 완성되기 전에 자바스크립트가 실행이 된다. 자바스크립트 엔진은 AST라는 트리를 만든다. 실행이 종료되면 돔을 만드는 작업을 마저한다. 중요단어 파싱, 돔트리, 렌더트리, CSSOM트리 검사창을 통해 테스트 하는 방법 console.log 디버깅이란? 논리적인 오류를 검출하여 제거하는 과정. 디버깅하는법 : 검사창을 통해 에러 확인 . Sources 탭에서 에러부분에 밑줄이 쳐있다. break 거는법은 의심가는 줄을 선택한다. 선탹된 소스부분은 디버깅시 넘어가지 않고 멈춘다. ESLint 코드 Linting 이란? 특정 스타일 규칙을 준수하지 않는 문제가 있는 소스코드를 찾는데 사용되는 방식 Linter는 이러한 Linting을 수행하는 도구를 의미. ESLint는 특정 스타일 규칙을 제한하거나 새롭게 개정까지 가능하다. 대부분의 프로그래밍 언어에는 컴파일하는 과정이 있어서 컴파일시 수행되는 Linter가 내장되어있다. 하지만, Javascript는 컴파일하는 언어가 아니기 때문에 이러한 오류를 잡기 위해 ESLint 와 같은 프로그램을 적극적으로 이용하여 실행하지 않고 기본적인 코드 오류, 구문 오류, 잘못된 규칙등을 발견할 수 있다. ESLint 사용 2가지 방식 JavaScript 개발시 사용되는 에디터에 플러그인을 추가하는 방식 Webpack에 번들링 하여 사용하는 방식. ESLint 설치 및 설정 폴더 생성 후 npm 초기화 및 npm으로 eslint 관련파일 설치 eslint eslint-config-airbnb-base : arirbnb 에서 제정된 코드 스타일 규칙은 좋기로 유명하다. eslint-plugin-import eslint-plugin-html 아래 명령 실행 $ cd &lt;project-folder&gt;$ npm init -y $ npm install eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-html --save-dev - 주의 : ESLint는 가급적이면 해당 폴더에서만 사용할 수 있도록 설치 하는것이 좋다. 전역설치는 매번 추가 설정이 필요로 한다. node_modules 폴더 package-lock.json (없을 수도 있다.) package.json VSCode에 extention 설치 사용중인 폴더에 .eslintrc.js 파일 생성 후 아래 코드 넣기 1234567891011121314151617181920212223module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) \"no-console\": \"warn\", \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"] &#125;&#125;; ESLint 사용처 명시하기 (맥OS 기준) - 설정 탭 접근 - 오른쪽 상단 아이콘 클릭 - 아래 코드 추가 12345\"eslint.validate\" : [ \"javascript\", \"javascriptreact\", \"html\"] ESLint 사용하기 ESLint 가 정상적으로 적용이 완료되었다면 위와 같이 전혀 문제 없어보이는 코드에도 에러, 경고등을 표시한다. 마우스를 살포시 올려보면 무엇이 에러인지 적혀있다. 위 예제에서는 “ var를 쓰지말고 let 이나 const를 써라 “라고 경고하고 있다. ESLint 규칙 설정하기 (.eslintrc.js) 위와 같이 마우스를 올릴 경우 나오는 에러 혹은 경고등을 .eslintrc.js 파일에서 설정이 가능하다. off : 0 warn : 1 error : 2","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"eslint-description","slug":"eslint-description","date":"2019-10-02T11:32:57.000Z","updated":"2019-10-02T11:36:44.604Z","comments":true,"path":"2019/10/02/eslint-description/","link":"","permalink":"http://yoursite.com/2019/10/02/eslint-description/","excerpt":"","text":"ESLint 코드 Linting 이란? 특정 스타일 규칙을 준수하지 않는 문제가 있는 소스코드를 찾는데 사용되는 방식 Linter는 이러한 Linting을 수행하는 도구를 의미. ESLint는 특정 스타일 규칙을 제한하거나 새롭게 개정까지 가능하다. 대부분의 프로그래밍 언어에는 컴파일하는 과정이 있어서 컴파일시 수행되는 Linter가 내장되어있다. 하지만, Javascript는 컴파일하는 언어가 아니기 때문에 이러한 오류를 잡기 위해 ESLint 와 같은 프로그램을 적극적으로 이용하여 실행하지 않고 기본적인 코드 오류, 구문 오류, 잘못된 규칙등을 발견할 수 있다. ESLint 사용 2가지 방식 JavaScript 개발시 사용되는 에디터에 플러그인을 추가하는 방식 Webpack에 번들링 하여 사용하는 방식. ESLint 설치 및 설정 폴더 생성 후 npm 초기화 및 npm으로 eslint 관련파일 설치 eslint eslint-config-airbnb-base : arirbnb 에서 제정된 코드 스타일 규칙은 좋기로 유명하다. eslint-plugin-import eslint-plugin-html 아래 명령 실행 $ cd &lt;project-folder&gt;$ npm init -y $ npm install eslint eslint-config-airbnb-base eslint-plugin-import eslint-plugin-html --save-dev - 주의 : ESLint는 가급적이면 해당 폴더에서만 사용할 수 있도록 설치 하는것이 좋다. 전역설치는 매번 추가 설정이 필요로 한다. node_modules 폴더 package-lock.json (없을 수도 있다.) package.json VSCode에 extention 설치 사용중인 폴더에 .eslintrc.js 파일 생성 후 아래 코드 넣기 1234567891011121314151617181920212223module.exports = &#123; \"parserOptions\": &#123; \"ecmaVersion\": 9 &#125;, \"env\": &#123; \"browser\": true, \"commonjs\": true, \"node\": true, \"jquery\": true &#125;, \"extends\": \"airbnb-base\", \"plugins\": [ \"import\", \"html\" ], \"rules\": &#123; // \"off\" or 0 - turn the rule off // \"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code) // \"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered) \"no-console\": \"warn\", \"quotes\": [ \"error\", \"single\" ], \"no-underscore-dangle\": \"warn\", \"no-plusplus\": [ \"error\", &#123; \"allowForLoopAfterthoughts\": true &#125;], \"comma-dangle\": [ \"error\", \"never\"] &#125;&#125;; ESLint 사용처 명시하기 (맥OS 기준) - 설정 탭 접근 - 오른쪽 상단 아이콘 클릭 - 아래 코드 추가 12345\"eslint.validate\" : [ \"javascript\", \"javascriptreact\", \"html\"] ESLint 사용하기 ESLint 가 정상적으로 적용이 완료되었다면 위와 같이 전혀 문제 없어보이는 코드에도 에러, 경고등을 표시한다. 마우스를 살포시 올려보면 무엇이 에러인지 적혀있다. 위 예제에서는 “ var를 쓰지말고 let 이나 const를 써라 “라고 경고하고 있다. ESLint 규칙 설정하기 (.eslintrc.js) 위와 같이 마우스를 올릴 경우 나오는 에러 혹은 경고등을 .eslintrc.js 파일에서 설정이 가능하다. off : 0 warn : 1 error : 2","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"http://yoursite.com/categories/Develop/Tips/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"ESLint","slug":"ESLint","permalink":"http://yoursite.com/tags/ESLint/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"daily_algorithm03","slug":"daily-algorithm03","date":"2019-10-02T00:39:36.000Z","updated":"2019-10-02T00:42:35.353Z","comments":true,"path":"2019/10/02/daily-algorithm03/","link":"","permalink":"http://yoursite.com/2019/10/02/daily-algorithm03/","excerpt":"","text":"문제 출저 : 프로그래머스 수박수박수박수박수박수?문제 설명길이가 n이고, 수박수박수박수….와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 수박수박을 리턴하고 3이라면 수박수를 리턴하면 됩니다. 제한 조건 n은 길이 10,000이하인 자연수입니다. 입출력 예 n return 3 수박수 4 수박수박 1234567891011121314151617function solution(n) &#123; var answer = ''; var su = \"수\"; var bak = \"박\"; var i = 0; for(i=1;i&lt;=n;i++)&#123; if(i%2==0)&#123; answer = answer + bak; &#125; else if(i%2!=0)&#123; answer = answer + su; &#125; &#125; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-study-01","slug":"javascript-study-01","date":"2019-10-01T05:56:40.000Z","updated":"2019-10-01T09:51:57.861Z","comments":true,"path":"2019/10/01/javascript-study-01/","link":"","permalink":"http://yoursite.com/2019/10/01/javascript-study-01/","excerpt":"","text":"JavaScript Study 01 용어 OT 프론트 엔드 개발자가 하는 일 웹페이지 vs 웹어플리케이션 프론트엔드 개발에 필요한 기술 초심자가 경험하는 3가지 개발의 어려움 프로그래밍이란 아스키코드 , 유니코드 컴파일러 interpreter Syntax , Semantics 자바스크립트 용어 - ( 러버덕 ) 플랫폼 : 어플리케이션이 동작하는 환경. 아스키 코드 유니 코드 컴파일러 인터프리터 JavaScript VS ECMAScript OT 프론트 엔드 개발자가 하는 일 애플리케이션을 사용하는 사람( 유저 )이 애플리케이션과 소통하기 위한 창구( User-Interface )를 사용하기 좋게 구현한다. UI는 상태는 정보를 서버로 전송하기도 하고 서버의 데이터를 가져와서 UI에 표시한다. 웹 어플리케이션은 웹 브라우저에서 작동됨. 브라우저가 직접 실행하는 언어는 JavaScript가 유일하다. 디자이너, 백엔드 개발자와의 협업. ( Tool의 학습이 중요하다. ) 웹페이지 vs 웹어플리케이션 웹페이지 : 정적 , 단순 정보제공. 웹어플리케이션 : 동적 , 정보제공 과 더불어 데이터흐름이 이루어진다. 프론트엔드 개발에 필요한 기술 HTML : tags &amp; attributes, Sementic web CSS : Layout(float , flex , grid), transition/animation, 반응형 웹 , Preprocessor(Sass, Less, Stylus, PostCSS), CSS방법론, CSS 프레임워크 크로스브라우징 JavaScript : ES5 , ES6 , ES Next , 클라이언트 사이드 웹 API( DOM/Event , Ajax ), 동작원리(브라우저, 자바스크립트 엔진), node.js HTTP Tools : Git / Webpack / Babel / ESLint / npm … Library / Framework : SPA(Angular, React, Vue.js), TypeScript, jQuery, Lodash, Axios… TDD(Test Driven Development) : karma / jasmins, mocha, chai 알고리즘 / 자료구조 초심자가 경험하는 3가지 개발의 어려움. 개발자가 하는 말을 이해하기가 힘들다. -&gt; 배경지식 : 기본적인 Computer Sience 지식 / 용어에 대한 이해 / 기본상식 어떻게 만들어야 할 지 감조차 오지 않는다. -&gt; 문제해결 능력 : 문제가 무엇인지 알아채야함. 알고리즘 자료경험. 어떻게 만들어야 할 지는 알겠는데 막상 코딩이 안된다. -&gt; 공부부족. 프로그래밍이란? 프로그래머가 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션 아스키 코드 , 유니코드 아스키코드 : 0과 1의 조합으로 사람이 이해할 수 있는 문자와 숫자의 조합. 1Byte / 경우의수 256개 유니코드 : 2Byte / 국제표준 컴파일러 사람의 언어를 컴퓨터가 이해할 수 있도록 변형 시켜주는 일종의 번역기. 전체적인 코드를 한번에 번역해준다. 컴파일이라는 과정을 필요로 한다. interpreter 사람의 언어를 컴퓨터가 이해할 수 있도록 변형 시켜주는 일종의 번역기. 사람이 적어놓은 코드 내용을 한줄, 한줄씩 컴퓨터가 이해하도록 동시 통역한다. 자바스크립트는 interpreter이다. 즉, 우리가 짠 코드를 브라우저한테 주면 브라우저가 한줄 한줄씩 통역해줄 것이다. 컴파일러보다는 느리다. 단 컴파일 과정이 별도로 필요하지 않다. Syntax &amp; Semantics Syntax : 프로그래밍 문법. Semantics : 말 그대로 문장의 의미. 프로그래밍 문법을 잘 안다고하여 코딩을 잘 하는 것이 아니다. 반드시 문법(Syntax) 와 의미(Semantics) 을 맞게 구성하여야 한다. 예를 들어보자. 123const number = 'string';console.log(number * number); // NaN 위는 문법(Syntax)에는 전혀 문제가 없다. 하지만 의미상으로는 매우 이상하다. number라는 의미의 변수에는 누가보아도 숫자가 들어갈 것이라고 예상했지만, 이상하게 문자열이 들어가있으며 심지어 그 문자열을 서로 곱하는 연산을 취하고 있다. 정말로 이상한 의미를 지니고 있다. 위와 같은 예제로 보아 문법과 더불어 의미를 지켜가며 코딩을 해야만 한다. 자바스크립트 브랜던 아이크가 개발한 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량의 프로그래밍 언어. 컴파일이 실행되는 언어가 아닌 브라우저에서 즉시 통역하는 인터프리터 언어이다. 브라우저들만의 특징을 이용하여 인터프리터의 단점인 느린속도를 조금이나마 보안하였고, 명령형, 함수형, 프로토기반 객체지향 프로그램을 내포하는 멀티 패러다임 프로그래밍 언어(프로토타입 기반의 객체 지향 언어) 자바스크립트 와 ECMAScript자바스크립트는 ECMAScript보다 더 큰 개념이다. ECMAScript에서 설계되어있는 모든 문법 규정들을 포함한 언어를 JavaScript 라고 한다. ECMAScript는 스크립트 언어가 준수해야 하는 규칙, 세부 사항 및 지침을 제공한다. 자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대(core)를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, Ajax 자바스크립트를 이용해서 서버와 브라우저가 비동기적으로 데이터를 교환할 수 있는 통신기능. 이전의 웹 페이지는 서버로부터 HTML을 전달받아서 웹페이지를 전체적으로 렌더링 하는 방식이었다. 따라서 화면 내부에 있는 사소한 움직임까지도 전부 서버로부터 HTML에게 전달받아서 웹페이지를 다시 렌더링해야되는 정말로 불편한 구조였다. Ajax의 등장은 이러한 부분을 크게 해소하였다. 페이지 전체를 렌더링하지 않고 필요한 부분만 다시 그리는 방식이 가능해진것이다. 또한 데스크탑 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환까지 가능하게되면서 기존의 패러다임을 크게 부셔주는 역할을 하였고 이는 자바스크립트에 대한 인식을 바꿔주는 큰 계기가 되었다. jQuery DOM 을 보다 쉽게 제어가 가능하고 , 크로스 브라우징을 해결해주는 라이브러리. 등장 당시에는 크로스브라우징 이슈 , 자바스크립트의 러닝 난이도 해소등의 이유로 인해 정말로 많이 사용되었던 기술이지만, 현재는 점점 사용률이 줄어들고 있는 추세이다. 이유는 예전에는 HTML이 바뀌게 되면 javascript가 영향을 받게되었는데 현재에는 HTML이 바뀌게 되면 javascript가 영향을 받지 않게되었다. ( Component Based Development 방법론 ) 하지만, CBD방법론은 보통 대규모 프로젝트나 큰 프레임워크( React.js , Vue.js , Angular.js )를 이용할때 사용하게된다. 따라서 소규모 프로젝트나 경험으로 해보기에는 매우 좋은 라이브러리. V8 자바스크립트 엔진 자바스크립트로 웹 애플리케이션을 구축하려는 시도가 늘어가면서 보다 빠르게 동작하는 자바스크립트 엔진이 요구됨. 따라서 구축된 것이 구글에서 개발한 V8 자바스크립트 엔진. Node.js 자바스크립트는 원래 웹 브라우저에서 작동을 한다. Node.js는 자바스크립트가 웹브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되게 하는 범용 프로그래밍 언어. SPA 프레임워크 Single Page Application 의 줄임말, 진짜 말그대로 .html 페이지가 단 1개만 존재하며 필요한 구성부분을 모두 Component로 제작하여 사용한다. 이는 재사용성에 큰 기여를 한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Javascript","slug":"TIL/Javascript","permalink":"http://yoursite.com/categories/TIL/Javascript/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm02","slug":"daily-algorithm02","date":"2019-10-01T05:56:06.000Z","updated":"2019-10-01T05:59:17.765Z","comments":true,"path":"2019/10/01/daily-algorithm02/","link":"","permalink":"http://yoursite.com/2019/10/01/daily-algorithm02/","excerpt":"","text":"문제 출저 : 프로그래머스 서울에서 김서방 찾기문제 설명String형 배열 seoul의 element중 Kim의 위치 x를 찾아, 김서방은 x에 있다는 String을 반환하는 함수, solution을 완성하세요. seoul에 Kim은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다. 제한 사항 seoul은 길이 1 이상, 1000 이하인 배열입니다. seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다. Kim은 반드시 seoul 안에 포함되어 있습니다. 입출력 예 seoul return [Jane, Kim] 1234567891011121314function solution(seoul) &#123; var answer = ''; var seoul_array_num = 0; for(var i=0;i&lt;seoul.length;i++)&#123; if(seoul[i] == \"Kim\")&#123; seoul_array_num = i; break; &#125; &#125; answer = \"김서방은 \" + seoul_array_num + \"에 있다\" return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"daily_algorithm01","slug":"daily-algorithm01","date":"2019-09-30T10:38:58.000Z","updated":"2019-09-30T10:40:43.593Z","comments":true,"path":"2019/09/30/daily-algorithm01/","link":"","permalink":"http://yoursite.com/2019/09/30/daily-algorithm01/","excerpt":"","text":"문제 출저 : 프로그래머스 체육복문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 123456789101112131415161718192021222324252627function solution(n, lost, reserve) &#123; var answer = n-lost.length; var temp_value = 0; var lost_value = 0; for(var i=0;i&lt;reserve.length;i++)&#123; for(var j=0;j&lt;lost.length;j++)&#123; if(reserve[j]-1 == lost[i])&#123; lost_value++; temp_value++; break; &#125; if(reserve[j]+1 == lost[i])&#123; lost_value++; temp_value++; break; &#125; &#125; if(temp_value==lost.length)&#123; break; &#125; &#125; answer = answer + lost_value; return answer;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"linux-study-03","slug":"linux-study-03","date":"2019-09-30T10:26:04.000Z","updated":"2019-10-02T09:04:55.015Z","comments":true,"path":"2019/09/30/linux-study-03/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-03/","excerpt":"","text":"프로세스 cpu - processor (process X) ram - memory hdd, sdd - storage *각 특징 : * Storage : 가격이 싸고, 용량이 크다. 속도가 느리다 Memory : 가격이 비싸고 , 용량이 작다. 속도가 빠르다 processor : 기격이 매우비싸고, 용량이 매우작고, 속도가 매우빠르다 프로세스 관련 명령어 프로세스 리스트를 확인하는 명령어 : ps 백그라운드에서도 돌아가는 ps까지 확인하는 방법 : ps aux 이 중 특정 이름의 프로그램을 찾고싶다 -&gt; : ps aux | grep apache 프로세스를 끄는 방법 sudo kill [process-ID] 프로세스 리스트를 확인하는 명령어1 : top 프로세스 리스트를 확인하는 명령어2 : htop (별도 설치해야됨) 그 외 명령어 및 개념멀티 태스킹 : 여러개의 일을 하나의 화면에서 할 수 있다. 백그라운드로 멈추어서 보내는법 : ctrl + z 백그라운드에 실행되는 상태로 보내는법 : 명령어 맨뒤에 &amp;를 넣어준다. ex) ls -la &amp; 포그라운드로 가져오는법 : fg jobs : 백그라운드에서 실행 중인 프로그램 확인. +표시 : 백그라운드로 물러나있다가 포그라운드로 들어오는 프로그램 -표시 : +로 된 백그라운드가 끝나고나서 실행될 프로그램 백그라운드 종료 : kill %[번호] 백그라운드 강제 종료 : kill -9 %[번호] 항상 실행 - DemonWeb server = Demon 데몬은 /etc/init.d에 위치해 있다. 데몬을 키는방법은 sudo service [파일명] start ex) sudo service apache2 start 데몬을 끄는방법은 sudo service [파일명] stop ex) sudo service apache2 stop 데몬이 자동으로 실행되는 경우를 확인하는방법 아래 위치의 폴더에서 확인 가능하다. /etc/rc3.d -&gt; CLI방식 /etc/rc5.d -&gt; GUI방식 rc3.d로 cd S02apache2 S는 리눅스가 실행되면 실행된다. 는 것을 의미. 02는 우선순위 자동 데몬을 만들려면 실행시키고 싶은 프로그램을 rc3.d 혹은 rc5.d 폴더에 규칙대로 파일명을 생성하고 링크를 걸어준다. CRONCRON : 정기적으로 실행시키는 도구 crontab -e: 하고자 하는 일을 정의. [실행되는 분의주기 */1 = 1분에 한번 ] [실행되는 시간 *=상관없음] [실행되는 일] [실행되는 월] [실행되는 요일] [실행될 명령어] date &gt;&gt; date.log = 현재시각을 게속 저장함 crontab -e */1 * * * * date &gt;&gt; date.log 2&gt;&amp; 의미 : 1분마다 date라는 명령어의 결과를 date.log에 저장하는데 만약 에러가 나면 표준출력으로 redirection나게한다. 쉘이 실행될때 /bin/bash/.bashrc라는 파일을 실행되도록 설정되어있음. 따라서 쉘이 시작할때 무언가를 하고싶다면 .bashrc 안에서 설정해주면됨. 다중사용자명령어 id -&gt; 나는 누구인가? 명령어 who -&gt; 현재 시스템에 누가 접속해있는가? 유닉스의 계열의 2가지형태의 사용자 super(root) user 일반 user super(root) user sudo는 슈퍼유저의 권한을 빌려오는것 $표시 현재 사용자가 일반유저라는것을 의미, 슈퍼유저는 # *명령어 su * su - root : 슈퍼 유저로 사용자 변경 슈퍼유저에서 빠져나가는법 exit. sudo passwd -u root : root에 대해 lock을 풀어버림. sudo passwd -l root : root에 대해 lock을 걸어버림. cd : 최상위 디렉토리 cd /root : 최상위 디렉토리 안에 있는 root디렉토리 사용자 추가useradd -m 사용자명 : 처음, 사용자를 추가하면 passwd를 설정해야함. sudo passwd 사용자명 sudo usermod -a -G sudo 사용자명 권한 변경하는법chmod o-r 파일명 : other에 대한 파일권한중 읽기를 뼴 chmod o+r 파일명 : other에 대한 파일권한중 읽기를 추가해줌. chmod o+w 파일명 : other에 대한 파일권한 쓰기를 추가해줌. chmod u-r 파일명 : 소유자에 대한 읽기권한을 뺴버림. directory 권한r = 해당 폴더의 내용을 확인 w = 해당 폴더의 내용물에 파일생성등등 x = 해당 폴더의 접근.(cd) chmod -R o+w [폴더명] : 해당 폴더와 폴더내에잇는 모든 파일들 권한을 변경함. 숫자 변경법chmod 444 perm.txt : perm.txt에 대한 권한을 모두 read로 변경 사칙연산법chmod a=rwx perm.txt : perm.txt에 대한 모든 사용권한을 오픈함.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux-study-02","slug":"linux-study-02","date":"2019-09-30T08:23:37.000Z","updated":"2019-10-02T09:04:50.136Z","comments":true,"path":"2019/09/30/linux-study-02/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-02/","excerpt":"","text":"[Input/Output] IO Redirection Output : 출력 redirection -&gt; 출력위치를 변경할 수 있다. (보통은 모니터)​ 예) ls -l &gt; result.txt = ls -l의 결과(Standard Output)를 result.txt에 저장한다. ​ 총 2가지의 Output 이 존재한다. Success : 성공했을 경우의 Output Error : 실패했을 경우의 Output Standard Output으로 redirection 하는 방법 : 1&gt; Error Output으로 redirection 하는 방법 : 2&gt; ex) rm rename2.tex 1&gt;result.txt 2&gt;result.txt Input : 입력 redirectionStandard Input : keyboard 예) hello.txt 안에는 hello 라는 텍스트가 저장되어있다. 만약에 hello.txt파일 안의 내용을 cat으로 출력하고 싶다면 다음과 같이 작성한다. cat &lt; hello.txt cat hello.txt IO Redirection Ouput Appendls -al &gt; result.txt 할 경우 result.txt로 결과가 저장된다. 그 후 ls -a &gt; result.txt할 경우 result.txt로 결과가 덮어씌우게 된다 만약 추가를 하고 싶다면 다음과 같이 사용해야만 한다. ls -al &gt;&gt; result.txt","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux-study-01","slug":"linux-study-01","date":"2019-09-30T06:44:47.000Z","updated":"2019-10-02T09:04:40.396Z","comments":true,"path":"2019/09/30/linux-study-01/","link":"","permalink":"http://yoursite.com/2019/09/30/linux-study-01/","excerpt":"","text":"리눅스 명령어 리눅스의 특징 : command line interface ls : 파일보기 ​ 옵션 -l : 파일권한, 소유자,생성시간등의 자세한 정보를 추가로 나열해준다. pwd : 현재 놓여있는 디렉토리를 파악한다. mkdir : 폴더생성 touch [파일명] : 파일생성 cd [디렉토리명] : 현재 디렉토리 위치 변경 ​ 디렉토리 변경시 2가지 방법이 있다. 절대경로 예) cd /home/ubuntu. =&gt; / : root를 의미한다. 상대경로 예) cd .. =&gt; 상대경로는 내 위치에 따라서 위치를 조정하는것. rm [파일 명] : 파일 삭제 명령어 rm -r [파일명] : 폴더 삭제 명령어 모든 명령어 뒤 –version : 해당 명령어의 버전을 알려준다. 모든 명령어 뒤 –help : 명령에 무슨 옵션이 있는지, 어떠한 기능을 하는지 설명 도움말을 보여준다. man [명령어명] : 예) man ls man 내부 상세 단어 검색 : 예) /sort : sort라는 단어 검색 -&gt; 넘기는 방법은 n키 누르면 됨. 돌아가는 방법은 b키 누르면 됨. man과 –help의 차이 : help는 간결하게 명령어의 기능및 옵션 / man은 상세하게 보여준다. mkdir -p [파일명] : 예) mkdir -p dir1/dir2/dir3/dir4 -&gt; 부모 디렉토리를 만들수 있다. 옵션 -는 축약형 –는 기본형 ex) mkdir -p / mkdir –parent 숨긴파일은 파일명 앞에 . 이 붙는다. 숨긴파일을 보는 방법은 ls -a / ls –all 옵션으로 보면 된다. mv [원본파일] [이동위치 또는 변경할 파일명] cp [원본파일] [대상위치] 명령어 검색방법구글에서 검색한다. 예) 구글에서 create a directory in linux sudo : 임시로 권리자 권한을 빌려온다. sudo는 super user do 의 약자로 권리자 권한을 의미함. 제일 심각한 명령어 : sudo rm -rf / =&gt; 묻지도 따지지않고 루트디렉토리 전부 삭제 sudo [command] 권한만 빌림. su - : root계정으로 전환함. Package manager ( 리눅스 apt / yum)​ 보통 권한이 필요하기 때문에 sudo를 사용해야만 한다. sudo apt-get update : 현재 사용할 수 있는 패키지들의 목록을 최신상태로 업데이트한다. sudo apt-get install [패키지명] : 패키지를 다운로드 받는다. sudo apt-get upgrade [패키지명] : 패키지를 최신상태로 업데이트 한다. 패키지명 생략시 모든 패키지를 업데이트 한다. sudo apt-get remove [패키지명]: 패키지를 삭제한다. sudo apt-cache search [패키지명]: [패키지명]와 관련된 패키지 목록을 보여준다. homebrew ( 맥용 )​ 맥에서 주로 사용하는 패키지 매니저 brew search [패키지명] : [패키지명]과 관련된 패키지 목록을 보여준다. brew install [패키지명] : [패키지명]과 관련된 패키지를 다운받는다. brew list : 로컬에서 homebrew를 통해 설치한 패키지목록을 표시해준다. brew uninstall [패키지명] : [패키지명]을 삭제한다. brew upgrade [패키지명] : [패키지명]을 업데이트한다. brew update : homebrew로 사용가능한 패키지들의 목록을 업데이트한다. 리눅스 명령어 기반에서 다운로드 받는 방법 : wget​ 다운로드 받을 프로그램이 필요하다. ( wget 이용 ) wget url주소 : 파일명 그대로 받게됨. wget -O [파일명] url주소 오픈소스 다운로드 방법 : git​ 맘에 드는 git 주소 들어가서 git clone~","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"VSCode-hotkey","slug":"VSCode-hotkey","date":"2019-09-30T06:44:10.000Z","updated":"2019-10-02T09:55:13.826Z","comments":true,"path":"2019/09/30/VSCode-hotkey/","link":"","permalink":"http://yoursite.com/2019/09/30/VSCode-hotkey/","excerpt":"","text":"VS 단축키(MAC은 command = ctrl / option = alt) shift + option + f : 전체 줄 정리 option + command + 화살표 : 다중 커서 라인 생성 option + command + g : 개별 약어 랩핑 ctrl + n : 파일 생성 ctrl + s : 저장 ctrl + b : 사이드 바 열기 ctrl + p : 시작 팔레트 ctrl + shift + P : 명령 팔레트 ctrl + shift + k : 그 줄 삭제 ctrl + F : 찾기(검색) ctrl + H : 찾기(검색)/바꾸기(대체) ctrl + / : 주석 Alt + Up : 해당 코드 줄 위로 이동 Alt + Down : 해당 코드 줄 아래로 이동 shift + alt + DownArrow : 아래 줄 복사 tab : 들여쓰기 shift + tab : 내어쓰기 ctrl + PageUp : 이전 편집기 열기(좌측 창으로 전환) ctrl + PageDown : 다음 편집기 열기 (우측 창으로 전환) ctrl + \\ : 편집기 분할(백슬래쉬) ctrl + 숫자 : 숫자 번째 분할된 편집기 그룹에 포커스 ctrl + W : 편집기 닫기 ! + enter : 기본적인 HTML","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Tips","slug":"Develop/Tips","permalink":"http://yoursite.com/categories/Develop/Tips/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"CSS-inline-block","slug":"CSS-inline-block","date":"2019-09-30T06:43:15.000Z","updated":"2019-10-02T09:57:13.981Z","comments":true,"path":"2019/09/30/CSS-inline-block/","link":"","permalink":"http://yoursite.com/2019/09/30/CSS-inline-block/","excerpt":"","text":"inline-block 특징 inline-block 끼리 나열할 경우 문제가 없다. 또한 inline-block은 서로간에 약간의 틈이 존재한다. 1234567891011121314151617&lt;style&gt; .test1&#123; display: inline-block; background: gold; width: 300px; height: 300px; &#125; .test2&#123; display: inline-block; background: silver; width: 300px; height: 300px; &#125;&lt;/style&gt;&lt;div class=\"test1\"&gt;&lt;/div&gt;&lt;div class=\"test2\"&gt;&lt;/div&gt; inline-block 끼리 나열 중 한 요소안에 또 다른 inline-block 요소가 나오면 레이아웃이 깨져버린다. 1234567891011121314151617181920212223242526272829&lt;/style&gt; .test1&#123; display: inline-block; background: gold; width: 300px; height: 300px; &#125; .test2&#123; display: inline-block; background: silver; width: 300px; height: 300px; &#125; .test2-test&#123; display: inline-block; background:lime; width: 20px; height: 100px; &#125;&lt;/style&gt; &lt;div class=\"test1\"&gt;&lt;/div&gt; &lt;div class=\"test2\"&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;div class='test2-test'&gt;&lt;/div&gt; &lt;/div&gt; 이럴 경우 각 부모 div에게 vertical-align 속성을 주어야 해결이 가능하다. 123.test1, .test2 &#123; vertical-align: top; &#125;","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"CSS","slug":"Develop/CSS","permalink":"http://yoursite.com/categories/Develop/CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"inline-block","slug":"inline-block","permalink":"http://yoursite.com/tags/inline-block/"}]},{"title":"html-css-study-13","slug":"html-css-study-13","date":"2019-09-28T08:01:51.000Z","updated":"2019-10-02T09:03:40.724Z","comments":true,"path":"2019/09/28/html-css-study-13/","link":"","permalink":"http://yoursite.com/2019/09/28/html-css-study-13/","excerpt":"","text":"HTML Study 13 css : filter ( 흑백처리 , blur 효과 등등 ) tab-index margin 겹침 현상 background size 중앙 정렬 처리하는 방법 (수직 정렬등) aria-label , aria-labelby ( vs title ) aria-expended , aria-haspopup iframe 사용시 주의점 fr 단위 반응형 디자인을 할때는 px보다는 em, rem같은 단위를 써야 유연해지기에 좋다. grid에서는 fr단위로 쉽게 조절이 가능하다. 수직중앙정렬시 translateY : -50%를 이용한다. iframe은 퍼올때부터 대부분 사이즈가 지정이 되어있으므로 유동적인 사이즈를 맞추려면 div로 한번더 감싼다. css : filter ( 흑백처리 , blur 효과 등등 ) filter 기능은 이미지를 흑백처리하거나 blur, 반전, 밝기 조절등의 효과를 넣는 것을 말한다. 포토샵만큼 디테일하게 효과를 줄 수는 없으나, CSS로 간단한 효과정도는 줄 수 있다. 12345678910/* 사용 방법 : 선택자 &#123;filter:효과이름(값)&#125; */ .blur &#123;filter:blur(20px);-webkit-filter:blur(20px);&#125; .grayscale &#123;filter:grayscale(100%);-webkit-filter:grayscale(100%);&#125; .sepia &#123;filter:sepia(100%);-webkit-filter:sepia(100%);&#125; .saturate &#123;filter:saturate(10);-webkit-filter:saturate(10);&#125; .hue-rotate &#123;filter:hue-rotate(100deg);-webkit-filter:hue-rotate(100deg);&#125; .invert &#123;filter:invert(10);-webkit-filter:invert(10);&#125; .opacity &#123;filter:opacity(0.5);-webkit-filter:opacity(0.5);&#125; .brightness &#123;filter:brightness(5);-webkit-filter:brightness(5);&#125; tab-index 처리 div, span 와 같은 focus 초점을 받지 못하는 요소나 혹은 foucs를 받는 요소에게 fouc를 빼앗는 역할을 부여 할 수 있다. tabindex=”1” : 문서 안에서 가장 먼저 초점을 받게 할 수 있다. (주의점 : 마크업 순서를 거스르기 때문에, autofocusr가 더 적합) tabindex=”0” : 키보드 초점을 받지 못하는 요소들( div, span 등등) 도 초점을 받도록 해준다. tabindex=”-1” : 키보드 초점을 받는 요소에게서 초점을 받지 못하도록 만든다. 123&lt;div class=\"test\" tabindex=\"0\"&gt; 초점을 받을 수 있게 된다.&lt;/div margin 겹침 현상 기본적으로 형제 사이에서 일어난다. (이 현상은 오직 세로 margin값에서 일어난다.) 부모 ~ 자식 간에서도 겹침 현상이 발생한다. (둘 중 하나 이상 inline block일때는 겹치지 않는다.) 이를 가장 쉽게 해결하는 방법은 부모에게 글자추가, border 혹은 padding,와 같은 시각적효과를 적용하면 해결된다. position:absolute / float / grid 와 같은 레이아웃 작업은 margin이 발생하지 않는다. background-size​ background에 url 형태로 이미지를 불러들였을 경우, 만약 이미지 크기가 맞지 않다면 background-size를 상자 크기에 맞게 조절하면 된다. ( 보통 100% 로 조절. ) 중앙 정렬 처리하는 방법가로 정렬은 보통 text-align , vertical-align 등을 통해 쉽게 배치가 가능하다. 하지만 가운데 정렬은 배치를 하기 위해서는 padding 값이나 margin값을 정적으로 계산해야만 한다. 하지만 위와 같은 방법을 이용한다면 쉽게 배치가 가능하다. 보통 absolute를 이용하여 많이 배치한다. 12345.header&#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; aria-label / aria-labelledbyaria-label 속성은 값에 ‘간결한’ 설명(string)을 직접 제공한다. 마치 해당 태그가 무슨 역할을 하는지 설명하듯 설명문을 적어주는것과 같다. 예를들면 다음과 같다. 12345&lt;!-- O: 참조할 설명이 없는 경우 --&gt;&lt;form&gt; &lt;input type=\"search\" aria-label=\"웹툰 검색\"&gt; &lt;button&gt;검색&lt;/button&gt;&lt;/form&gt; aria-labelledby 속성은 ID(s) 값을 이용하여 ‘간결한’ 내용을 참조(연결)하는 방식으로 설명한다. 보통 h1, h2, h3, h4, h5, h6, a, button 요소를 참조하면 적절하다. aria-label 속성과 함께 선언하는 경우 aria-labelledby 속성이 우선순위가 높기 때문에 보조기기는 aria-labelledby 속성을 설명한다. 예를들면 다음과 같다. 123456789101112&lt;!-- O: 설명 참조 --&gt;&lt;section aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;h2 id=\"LZ-PATH\"&gt;레진패스란?&lt;/h2&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/section&gt;&lt;!-- O: 잘못된 참조 --&gt;&lt;a id=\"LZ-PATH\" href=\"#LZ-PATH-TEXT\"&gt;레진패스란?&lt;/a&gt;&lt;!-- 숨긴처리된 설명은 참조해서는 안된다. --&gt;&lt;div id=\"LZ-PATH-TEXT\" aria-labelledby=\"LZ-PATH\" hidden&gt; &lt;p&gt;이 작품의 유료 에피소드 열람 시 자동으로 구매합니다.&lt;/p&gt;&lt;/div&gt; aria-labelledby 속성으로 숨김 처리한 설명을 참조하면 안 됩니다. 참조가 불가능한 설명은 aria-label 속성을 사용한다. 자세한 설명을 참조하면 안 된다다. 자세한 설명은 aria-descibedby 속성을 사용. aria-expanded 애플리케이션에서 제공되는 메뉴가 하위 메뉴를 포함하고 있 을 경우 현재 하위 메뉴가 접힌 상태인지 펼쳐진 상태인지 스크린리더 사용자에게 정보를 제공 해야 할 경우가 있다. 이때 aria-expanded 속성을 사용하여 접힌 상태라면 false 값을 펼쳐진 상태라면 true 값을 지정할 수 있다. aria-haspopup레진 블로그 설명 aria-haspopup 속성은 요소에 연결되어 있는 팝업(메뉴, 대화상자 등) 정보를 제공한다. 팝업은 다른 내용 위에 표시하는 블럭을 의미한다. iframe 사용시 주의점 iframe 태그는 하나의 html 로 생각해야만 한다. 따라서 iframe 태그 자체를 width, height등을 이용해 유연한 배치를 할 수 없다. 만약에 iframe 의 크기를 조절하고 싶다면 div태그로 1번더 감싸야만 한다. 그리고서 해당 div에 absolute를 거는 방식을 이용한다. 12345678910111213141516171819202122232425&lt;style&gt; .responsive-container&#123; position: relative; width: 100%; height: 0 !important; &#125; .responsive-iframe&#123; position: absolute; top:0; left:0; width: 100%; height: 100%; border: 0 none; &#125; .responsive-iframe-43&#123; padding-top: 75%; &#125; .responsive-iframe-169&#123; padding-top: 56.25%; &#125;&lt;/style&gt;&lt;div class=\"responsive-container responsive-iframe-169\"&gt; &lt;iframe aria-labelledby=\"video-subject\" class=\"responsive-iframe\" src=\"https://www.youtube.com/embed/umfaXctbqOs\"allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt; fr 단위fr이란 유연한 크기를 갖는 단위이다.grid 컨테이너 내의 공간 비율을 분수(fraction)로 나타낸다. 다만, 지원 브라우저가 낮다. 사용자가 계산해야 할 부분을 fr을 통해서 쉽고 유연하게 사용할 수 있다. 1234.grid &#123; display: grid; grid-template-columns: auto 100px 1fr 2fr;&#125; 1번 열은 auto를 사용한다. 해당 Element 내부 콘텐츠에 맞게 사이즈가 조정된다. 2번 열은 100px을 할당한다. 100픽셀 크기만큼의 폭을 차지한다. 3번 열은 1fr 크기를 할당한다. 1fr이란 남은 자유 공간의 1/3(총fr)만큼의 크기를 할당한다. 4번 열은 2fr 크기를 할당한다. 2fr이란 남은 자유 공간의 2/3(총fr)만큼의 크기를 할당한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-12","slug":"html-css-study-12","date":"2019-09-24T16:56:09.000Z","updated":"2019-10-02T09:03:46.859Z","comments":true,"path":"2019/09/25/html-css-study-12/","link":"","permalink":"http://yoursite.com/2019/09/25/html-css-study-12/","excerpt":"","text":"HTML Study 12 webfont 정리 flex 재정리 white-space 속성 - pre , pre-wrap, pre-line 프로젝트 하면서 느낀점 9월 24일 webfont 정리 웹폰트를 사용하기 위해서는 다음과 같은 코드들이 일부 필요하다. 123456789101112131415@font-face &#123; font-family: NanumSquareWeb; src: local(NanumSquareR), local(NanumSquare), url(NanumSquareR.eot?#iefix) format('embedded-opentype'), url(NanumSquareR.woff) format('woff'), url(NanumSquareR.ttf) format('truetype'); font-style: normal; font-weight: normal; unicode-range: U+0-10FFFF;&#125; h1 &#123; font-family: NanumSquareWeb, sans-serif;&#125; 내가 사용할 웹폰트 패밀리명을 NanumSquareWeb으로 하겠다. 라고 선언한 예이다. 반드시는 아니지만, font-family 명과 사용할 폰트명을 동일시하게 하는 것 이 좋다. 로컬에 이미 설치 된 폰트의 경로를 적는 local() 속성과 다운로드 할 웹폰트의 주소를 적는 url() 속성이다. 위 코드는 local(NanumSquareR) → local(NanumSquare) → url(NanumSquareR.eot) → url(NanumSquareR.woff) → url(NanumSquareR.ttf) 순으로 폰트를 찾는다. format 속성을 사용하면 브라우저에서 지원 가능한 파일만 다운로드 받을 수 있습니다. 사용할 유니코드의 범위를 정한다. flex 재정리 (TCP 스쿨 내용 재정리)flex-direction 속성flex-direction 속성은 플렉스 컨테이너 안에서 플렉스 요소가 배치될 방향을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. row : 기본 설정으로, 플렉스 요소는 왼쪽에서 오른쪽으로, 그리고 위쪽에서 아래쪽으로 배치됩니다. row-reverse : 만약에 direction 속성값이 ltr(left-to-right)이면, 플렉스 요소는 반대로 오른쪽에서 왼쪽으로 배치됩니다. column : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 위쪽에서 아래쪽으로 배치됩니다. column-reverse : 만약에 쓰기 방식이 수평이면, 플렉스 요소는 수직 방향으로 아래쪽에서 위쪽으로 배치됩니다. justify-content 속성justify-content 속성은 플렉스 요소의 수평 방향 정렬 방식을 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. flex-start : 기본 설정으로, 플렉스 요소는 플렉스 컨테이너의 앞쪽에서부터 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 뒤쪽에서부터 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에서부터 배치됩니다. space-between : 플렉스 요소는 요소들 사이에만 여유 공간을 두고 배치됩니다. space-around : 플렉스 요소는 앞, 뒤, 그리고 요소들 사이에도 모두 여유 공간을 두고 배치됩니다. align-items 속성align-items 속성은 플렉스 요소의 수직 방향 정렬 방식을 설정합니다. 이 속성은 한 줄만을 가지는 플렉스 박스에서는 효과가 없으며, 두 줄 이상을 가지는 플렉스 박스에서만 효과가 있습니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 요소의 높이가 플렉스 컨테이너의 높이와 같게 변경된 뒤 연이어 배치됩니다. flex-start : 플렉스 요소는 플렉스 컨테이너의 위쪽에 배치됩니다. flex-end : 플렉스 요소는 플렉스 컨테이너의 아래쪽에 배치됩니다. center : 플렉스 요소는 플렉스 컨테이너의 가운데에 배치됩니다. baseline : 플렉스 요소는 플렉스 컨테이너의 기준선(baseline)에 배치됩니다. flex-wrap 속성flex-wrap 속성은 플렉스 라인에 더 이상의 여유 공간이 없을 때, 플렉스 요소의 위치를 다음 줄로 넘길지를 설정합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. nowrap : 기본 설정으로, 플렉스 요소가 다음 줄로 넘어가지 않습니다. 대신에 플렉스 요소의 너비를 줄여서 한 줄에 모두 배치시킵니다. wrap : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. wrap-reverse : 플렉스 요소가 여유 공간이 없으면 다음 줄로 넘어가서 배치됩니다. 단, 아래쪽이 아닌 위쪽으로 넘어갑니다. align-content 속성align-content 속성은 flex-wrap 속성의 동작을 변경할 수 있습니다. 이 속성은 align-items 속성과 비슷한 동작을 하지만, 플렉스 요소를 정렬하는 대신에 플렉스 라인을 정렬합니다. 이 속성은 다음과 같은 속성값을 가질 수 있습니다. stretch : 기본 설정으로, 플렉스 라인의 높이가 남는 공간을 전부 차지하게 됩니다. flex-start : 플렉스 라인은 플렉스 컨테이너의 앞쪽에 뭉치게 됩니다. flex-end : 플렉스 라인은 플렉스 컨테이너의 뒤쪽에 뭉치게 됩니다. center : 플렉스 라인은 플렉스 컨테이너의 가운데에 뭉치게 됩니다. space-between : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. space-around : 플렉스 라인은 플렉스 컨테이너에 고르게 분포됩니다. 단, 양쪽 끝에 약간의 공간을 남겨둡니다. 플렉스 요소(flex item)의 flex 속성flex 속성을 이용하면 같은 플렉스 컨테이너 안에 있는 플렉스 요소의 너비를 상대적으로 설정할 수 있습니다. 다음 예제에서 첫 번째 플렉스 요소는 전체 너비의 3/5을 차지하며, 나머지 두 요소는 각각 전체 너비의 1/5씩을 차지하게 됩니다. 123.item:nth-child(1) &#123; -webkit-flex: 3; flex: 3; &#125;.item:nth-child(2) &#123; -webkit-flex: 1; flex: 1; &#125;.item:nth-child(3) &#123; -webkit-flex: 1; flex: 1; &#125; white-space 속성 - pre , pre-wrap, pre-line normal : 기본값. 공백을 여러개 넣어도 공백 1개만 인정. 자동줄바꿈. nowrap : 공백 1개만 인정. 텍스트가 길어도 줄바꿈이 안됨. pre : 공백을 마크업 그대로 표시. 코드에 줄바꿈이 없다면 줄바꿈이 안됨. pre-wrap : 공백을 마크업 그대로 표시함. 코드에 줄바꿈이 없어서 코드따라 줄바꿈됨. pre-line : 공백을 여러개 넣어도 1개만 표시. 코드에 불바꿈이 없어도 자동 줄바꿈이 됨. 프로젝트 하면서 느낀점 9월 24일 내가 모르는 태그들이 정말로 많다. layout 작업시 큰 틀에 대한 width를 전부 지정해주어야한다. 작은 틀을 맞추고 싶다면 width값을 100%로 큰틀에 대해 맞춘다. 최대한 그려가면서 레이아웃 작업을 진행해야 될 것 같음. 조언을 아끼지 말아라. (구하는 조언도, 모르는 조언도) 남들보다 1개더 안다면 1개더 배풀고 더 모른다면 알 떄까지 노력할 것. 암기보다 이해가 먼저고 이해가 정 안될 경우 암기한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-11","slug":"html-css-study-11","date":"2019-09-23T17:25:10.000Z","updated":"2019-10-02T09:03:30.957Z","comments":true,"path":"2019/09/24/html-css-study-11/","link":"","permalink":"http://yoursite.com/2019/09/24/html-css-study-11/","excerpt":"","text":"HTML Study 11 fontello 사용법 letter, word spacing transition 사용 주의점 프로젝트 하면서 느낀점 9월 23일 fontello 사용법 fontello 사용법 fontello 접속 마음에 드는 fontello 아이콘들 선택(라이센스 주의) 다운로드 다운로드 된 압출파일을 해제 해제된 폴더를 프로젝트에 붙여넣는다.(가급적이면 폴더 네임수정 - 지저분함) CSS파일에 다음과 같이 넣어준다. 12345678@import url('./fontello/css/fontello.css'); /*import*//*사용 방법*/.header::after&#123; content: '\\e805'; font-family: \"fontello\";&#125; letter , word spacing 글자 사이의 간격은 letter-spacing으로, 단어 사이의 간격은 word-spacing으로 정한다. 값이 커지면 간격이 커진다. 값에는 음수를 넣을 수 있다. ( 마이크로소프트 엣지나 인터넷 익스플로러에서는 단어 사이의 간격을 음수로 정해도 글자가 겹치지 않을 정도로만 간격이 줄어든다.) 음수를 값으로 하는 경우 글자가 겹칠 수 있다. 글자 사이의 간격을 변화시키면 단어 사이의 간격도 변한다. 단어 사이의 간격을 변화시켜도 글자 사이의 간격은 변하지 않는다. transition 사용 주의점​ transition 사용시 초(s) 단위를 붙일 경우, 0일떄 s를 생략하면 작동을 안한다. ​ 꼭 유의 하고 사용할 것. 프로젝트 하면서 느낀점 막히면 차분히 무엇이 문제인지 돌아보고 꼭 구조적으로 해결하기 보다는 작은부분부터 수정해 나가기. 개발 도중 정적이니 동적이니 반응형이니 고정형이니 생각하지 말고 현재 주어진 디자인만 생각하기. 레이아웃 설계는 가능한 그리면서 진행하기. (나중에 레이아웃을 뒤엎는 경우가 생긴다.) flex , float , absolute , grid 특성에 대해서 다시 한번 공부하기","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"CSS-Selector-Organize","slug":"CSS-Selector-Organize","date":"2019-09-22T16:12:32.000Z","updated":"2019-10-02T09:57:06.531Z","comments":true,"path":"2019/09/23/CSS-Selector-Organize/","link":"","permalink":"http://yoursite.com/2019/09/23/CSS-Selector-Organize/","excerpt":"","text":"CSS 선택자 정리 Etc 참고 : CSS 선택자 총 정리 사이트","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"CSS","slug":"Develop/CSS","permalink":"http://yoursite.com/categories/Develop/CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://yoursite.com/tags/Selector/"}]},{"title":"html-css-study-10","slug":"html-css-study-10","date":"2019-09-21T10:58:02.000Z","updated":"2019-10-02T09:03:21.734Z","comments":true,"path":"2019/09/21/html-css-study-10/","link":"","permalink":"http://yoursite.com/2019/09/21/html-css-study-10/","excerpt":"","text":"HTML Study 10 viewport VS % calc flex-basis 반응형 웹페이지 flex 이용 반응형 콘텐츠 -&gt; 이미지&amp;비디오 , iframe grid 이용 오늘의 학습 깨달음 레이아웃 구성 시 여라가지 flex 나 grid시스템을 사용할 수 있지만, 브라우저의 지원 유형을 잘 생각해보아야 한다. padding의 %는 width 기준이다. 즉, 가로의 %기준 만큼 패딩이 늘어난다. iframe은 이미지처럼 max-width 옵션이 작동안한다. 최대 넓이가 1600px 이상 넘어갔을 경우 화면 중앙으로 오게하는 방법 12max-width: 1600px;margin: 0 auto; viewport VS % viewport 는 화면대비 %비율이라 생각하면 편하고, %는 부모영역대비의 %비율이라 생각하면 편하다. 한, 예로 %는 부모영역보다 크게 %를 주어도 부모영역을 벗어날수는 없지만 viewport는 자식요소에 더 큰 viewport값을 줄 경우 부모요소를 넘어갈 수 있다. 초록색 영역이 %비율이고, 보라색 영역이 viewport 이다. calc 단순하게 생각하여, 사칙연산을 실행하고 계산값을 돌려주는 함수이다. calc(100vh - 100px); 와 같이 사용한다. flex-basis flex item이 된 컨텐츠들에게 적용할 수 있는 flex속성이다. flex-basis각 적용될 경우 기본 width값은 무의미하다. flex item이 적용된 width , height를 사용하고 싶다면 flex:auto 를 지정해주어야한다. flex-basis를 생략해면 flex-basis:auto 가 된다. flex-basis:0 과 flex-basis:auto의 차이는 auto는 width 만큼 item을 관리하며, flex-basis는 진짜 item 사이즈를 0으로 만든다. 단, 텍스트같은 콘텐츠가 있을 경우 콘텐츠 크기 만큼 줄게된다. flex-grow는 기본값이 0 / flex-shrink는 기본값이 1이다. 반응형 웹페이지 반응형 웹페이지는 말 그대로 유동적으로 변화가 가능한 웹페이지를 의미한다. 현재 시대는 모바일 , 테블릿 , 데스크탑 과 같은 여러가지 화면을 다루고 있기 때문에 유동적으로 각 기기에 맞는 화면을 송출할 줄 알아야만 한다. 반응형 웹페이지 제작시 주로 다음과 같이 이용한다. @media screen and (길이){ ​ 변할값 } 123456@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; width : 850px; &#125;&#125; 위 웹페이지의 fontsize가 16px이라 가정을 지었을 경우. 799px에서 800px로 넘어가는 순간 header 부분의 width가 850px로 넘어간다. 보통의 웹페이지는 flex,grid같은 시스템을 이용하여 min-width:800px (50em) / min-width:1024px (64em) / min-width:1600px (100em) [font-size : 16px기준] 로 설정해서 반응형을 많이 구축한다. flex 이용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* 모바일 스타일 */ /* 모바일 헤더 */ .header&#123; /* grow shrink basis */ flex-basis: 100%; height: 50px; &#125; /* 모바일 네비게이션 */ .navigation&#123; height: 50px; flex-basis: 100%; &#125; /* 모바일 메인 콘텐츠 */ .main-content&#123; height: calc(100vh - 200px); flex-basis: 100%; &#125; /* 모바일 광고 */ .ad&#123; flex-basis: 100%; height: 50px; &#125; /* 모바일 푸터 */ .footer&#123; flex-basis:100%; height: 50px; &#125;/* 테블릿 스타일 *//* 50em -&gt; 50글자까지 , 폰트사이즈 16px일경우 800px까지 */@media screen and (min-width:50em)&#123; /* 800 헤더 */ .header&#123; flex-basis: 70%; &#125; /* 800 네비게이션 */ .navigation&#123; flex-basis:30%; &#125; /* 800 메인 콘텐츠 */ .main-content&#123; flex-basis:100%; height: calc(100vh - 150px); &#125; /* Tablet 레이아웃 순서 */ .header, .navigation, .ad&#123; order: -1; &#125;&#125;/* 랩탑 스타일 */@media screen and (min-width:64em)&#123; /* 랩탑 순서 */ .navigation&#123; order: -2; &#125; /* 랩탑 헤더 */ .header&#123; flex-basis: 100%; &#125; /* Laptop 내비게이션 */ .navigation&#123; flex-basis: 100%; &#125; /* 랩탑 메인 콘텐츠 */ .main-content&#123; flex-basis: 70%; &#125; /* 랩탑 광고 */ .ad&#123; flex-basis: 30%; height: calc(100vh - 150px); &#125;&#125;/* 와이드 랩탑 스타일 */@media screen and (min-width:100em)&#123; /* 와이드 랩탑 헤더 */ .navigation, .ad&#123; order: 0; &#125; .navigation, .main-content, .ad&#123; height: calc(100vh - 100px); &#125; /* 와이드 네비게이션 */ .navigation&#123; flex-basis: 30%; &#125; /* wide 메인 콘텐츠 */ .main-content&#123; flex-basis: 50%; &#125; /* wide 광고 */ .ad&#123; flex-basis: 20%; &#125;&#125; 반응형 콘텐츠 : 이미지&amp;비디오이미지 소스(비디오도 동작방식은 같다.) 1234567891011121314151617181920@charset \"utf-8\";/* 반응형 이미지 */.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; flex-basis: 50%; border: 10px solid #aaa; box-sizing: border-box; margin: 0; padding: 0;&#125;.rwd-img&#123; max-width: 100%; height: auto;&#125; 반응형 콘텐츠 : iframeiframe은 비디오와는 다르게 화면 비율에 대해 신경을 써주어야만 한다. 1234567891011121314151617181920212223242526 &lt;div class=\"container\"&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rNDmpbs4JTc\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\"width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nSHs3241p7E\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Vtj-T2c6jf0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;figure class=\"rwd-container\"&gt; &lt;!-- frameborder=\"0\" 제거 allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" 제거 --&gt; &lt;div class=\"rwd-iframe-container\"&gt; &lt;iframe class=\"rwd-iframe\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/G-12mgNUwh0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/figure&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233@charset \"utf-8\";.container&#123; display: flex; flex-wrap: wrap;&#125;.rwd-container&#123; border: 10px solid teal; box-sizing: border-box; margin: 0; padding : 0; flex-basis: 30%; flex-grow : 1;&#125;.rwd-iframe-container&#123; width: 100%; padding-top: 56.25%; height: 0 !important; background: yellow; position: relative;&#125;.rwd-iframe&#123; /* iframe은 이미지처럼 max-width 옵션이 작동안한다. */ max-width: 100%; height: auto; position: absolute; top : 0; left : 0; width: 100%; height: 100%;&#125; grid 이용grid시스템 이용시 Chrome 보다는 firefox에서 확인한는게 더 편한다. 부모요소에서 display: grid; 를 쓰면서 시작할 수 있다. repeat함수 -&gt; repaet(반복할횟수, 크기[1 2) 크기 1개만 적을시 1개만 횟수만큼, 크기 1 2 다적을 시 배열식으로 적용한다.fr = fraction 분수단위 grid에서 순서를 지정해주고 싶다면 order를 쓰면 된다. 모든 기본 order값은 0이다. grid-auto-rows : 크기 / 콘텐츠 갯수만큼 자동적으로 적은 크기의 행을 만들어준다. grid-template-columns : 크기 / 크기 갯수만큼 적어 열을 생성한다. grid-template-rows : 크기 / 크기 갯수만큼 적어 행을 생성한다. grid-column-gap: 크기 / 각 콘텐츠 사이에 적은 크기의 마진을 발생시킨다. 라인 넘버 지정방법. 123456789101112131415.container&#123; display: grid grid-template-columns: 1fr 3fr 1fr; /* 3개의 열을 각각 5분의 1,3,1크기로 선언한다. */ grid-template-rows: repeat(3, 50px); /* 3개의 행을 50px크기로 선언한다.*/ &#125; .header&#123; /* grid-row : 1/2; grid-column : 1/4; */ /* row시작점 column시작점 row끝나는점 column끝나는점*/ grid-area: 1/1/2/4; &#125; /* 위에 구문은 병합 span으로도 아래처럼 사용이 가능하다. */.header&#123; grid-ared : 1/1/span 1/span 3; &#125; area 지정방법. 123456789101112131415161718192021222324252627282930313233343536@media screen and (min-width:50em)&#123; .container&#123; margin : 0 auto; max-width: 1600px; grid-template-columns: 1fr 3fr 1fr; grid-auto-rows: minmax(50px,auto); /* 최소 높이 50px이고 글자(텍스트 -콘텐츠)가 늘어남에 따라 auto로 상자가 늘어남. */ /* 아래에서 grid-area: 이름 ; 으로 지정한 것을 grid-template-areas에 각각 넣어준다. */ grid-template-areas: \"header header header\" \"navigation content ad\" \"footer footer footer\"; &#125;&#125; .container&#123; display: grid;&#125;.header&#123; grid-area: header;&#125;.navigation&#123; grid-area: navigation;&#125;.content&#123; grid-area: content;&#125;.ad&#123; grid-area: ad;&#125;.footer&#123; grid-area: footer;&#125; gird 시스템 이용시 짧게 사용할 경우 area:이름 기법이 훨씬 간편하지만, 열과 행이 많을 경우에는 line기법이 수월하다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-09","slug":"html-css-study-09","date":"2019-09-19T17:38:10.000Z","updated":"2019-10-02T09:03:14.524Z","comments":true,"path":"2019/09/20/html-css-study-09/","link":"","permalink":"http://yoursite.com/2019/09/20/html-css-study-09/","excerpt":"","text":"HTML Study 09 q , blockqueto 태그 + cite 속성 small 태그 address 태그 flex 속기법 + order, grow , shrink flex-basis aside 태그 CSS animation : transition background 속기법 태그들이 공통으로 사용가능한 속성 오늘의 학습 깨달음 의미없는 구분자들은 마크업 하지 않는다. 만약 의미없는 img 태그들을 사용해야할 경우 alt값은 비워둔다 ( alt = “” ) img 태그를 사용할 것인지, 일반적인 태그를 이용하고 SEO적인 내용을 붙인 후 CSS 배경처리를 할 지 고민이 필요함. 사이트를 마무리하는 영역인 footer에서는 heading 태그를 사용하지 않는다. header 태그의 대신 역할 role=”banner” 와 footer 태그의 대신 역할 role=”content-info”등은 article 태그나 section태그 내에서 사용하면 안된다!!!! 반드시, body 태그의 직계 자식 요소로 사용되는 태그들의 역할 모델이 되어야만 한다. button 태그 사이의 띄어쓰기는 요소검사로 잡기 힘드니 button 태그가 나란히 사용되었을 때, 간격이 있다면 확인할 것. 레이아웃 작업 시, 가능한 노말플로우를 유지하라. 레이아웃 작업 시, 더 간단하고 쉽게 적용가능한 방법들을 모색하라. q , blockqueto 태그 인용임을 나타내는 태그에는 q와 blockquote가 있다. q는 문단 안에서 인용할 때 사용하는 인라인 요소이고, blockquote는 새로운 문단에서 인용하는 블록 요소 이다. 12345678q&#123; quotes: \"[[\" \"]]\"; &#125; /* 사용한 태그의 앞과 뒤에 [[ 과 ]] 이 생긴다.*//*혹은 한쪽만 선택하고 싶을경우 다음처럼도 이용함.*/q::after&#123; content: \"\";&#125; 인용문 출처는 cite 속성 을 이용한다. 1&lt;q cite=\"https://www.codingfactory.net/\"&gt;consectetur adipiscing&lt;/q&gt; small 태그 small 태그는 저작권, 면책조항, 주의사항, 법적 제한 사항, 주석표시에 사용한다. small 태그는 부가 정보를 나타내는 주석표시이므로, 여러 단락이나 광범위한 텍스트가 포함된 섹션에서는 사용하지 않는다. 1&lt;small class=\"copyright\"&gt; Copyright since &amp;copy; 2010 by Web Cafe &lt;/small&gt; address 태그 address는 소유자 또는 작성자의 연락처를 나타내는 태그. body 태그 안에 있으면 문서의 소유자 또는 작성자의 연락처를 나타냄. article 태그 안에 있으면 기사의 소유자 또는 작성자의 연락처를 나타냄. 기본 모양은 기울임꼴. 12345&lt;address class=\"address\"&gt; &lt;span&gt;서울시 강남구 성수동 &lt;/span&gt; &lt;span&gt;전화 : 02-1234-5678 &lt;/span&gt; &lt;span&gt;email : iasg2004@gmail.com&lt;/span&gt;&lt;/address&gt; &lt;!-- span을 준 이유 : 간격을 관리가 편해서 --&gt; flex 속기법 + order, grow , shrink flex : flex-grow flex-shrink flex-basis Flex 한국어 정리 사이트 order Item의 순서를 설정.Item에 숫자를 지정하고 숫자가 클수록 순서가 밀린다.음수가 허용. flex-grow Item의 증가 너비 비율을 설정.숫자가 크면 더 많은 너비를 가짐.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-shrink Item이 감소하는 너비의 비율을 설정.숫자가 크면 더 많은 너비가 감소.Item이 가변 너비가 아니거나, 값이 0일 경우 효과가 없다. flex-basisItem의 (공간 배분 전) 기본 너비를 설정.값이 auto일 경우 width, height 등의 속성으로 Item의 너비를 설정할 수 있다.하지만 단위 값이 주어질 경우 설정할 수 없다. 값 의미 기본값 auto 가변 Item과 같은 너비 auto 단위 px, em, cm 등 단위로 지정 flex 속성에서 설명한 것 같이 단축 속성 내에서 flex-basis를 생략하면 값이 0이 되는 것을 주의합시다. aside 태그&lt;aside&gt; 컨텐츠는 추가되어야 할 요소이지만, 메인 컨텐츠를 이해하기 위해 필수적인 것은 아니다. 예를 들어, 각주는 추가적인 정보를 제공하지만 필수적이지 않다. 그리고 발췌문은 필수적인 컨텐츠인 반면, 메인 컨텐츠에서 인용된 카피 문구이다. 하지만, &lt;aside&gt;는 관련성이 있어야 한다는 사실을 명심해야 한다. 사이트의 사이드바를 &lt;body&gt;의 자식요소로&lt;aside&gt;에 넣는 것은 좋다. 하지만 사이트 전반에 걸친 정보를 &lt;article&gt;의 자식요소로서 &lt;aside&gt; 안에 보여져서는 안되는 것. 그리고 &lt;aside&gt; 요소가 그 부모 섹셔닝 요소에 관련만 있으면, 광고에도 적합하다. 123456789&lt;aside&gt; &lt;p&gt; &lt;em&gt;섹셔닝 루트&lt;/em&gt; 요소에는 &lt;blockquote&gt;, &lt;body&gt;, &lt;details&gt;, &lt;fieldset&gt;, &lt;figure&gt;,&lt;td&gt;가 있다. &lt;/p&gt; &lt;/aside&gt; &lt;p&gt; &lt;header&gt;와 &lt;footer&gt;는 현재 속해 있는 섹셔닝 요소 또는 '섹셔닝 루트' 요소에만 적용된다.&lt;/p&gt; CSS animation : transition​ CSS transition은 :hover , :focus 와 같은 이벤트에 CSS 장면전환을 주기 위한 옵션이다. 12345678910.list&#123; transition : height 3s 0s, padding 3s 0s, background 2s 3s; /* 속성 지속시간 딜레이 */&#125;.list:hover, .list:focus&#123; padding : 10px; background: yellow; height : 100px;&#125; 위 구문은 list 클래스에 마우스가 올라가거나 , 키보드로 선택이 되었을 경우 3초에 동안 높이가 100픽셀 , 패딩이 10픽셀 늘어난다. 3초 기다린 후 2초동안 점점 노란색으로 배경색이 변경된다. background 속기법123456789101112/* background-image background-position [/background-size] repeat-style attachement box background-color */ h1 &#123; background: url('img.jpg') 0 50% /8em no-repeat fixed border-box blue; &#125;/* background-image repeat-style background-position attachement */ h2&#123; background: url(./images/bg_flower.png) no-repeat 50% 0 fixed, #eee linear-gradient(#ccc,#eee,#fff) repeat 0 0 fixed;&#125; /* 배경 이중 중첩, 먼저 나온 배경이 위로.*/ 태그들이 공통으로 사용이 가능한 속성 title id style class lang data-*","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-08","slug":"html-css-study-08","date":"2019-09-18T17:58:58.000Z","updated":"2019-10-02T09:03:05.164Z","comments":true,"path":"2019/09/19/html-css-study-08/","link":"","permalink":"http://yoursite.com/2019/09/19/html-css-study-08/","excerpt":"","text":"HTML Study 08 position : sticky / fixed counter cursor : pointer calc( ) 함수 tabindex 일자로 요소를 나열하는 4가지 방법( 크게 ) position : sticky / fixed레진 fixed/sticky 참고 sticky sticky는 평소에는 기본 상태였다가 스크롤을 내리면서 임계점에 다했을 시 fixed처럼 요소가 게속 남아있는 형태를 말한다. 필수로 top, right, bottom, left 속성이 필수이다. fixed fixed는 스크롤 유무에 관계의 상관없이 뷰포트에 고정을 하는 것이다. 다만, sticky는 브라우저의 제한이 걸려있다.(아래참조) sticky와 fixed의 차이점은 fixed는 스크롤의 상관없이 뷰포트 자리 고정!, sticky는 스크롤이 다야 적용이된다는 것이다. counter​ css로 요소에 일일이 접근하지 않고 연속적인 리스트등에게 일렬번호등을 붙일 수 있다. 예를들어보자, 1234567891011ol&#123; counter-reset: chapter 0; /* counter-reset으로 초가화 : 카운터명 증가값(생략시 1씩 증가,0도 1씩증가)*/&#125;ol li&#123; counter-increment : chapter;&#125;ol li::before&#123; content : counter(chapter);&#125; cursor여러가지 커서 모양들 cursor : pointer는 마우스가 올라갈시 a링크를 hover한것처럼 마우스 커서가 손가락 표시 모양으로 바뀌게 된다. 그외 추가적인 커서 모양들은 위 링크를 참조하라. calc( ) 함수calc( ) 관련 블로그 CSS3에 새롭게 추가된 기능 중 calc()라는 것이 있다. 계산을 해주는 속성인데 기존에 자바스크립트로 하던 계산을 상당 부분 덜어준다. 예를 들어, 모든 문단을 “100% 너비에서 20픽셀(px)만큼 뺀 너비”로 설정하고 싶다면 다음과 같이 작성한다. 123456p &#123; width : 95%; /* 구식 브라우저를 위한 대비책(fallback) */ width : -webkit-calc(100% - 20px); /* for Chrome, Safari */ width : -moz-calc(100% - 20px); /* for Firefox */ width : calc(100% - 20px); /* for IE */&#125; calc() 내부에 입력할 수 있는 표현식은 +, -, *, / 등의 사칙 연산이 가능하다. 주의할 부분은 사칙 연산시 + 또는 - 는 반드시 기호 양쪽으로 공백을 삽입해야 한다는 것. 속성에 따라 값이 - 로 내려갈 수도 없는 경우가 있다.( width : calc(5px - 10px); = width: 0px; ) tabindex어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법이다. 어떤 엘리먼트에 키보드 포커스를 주는 가장 흔한 방법으로 사용된다. 크게 3가지 속성값을 이용할 수 있다. 0 값 - tabindex=”0” 양수 - tabindex=”1~32768” 음수 - tabindex=”-1” 속성 값이 0인 경우는 탭을 눌렀을 때 포커스가 가지 않는 엘리먼트에게 포커스를 줄 수 있다. 예를 들어, div영역에도 포커스를 줄 수 있다는 의미이다. 속성 값이 -1인 경우는 반대로 탭을 눌렀을 때 포커스가 가는 엘리먼트에게 포커스를 잃게 할 수 있다. 예를 들어, 링크 엘리먼트에 포커스를 잃게 한다는 의미다. 속성 값이 양수인 경우에는 우선순위를 지정해주는 것이다. 예를들어 , h3 tabindex=”6” 이라는 태그가 h3 tabindex=”3” 보다 먼저 나왔어도 키보드 탭 포커스는 3을 먼저 보여주고, 6을 보여줄 것이다. 일자로 요소를 나열하는 4가지 방법( 크게 )123456&lt;ol class=\"favorite-list\"&gt; &lt;li class=\"no1\"&gt; &lt;a href=\"#\"&gt;W3C&lt;/a&gt; &lt;em class=\"up\"&gt;상승&lt;/em&gt; &lt;/li&gt; &lt;/ol&gt; 위 그림과 같이 일자로 구성된 요소가 있다고 가정했을 떄. 만드는 방법은 크게 4가지가 존재한다. 1. flex flex는 가장 쉬운 방법이다. 다만, 브라우저 지원을 잘 확인해야만 한다. 12345678910.favorite-list li&#123; display : flex; align-items: center; /*y축 중간 매치*/ &#125; .favorite-list em &#123; margin-left: auto; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/&#125; 2. float float의 단점은 일자로 나열하고 하는 요소들의 높이가 모두 같다면 크게 문제가 없지만 높이의 차이가 존재한다면 억지로 높이를 맞춰주어야만 한다. 12345678910.favorite-list li::before&#123; float : left; &#125;.favorite-list a&#123; float : left;&#125;.favorite-list em &#123; float : right;&#125; /* 높이의 차이 때문에 억지로 크게를 맞춰주어야한다.*/ 3. position 부모요소에 relative를 주고 왼쪽부터 작성되는 html 특성을 고려하여 가장 오른쪽 상승,하락 그림만 absolute를 이용하여 오른쪽에 배치하는 기법이다. 12345678910111213141516171819.favorite-list li&#123; position: relative;&#125; .favorite-list li::before&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list a&#123; display: inline-block; vertical-align: middle;&#125;.favorite-list em &#123; position : absolute; margin-top : -5px; /*absolute를 이용함으로서 상승,수직 이미지를 오른쪽으로 붙어버린다.*/ top : 50%; /* top과 margin은 글씨가 많아서 칸이 넘어가도 상승 좌표도 덩달아 움직이게 하기 위함이다.*/ right : 0;&#125; 4. inline-block inline-block에서 margin-left를 이용하여 em요소를 오른쪽으로 보내버리는 방법이다. inline-block에서의 특징은 반드시 정렬하고자는 요소들은 모두 width값들이 명시가 되어야만 한다. 그래야 컴퓨터가 maring-left : auto 값을 계산하여 em요소를 오른쪽에 배치시킬수 있다. 1234567891011121314151617.favorite-list li::before&#123; display: inline-block; vertical-align: middle; width: 20px;&#125;.favorite-list a&#123; display: inline-block; width: 120px; vertical-align: middle;&#125;.favorite-list em &#123; display: inline-block; width: 9px; /*em은 inline 이지만 flexitem화되어서 가능함*/ margin-left: auto; vertical-align: middle;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-07","slug":"html-css-study-07","date":"2019-09-16T18:12:39.000Z","updated":"2019-10-02T09:02:57.136Z","comments":true,"path":"2019/09/17/html-css-study-07/","link":"","permalink":"http://yoursite.com/2019/09/17/html-css-study-07/","excerpt":"","text":"HTML Study 07 article태그 강조 태그 ( em , strong ) font weight 가중치 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 agent-style 시 확인해야할 점들. float 대신에 inline-block 사용시 주의점. 밑줄 gradient 만드는 방법들. 애니메이션 방법들 article 태그 article 요소는 독립적이고 재배포하며 재사용 가능한 , 홀로 설 수 있는 내용들을 위주로 담는다. article 내부에는 header태그,footer등을 삽입할 수 있다. 주로 블로그 글, 포럼 글, 뉴스 기사, RSS피드 등이 article에 해당된다. 강조 태그 강조하는 태그 em em보다 더 큰 강조를 하는 strong 의미없이 글자크기만 굵게 하는 b태그 의미없이 기울이는 i태그 주로, 작품명(그림명, 책명, 영화명 등)을 표시하거나 인용할 때 사용 시멘틱점 관점으로 strong이 em보다 강조도가 높다. 디자인적 요소로는 em은 기울임, b와 strong은 굵게 표시한다. cite태그는 작품명 ,인용시 사용한다. b태그는 단순히 의미는없고 굵게만 표시한다. i태그는 단순히 의미없고 기울이게만 표시한다. font-weight 가중치웹 폰트 파헤치기 웹 폰트는 그룹화가 가능하다. 예를 들어보면, 다음과 같다. 12345678910111213141516171819@font-face &#123; font-family: Ngothic-Regular; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Bold; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-ExtraBold; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: Ngothic-Italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 나눔고딕 보통, 굵게 , 아주굵게, 이탤릭 을 사용한다고 가정시 보통 웹폰트의 이름을 모두 다르게 붙이고 필요에 따라 각 스타일을 호출한다. 이와 같이 같은 나눔고딕들을 묶어서 사용하는 방법이 바로 font-weight 다. 다음 코드를 보자. 123456789101112131415161718192021222324@font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; src: url('NanumGothic-Regular.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 700; src: url('NanumGothic-Bold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 800; src: url('NanumGothic-ExtraBold.woff') format('woff');&#125; @font-face &#123; font-family: \"Nanum Gothic\"; font-weight: 400; font-style: italic; src: url('NanumGothic-Italic.woff') format('woff');&#125; 위와 같이 font-family는 나눔고딕이라는 그룹으로 맺고 각 weight와 style을 통해 각 글꼴을 선택할 수 있게된다. 123456body &#123; font-family: \"Nanum Gothic\" &#125; h1 &#123; font-weight: 400 &#125; /* NanumGothic-Regular.woff */h2 &#123; font-weight: 700 &#125; /* NanumGothic-Bold.woff */h3 &#123; font-weight: 800 &#125; /* NanumGothic-ExtraBold.woff */h4 &#123; font-weight: 400; font-style: italic &#125; /* NanumGothic-Italic.woff */ 데이터는 숨기고 이미지를 표기하는 IR 기법. 종류 및 장단점 글자 위에 이미지로 해당 글자를 가려야 할 경우. 사용하는 기법들. 글자를 안사용하고 바로 이미지만 넣을 수는 있으나 SEO관점에서 불리하다. 따라서 글자는 적되 이미지를 특정기법을 이용하여 덮음으로써 SEO관점과 시각적 요소 모두 챙긴다. padding을 활용한 IR 기법 기본적인 방법. 높이를 0으로 줘서 그림 아래로 텍스트를 내려버린다. 그 후 overflow:hidden 속성을 이용하여 텍스트를 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 12345678910111213@charset \"utf-8\";/* padding을 활용한 IR 기법 */.brand1&#123; background:yellow url(../images/title.png) no-repeat; height: 0; width: 290px; padding-top: 195px; overflow: hidden;&#125;/* 위 2가지 트릭의 단점 -&gt; 네트워크의 오류로 인해 이미지가 안날라올경우 문제가 있다. */ text-indent를 이용한 IR 기법 넓이를 지정해놓고 , 들여쓰기를 넓이만큼 준다. 개행 금지 속성을 이용하여 텍스트가 다음 줄로 못내려가게 막고 화면을 넘어가버린 텍스트는 overflow:hidden 속성을 통해 가려버린다. 단점, 네트워크 오류시 시각이미지를 못불러온다. 또한 overflow: hidden 을 주었기 때문에 이미지도 안보이고 해당 텍스트 또한 안보이기 때문에 무슨 이미지인지 전혀 유추를 할 수 없다. 123456789/* text-indent 트릭을 이용한 IR 기법 */.brand2&#123; background:pink url(../images/title.png) no-repeat; height: 195px; width: 290px; text-indent: 290px; white-space: nowrap; overflow: hidden;&#125; position 트릭 가상요소를 이용하여 텍스트는 자리 그대로 유지하고 absolute한 가상요소 이미지로 덮어씌운다. 네트워크 에러시 이미지가 안날라와도 가려져있던 텍스트가 보이게 됨으로써 무슨 텍스트인지 유추가 가능하다. 123456789101112131415161718192021222324/* 한줄일때만 이용 가능한 트릭. position트릭. 네트워크 오류로 이미지가 안날라올경우 가상요소는 안보이고 덮어쓰기 전의 내용이 보인다. */.brand3&#123; background: lime; height: 195px; line-height: 195px; width: 290px; text-align: center; font-size : 16px; font-weight: 400; position : relative;&#125;.brand3::after&#123; content: \"\"; position: absolute; background: orange url(../images/title.png); width: 100%; height : 100%; top: 0; left : 0;&#125; agent-style 시 확인해야할 점들. box 모델 겹침 문제 오타 상속 이슈 레이아웃 (margin, padding, position , display , float …) inline-block 으로 레이아웃 작업시 문제점들 inline-block으로 레이아웃시 다음과 같은 문제가 발생한다. 주의 깊게 봐야되는 점은 묻고답하기 오른쪽에 존재하는 Border 선과의 사아아알짝 떨어진 여백이다. 보통 li태그를 일자로 나열하는 방법으로 inline-block으로 지정하고서 구분선을 주기 위해 border를 주게되면 위와 같은 여백이 생기게 된다. 이 부분을 아래와 같이 margin값을 -로 주면서 해결을 할 수 있다. 1margin-left: -6px; /*극단적이게 큰 값을 줌.*/ 웬만해서는 float형태나 다른 레이아웃을 권장한다. 밑줄 gradient 만드는 방법들. 가상 요소 absolute 를 이용한 방법. 밑줄을 그리고 싶은 곳에 가상요소를 하나 띄우고 absolute화 한후 높이와 넓이를 맞춰서 대치하는 방법. 123456789.news::before&#123; content: \"\"; background: red linear-gradient(to right,#aaa,#fff); position : absolute; top : 30px; left : 0; width: 80%; height: 1px;&#125; border 선 자체에 gradient를 설정 하는 방법 123456789101112.news-heading&#123; margin : 20px 0; padding : 0 0 15px 0; width : 80%; font-size : 1.5rem; color: #bb7b13; border-style: solid; border-image: linear-gradient(to right, rgb(168, 167, 167), rgb(228, 228, 228)); border-image-slice: 0 0 1 0; border-image-width: 0 0 1px 0; border-left: none;&#125; 애니메이션 방법들 CSS 애니메이션 사용하기 참고 123456789101112131415161718192021/* 1번 Fade Slide In From Top */ @keyframes fade-slide-in-from-top &#123; 0% &#123; transform: translateY(-4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.app-header &#123; opacity: 0; animation: fade-slide-in-from-top 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 2번 Fade Slide In From Left */@keyframes fade-slide-in-from-left &#123; 0% &#123; transform: translateX(-4rem); /*right는 transform: translatxX(4rem);*/ opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.brand &#123; opacity: 0; animation: fade-slide-in-from-left 0.35s 0.4s ease-out forwards; &#125; 12345678910111213141516171819202122232425262728293031323334353637/* 3번 Fade In &amp; out */@keyframes fade-in &#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;button[title=\"메뉴 열기\"] &#123; opacity: 0; animation: fade-in /* name */ 0.35s /* duration */ 0.4s /* delay */ ease-out /* timing function */ forwards; /* fill mode */&#125;@keyframes fade-out &#123; 0% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125;.button[title=\"메뉴 열기\"] &#123; animation: fade-out 0.35s 0.4s ease-out forwards; &#125; 123456789101112131415161718192021/* 4번 Fade Slide In From Bottom */@keyframes fade-slide-in-from-bottom &#123; 0% &#123; transform: translateY(4rem); opacity: 0; &#125; 100% &#123; transform: none; opacity: 1; &#125;&#125;.ediya-menu__item &#123; opacity: 0; animation: fade-slide-in-from-bottom 0.35s 0.4s ease-out forwards; &#125; 1234567891011121314/* 5번 Motion Sequnce Animation */.ediya-menu__item &#123; /* 0% */ opacity: 0; transform: translateY(4rem); /* 100% */ animation: transform-none 0.3s 0.85s cubic-bezier(0.6, 0.01, 0.16, 1) forwards;&#125; /* 시간 차 애니메이션 */.ediya-menu__item:nth-child(1) &#123; animation-duration: 0.8s &#125;.ediya-menu__item:nth-child(2) &#123; animation-duration: 1.2s &#125;.ediya-menu__item:nth-child(3) &#123; animation-duration: 1.6s &#125;.ediya-menu__item:nth-child(4) &#123; animation-duration: 2.0s &#125; 그외 사이트 참조 Effective Management 애니메이션 코드 수 줄이고 관리하기. Text Sequencing Motion Stop &amp; Play Animation for Everyone (애니메이션 껏다 켜기 버튼기능)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"java-tips02","slug":"java-tips02","date":"2019-09-13T16:12:50.000Z","updated":"2019-10-02T09:59:33.239Z","comments":true,"path":"2019/09/14/java-tips02/","link":"","permalink":"http://yoursite.com/2019/09/14/java-tips02/","excerpt":"","text":"####1. String == 와 equals의 차이점 String으로 = =을 비교시 주소를 비교하는것이다. 따라서 내부 값을 비교하기 위해서는 equals를 쓰도록한다. 참고로 문자열말고 문자는 그냥 ==으로 하여도 무방함. ex) char A == ‘6’; 123456789101112131415// 둘다 똑같은 값을 가지고 있으니까 참 new String(\"test\").equals(\"test\") // --&gt; true // new String으로 새로운 객체를 생성하고 \"test\"는 다른 객체여서 falsenew String(\"test\") == \"test\" // --&gt; false // \"test\"라는 값을 가진 객체를 둘다 각자 생성해서 falsenew String(\"test\") == new String(\"test\") // --&gt; false // \"test\" \"test\"를 컴파일러는 같은 객체로 봐서 참 \"test\" == \"test\" // --&gt; true // checks for nulls and calls .equals()Objects.equals(\"test\", new String(\"test\")) // --&gt; trueObjects.equals(null, \"test\") // --&gt; false 02. charAt() , toCharArray() charAt() : 문자열타입에 저장된 값들을 배열형태로 인식하여 반환하는 함수. to.CharArray() : 문자열에 있는 모든 내용을 문자배열로 반환하는 함수. 12345678910111213141516 String a=\"001100111\";char[] x = a.toCharArray();for(int i=0;i&lt;a.length();i++)&#123;if(a.charAt(i)=='0')&#123; System.out.print(\"영\");&#125;else&#123; System.out.print(\"일\");&#125;&#125;System.out.println();for(int i=0;i&lt;a.length();i++)&#123;System.out.print(x[i]);&#125; System.out.println(); 03_1. 형변환 (요약) Integer.parseInt( ) -&gt; 문자열 -&gt; 정수 String.valueOf( ) -&gt; 정수 -&gt; 문자열 12345int a = 0;String s = \"55\";int a = Integer.parseInt(s); //a=55String s = String.valueOf(a+10); //s=\"65\" 03_2. 형변환 (목록) ①. 문자열에서 정수형으로 변환 (String to int) - int i = Integer.parseInt(String str); ②. 정수형을 문자열로 변환 (int to String) - String str = Integer.toString(int i); - String str = String.valueOf(int i); ③. 형식에 맞춰서 변수들을 문자열로 변환 (c언어의 printf 동일) - int i; float f; String str = String.format(“%d %f”,i,f); ④. 문자열에서 다른 숫자형태로 변환 - float f = Float.parseFloat(String str); // String to float - double d = Double.parseDouble(String str); // String to double - byte b = Byte.parseByte(String str); // String to byte - long l = Long.parseLong(String str); // String to long - short s = Short.parseShort(String str); // String to short ⑤. 다른 숫자형태에서 문자열로 변환 - String str = String.valueOf(boolean b); // true 또는 false가 str에 저장됨. - String str = String.valueOf(char c); // char to String - String str = String.valueOf(char[] data); // char array to String - String str = String.valueOf(double d); // double to String - String str = String.valueOf(float f); // float to String - String str = String.valueOf(long l); // long to String - String str = String.valueOf(Object o); // Object to String , o == null이면 “null” 이 되고 o!= null이면 o.toString()함수의 반환값은 str - String str = String.valueOf(char[] data, int offset, int count); // offset 의 index부터 count 개의 문자로 부분문자열 생성","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"http://yoursite.com/categories/Develop/Java/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"java-tips01","slug":"java-tips01","date":"2019-09-13T16:06:51.000Z","updated":"2019-10-02T09:59:24.672Z","comments":true,"path":"2019/09/14/java-tips01/","link":"","permalink":"http://yoursite.com/2019/09/14/java-tips01/","excerpt":"","text":"####1. charAt(i) charAt(i)는 문자열(String)을 대상으로 한다. 문자열의 i-1번째에 위치한 문자열을 char형으로 반환한다 12String n = \"abcda\";n.charAt(0) // char형으로 a를 의미. 즉, 'a'을 반환. 2. indexOf(문자열) indexOf(“문자열” || ‘문자’)은 문자열(String)을 대상으로 한다. (“문자열” || ‘문자’)가 해당 문자열(String)내에 존재할 경우 존재하는 위치를 값으로 반환한다. 만약 존재하지 않을 경우 -1을 반환한다. *주의점 1 : 첫 위치만 반환한다. *주의점 2 : 문자열을 대상으로한다. char형은 대상이 아니다. *주의점 3 : 매개변수는 문자(char형)도 가능하다. 12String n = \"abcda\";n.indexOf(\"a\") // 0을 반환한다. 4번째에도 a가 있지만 처음에 있는 위치만 반환한다. 3. replace(),replaceAll(), replaceFirst() replace 관련 함수를 이용하여 치환 혹은 제거가 가능하다. replace(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거 replaceAll(“찾는 문자열”,”바꿀 문자열”) -&gt; 모든 문자열을 치환 혹은 제거. replace와 다른 점은 정규식도 사용 가능. repaceFirst(“찾는 문자열”,”바꿀 문자열”) -&gt; 조건에 있는 첫 문자열을 치환 혹은 제거. * 주의점 1 : 바꿀 문자열을 “”으로 줄 경우 제거가 됨. * 주의점 2 : 반드시 반환 대상이 있어야 됨. 자기 자신으로라도 반환을 해주어야함.(당연한 것) 12345678910111213141516171819202122String s = \"봉숭아 학당! 봉숭아 학당!\"; // 원본 문자열String s2; // (1) s2 = s.replace(\"숭아\", \"맹구\"); System.out.println(\"치환(1): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (2) s2 = s.replaceFirst(\"숭아\", \"맹구\"); System.out.println(\"치환(2): \" + s2); // 출력 결과: 봉맹구 학당! 봉숭아 학당! // (3) s2 = s.replaceAll(\"숭아\", \"맹구\"); System.out.println(\"치환(3): \" + s2); // 출력 결과: 봉맹구 학당! 봉맹구 학당! // (4) s2 = s.replace(\"숭아\", \"\"); System.out.println(\"치환(4): \" + s2);// 출력 결과: 봉 학당! 봉 학당! 04. char형 아스키코드를 이용한 알파벳배열 초기화. 아스키 코드를 이용하여 알파벳 배열을 만들 수 있다. 이런식으로 아스키코드를 이용한 조건을 만들 수도 있다. 123456char[] alphabet = new char[25];for(int i=0;i&lt;25;i++)&#123; alphabet[i] = (char) (i+65);&#125; // A - 65System.out.println(alphabet[0]); //'A' 출력됨.","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"Java","slug":"Develop/Java","permalink":"http://yoursite.com/categories/Develop/Java/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"html-markup","slug":"html-markup01","date":"2019-09-12T16:01:04.000Z","updated":"2019-10-02T09:04:05.708Z","comments":true,"path":"2019/09/13/html-markup01/","link":"","permalink":"http://yoursite.com/2019/09/13/html-markup01/","excerpt":"","text":"123456789101112131415161718192021&lt;section class=\"news\"&gt; &lt;h2 class=\"news-heading\"&gt; 새소식 &lt;/h2&gt; &lt;a href=\"#\" class=\"news-link\"&gt; &lt;dl class=\"news-list\"&gt; &lt;dt class=\"news-title\"&gt; &lt;span&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/span&gt; &lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; &lt;/dt&gt; &lt;dd class=\"news-description\"&gt; 디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다. &lt;/dd&gt; &lt;/dl&gt; &lt;figure class=\"news-thumbnail\"&gt; &lt;img class=\"news-thumbnail-image\" src=\"./images/news.gif\" alt=\"W3C 리뉴얼\"&gt; &lt;figcation class=\"news-thumbnail-title\"&gt;W3C 리뉴얼&lt;/figcation&gt; &lt;/figure&gt; &lt;/a&gt; &lt;a href=\"#\" class=\"icon-plus news-more\" title=\"새소식 더보기\" aria-labelledby=\"news-link\"&gt;더보기&lt;/a&gt;&lt;/section&gt; webcafe.html 부분 새소식 영역 마크업 및 html 구성","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"MarkUP","slug":"MarkUP","permalink":"http://yoursite.com/tags/MarkUP/"}]},{"title":"html-css-study-06","slug":"html-css-study-06","date":"2019-09-12T13:15:38.000Z","updated":"2019-10-02T09:01:57.604Z","comments":true,"path":"2019/09/12/html-css-study-06/","link":"","permalink":"http://yoursite.com/2019/09/12/html-css-study-06/","excerpt":"","text":"HTML Study 06 MarkUp 짤 때 고민해야하는 점. fieldset 태그의 버그 button태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?) vertical-align / text-align time 태그 block 태그 안에서 여백을 주는 여러가지 방법들. 글자 수 숨기기 (… 처리하기) fontello aria-labelledby MarkUp 짤 때 고민해야하는 점.​ MarkUp시 너무 많은 버튼에 대한 고민을 해야만 한다. 예를들어보자, 위와 같은 공지사항과 자료실에 대한 게시물 리스트를 모아놓은 영역을 마크업 해야할 때, 보통의 경우라면, 다음과 같이 생각할것 같다. 공지사항 , 자료실은 서로 다른 영역이다. 게시물 목록을 나열한다. 더보기 버튼을 나눈다. 결론적으로, 공지사항 - 목록 - 더보기 | 자료실 - 목록 - 더보기 구성이 되겠다. 문제는 이와같은 구성시 너무 많은 탭을 요구하게 된다. 비장애의 영역에서는 시각을 통해 여러가지 정보를 한번에 확인을 할 수 있지만, 장애 또는 봇의 영역에서는 눈대신 청각에 의존해야한다. 스크린 리더기가 모든 게시물 제목을 하나하나 전부 읽는다는 것은 너무 힘들고 듣는다는것도 힘들것이다. ! 해결법은 무엇인가?​ 해결법이야 여러가지 방법이 존재하겠지만, 그 중 대표적인 예를 들어보면 - 공지사항,자료실 같은 수많은 포커스가 되는 영역에서는 방향키 화살표를 통해 읽고 싶은 요소만 선택하게 하는것이다. 공지사항 자료실 세션 1 목록 더보기 세션2 목록 더보기 [이를 적용한 대한항공 사이트] https://www.koreanair.com/content/koreanair/global/en.html/ fieldset 태그의 버그​ fieldset 태그는 보통 form 태그 내부에서 쓰인다. form - fieldset + legend + label + input 형식으로 많이 사용하는데, 여기서 fieldset 태그에 flex를 주게 될 경우, 크롬에서는 버그를 일으키게된다. ( 보통, form태그에 display:flex를 주면 크롬은 flex가 적용이 안되는 버그를 일으킨다. ) 해결법으로는 form - fieldset + legend + label + input 과 같은 형식에서 form - fieldset - div + legend + label + input 과 같이 태그로 1번더 그룹핑한다. 그리고 div에 flex관련 css 스타일을 주면 해결할 수 있다. [flex 관련 이슈] https://naradesign.github.io/article/flex-browser-compatibility.html button 태그의 버그 (왜? button 대신 a role=”button” 을 이용하는가?)​ button 태그는 브라우저마다 padding , margin 영역이 다른 특성을 가지고 있다. 따라서 a 태그와 WAI-ARIA를 이용하고 role=”button” 을 주어 이 부분을 해결할 수 있다. vertical-align / text-align vertical-align 은 inline 요소를 수직으로 정렬해주는 기능을 담고 있다. text-align 은 block 요소를 정렬해주는 기능으로 block 요소 안에있는 inline 요소들(텍스트나 이미지)등도 같이 정렬해준다. inline 관련 태그에 직접 text-align 속성을 지정해줘도 작동하지 않는다. time 태그​ 이 태그의 용도는 문서 내용 안에 어떤 날짜나 시간을 나타내는 표현이 있을 때 그 부분에 사용하여 알맞은 날짜나 시간을 컴퓨터가 인식할 수 있게 의미적으로 나타내는 데 사용한다. 1&lt;time datetime=\"2018-05-31T13:53:45\"&gt;2018.05.31&lt;/time&gt; block 태그 안에서 여백을 주는 여러가지 방법들.​ 여백을 주는 각 방법들마다 차이가 있으니 확인하고 써야 할 것. 특히 %, auto , 정적px에 대한 차이를 이해하는것이 중요하다. padding ?%; ?px; margin ?%; ?px; width : ?px; width : ?%; margin : auto; calc -&gt; 반응형 글자 수 숨기기 (… 처리하기)​ block 박스에서 글자수가 일정 이상 넘어가서 …을 처리하고 싶다먼 아래 style을 모두 구성해주어야한다. 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; fontello​ 이전에 설명한 fontello를 html문서에서 class 형태로 주어 icon이미지를 생성하면 그 태그 앞에 가상클래스를 자동으로 만들어주고 이미지를 넣게된다. 12&lt;li class=\"icon-dot-circled\"&gt; &lt;!-- li클래스 앞에 가상클래스를 만들고 이미지를 넣는것을 자동으로 해줌. --&gt; ​ fontello.css 에 있는 내용 중… 1.icon-dot-circled:before &#123; content: '\\f192'; &#125; aria-labelledby1 &lt;a href=\"#\" class=\"icon-plus notice-more more\" title=\"공지사항\" aria-labelledby=\"notice\"&gt;더보기&lt;/a&gt; 위 a링크는 aria-labelledby=”notice” 로 인해 id가 “notice”인것을 연결해준다. 1&lt;a href=\"#\" class=\"tab\" role=\"button\" id=\"notice\"&gt;공지사항&lt;/a&gt; JavaScript 맛보기[defer 및 async] https://blog.asamaru.net/2017/05/04/script-async-defer/ 12&lt;script src=\"./js/jquery.min.js\" defer&gt;&lt;/script&gt;&lt;script src=\"./js/webcafe.js\" defer&gt;&lt;/script&gt; 1234567891011var section = $('.board section'); //jqeury lib에서 지원하는 선택 객체var tab = $('.tab');// .on('이벤트명')// tab.on('click keyup',function(e)&#123;tab.on('click', function(e)&#123; e.preventDefault();// 기본 이벤트를 취소함. 예를들면 a의 속성 href의 이벤트를 취소함. // if((e.type === 'keyup' &amp;&amp; e.keyCode === 13) || e.type === 'click')&#123; section.removeClass('tab-act'); $(this).parent().parent().addClass('tab-act');&#125;)//멀티 이벤트 바인딩 예-&gt; 클릭, 마우스온 등 다양한 환경 대응 board라는 이름을 가진 클래스의 section태그의 내용을 section이라는 이름의 변수로 선언. tab이라는 이름을 가진 클래스의 정보를 tab이라는 이름의 변수로 선언. tab이 클릭 되었을 때, 다음과 같은 기능을 수행한다. tab이라는 이름을 가진 클래스의 태그가 가진 기본적인 이벤트 기능을 모두 취소(제거) 한다. board라는 이름을 가진 클래스의 section태그 내부에서 tab-act라고 불리는 클래스를 제거한다. tab이라는 이름을 가진 클래스의 태그의 부모의 부모에게 tab-act라는 클래스네임을 붙여준다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-05","slug":"html-css-study-05","date":"2019-09-10T16:48:58.000Z","updated":"2019-10-02T09:01:51.405Z","comments":true,"path":"2019/09/11/html-css-study-05/","link":"","permalink":"http://yoursite.com/2019/09/11/html-css-study-05/","excerpt":"","text":"HTML Study 05 MarkUp 짜기 로그인창 HTML ~CSS 구성해보기 form 태그 dt dl dd 태그 a태그의 속성 들여쓰기 방법들 line-height 마크업시 생각나는 고민들!div -&gt; 의미없는 정보 section -&gt; 1장 1절 같은 정보 , header 태그가 없으면 경고를 띄운다. article -&gt; 독립된 완결된 정보, RSS , header 태그가 없으면 경고를 띄운다. margin은 겹침현상이 발생한다. box-shadow 도 인접 태그의 margin에 영향을 주지 않는다.(즉, 겹친다.) title은 id, class, style같은 대표속성이며 태그에 사용시 마우스를 올렸을 경우 글박스를 띄운다. text-indent 는 첫줄 들여쓰기를 넣어주는 속성이며, 박스에 영향을 주지않는다. 단, 개행시 유효하지 않은 속성이 된다. 반응형 이미지들은 반드시 등으로 랩핑하는것이 좋다. 이유 : 이미지가 유동적으로 커짐과 줄어듬 MarkUp 짜기​ 간단해보이지만 HTML중 가장 어려운 구간이다. 어떠한 태그를 좋게 사용하느냐, 논리적인 순서를 지켰느냐의 위주로 짜야하며 반드시 디자인적 관점으로 구성하면 안된다! 논리적 순서를 가려낸다. 시멘틱하게 이름 정하기 코드 짜기 대표적인 네이버의 로그인창 예제. 보통 마크업 순서라면 아이디 -&gt; 비밀번호 -&gt; 로그인 -&gt; 로그인 상태 유지 일것이다. 하지만! 논리적으로 계산해보면 로그인 하기전에 로그인상태유지 버튼을 체크하거나 해제하는것이 맞지 않을까? 로그인창 HTML ~CSS 구성해보기 form 태그form 관련 요소 -&gt; 정보를 보내고 받는 값들의 입력 서식을 모아놓은 모음들. https://formspree.io/ : form 정보를 내 이메일로 보내게끔 서비스하는 사이트 . 무료,유료 나뉜다. form , fieldset, legend ==&gt; XHTML 관점에서 다 있어야만 한다. HTML4에서는 form만 있어도 되고 HTML5에서는 둘다 허용이된다. 따라서 form, fieldset , legend, label, input 모두 사용하는 것이 좋다. fieldset은 폼서식을 그룹화하는 것. legend는 그룹화한 폼서식에 대한 제목이다. 하나의 form안에 fieldset은 여러개 들어가도 상관없다. required -&gt; 논리적 검사 예 ) input 태그 안에 required를 적게 되면 이메일 값을 안적을 경우 경고창을 띄운다. form 안 에서 값을 그냥 입력하면 안되고 반드시 1:1로 값을 대입해줘여한다. 아이디 은 입력서식에 대한 이름 이고 는 정보를 입력받는 창이다. placeholder 속성은 입력서식에 대한 예시다. dl dt dd 태그용어를 설명하는 정의형 목록을 만든다. dt -&gt; 용어의 제목을 의미하며 dd는 용어를 설명하는 내용이다. dl dt dd는 정의형 목록을 의미하며 각 태그당 한개씩만 사용하는것이 좋다. dl 안에 태그를 삽입해도 되지만, 아래와 같은 유형만 추천한다. 1234567&lt;dl&gt; &lt;div&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/div&gt;&lt;/dl&gt; &lt;!--가능한 구문. 단, div가 dt나 dd쪽에 들어가서는 안된다.--&gt; a태그하이퍼링크를 걸어주는 태그. 1&lt;a href=\"#\" target=\"_self | _blank | _parent | _top | 프레임명\" &gt;&lt;/a&gt; self -&gt; 기본값 생략가능. target=”_blank”. -&gt; 새창을 열음 parent -&gt; 부모페이지로, iframe에서 사용. top -&gt; 최상위페이지로, iframe에서 사용. 프레임명 : 직접 명시 들여쓰기 방법들 padding margin text-indent line-height1line-height: normal | length | number | percentage | initial | inherit | 숫자값 normal : 웹브라우저에서 정한 기본값. 보통 1.2 length : 길이로 줄 높이를 정한다. number : 글자 크기의 몇 배인지로 줄 높이를 정한다. percentage : 글자 크기의 몇 %로 줄 높이로 정한다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 예) 글자크기가 40px일 때 line-height의 값을 1.5로 하면, 줄 높이는 40의 1.5배인 60px가 된다. 줄 높이는 60px인데 글자 크기는 40px이므로, 글자 위와 아래에 각각 10px의 여백이 생긴다. 줄 높이가 글자 크기보다 작으면 세로 방향으로 글자가 겹치게 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-04","slug":"html-css-study-04","date":"2019-09-09T11:33:31.000Z","updated":"2019-10-02T09:01:40.084Z","comments":true,"path":"2019/09/09/html-css-study-04/","link":"","permalink":"http://yoursite.com/2019/09/09/html-css-study-04/","excerpt":"","text":"HTML Study 04 HTML5 콘텐츠 모델 CSS 셀렉터 html5 표준확인 CSS 구체성점수 Shadow Entity list opcacity 시나리오 작성 z-index background 애니메이션( @keyframes, + 곡선도 ) position, float 다시 정리 float 객체에 강제로 높이 를 알려주는법(overflow, 가상요소 clear:both) float, position:absolute -&gt; display를 block화 시킨다. 오늘의 팁 position : absolute , float는 강제로 display:block 화시킨다. 1에서 한 absolute의 경우 display는 block이 맞지만 마치 inline 형태의 display를 띄고 있으며, absolute 선언 시, block 레벨 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정해야만 하며, 부조 또는 조상요소가 static일 경우, 최종으로는 document의 body태그를 기준으로 위치하게된다. 태그의 링크 클릭 반경을 넓히고 싶다면 padding 을 늘려야 한다. 간단하게 여백을 주는 방법으로는 대표적으로 margin, padding 등이 있다. float화 된 상태에서 부모의 자식들 요소가 모두 float화 되었다면 그 부모요소는 높이를 잃어버리게 된다. 이에 잃어버린 높이를 찾는 3가지 방법이 있다. height = 45px : 높이를 직접 입력 [비추천] &lt;부모&gt; overflow:hidden/auto : overflow 자체는 흘러넘치는 콘텐츠를 다루는 태그지만 overflow태그는 잠재적으로 잃어버린 높이를 일깨워주는 역할을 하기 때문에 사용할 수 있다. clear:both : 가장 좋은 방법. float화된 요소 마지막에 가상자식요소를 생성하여 clear:both를 선언. clear:both는 float요소 중에 높이가 제일 긴 것을 찾아서 강제로 margin을 추가하여 높이가 늘어나 잃어버린 높이를 찾아낸다. 123456.menu::after&#123; content:\"\"; clear: both; /* clear는 display:block 에서만 사용 가능. right, left 등도 있다. */ display: block; &#125; display 숨김처리 12345678910.a11y-hidden &#123; background-color: red; position: absolute; width: 1px; height: 1px; overflow: hidden; margin: -1px; clip: rect(0,0,0,0); white-space: nowrap;&#125; HTML5 콘텐츠 모델 CSS 셀렉터​ 대표적으로 id 셀렉터인 # , 클래스 셀렉터인 점(.) , 전체 선택자인 * 외에도 수많음 셀렉터가 있다. 자세한 내용은 아래 블로그가 정리를 정말 잘 해놓았기에 링크로 남겨둔다. https://code.tutsplus.com/ko/tutorials/the-30-css-selectors-you-must-memorize--net-16048 html 5 표준확인 google에 html w3c 검색 [html5 mulder21c : 블로그] https://mulder21c.github.io/html/ [html5 한글명세서] https://mulder21c.github.io/html/ CSS 구체성 점수​ css 셀렉터에 id, class, tag 이름이 갖는 점수를 계산하여 점수가 높은 selector가 우선순위를 갖는 가상 개념. 대표적으로 id &gt; class &gt; tag 순이며, 제일 높은 html 태그 내부에 적용하는 css가 제일 높은 우선순위를 지닌다. 착각하면 안되는 것!! -&gt; class가 10개 쓰인다고 해서 id보다 높을 수 없다. 체급차이가 다르다고 생각하면됨. 123&lt;div style=\"padding : 20px\"&gt; 이것은 div 태그에 style이 적용된 예입니다.&lt;/div&gt; 추가 important 1234&gt; .menu-act .btn-menu&#123;&gt; color:yellow important;&gt; &#125;&gt; important는 우선순위를 무력화시킬 수 있다. 즉, important 는 지정한 스타일이 안먹는다고 생각햇을떄. 추적할때. 파악용도 클래스가 동적으로 추가될 가능성이 있을떄; 다른 사람이 수정해서 내 소스의 상속이 깨질 우려가 있을 경우. Shadow 그림자를 나타내는 태그는 크게 박스와 텍스트가 있다. 1box-shadow: none | x-position y-position blur spread color | inset | initial | inherit; none : 그림자 효과를 없앤다.. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어진다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어진다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려짐. spread : 양수면 그림자를 확장하고, 음수면 축소. color : 그림자 색을 정한다, inset : 그림자를 요소의 안쪽에 만든다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 1text-shadow: offset-x offset-y blur-radius color | none | initial | inherit offset-x : 그림자의 수평 거리를 정한다. (필수) offset-y : 그림자의 수직 거리를 정한다. (필수) blur-radius : 흐림 정도를 정한다. (선택 : 값을 정하지 않으면 0) color : 색을 정한다. (선택 : 값을 정하지 않으면 브라우저 기본값) none : 글림자 효과를 없앤다. initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. Entity list​ CSS에서 사용할 수 있는 특수문자 리스트. html에서 &amp;&amp;를 그냥 입력하면 안되기 때문에 아래의 리스트를 이용한다. [사용가능한 특수문자 코드 리스트] https://www.w3schools.com/cssref/css_entities.asp Opacity1opacity: number | initial | inherit number : 0.0부터 1.0까지의 수를 넣는다. (투명도 0 -&gt; 불투명 / 1-&gt; 투명) initial : 기본값으로 설정한다. inherit : 부모 요소의 속성값을 상속받는다. 시나리오 작성 CSS의 style을 작성할 때, 시나리오를 작성하며 차근차근 하는것을 익숙해지도록 한다. 예) 글씨가 왼쪽 -&gt; 오른쪽으로 날라옴. : 이동효과 [padding, margin, position-relative, position-absolute] 글자의 투명도를 추가 해야함 . [color: rgba 또는 opacity] 글자 크기의 번화 [font-size] z-index요소들의 배치가 자유로워지면서, 때떄로 서로의 위치를 겹치게 하는 경우가 생긴다. 그 때 사용하는것이 z-index. z-index 값을 지정하기 위해서는 해당 요소의 position 속성이 relative, absolute, fixed 중 하나여야만 한다. [z-index 를 잘 설명한 블로그] http://dev.epiloum.net/904 backgroundbackground-color : yellow 같은 기본 코드 외에도, background는 말 그대로 배경에 대한 색 , 이미지등의 콘텐츠를 다루는 요소 css이다. 123456789/*background-image : url로 2개의 이미지를 불러낸다. */background-image: url('./images/ani_flower_01.png'),url('./images/ani_flower_02.png');/*해당 이미지들은 처음에는 일정 간격마다 반복 되어있기에 반복을 제거한다.*/background-repeat : no-repeat;/*해당 이미지들에 대한 위치값을 지정해준다.*/background-position: 0 -10px, 670px 0; /*x축 y축을 의미*//*위 내용 한꺼번에 입력하기. */background : url('./images//ani_flower_01.png') no-repeat 0 -10px, url('./images/ani_flower_02.png') no-repeat 670px 0; 애니메이션[애니메이션 정리 잘된 블로그] https://brunch.co.kr/@99-life/3 애니 메이션을 사용하기 위해서는 먼저 2가지 조건을 충족시켜야 한다. animation-name : 키프레임 이름 *필수 animation-duration : 시간(s,ms 등등) *필수 animation-fill-mode : forwards; 먼저 keyframes를 선언한다12345678910111213141516171819@keyframes text-ani&#123; 0%&#123; font-size: 12px; color : rgba(0,0,0,0); transform: translate(0,0); /* top: 0; left: 0; *//* margin : 0; *//* padddig : 75px 0 0 400px */ &#125; /* from */ 100%&#123; font-size : 24px; color : rgba(0,0,0,1); transform: translate(400px,75px) /* top : 75px; left:400px; *//*padding:75px 0 0 400px*//*margin:75px 0 0 400px; */ &#125; /* to */&#125;@keyframes bg-ani&#123; 0%&#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125; transform 은 좌표공간을 변형함으로써 일반적인 문서 흐름을 방해하지 않고 콘텐츠의 형태와 위치를 바꾼다. 그 중, transform : translate는 요소의 위치를 이동 시키는 함수이다. 구버전의 browser는 사용이 안된다. animation-duration지속성을 의미한다. 필수조건. 기본적으로 s , ms단위의 시간을 입력한다. 1animation-duration: 5s; animation-fill-mode 속성 및 내용1animation-fill-mode: none | forwards | backwards | both | inherit; none 애니메이션이 끝난 후 상태를 설정하지 않습니다. forwards 애니메이션이 끝난 후 그 지점에 그대로 있습니다. backwards 애니메이션이 끝난 후 시작점으로 돌아옵니다. both 애니메이션이의 앞 뒤 결과를 조합하여 설정합니다. inherit 애니메이션의 상태를 상위 요소한테 상속받습니다. 추가내용 123456789101112/*animation-name: bg-ani;animation-duration: 2000ms;animation-iteration-count: infinite;animation-direction: alternate;animation-timing-function: paused; *//* 위 내용을 짧게 줄인 short 표기법 *//* short표기법 : 이름 듀레이션 딜레이 반복 방향 반복곡선도 */animation: bg-ani 2000ms 1000ms infinite alternate ease-in-out; animation-timing-function에 관한 내용 중 cubic-bezier 에 관한 내용 https://kutar37.tistory.com/entry/CSS-cubic-bezier%EB%9E%80 cubic-bezier 설정하는 곳 https://cubic-bezier.com/#.17,.67,.83,.67","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-03","slug":"html-css-study-03","date":"2019-09-07T12:52:07.000Z","updated":"2019-10-02T09:01:29.872Z","comments":true,"path":"2019/09/07/html-css-study-03/","link":"","permalink":"http://yoursite.com/2019/09/07/html-css-study-03/","excerpt":"","text":"HTML Study 03 가상 요소 nth:child WAI-ARIA a11y-hidden / aria-hidden : 태그 숨김처리 role Web Font - 이미지 아이콘 CSS 단위 float 그림자 gradiunt CSS 색상값 단위 {참고} 가상 요소[가상요소] https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements 가상 요소는 존재하지 않는 요소를 존재하는 것처럼 부여하여 문서의 특정부분을 선택하게 할 수 있다. 대표적인 가상 요소 ::before -&gt; 해당 css의 요소박스 전에 같은 형식의 태그요소를 가상으로 만든다. ::after -&gt; 해당 css의 요소박스 후에 같은 형식의 태그요소를 가상으로 만든다. nth:child[nth:child] http://nthmaster.com/ nth-child는 형제 요소 중에서 특정 순서 요소를 선택하고 싶을 때 사용한다. 1234567.member li:nth-child(n+2)::before&#123;content: '\\f142'; /*가상요소 before 와 after에게 필수*/font-family:'fontello';width: 1em;&#125;/* nth-child를 이용하여 member 하위의 &lt;li&gt;중 2번째 요소부터 끝까지 각 요소 앞에 가상 요소를 생성하고 내용은 '\\f142'를 입력하고 font 와 width를 적용한다.*/ WAI-ARIA [설명] https://www.biew.co.kr/36 WAI-ARIA는 ‘Web-Accessibility Initiative’의 약자로 W3C에서 웹 접근성을 담당하는 조직. ARIA는 리치 인터넷을 위한 W3C의 접근 명세. [W3C에서 제공하는 명세서를 보기 좋게 기술로 변화시킨 레진의 ARIA] https://tech.lezhin.com/2018/04/20/wai-aria a11y-hidden / aria-hidden : 태그 숨김처리a11y-hidden 화면상에서는 안보이나 스크린 리더기 혹은 보조기등에서 보이게 끔 하기 위하여 개안된 CSS스타일. 헷갈리면 안되는것이 WAI-ARIA 에서 재정된 aria-hidden은 클래스명이 아니라 하나의 속성이다! 결국 다른거임. 추가로 off-screen / readable-hidden 등도 있다. aria-hidden 시각장애인, 검색봇, 스크린리더 사용자가 홈페이지에 더 쉽게 접근하기 위해서 읽을 필요없는 요소나 내용을 감춰준다. 외에도 여러가지 태그 숨긴 방법이 있지만, 대표적으로 위와 같은 형태를 권장한다. display:none , visibilitty , hidden 은 비권장. 1234567891011121314/* a11y-hidden */.a11y-hidden&#123; position: absolute; width: 1px; height: 1px; margin: -1px; overflow: hidden; /* 넘치는 부분을 감쳐준다 */ clip: rect(0,0,0,0); /* 선행조건 : position:absolute 해당 화면을 잘라내서 보여줌 */ white-space: nowrap; /* 줄바꿈을 하지않음. */ opacity: 0; /* 투명도 */&#125;/* aria-hidden */&lt;span class=\"line\" aria-hidden=\"true\"&gt;내용&lt;/span&gt; role​ 다른태그에 role로 규정한 태그의 역할? 혹은 기능을 넣을 수 있다. 역시 WAI-ARIA에저 정의한 기술로 https://webdir.tistory.com/89 에 정리가 되어있다. 대표적인 예로는 button이 있으며 , 시멘틱 관점에서도 중요한 역할을 지닌다. role = header,main,contentinfo 는 각각 를 의미한다. 1&lt;a href=\"#\" class=\"btn-menu\" role=\"button\"&gt;CSS에 대해&lt;/a&gt; Web Font - 이미지 아이콘 로컬에 있는 폰트를 쓰는게 아닌 웹에서 폰트를 받았다가 사용함. 저작권에 주의 대표적 : [Font Awesome] https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use [Fontello] http://fontello.com/ Fontello 적용 방법. 다운받은 압축파일을 해제하고 들어가보면 font폴더와 css폴더가 존재한다. 다운받은 font폴더에서 모두 복사하여 하고있는 프로젝트 font폴더에 붙여넣기를 한다.(단, css내부의 font폴더가 아니다.) 다운받은 css폴더에서 fontello.css를 복사하여 하고있는 프로젝트 css폴더에 붙여넣기를 한다. import 시키기 12/* css 파일 */@import url('./fontello.css'); 사용방법은 html 내부 , css 내부 가 있다. 123456789101112&lt;!-- html 내부 --&gt;&lt;!-- class 명으로 선언하여 사용하는 방법. class 명은 다운받은 css폴더에서 확인이 가능하다. --&gt;&lt;a href=\"#\"&gt;&lt;span class=\"icon-ellipsis-vert\"&gt;로그인&lt;/span&gt; &lt;style&gt;/* 사용하고자 하는곳에서 숫자값과 font-family를 선언. 숫자값은 css폴더에서 확인이 가능하다. */ .member li:nth-child(n+2)::before&#123; content: '\\f142'; font-family:'fontello'; width: 1em; &#125;&lt;/style&gt; CSS 단위https://github.com/HYEOK999/TIL/blob/master/HTML-CSS/study01/CSS-7%EA%B0%80%EC%A7%80-%EB%8B%A8%EC%9C%84.md float float는 css에서 정렬하기 위해 사용되는 속성이다. 떠잇다는 의미로 float태그 걸려있는 요소를 띄워서 표시한다. float는 display:block 형태의 태그에만 적요이 가능하다. … float는 글씨가 겹칠수 없는 속성을 가지고 있는 float가 정의된 요소가 공중에 뜬다면 그 다음 글씨는 옆으로 밀어낸다. 만약 float가 정의된 모든 요소가 공중에 떳을 경우, 해당 요소는 크기를 잃기때문에 그 다음 태그 이어지게 보일 수 있다. 따라서 강제적으로 크기를 주거나 overflow:hidden 같은 기능을 이용하여 height 값을 간접적으로 알려줘야만한다. 1234567891011121314151617.box&#123; background-color: lime; /* height: 50px; --- 강제로 높이를 주어 float로 잃어버린 높이를 깨워넴(안쓰는게 좋음) overflow:hidden 은 원래 넘치는 content를 감추는 역할인데 이 속성은 잊혀진 높이등을 일깨워 준다.따라서 float로 잃어버린 높이를 일깨워서 heading3를 밑으로 내린다. */ overflow: hidden; /*넘치는 값을 지워주세요.*/ &#125; .box2&#123; position: relative; top:10px; &#125; .box [class^=\"box\"]&#123; /* border: 1px solid red; */ float: left; &#125; float 는 position: relative와는 겹칠수 있으나 absolute선언시 float는 자동으로 none 값이 된다. clear : both , left , right 각각 float가 걸려있는 요소의 양쪽, 왼쪽, 오른쪽에 있는 요소들에게 clear값을 취소하는것. 이는 반드시 display : block이여만 한다. 그림자 box-shadow: none | x-position y-position blur spread color | inset | initial | inherit none : 그림자 효과를 없앱니다. x-position : 가로 위치입니다. 양수면 오른쪽에, 음수면 왼쪽에 그림자가 만들어집니다. (필수) y-position : 세로 위치입니다. 양수면 아래쪽에, 음수면 위쪽에 그림자가 만들어집니다. (필수) blur : 그림자를 흐릿하게 만듭니다. 값이 클 수록 더욱 흐려집니다. spread : 양수면 그림자를 확장하고, 음수면 축소합니다. color : 그림자 색을 정합니다. inset : 그림자를 요소의 안쪽에 만듭니다. initial : 기본값으로 설정합니다. inherit : 부모 요소의 속성값을 상속받습니다. 12 text-shadow: 1px 0 0 black, -1px 0 0 black, 0 1px 0 black, 0px -1px 0 black;/* 그림자를 각각 위 아래 오른쪽 왼쪽 을 줌으로서 글씨 주변으로 박스 쳐진것처럼 보이게 할수 있다. */ gradient[gradient 가공 사이트] “https://www.colorzilla.com/gradient-editor/&quot; 123456789/* gradient 적용하기- 위 사이트에서 그라디언트 만든 후 복사 후 적용. 단, background를 background-image로 수정.*/.menu&#123;background-image: linear-gradient(to bottom, #f4c730 0%,#f7aa2e 35%,#f7aa2e 70%,#f4c730 100%);/* background-image: linear-gradient(to bottom, red, green,red); 시작 빨간색,끝 - 녹색 */&#125; [++ 추가 사이트] “https://codepen.io/FelixRilling/pen/qzfoc&quot; CSS 색상값 단위 (참고)[CSS 색상 값단위] https://aboooks.tistory.com/279","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"git-gui-study02","slug":"git-gui-study02","date":"2019-09-06T14:38:43.000Z","updated":"2019-10-02T09:56:51.688Z","comments":true,"path":"2019/09/06/git-gui-study02/","link":"","permalink":"http://yoursite.com/2019/09/06/git-gui-study02/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 -\\1. GIT Hubhttp://github.com Build software better, togetherGitHub is where people build software. More than 28 million people use GitHub to discover, fork, and contribute to over 85 million projects.github.com ▷ 버전관리 시스템인 Git을 이용하는 프로젝트들을 위한 원격저장소를 제공하는 서비스▷ 오픈소스는 무료, 비공개 프로젝트는 유료 정책▷ 저장소 크기의 제한이 없다.▷ 로컬 버전관리 시스템이 없이도 많은 작업을 웹상에서 할 수 있으며 따로 설치가 필요없다.▷ 사람 중심의 서비스 구성이기 때문에 특정 저장소에 접근하려면 ‘아이디/저장소명’으로 해야 한다.EX) HYEOK999/TEST01 \\2. Git 사용하기1 ( 저장소 생성 , 첫 버전파일 생성 ) ▷ Source Tree를 처음 실행하여 계정 등록의 절차를 걸치고 난 후에 뜨는 화면입니다.▷ 1번 Local 현재 자신의 pc 저장소를 의미합니다.▷ 2번 Remote는 원격저장소를 의미합니다.SourceTree에 타 원격저장소 Git HUB , Git lab등과 같은 저장소를 이용할때 사용되는 탭입니다.▷ 3번은 클론저장소 입니다.협업 프로젝트 진행 할 때 개발되어진 소스를 처음에 전부 가지고와야될 경우 사용합니다.▷ 4번은 자신의 PC에 이미 생성된 저장소를 불러올경우 사용되는 탭입니다.Git으로 인해 버전관리가 되어진 폴더의 경우에만 사용이 가능합니다.▷ 5번은 버전관리에 사용될 저장소를 생성합니다. ▷ 5번 탭에서 새로운 버전관리 저장소를 만듭니다.test_git 이라는 새로운 폴더를 만들어주고 해당 폴더에 간단한 html문서를 하나 생성하고test01.html 이라고 저장을 하도록 하겠습니다. 그럴경우 소스트리에서 변화가 생겼습니다.우선 왼쪽 상단의 파일 상태 탭을 보면 2가지 창으로 분류 되어있는 것을 볼수 있습니다.아래쪽의 창을 Working Copy 라고 부르고위쪽의 창을 Staging Area 혹은 Index라고 부릅니다. 그리고 Working Copy를 자세히 볼 경우? 라고 되어 있는 곳에 아까 생성한 html 파일명이 있는 것을 확인할 수 있습니다.우선 ? 라는 표시의 의미는 git이 모르는 파일 .즉, 관리가 안되고 있는 파일 혹은 관리를 처음으로 시작해야하는 파일을 의미합니다.해당 파일을 Stage selected 나 all을 누를경우 스테이징 에어리어에 test01.html 파일이 올라갑니다.그리고나면 왼쪽의 아이콘은 +로 바뀌는데 이것은 해당 파일을 버전관리에 추가함을 의미합니다. 그 후 코멘트를 작성 한 후 Commit을 누를경우 처음으로 버전관리가 되어집니다.여기서 코멘트는 무조건 작성해야 합니다. 만약 작성을 안할경우 Commit이 불가능합니다.왜냐하면 버전관리의 의도는 해당 버전이 무엇인 변경되었는지 어떠한 코드가 추가되었는지알 수 있도록 해야하기 위함이기 때문입니다. Commit을 누를 경우 왼쪽에서 Branches 라는 탭을 보면 master라고 뜨면서 오른쪽 창에는제가 적은 코멘트와 함께 버전이 올아와있습니다.여기서 master는 저 자신 즉, 본인을 의미하고 왼쪽하단에는 코멘트와 날짜와 같은 정보,오른쪽 하단에는 추가된 내용이 있습니다. \\2. Git 사용하기2 ( 추가 버전 생성 ) 이제 다시 HTML 로 돌아와서 간단하게 내용을 추가하도록 하겠습니다. 태그 안에 ‘Git 테스트 공부!’ 라는 내용을 추가하고 저장을 하겠습니다. 그럴경우 master BRANCHES에서 변화가 생깁니다.Uncommitted changes라는 문구와 함께 새로운 버전이 올라와 있습니다.왼쪽에 나타난 쿠키모양의 아이콘은 버전관리중인 파일을 의미합니다. 그리고 하단을 보면 Working copy와 Staging Area 창이 보입니다.Working copy에 있는 파일을 눌러보면 오른쪽창에 무엇이 변경되었는지 확인할 수 있습니다.해당 파일을 Staging Area에 올려놓도록 하겠습니다. 해당 파일을 Staging Area에 올려놓고 오른쪽 클릭을 하면 Commit이 있습니다.해당 버튼을 클릭하면 오른쪽 그림처럼 코멘트를 입력할 수 있는 창이 뜨게 됩니다.해당 창에 ‘ 태그 내용 추가’라고 입력하고 Commit하도록 하겠습니다. 그러면 최종적으로 이제 새로운 버전이 추가된 것을 알 수 있습니다.","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"http://yoursite.com/categories/Develop/GIT/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"git-gui-study01","slug":"git-gui-study01","date":"2019-09-06T14:36:10.000Z","updated":"2019-10-02T09:56:44.023Z","comments":true,"path":"2019/09/06/git-gui-study01/","link":"","permalink":"http://yoursite.com/2019/09/06/git-gui-study01/","excerpt":"","text":"- 해당 공부는 생활코딩을 토대로 하였음 - 1. Git의 개요 GIT이란? 프로젝트를 실행하면서 문제가 생길경우 문제를 찾기 위해 해매거나 수시로 과거의 파일을 뒤지면서 결국 예전 상태로 돌아가려는 행위를 한적이 있을 것이다. Git은 문제가 발생하여 프로젝트에 이상이 생길 경우 과거의 상태로 쉽게 돌아가게 해준다. 결과적으로서 실패에 대한 부담감이 확연히 줄어들고(그냥 과거로 백하면 되기떄문) 이것저것 시도를 할 수 있게 해주는 효과를 제공한다. 현재 Git은 버전관리, 백업, 협업과 같은 중대한 장점을 제공한다. 2. Git 설치 www.git-scm.com여기서 git을 받을 수 있다. GitAbout The advantages of Git compared to other source control systems. Documentation Command reference pages, Pro Git book content, videos and other material. Downloads GUI clients and binary releases for all major platforms. Community Get involved! Bug reporting, mailing list, chat, development andwww.git-scm.com △Git 다운로드 완료시 시작버튼에 Git에 관련된 아이콘들이 추가되어 있는 것을 확인 할 수 있다.▽Git Bash를 실행시키고 “git” 이라고 입력시 제대로 설치되었는지 확인할 수 있다. 이 Bash 창을 통해 Git을 유닉스 나 리눅스의 환경처럼 다룰수도 있고 명령어를 이용한 관리가 가능하다. 3. Git을 GUI 형태로 이용할 Source Tree( 소스트리 )설치 Git은 원래 명령어를 가지고 이용을 하는 버전관리 프로그램이다.하지만 이 기능이 너무 어렵고 GUI에 익숙해진 우리들로서는 너무너무 불편하다!따라서 GUI 기능을 가진 SW인 소스트리를 추가적으로 설치하자. 설치는 이곳에서 가능하다.https://www.sourcetreeapp.com/그 외 설치방법은 이 블로그의 포스트를 참조하자.http://codedragon.tistory.com/4907 Sourcetree | Free Git GUI for Mac and WindowsA Git GUI that offers a visual representation of your repositories. Sourcetree is a free Git client for Windows and Mac.www.sourcetreeapp.com SourceTree(소스트리) 설치하기SourceTree(소스트리) 설치파일 다운받기 http://codedragon.tistory.com/4906 SourceTree(소스트리) 설치하기 다운받은 설치파일을 실행합니다. [계속] 계정이 이미 있다면 [Use an existing account] 클릭 o..codedragon.tistory.com 다운로드 완료시 SourceTree 실행화면","categories":[{"name":"Develop","slug":"Develop","permalink":"http://yoursite.com/categories/Develop/"},{"name":"GIT","slug":"Develop/GIT","permalink":"http://yoursite.com/categories/Develop/GIT/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"html-css-study-02","slug":"html-css-study-02","date":"2019-09-05T16:15:15.000Z","updated":"2019-10-02T08:56:43.140Z","comments":true,"path":"2019/09/06/html-css-study-02/","link":"","permalink":"http://yoursite.com/2019/09/06/html-css-study-02/","excerpt":"","text":"HTML Study 02 display flex layout a 태그 position font css 개발 방법론 외부 css 적용 방법 ( reset CSS 와 normalize CSS ) 오늘의 중요점!css 문제가 생길시 홈페이지를 열어서 검사를 하고 항상 작은 단위부터 큰단위로 확인하다.( 특히 상속,겹침,우선순위 ) box-sizing 방식은 통일하는게 나중의 유지보수에 좋다. 123456&gt; *, *::before, *::after&#123;&gt; &gt; box-sizing: border-box;&gt; &gt; &#125; /*import 바로 아래*/&gt; 부모가 css box 레이아웃을 결정하면 자식도 그것을 따라감.(상속 - 무조건은 아니다. margin , padding 등등) display 요소(즉 태그)는 inline과 block 요소로 나뉜다. inline : 줄 속에 넣는 요소. 줄바꿈이 되지 않고 글자수에 따라 크기 자체가 줄고 늘어난다. block : 좀 더 넓은 범위를 지정할 때 사용하는 요소. 가로화면을 100% 다차지. 줄바꿈이 됨. display : inline - block과 다르게 줄바꿈이 안되고, width와 height가 적용되지 않는다. 오로지 적용된 글자 수에 따라서 크기가 결정된다. display : block - 가로 화면을 다 차지함. 줄바꿈 O display : none - 박스 생성x, 공간 차지x display : flex - 새로 생긴 display. 따라서 특정 버전이 낮은 브라우저에서는 실행X Flex layout flex 모델은 크기 수치를 잘못입력하여도 레이아웃이 크게 깨지지 않는다. 이유는 전체길이에 대해서 비율로 따져서 스스로 값을 정해주기 떄문. display: flexIE 10 or 그 이상 버전에서 사용 가능. flex 설정된 노드의 자식도 flex item을 가지고 모두 flex display가 된다. flex-direction (부모노드)flex-direction은 flex설정시 어떤 방향으로 제기 될것인가를 나열한다. 기본 flex-direction=row 이다. x축 , y축 으로 기준을 나눈다. row = x축 column = y축 flex-basis (자식 노드)flex-item의 크기를 결정합니다. 각 축에 해당하는 (width / height) 의 값을 설정. JUSTIFY-CONTENT: 메인 축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 space-between , flex-item들의 사이를 동일하게 비워줌. space-around, flex-item들의 사이를 비워줌. space-evenly : 익스플로러 지원x ALIGN-ITEMS: 교차축을 중심으로 정렬 flex-start(default) ,기본 flex-end ,끝방향 정렬 center ,중앙 정렬 order : item 간에 순서를 지정합니다. flex-grow : item들 끼리 크기에 대한 비율을 결정합니다. ex) a-1 b-2 c-1 flex-shrink : flex-item의 크기가 flex-container보다 클때 다른 items의 크기들을 축소시키고 그만큼 해당 item크기를 확대 시킨다. a 태그1&gt; 하이퍼링크 태그인 &lt;a&gt; 는 상황에 따른 css 스타일을 지정할 수 있다. 1234a:link&#123; &#125; /* 선택 안했을 때의 css */a:visited&#123; &#125; /* 선택해서 들어갔을때 */a:hover&#123; &#125; /* 마우스 올라갔을때 글자색 변경 */a:active&#123; &#125; /* 마우스로 클릭한 순간의 상태 */ position static : MarkUp 순서대로 배치, top-bottom-left-right 의 속성값이 적용되지 않는다. absolute : 상위 요소(상위는 반드시 static이 아닌 다른 값)를 기준으로 위치를 설정. relative : 상위 요소(상위는 반드시 static)를 기준으로 위치를 설정. fixed : 요소의 위치를 사용자의 브라우저 기준으로 설정. ( 광고, 상단바, 하단바 등등) font em : 상위요소의 크기에 대해서 비율로 계산한다. rem : 최상위 요소(root)의 크기에 대해서 비율로 계산한다. line-height : 1.15 추천 SpoqaHanSans-kr 본고딕 ( 어도비 배포 ) 1@import url('https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css'); Noto Sans KR 본고딕( 구글 배포 ) 12345&lt;link href=\"https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap\" rel=\"stylesheet\"&gt;&lt;style&gt;@import url('https://fonts.googleapis.com/css?family=Noto+Sans+KR&amp;display=swap');&lt;/style&gt; CSS 개발 방법론 쉬운 유지보수 코드의 재사용 확장 가능 직관적인 네이밍 BEM OOCSS SMACSS [ CSS 개발 방법론 ] https://gomdoreepooh.github.io/notes/smacss-bem-oocss 외부 CSS 적용 방법 대표적 외부 CSS normalize CSS : 개발 초기 필요한 정도만 초기화 후 사용. Reset CSS : 개발 초기 불필요한 margin, padding 같은 크기들을 모두 초기화. ​ [nomalize css] https://github.com/necolas/normalize.css/ ​ [Reset css] https://meyerweb.com/eric/tools/css/reset/ 적용방법 ( 예 - nomalize ) 123456&lt;link rel=\"stylesheet\"href=\"https://necolas.github.io/normalize.css/latest/normalize.css\"&gt; &lt;style&gt;@import url('https://necolas.github.io/normalize.css/latest/normalize.css');&lt;/style&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"html-css-study-01","slug":"html-css-study-01","date":"2019-09-04T12:47:07.000Z","updated":"2019-10-02T08:56:52.240Z","comments":true,"path":"2019/09/04/html-css-study-01/","link":"","permalink":"http://yoursite.com/2019/09/04/html-css-study-01/","excerpt":"","text":"HTML Study 01 DTD 소개 및 사용 방법 html 영역의 언어 선택 head 영역 안 인코딩 선언 타이틀 요소를 이용한 좋은 제목을 만드는 방법 HTML의 구조 설계 CSS 레이아웃 박스 모델 WEB은 디자인관점이 아닌 콘텐츠 관점으로 보아야 한다.SEO 관점으로 페이지를 작성해야만 한다.문서와 구조와 표현을 분리 해놓는 것이 중요하다.DTD 소개 및 사용 방법 문서타입을 정의 한다. 브라우져에게 해당 HTML이 어떤 표준에 따른 것인지를 알려주는 것을 DTD(Document Type Definition)이라고 한다.DTD는 문서의 제일 위에 위치한다. &lt;! DOCTYPE html&gt; html 영역의 언어 선택 속성 lang=”언어” 식으로 한다. (영어 en, 한국 ko-KR) 언어를 지정해주는 이유는 SEO관점으로서 브라우저에서 검색엔진에 따른 효율성을 높이기 위함이다. head 영역 안 인코딩 선언 meta 태그는 빈요소이다. meta의 속성 charset은 인코딩 형식을 지원한다. 반드시 타이틀보다 먼저 등장해야만 한다. 1&lt;meta charset=\"UTF-8\"&gt; meta의 속성 http-equiv=”X-UA-Compatible” content=”ie=edge” 는 브라우저 사용자 호환성 모드를 의미한다. ( 예, 지원하는 렌더링 모드가 11인데 깔려있는 브라우저 렌더링 버전이 8일경우 11의 렌더링을 8로 호환하여 열어준다.) content는 기본 호환성 브라우저 렌더링 모드를 지정할수있다. 사용자의 브라우저가 edge브라우저를 지원한다면 해당 모드로 연다. 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; 타이틀 요소를 이용한 좋은 제목을 만드는 방법​ SEO 관점에 따라 타이틀 요소를 제대로 적는 것이 중요하다.​​ &gt; 검색 엔진 최적화 (영어: search engine optimization, SEO)는 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다.​​ 12​ &lt;title&gt;웹카페-HTML5,CSS3,웹표준,웹접근성&lt;/title&gt;​ ​​ ###​​​​ ### HTML의 구조 설계​​​​ ## 웹페이지 분석 -&gt; Mark Up -&gt; Naming​​ #### 분석 : 웹페이지는 주로 삼단 구조를 가진다.​​ &gt; 머리말(헤더)​ &gt;​ &gt; 본문(콘텐츠)​ &gt;​ &gt; 꼬리말(푸터)​​​​ #### Web. Cafe. 페이지 분석(삼단 ++)​​ &gt;머리말(헤더)​ &gt;​ &gt;+비주얼(광고등으로 활용가능성)​ &gt;​ &gt;본문(콘텐츠)​ &gt;​ &gt;+슬로건 (커피잔 , 명언)​ &gt;​ &gt;꼬리말(푸터)​​​​ #### Mark Up 단계​​ &gt; body 태그 안​ &gt;​ &gt; ​ header - 머리말​ &gt;​ &gt; ​ div - 비주얼​ &gt;​ &gt; ​ main - 본문​ &gt;​ &gt; ​ article - RSS, 슬로건​ &gt;​ &gt; ​ footer - 꼬리말​​​​ #### Naming 단계 ( Naming : 컴퓨터가 이해할 수 있도록 이름을 지어준다. )​​ &gt; ### { top , bottom 같은 위치 기반 이름은 정말로 안좋음!!! }​ &gt;​ &gt; 이름 주는 방법​ &gt;​ &gt; class : 여러번 사용가능.​ &gt;​ &gt; id : 고유하게 정할 때 사용.​​​​ ### CSS 레이아웃​​ &gt; 정통방식 : float , position, display:inline, display:inline-block​ &gt;​ &gt; 모던방식 : display:inline, display:inline-block, flex, glid​​ ### 박스 모델​​ 12​ box-sizing: content-box | border-box | initial | inherit​ ​​ - content-box : 콘텐트 영역을 기준으로 크기를 정합니다.​ - border-box : 테두리를 기준으로 크기를 정합니다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"HTML&CSS","slug":"TIL/HTML-CSS","permalink":"http://yoursite.com/categories/TIL/HTML-CSS/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/tags/TIL/"}]},{"title":"백준 TEST07_문자열 사용하기","slug":"Algorism-for-java07","date":"2019-09-04T10:26:52.000Z","updated":"2019-10-02T09:11:12.245Z","comments":true,"path":"2019/09/04/Algorism-for-java07/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java07/","excerpt":"","text":"백준 TEST07_문자열 사용하기필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 아스키코드1234567891011121314class TEST07_01&#123; public TEST07_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int a = n.charAt(0); // n에 담겨진 첫번째 문자(0번쨰)를 캐릭터형으로 변환후 다시 정수형으로 변환. bw.write(a +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (이클립스 상 답이 맞지만 어째서인지 오답처리됨.)123456789101112131415161718192021222324252627282930313233343536373839404142434445class TEST07_02_t&#123; public TEST07_02_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; int null_num = -1; String S = null; String str = \"abcdefghijklmnopqrstuvwxyz\"; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(int i=0;i&lt;str.length();i++)&#123; int a = 0; for(int j=0;j&lt;S.length();j++)&#123; if(j &gt;= 1 &amp;&amp; S.charAt(j-1) == S.charAt(j))&#123; continue; &#125; if(str.charAt(i) == S.charAt(j))&#123; bw.write(j + \" \"); a++; &#125; &#125; if(a==0)&#123; bw.write(null_num + \" \"); &#125; &#125; bw.flush(); bw.close(); &#125;&#125; 알파벳 찾기 (정답)123456789101112131415161718192021222324252627282930class TEST07_02_A&#123; public TEST07_02_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int count=0; String S = null; while(true)&#123; S = br.readLine(); if(S.length()&lt;101)&#123; for(int i=0;i&lt;S.length();i++)&#123; char chrInput = S.charAt(i); if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; count++; &#125; // 입력받은 값 처음부터 끝까지 소문자인지 비교하고 비교후 count값을 올린다. &#125;// for end //System.out.println(S.length() +\" break를 탈출\" + count + \" break를 탈출\"); if(count == S.length())&#123; break; &#125; //카운트값과 문자열의 길이가 같다면 무한반복 탈출. &#125; &#125;// while end for(char alphabet = 'a'; alphabet &lt;= 'z'; alphabet++) &#123; bw.write(S.indexOf(alphabet) + \" \"); &#125; //String.indexOf() 메소드는 원하는 값을 문자열 내에서 원하는 값을 찾아 인덱스 값을 반환한다. 단, 원하는 값이 없으면 -1 을 반환한다. bw.flush(); bw.close(); &#125;&#125; 문자열 반복123456789101112131415161718192021222324class TEST07_03&#123; public TEST07_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = Integer.parseInt(br.readLine()); String a = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\$%*+-./:\"; int b = 0; for(int i=0;i&lt;n;i++)&#123; String xx = br.readLine(); for(int z=2;z&lt;xx.length();z++)&#123; for(int j=0;j&lt;Integer.parseInt(xx.substring(0, 1));j++)&#123; bw.write(xx.charAt(z)); &#125; &#125; bw.write(\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (시간초과 ㅜㅜㅜㅜㅜㅜㅜㅜ)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class TEST07_04_t&#123; public TEST07_04_t() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String a = null; String A = null; ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); int[] num; while(true)&#123; int count = 0; a = br.readLine(); A = a.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 num = new int[A.length()]; //입력받은 문자의 갯수만큼 정수형 배열을 생성. if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! array.add(String.valueOf(chrInput)); &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end //각각 자신의 개수를 비교하기 시작. for (int i = 0; i &lt; A.length()-1; i++) &#123; for(int j=i+1;j&lt;A.length();j++)&#123; if(array.get(i).equals(array.get(j)))&#123; num[i]++; &#125;//if end &#125;//for-2 end &#125;//for-1 end int temp = 0; String chr_tmp = \"\"; for(int i=0;i&lt;A.length()-1;i++)&#123; for(int j=i+1;j&lt;A.length();j++) if(num[i]&gt;num[j])&#123; temp = num[i]; chr_tmp = array.get(i); num[i] = num[j]; array.set(i,array.get(j)); num[j] = temp; array.set(j,chr_tmp); &#125; &#125; /* for(int i=0;i&lt;A.length();i++)&#123; bw.write(array.get(i)+\" \"); &#125; bw.write(\"\\n\\n\"); for(int i=0;i&lt;A.length();i++)&#123; bw.write(num[i]+\" \"); &#125; bw.write(\"\\n\\n\"); */ if(num.length == 1)&#123; bw.write(array.get(0)); &#125; else if(num[A.length()-1] == num[A.length()-2])&#123; bw.write(\"?\\n\"); &#125; else&#123; bw.write(array.get(A.length()-1)); &#125; bw.flush(); bw.close(); &#125;&#125; 단어공부 (정답)123456789101112131415161718192021222324252627282930313233343536373839404142class TEST07_04_A&#123; public TEST07_04_A() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String A = null; int[] num = new int[26]; int max = 0; char answer = 0; while(true)&#123; int count = 0; A = br.readLine(); A = A.toUpperCase(); //입력받은 문자를 강제로 대문자로 형변환 if(A.length() &gt; 1000000)&#123; continue; &#125; for (int i = 0; i &lt; A.length(); i++) &#123; char chrInput = A.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; count++; // 영문(대문자) OK! &#125; &#125;//for end if(count == A.length()) &#123; break; &#125; //count값과 A의 길이가 동일시 while 탈출 &#125;//while end for(int i=0;i&lt;A.length();i++)&#123; num[A.charAt(i)-65]++; if(num[A.charAt(i)-65]&gt;max)&#123; //최초 max는 0 answer = A.charAt(i); max = num[A.charAt(i)-65]; //max값이 증가한다. &#125; else if((num[A.charAt(i)-65]==max))&#123; answer = '?'; &#125; &#125; bw.write(answer); bw.flush(); bw.close(); &#125;&#125; 그룹 단어 체커1234567891011121314151617181920212223242526272829303132333435363738394041class TEST07_05&#123; public TEST07_05()throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String str = null; int count = 0; // a-97 z-122 while(true)&#123; int n = Integer.parseInt(br.readLine()); count = n; int i=0; if(n&lt;=100)&#123; for(i=0;i&lt;n;i++)&#123; int[] num = new int[26]; str = br.readLine(); num[str.charAt(0)-97] = -1; //맨 처음 문자 값은 -1 if(str.length()&gt;1) &#123; for(int j=1;j&lt;str.length();j++)&#123; if(num[str.charAt(j)-97] == -1 &amp;&amp; str.charAt(j) != str.charAt(j-1))&#123; count--; //초기값으로 -1을 지정하였고 그 다음에는 서로 붙어있는지 비교함. 만약 안 붙어있다면 카운트-- break; &#125;//if end num[str.charAt(j) - 97] = -1; // 초기값을 -1로 초기화 시켜나감. &#125;//for-j end &#125;//if end &#125;//for-i end bw.write(count+\"\"); &#125;//if end if(i == n) &#123; break; &#125; &#125;//while end bw.flush(); bw.close(); &#125; &#125; 6단계 - 1차원배열 사용하기 1번문제 임. (전 포스팅 참조)상수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class TEST07_07&#123; public TEST07_07() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] num; while(true)&#123; num = br.readLine().split(\" \"); int w_count = 0; if(num[0].length() &gt; 3 &amp;&amp; num[0].length() &lt; 0)&#123; continue; &#125; if(num[1].length() &gt; 3 &amp;&amp; num[1].length() &lt; 0)&#123; continue; &#125; for(int i=0;i&lt;2;i++)&#123; w_count = 0; for(int j=0;j&lt;num[i].length();j++) if(num[i].charAt(j) == '0')&#123; w_count++; break; &#125; &#125; if(w_count &gt;= 1 )&#123; continue; &#125; int A = Integer.parseInt(num[0]); int B = Integer.parseInt(num[1]); if(A != B)&#123; break; &#125; &#125; int a = 0; int[] sum = new int[2]; for(int i=0;i&lt;2;i++)&#123; for(int j=2;j&gt;=0;j--)&#123; switch(j)&#123; case 2 : a = num[i].charAt(j) - '0'; a = a*100; break; case 1 : a = num[i].charAt(j) - '0'; a = a*10; break; case 0 : a = num[i].charAt(j) - '0'; break; &#125;// charAt(i) - '0' -&gt; char형을 int형으로 변환 sum[i] = sum[i] + a; &#125; &#125; if(sum[0] &gt; sum[1])&#123; bw.write(sum[0] + \"\"); &#125; else&#123; bw.write(sum[1] + \"\"); &#125; bw.flush(); bw.close(); &#125;&#125; 다이얼1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST07_08&#123; public TEST07_08() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String num; int count = 0; while(true)&#123; num = br.readLine(); int w_count = 0; if(num.length()&lt;2 &amp;&amp; num.length()&gt;15)&#123; continue; &#125; for(int i=0;i&lt;num.length();i++)&#123; if(num.charAt(i) &lt; 64 &amp;&amp; num.charAt(i) &gt; 91)&#123; w_count++; break; &#125; &#125;//대문자로만 입력 if(w_count == 0)&#123; break; &#125; &#125; for(int i=0;i&lt;num.length();i++)&#123; switch(num.charAt(i))&#123; case 'A': case 'B': case 'C' : count += 3; break; case 'D': case 'E': case 'F' : count += 4; break; case 'G': case 'H': case 'I' : count += 5; break; case 'J': case 'K': case 'L' : count += 6; break; case 'M': case 'N': case 'O' : count += 7; break; case 'P': case 'Q': case 'R' : case 'S' : count += 8; break; case 'T': case 'U': case 'V' : count += 9; break; case 'W': case 'X': case 'Y' : case 'Z' : count += 10; break; &#125; &#125; bw.write(count + \"\"); bw.flush(); bw.close(); &#125;&#125; 크로아티아 알파벳12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TEST07_09&#123; public TEST07_09() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String c_alpha2[] = &#123;\"c=\",\"c-\",\"d-\",\"lj\",\"nj\",\"s=\",\"z=\"&#125;; String c_alpha3 = \"dz=\"; String croa; while(true)&#123; croa = br.readLine(); int w_count = 0; if(croa.length()&lt;1 &amp;&amp; croa.length()&gt;100)&#123; continue; &#125; for(int i=0;i&lt;croa.length();i++)&#123; if(croa.charAt(i) &lt; 97 || croa.charAt(i) &gt; 122)&#123; if (croa.charAt(i) == '-'|| croa.charAt(i) == '=' )&#123; continue; &#125; w_count++; break; &#125; //소문자 혹은 '-' '=' 가 아닐경우 무한반복 &#125; if(w_count == 0)&#123; break; &#125; &#125; int count = croa.length(); while(true)&#123; if(croa.indexOf(c_alpha3) &gt; -1)&#123; count = count - 2; croa = croa.replaceFirst(c_alpha3,\" \"); &#125; else&#123; break; &#125; &#125;//\"dz=\" 이라는 문자가 존재시 해당 문자를 빼머리고 전체값에서 -2 후 공백으로 변환. for(int k=0;k&lt;7;k++)&#123; while(true)&#123; if(croa.indexOf(c_alpha2[k]) &gt; -1)&#123; count = count - 1; croa = croa.replaceFirst(c_alpha2[k],\" \"); &#125; else&#123; break; &#125; &#125; &#125;//for-k end bw.write(count + \" \"); bw.flush(); bw.close(); &#125;&#125; Main123456789101112131415public class TEST07 &#123; //Main&#123; public static void main(String[] args) throws IOException&#123; // TEST07_01 test07_01 = new TEST07_01(); // TEST07_02_t test07_02_t = new TEST07_02_t(); // TEST07_02_A test07_02_A = new TEST07_02_A(); // TEST07_03 test07_03 = new TEST07_03(); // TEST07_04_t test07_04_t = new TEST07_04_t(); //시간초과 // TEST07_04_A test07_04_A = new TEST07_04_A(); //정답 // TEST07_05 test07_05 = new TEST07_05(); //6번 문제는 1차원배열사용하기 - 1번문제 // TEST07_07 test07_07 = new TEST07_07(); // TEST07_08 test07_08 = new TEST07_08(); TEST07_09 test07_09 = new TEST07_09(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST06_1차원 배열 사용하기","slug":"Algorism-for-java06","date":"2019-09-04T10:26:50.000Z","updated":"2019-10-02T09:11:07.127Z","comments":true,"path":"2019/09/04/Algorism-for-java06/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java06/","excerpt":"","text":"백준 TEST06_1차원 배열 사용하기 필요한 패키지 및 외부 클래스1234567package test_java;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter; 단어의개수123456789101112131415161718192021222324252627282930313233class TEST06_01 &#123; public TEST06_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String n = br.readLine(); int count=1; for(int i=0;i&lt;n.length();i++)&#123; char chrInput = n.charAt(i); if(n.charAt(i) ==' ')&#123; count++; &#125; if (chrInput &lt; 0x61 &amp;&amp; chrInput &gt; 0x7A) &#123; break; &#125; // 영문(소문자)가 아닐경우 무한 반복! else if (chrInput &lt; 0x41 &amp;&amp; chrInput &gt; 0x5A) &#123; break; &#125; // 영문(대문자)가 아닐 경우 무한 반복! &#125;// for end //count++; if(n.charAt(0)==' ' &amp;&amp; n.charAt(n.length()-1)==' ')&#123; count--; count--; &#125; else if(n.charAt(0)==' ' || n.charAt(n.length()-1)==' ')&#123; count--; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 숫자의 개수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TEST06_02&#123; public TEST06_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int[] num = new int[10]; int A = Integer.parseInt(br.readLine()); int B = Integer.parseInt(br.readLine()); int C = Integer.parseInt(br.readLine()); //bw.write( A * B * C +\"\\n\"); String sum = A * B * C +\"\"; //bw.write(sum); char[] a = sum.toCharArray(); for(int i=0;i&lt;a.length;i++)&#123; switch(a[i])&#123; case '0' : num[0]++; break; case '1' : num[1]++; break; case '2' : num[2]++; break; case '3' : num[3]++; break; case '4' : num[4]++; break; case '5' : num[5]++; break; case '6' : num[6]++; break; case '7' : num[7]++; break; case '8' : num[8]++; break; case '9' : num[9]++; break; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; bw.write(num[i]+\"\\n\"); &#125; bw.flush(); bw.close(); &#125;&#125; OX퀴즈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST06_03&#123; public TEST06_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int t_case = Integer.parseInt(br.readLine()); int[] num = new int[t_case]; String[] ox = new String[t_case]; // O- 0x4F X-0x58 while(true)&#123; int i = 0; for(i=0;i&lt;t_case;i++)&#123; int j = 0; ox[i] = br.readLine(); char[] chrInput= ox[i].toCharArray(); if(ox[i].length() &gt; 80 || ox[i].length() &lt; 0)&#123; break; //MAIN FOR BREAK &#125; for(j=0;j&lt;ox[i].length();j++)&#123; if(chrInput[j] == 'O' ||chrInput[j] == 'X') continue; else break; //SUB FOR BREAK &#125; if(j!=ox[i].length()) break; //MAIN FOR BREAK &#125; if(i==t_case) break; //O혹은 X가 아닐경우 처음 부터 다시 &#125;//while end for(int i=0;i&lt;t_case;i++)&#123; char[] sub = ox[i].toCharArray(); int score = 0; for(int j=0;j&lt;ox[i].length();j++)&#123; if(sub[j] == 'O')&#123; score++; num[i] += score; &#125; else score = 0; &#125;// for - j end bw.write(num[i] + \"\\n\"); &#125;//for - i end bw.flush(); bw.close(); &#125;&#125; 음계1234567891011121314151617181920212223242526272829303132333435363738class TEST06_04&#123; public TEST06_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] m = br.readLine().split(\" \"); String[] x = new String[8]; String[] y = new String[8]; int count = 0 ; for(int i=0;i&lt;m.length;i++)&#123; x[i] = String.valueOf(i+1); y[i] = String.valueOf(8-i); if(x[i].equals(m[i]))&#123; count++; &#125; if(y[i].equals(m[i]))&#123; count--; &#125; &#125; // bw.write(m.length+\"\\n\"); // bw.write(x[3]+\"\\n\"); if(m[0].equals(\"1\") &amp;&amp; count == 8)&#123; bw.write(\"ascending\"); &#125; else if(m[0].equals(\"8\") &amp;&amp; count == -8)&#123; bw.write(\"descending\"); &#125; else&#123; bw.write(\"mixed\"); &#125; bw.flush(); bw.close(); &#125;&#125; 평균 점수12345678910111213141516171819202122232425262728class TEST06_05&#123; public TEST06_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int sum = 0; while(true)&#123; int i=0; for(i=0;i&lt;5;i++)&#123; int n = Integer.parseInt(br.readLine()); if(n&lt;0 || n%5!=0)&#123; break; &#125; if(n&lt;40) n=40; sum += n; &#125;//main for end if(i==5)&#123; break; &#125; &#125;//while end bw.write(sum/5 +\"\\n\"); bw.flush(); bw.close(); &#125;&#125; Main123456789public class TEST06 &#123; public static void main(String[] args) throws IOException&#123; // TEST06_01 test06_01 = new TEST06_01(); // TEST06_02 test06_02 = new TEST06_02(); // TEST06_03 test06_03 = new TEST06_03(); // TEST06_04 test06_04 = new TEST06_04(); TEST06_05 test06_05 = new TEST06_05(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST05_함수 사용하기","slug":"Algorism-for-java05","date":"2019-09-04T10:26:48.000Z","updated":"2019-10-02T09:10:58.677Z","comments":true,"path":"2019/09/04/Algorism-for-java05/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java05/","excerpt":"","text":"## 필요 패키지 및 외부 클래스 123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 셀프넘버12345678910111213141516171819202122232425262728293031323334class hamsu&#123; public int d(int num)&#123; int xxxx = num/1000; int xxx = (num/100)%10; int xx = (num/10)%10; int x = num%10; num = num + xxxx + xxx + xx + x; return num; &#125;&#125;class TEST05_01 extends hamsu&#123; public TEST05_01()&#123;// ArrayList array = new ArrayList(); int i = 0; int[] fin = new int[10000]; //배열 10000개 선언 알아서 0으로 초기화함. for(i=0;i&lt;10000;i++)&#123; if(d(i)&lt;10000)&#123; fin[d(i)] = 1; &#125; if(fin[i] == 0)&#123; System.out.println(i); &#125; &#125; &#125; &#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_01 test05_01 = new TEST05_01(); &#125;&#125; 한수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST05_02 &#123; public TEST05_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int count = 0; int xxxx,xxx,xx,x = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000)&#123; break; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i&lt;100)&#123; count++; &#125; if(i&gt;=100)&#123; xxx = i/100; xx = (i/10)%10; x = i%10; if(xx-x==xxx-xx)&#123; count++; &#125; &#125; if(i&gt;=1000)&#123; xxxx = i/1000; xxx = (i/100)%10; xx = (i/10)%10; x = i%10; if(xxxx-xxx == xxx-xx) if(xx-x == xxx-xx)&#123; count++; &#125; &#125; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_02 test05_02 = new TEST05_02(); &#125;&#125; 별찍기 - 11 별찍기에 대해서 초반에 어떻게 문제를 풀어야하는지 감이 너무 오질 않았다. 따라서 강의를 보면서 이해하는 형식으로 진행하였다. 해당 강의는 C를 기반으로 진행하였으므로 나는 자바의 형식에 맞게 수정을 해주었다. https://youtu.be/WjmEVp-Lgns 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class TEST05_03 &#123; static char[][] arr; public TEST05_03() throws IOException&#123; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = input_num(); arr = new char[n][2*n-1]; //예제 y축 24칸, x축 47칸임(맨 아래 밑변). //배열 선언은 while문 아래가 될 수 없다. for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;2*n-1; j++) &#123; arr[i][j] = ' '; &#125; &#125;//초기화 구문, 자바에서 미선언시 char은 널값으로 초기화됨. 따라서 모두 공백으로 미리 초기화. solution(n,n-1,0);// n은 몇층까지 를 의미, n-1은 첫 시작의 별 위치 -&gt; x축, 0은 첫줄을 의미한다. -&gt;y축 for(int i=0; i&lt;n; i++) &#123; bw.write(arr[i]); bw.write('\\n'); &#125; //이차원배열로 선언되었기 때문에 a[i]번째 줄에 저장된 모든 값을 출력. bw.flush(); bw.close(); &#125; public int input_num() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = 0; int count = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); for(int k=0;k&lt;=10;k++)&#123; if(n==3*(Math.pow(2, k)))&#123; count = 1; &#125; //제대로 된 수를 입력할 때 까지 무한반복 N은 3*2^k승. &#125; if(count == 1) break; &#125; return n; &#125; // 제대로된 n값을 입력하였느지 확인. 제대로된 값이 아니라면 무한반복. public void solution(int n,int x,int y)&#123; if (n == 3) &#123; arr[y][x] = '*'; //첫 별 * arr[y + 1][x - 1] = '*'; //두번 째 별 1 * * arr[y + 1][x + 1] = '*'; //두번째 별 2 arr[y + 2][x - 2] = '*'; //세번째 별 1 ***** arr[y + 2][x - 1] = '*'; //세번째 별 2 ***** arr[y + 2][x] = '*'; //세번째 별 3 ***** arr[y + 2][x + 1] = '*'; //세번째 별 4 ***** arr[y + 2][x + 2] = '*'; //세번째 별 5 ***** return; &#125; //n이 3일때 별을 그려주는 로직 시작. // n이 3이 최소임. solution(n/2, x, y); // 첫 큰 삼각형 solution(n/2, x-(n/2) , y+(n/2)); // 왼쪽 큰 삼각형 solution(n/2, x+(n/2) , y+(n/2)); // 오른쪽 큰 삼각형 &#125;&#125;public class TEST05&#123; public static void main(String[] args) throws IOException&#123; TEST05_03 test05_03 = new TEST05_03(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST04_if문 사용해보기","slug":"Algorism-for-java04","date":"2019-09-04T10:26:47.000Z","updated":"2019-10-02T09:10:53.516Z","comments":true,"path":"2019/09/04/Algorism-for-java04/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java04/","excerpt":"","text":"백준 TEST04_if문 사용해보기 기본 필요 패키지 및 외부클래스123456import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.*; 시험성적1234567891011121314151617181920212223242526272829303132333435363738394041424344class TEST04_01&#123; public TEST04_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&gt;= 0 &amp;&amp; n&lt;101)&#123; break; &#125; &#125; switch (n/10) &#123; case 10 : case 9 : bw.write(\"A\\n\"); bw.flush(); break; case 8 : bw.write(\"B\\n\"); bw.flush(); break; case 7 : bw.write(\"C\\n\"); bw.flush(); break; case 6 : bw.write(\"D\\n\"); bw.flush(); break; default : bw.write(\"F\\n\"); bw.flush(); break; &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_01 test04_01 = new TEST04_01(); &#125;&#125; 세 수 - 버전112345678910111213141516171819202122232425262728293031323334class TEST04_02_01&#123; public TEST04_02_01() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); if ((A&gt;=B)&amp;&amp;(A&lt;=C)||(A&gt;=C)&amp;&amp;(A&lt;=B))&#123; bw.write(A+\"\\n\"); bw.flush(); bw.close(); &#125; else if((B&gt;=C)&amp;&amp;(B&lt;=A)||(B&gt;=A)&amp;&amp;(B&lt;=C))&#123; bw.write(B+\"\\n\"); bw.flush(); bw.close(); &#125; else&#123; bw.write(C+\"\\n\"); bw.flush(); bw.close(); &#125; &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_01 test04_02_01 = new TEST04_02_01(); &#125;&#125; 세 수 - 버전2 (정렬이용)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TEST04_02_02&#123; public TEST04_02_02() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int A,B,C; int tmp; ArrayList&lt;Integer&gt; num = new ArrayList&lt;&gt;(); String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. A = Integer.parseInt(a[0]); B = Integer.parseInt(a[1]); C = Integer.parseInt(a[2]); num.add(A); num.add(B); num.add(C); //버블정렬 for(int i=1;i&lt;num.size();i++)&#123; for(int j=0;j&lt;num.size()-i;j++)&#123; if(num.get(j)&gt;=num.get(j+1))&#123; //num.get(1);//확인. num.set(1,temp);//수정. tmp = num.get(j); num.set(j, num.get(j+1)); num.set(j+1, tmp); &#125; &#125; &#125; /* //선택정렬 for(int i=0;i&lt;num.size()-1;i++)&#123; for(int j=i+1;j&lt;num.size();j++)&#123; if(num.get(i) &gt;= num.get(j)) &#123; tmp = num.get(j); num.set(j,num.get(i)); num.set(i,tmp); &#125; &#125; &#125; */ bw.write(num.get(1)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_02_02 test04_02_02 = new TEST04_02_02(); &#125;&#125; X보다 작은 수12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TEST04_03&#123; public TEST04_03() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int i = 0; int x = 0; while(true)&#123; String[] a = br.readLine().split(\" \"); n = Integer.parseInt(a[0]); x = Integer.parseInt(a[1]); if(x&gt;=1 &amp;&amp; x&lt;=10000 &amp;&amp; n&gt;=1 &amp;&amp; n&lt;=10000)&#123; break; &#125; &#125; String[] A = br.readLine().split(\" \"); while(true)&#123; for(i=0;i&lt;n;i++)&#123; int y = Integer.parseInt(A[i]); if(y&lt;=0 &amp;&amp; y&gt;=10000)&#123; break; &#125; if(y&lt;x)&#123; bw.write(y+\" \"); &#125; &#125; if(i==n)&#123; break; &#125; &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_03 test04_03 = new TEST04_03(); &#125;&#125; 평균1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TEST04_04&#123; public TEST04_04() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); //정수형을 값을 저장할 리스트 공간 int n,i,tmp = 0; //n은 과목수 , i는 조건을 위한 수 , tmp는 임시저장소 , sum 최종합 double sum = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); if(n&lt;=1000) break; &#125; while(true)&#123; String[] a = br.readLine().split(\" \"); for(i=0;i&lt;n;i++)&#123; tmp = Integer.parseInt(a[i]); array.add(Integer.parseInt(a[i])); if(tmp&gt;100 &amp;&amp; tmp&lt;=0)&#123; break; &#125; &#125; if(i==n)&#123; break; &#125; &#125; for(i=0;i&lt;array.size()-1;i++)&#123; for(int j=i+1;j&lt;array.size();j++)&#123; if(array.get(i)&gt;array.get(j))&#123; tmp = array.get(i); array.set(i, array.get(j)); array.set(j,tmp); &#125; &#125; &#125;//선택정렬 이용 for(i = 0;i&lt;array.size();i++)&#123; sum += array.get(i); &#125; bw.write((double)(sum/array.size()/array.get(array.size()-1)*100.0)+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_04 test04_04 = new TEST04_04(); &#125;&#125; 텍스트 추가 \\05. 평균은 넘겠지 텍스트 추가 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TEST04_05&#123; public TEST04_05() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); ArrayList&lt;Double&gt; number = new ArrayList&lt;&gt;(); int C = Integer.parseInt(br.readLine()); int j = 0; double hap = 0; while(true)&#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); double num = 0; int sum = 0; double avg = 0; String[] x = br.readLine().split(\" \"); if(Integer.parseInt(x[0])&lt;1 &amp;&amp; Integer.parseInt(x[0])&gt;1000)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); for(int i=0;i&lt;=Integer.parseInt(x[0]);i++)&#123; array.add(Integer.parseInt(x[i])); if(Integer.parseInt(x[i])&lt;0 &amp;&amp; Integer.parseInt(x[i])&gt;100)&#123; break; &#125; //System.out.println(\"잘못입력하였습니다.\"); &#125; sum = 0; for(int i=1;i&lt;array.size();i++)&#123; sum = sum + array.get(i); &#125; avg = sum/array.get(0); for(int i=1;i&lt;array.size();i++)&#123; if(array.get(i)&gt;avg)&#123; num++; &#125; &#125; hap = num/array.get(0); number.add((num/array.get(0))*100); j++; if(j==C)&#123; break; &#125; &#125; for(int i=0;i&lt;C;i++)&#123; System.out.printf(\"%.3f\",number.get(i)); System.out.println(\"%\"); &#125; /* for(int i=0;i&lt;C;i++)&#123; bw.write(number.get(i)+\"%\"+\"\\n\"); &#125; bw.flush(); bw.close(); */ &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_05 test04_05 = new TEST04_05(); &#125;&#125; 더하기 사이클123456789101112131415161718192021222324252627282930313233343536373839404142class TEST04_06&#123; public TEST04_06() throws IOException&#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = 0; int xx = 0; int x = 0; int fin = 0; int cycle_num = 0; while(true)&#123; n = Integer.parseInt(br.readLine()); fin = n; if(n&gt;=0 &amp;&amp; n&lt;=99)&#123; break; &#125;// 아닐경우 무한반복 &#125; while(true)&#123; xx = n/10; x = n%10; n = (xx + x)%10; n = (x*10)+n; cycle_num++; if(fin == n)&#123; break; &#125; &#125; bw.write(cycle_num+\"\\n\"); bw.flush(); bw.close(); &#125;&#125;public class TEST04&#123; public static void main(String[] args) throws IOException&#123; TEST04_06 test04_06 = new TEST04_06(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST03_for문 사용해보기","slug":"Algorism-for-java03","date":"2019-09-04T10:26:45.000Z","updated":"2019-10-02T09:10:38.033Z","comments":true,"path":"2019/09/04/Algorism-for-java03/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java03/","excerpt":"","text":"백준_TEST03_for문 사용해보기N찍기123456789101112131415161718192021import java.util.*;class TEST03_01&#123; public TEST03_01()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_01 test03_01 = new TEST03_01(); &#125;&#125; 기찍 N123456789101112131415161718192021import java.util.*;class TEST03_02&#123; public TEST03_02()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=N;i&gt;=1;i--)&#123; System.out.println(i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_02 test03_02 = new TEST03_02(); &#125;&#125; 구구단12345678910111213141516171819202122import java.util.*;class TEST03_03&#123; public TEST03_03()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=9;i++)&#123; System.out.println(N+\" * \"+i+\" = \"+N*i); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_03 test03_03 = new TEST03_03(); &#125;&#125; 별찍기-1123456789101112131415161718192021222324import java.util.*;class TEST03_04&#123; public TEST03_04()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_04 test03_04 = new TEST03_04(); &#125;&#125; 별찍기-21234567891011121314151617181920212223242526272829303132333435import java.util.*;class TEST03_05&#123; public TEST03_05()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); // int K = N-1; for(int i=1;i&lt;=N;i++)&#123; /* for(int x=K;x&gt;=1;x--)&#123; System.out.print(\" \"); &#125; */ for(int j=1;j&lt;=N-i;j++)&#123; System.out.print(\" \") ; &#125; for(int j=1;j&lt;=i;j++)&#123; System.out.print(\"*\"); &#125; //K--; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_05 test03_05 = new TEST03_05(); &#125;&#125; 별찍기-3123456789101112131415161718192021222324252627import java.util.*;class TEST03_06&#123; public TEST03_06()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=1;i&lt;=N;i++)&#123; for(int j=N-i+1;j&gt;=1;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_06 test03_06 = new TEST03_06(); &#125;&#125; 별찍기-4123456789101112131415161718192021222324252627import java.util.*;class TEST03_07&#123; public TEST03_07()&#123; Scanner scan = new Scanner(System.in); System.out.print(\"N값 입력 : \"); int N = scan.nextInt(); for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;i;j++)&#123; System.out.print(\" \"); &#125; for(int j=N-i;j&gt;0;j--)&#123; System.out.print(\"*\"); &#125; System.out.println(\"\"); &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_07 test03_07 = new TEST03_07(); &#125;&#125; ###2007년 -&gt; 해결은 하였으나 더 간단하게 푸는 방법이 존재함. -&gt; 1번=직접 해결한 소스. 2번=해답 소스 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1번import java.util.*;class TEST03_08&#123; public TEST03_08()&#123; Scanner scan = new Scanner(System.in); int x,y,z = 0; //z는 일주일 7을 의미. while(true)&#123; x = scan.nextInt(); if(x&gt;=1 &amp;&amp; x&lt;=12)&#123; break; &#125; &#125; while(true)&#123; y = scan.nextInt(); if(y&gt;=1 &amp;&amp; y&lt;=31)&#123; break; &#125; &#125; // x = 월, y = 일을 입력받는다. //ArrayList&lt;String&gt; month = new ArrayList&lt;&gt;(); //month.add(\"SUN\");month.add(\"MON\"); //한개씩은 위처럼 한번에는 아래처럼 이용. Array.asList ArrayList&lt;String&gt; week = new ArrayList&lt;&gt;(Arrays.asList(\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\",\"SUN\")); for(int i=1;i&lt;=12;i++)&#123; if(i==1 || i==3 || i==5|| i==7 || i==8 || i==10 || i==12)&#123; for(int j=1;j&lt;=31;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 1,3,5,7,8,10,11,12 월 for문 end &#125; else if(i==2)&#123; for(int j=1;j&lt;=28;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 2월 for문 end &#125; else&#123; for(int j=1;j&lt;=30;j++)&#123; if(i==x &amp;&amp; j==y)&#123; System.out.println(week.get(z).toString()); &#125; z++; if(z==7)&#123; z = 0; &#125; &#125; // 4,6,9,11 월 for문 end &#125; // if end &#125;//for-i end &#125; &#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_08 test03_08 = new TEST03_08(); &#125;&#125; 12345678910111213141516171819202122//2번 - 해답import java.util.Scanner; public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int month = sc.nextInt(); int day = sc.nextInt(); sc.close(); int[] daysInMonth = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; String[] dayOfTheWeeks = &#123;\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"&#125;; int totalDays = day; for (int i = 0; i &lt; month - 1; ++i) &#123; totalDays += daysInMonth[i]; &#125; System.out.println(dayOfTheWeeks[totalDays % 7]); &#125;&#125; 합123456789101112131415161718192021import java.util.*;class TEST03_09&#123; public TEST03_09()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int sum = 0; for(int i=1;i&lt;=n;i++)&#123; sum += i; &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_09 test03_09 = new TEST03_09(); &#125;&#125; 숫자의 합 &lt;미해결&gt;-&gt; 미해결한 이유 : Scanner 메서드로는 숫자를 1개씩 입력 받는건 불가능하다. 123456789101112131415161718192021222324252627import java.util.*;class TEST03_10_1&#123; public TEST03_10_1()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int a = 0; int sum = 0; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=n;i++)&#123; a = scan.nextInt(); array.add(a); &#125; for(int i=1;i&lt;=n;i++)&#123; sum += array.get(i-1); &#125; System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_1 test03_10_1 = new TEST03_10_1(); &#125;&#125; 숫자의 합 &lt;해결&gt;-&gt; 해결법 : 문자열로 받아서 끊어서 하나하나 더하거나 아스키코드를 이용한다. -&gt; 여기서는 끊어서 사용하는 substring() 함수를 이용. 12345678910111213141516171819202122232425import java.util.*;class TEST03_10_2&#123; public TEST03_10_2()&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); String a = scan.next(); scan.close(); int sum = 0; for(int i=0;i&lt;n;i++)&#123; sum += Integer.parseInt(a.substring(i, i + 1)); &#125; //Integer.parseInt() 인트형으로 형변환 메서드 //substring(a,b); a=현재위치 b=까지 System.out.println(sum); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_10_2 test03_10_2 = new TEST03_10_2(); &#125;&#125; 열 개씩 끊어 출력하기1234567891011121314151617181920212223import java.util.*;class TEST03_11&#123; public TEST03_11()&#123; Scanner scan = new Scanner(System.in); String n = scan.next(); scan.close(); for(int i=1;i&lt;=n.length();i++)&#123; System.out.print(n.charAt(i-1)); if(i%10==0)&#123; System.out.println(\"\"); &#125; &#125; &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_11 test03_11 = new TEST03_11(); &#125;&#125; 빠른 A+B (BufferedReader , BufferedWriter)1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;class TEST03_12&#123; public TEST03_12() throws IOException&#123; //버퍼드리더와 버퍼드라이터를 쓰기 위한 조건 : throws NumberFormatException, IOException BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));//선언 int test_case = Integer.parseInt(br.readLine()); // 몇개 입력? //readline은 버퍼에 입력하는것. for(int i=0; i&lt;test_case;i++) &#123; //ex) 5개라 입력했으면 총 5줄의 입력을 받음. String a[] = br.readLine().split(\" \");//입력과 동시에 \" \"공백을 구분하여 배열을 나눈다. bw.write(\"현재 입려숫자는 각각\"+a[0]+\" \"+a[1]+\"\\n\"); int answer = Integer.parseInt(a[0]) + Integer.parseInt(a[1]); bw.write(answer+\"\\n\"); // write는 버퍼에 해당 값을 저장하는것. // flush는 버퍼에 있는 내용을 printf하는것이다. // 여기서 한번 flush를 해버리면 버퍼의 내용을 출력과 동시에 비운다. &#125; bw.flush(); bw.close(); &#125;&#125;public class TEST03 &#123; public static void main(String[] args) throws IOException &#123; // import java.util.*; // Scanner scan = new Scanner(System.in); TEST03_12 test03_12 = new TEST03_12(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준_TEST02_사칙연산 도전하기","slug":"Algorism-for-java02","date":"2019-09-04T10:26:42.000Z","updated":"2019-10-02T09:10:45.829Z","comments":true,"path":"2019/09/04/Algorism-for-java02/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java02/","excerpt":"","text":"백준 TEST02_사칙연산 도전하기A*B123456789101112131415161718192021import java.util.*;//1번 2번은 TEST01단계에서 해결했음. A+B , A-Bclass TEST02_03&#123; public TEST02_03()&#123; // 생성자 Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.println(a*b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_03 test02_03 = new TEST02_03(); &#125;&#125; A / B (오차범위 10-9까지)1234567891011121314151617181920import java.util.*;class TEST02_04&#123; public TEST02_04()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;0 &amp;&amp; b&lt;10)&#123; System.out.printf(\"%.9f\",a/b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자// TEST02_03 test02_03 = new TEST02_03(); TEST02_04 test02_04 = new TEST02_04(); &#125;&#125; 사칙연산1234567891011121314151617181920212223import java.util.*;class TEST02_05&#123; public TEST02_05()&#123; Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); if(a&gt;=1 &amp;&amp; b&lt;=10000)&#123; System.out.println((int)a+(int)b); System.out.println((int)a-(int)b); System.out.println((int)a*(int)b); System.out.println((int)a/(int)b); System.out.println((int)a%(int)b); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_05 test02_05 = new TEST02_05(); &#125;&#125; 나머지1234567891011121314151617181920212223import java.util.*;class TEST02_06&#123; public TEST02_06()&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); int c = scan.nextInt(); if(a&gt;=2 &amp;&amp; a&lt;=10000 &amp;&amp; b&gt;=2 &amp;&amp; b&lt;=10000 &amp;&amp; c&gt;=2 &amp;&amp; c&lt;=10000)&#123; System.out.println((a+b)%c); System.out.println((a%c + b%c)%c); System.out.println((a*b)%c); System.out.println((a%c * b%c)%c); &#125; &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_06 test02_06 = new TEST02_06(); &#125;&#125; A+B-2 백준 TEST01 단계의 A+B 동일 문제. 따라서 넘어감. 설탕 배달 알고리즘1234567891011121314151617181920212223242526272829303132import java.util.*;class TEST02_08&#123; public TEST02_08()&#123; Scanner scan = new Scanner(System.in); int box = 0 ; int sugar_kg = scan.nextInt(); if(sugar_kg &gt;=3 &amp;&amp; sugar_kg &lt;= 5000)&#123; if(sugar_kg/5 != 0)&#123; for(box = sugar_kg/5;box&gt;=0;box--)&#123; if((sugar_kg - box*5)%3==0)&#123; box += (sugar_kg - box*5)/3; break; &#125; &#125; &#125; else if(sugar_kg == 3)&#123; box = 1; &#125; else&#123; box = -1; &#125; &#125; System.out.println(box); &#125;&#125;public class TEST02 &#123; public static void main(String[] args) &#123; // 생성자 TEST02_08 test02_08 = new TEST02_08(); &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"백준 TEST01_입/출력 받아보기","slug":"Algorism-for-java01","date":"2019-09-04T10:26:38.000Z","updated":"2019-10-02T09:10:32.255Z","comments":true,"path":"2019/09/04/Algorism-for-java01/","link":"","permalink":"http://yoursite.com/2019/09/04/Algorism-for-java01/","excerpt":"","text":"# # 백준 TEST01_입/출력 받아보기 Hello World12345public class TEST01_01 &#123; public static void main(String args[])&#123; System.out.println(\"Hellow World\"); &#125;&#125; A+B12345678910import java.util.*;public class TEST01_02&#123; public static void main(String args[])&#123; Scanner scan = new Scanner(System.in); int a, b; a = scan.nextInt(); b = scan.nextInt(); System.out.println(a + b); &#125;&#125; A-B1234567891011import java.util.*;public class TEST01_03 &#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); System.out.println(a-b); &#125;&#125; 등록텍스트 추가 123456public class TEST01_04 &#123; public static void main(String[] args)&#123; System.out.println(\"맞은갯수\"); System.out.println(\"아이디명\"); &#125;&#125; 개텍스트 추가 1234567891011public class TEST01_05 &#123; public static void main(String[] args)&#123; System.out.println(\"|\\\\_/|\"); //역슬래쉬를 print로 표시하고 싶으면 \\\\로 사용. System.out.println(\"|q p| /&#125;\"); System.out.println(\"( 0 )\\\"\\\"\\\"\\\\\"); //따옴표를 print로 표시하고 싶으면 \\\"로 사용. System.out.println(\"|\\\"^\\\"` |\"); System.out.println(\"||_/=\\\\\\\\__|\"); &#125;&#125; We love kriii12345public class TEST01_06 &#123; public static void main(String[] args)&#123; System.out.printf(\"강한친구 대한육군\\n강한친구 대한육군\\n\"); &#125;&#125; 그대로 출력하기 (연습)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. charAt(i) =&gt; str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. substring(i,j) =&gt; i부터 j-1까지. 문제점 -&gt; 0~100줄까지 전부 입력을 해야하는데 빈줄이 주어지지않는다. 라는 점에서 문제가 있다고 생각함. 만족 조건은 입력 최대 100줄과 각 줄이 100줄을 넘을 경우 잘라내는 기능 까지만 구현이 완료됬음. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;public class TEST01_07 &#123; public static boolean checkInputOnlyNumberAndAlphabet(String str) &#123; char chrInput = str.charAt(0); for (int i = 0; i &lt; str.length(); i++) &#123; chrInput = str.charAt(i); // 입력받은 텍스트에서 문자 하나하나 가져와서 체크 // charAt(i) = str문자열에 담은 문자열에서 첫번째문자를 chrInput에 담는다. if (chrInput &gt;= 0x61 &amp;&amp; chrInput &lt;= 0x7A) &#123; // 영문(소문자) OK! &#125; else if (chrInput &gt;=0x41 &amp;&amp; chrInput &lt;= 0x5A) &#123; // 영문(대문자) OK! &#125; else if (chrInput &gt;= 0x30 &amp;&amp; chrInput &lt;= 0x39) &#123; // 숫자 OK! &#125; else &#123; return false; // 영문자도 아니고 숫자도 아님! &#125; &#125; return true; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); for (int n = 0; n &lt; 100; n++) &#123; String str = scan.nextLine(); if (str.length() &gt; 100) &#123; str = str.substring(0, 100); &#125; // substring(i) =&gt; 하나의 인자값 해당 인덱스부터 모든 글자 리턴. 예를들어 i=3 일경우 3부터 모든값. // substring(i,j) =&gt; i부터 j-1까지. if (checkInputOnlyNumberAndAlphabet(str)) &#123; System.out.println(str); &#125;//줄에 영문,숫자를 제외한 다른글자가 포함되어있을 경우 출력을 안함. &#125; // for문 끝 &#125; &#125; 그대로 출력하기 (답)* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. * 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다. 고친점 : 너무 어렵게 생각하고 있었음. 굳이 함수를 따로 생성하지 않고 hasNextLine()을 이용해 엔터를 치면서 게속해서 글을 작성하도록 변경 그 외 함수를 추가적으로 이용하였음. ArryList에 제네릭을 이용하여 String만 받기로 함. -함수-각 줄은 100글자를 넘지 않으며: word.length() &gt; 100 빈 줄은 주어지지 않는다: word.isEmpty() 각 줄은 공백으로 시작하지 않고: word.startsWith(“ “) 공백으로 끝나지 않는다: word.endsWith(“ “) 1234567891011121314151617181920212223242526272829303132333435import java.util.*; public class TEST01_07_ANS &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.startsWith(\" \") || word.endsWith(\" \") || word.length()&gt;100 || word.isEmpty()) &#123; break; &#125; array.add(word); &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); &#125; &#125; &#125; /*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break빈 줄은 주어지지 않는다: word.isEmpty()-&gt; 빈줄일경우 break각 줄은 공백으로 시작하지 않고: word.startsWith(\" \")-&gt; 첫글자가 공백 일경우 break공백으로 끝나지 않는다: word.endsWith(\" \")-&gt; 마지막 글자가 공백 일 경우 break */ 그대로 출력하기2* 입력이 주어진다. * 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. * 각 줄은 100글자를 넘지 않으며, 빈 줄이 있을 수도 있다. * 각 줄은 공백으로 시작할수도 있고, 공백으로 끝날수도 있다. 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Scanner;public class TEST01_08 &#123; public static void main(String[] args) &#123; Scanner scan= new Scanner(System.in); ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; //입력이 있다면 게속적으로 true를 반환 ^z입력시 false를 반환 //즉 ^z전까지는 게속적으로 true이기 때문에 무한반복. String word = scan.nextLine(); if (word.length()&gt;100 ) &#123; break; &#125; if(word.equals(\"BYE\"))&#123; //BYE를 입력해서 WHILE 탈출 break; &#125; array.add(word); //현재 줄의 입력내용을 Array배열에 추가. &#125; scan.close();// while이 끝나면 scan을 닫는다. for (int i = 0; i &lt; array.size(); i++) &#123; System.out.println(array.get(i)); // 각 Array배열의 내용을 출력. &#125; &#125;&#125;/*각 줄은 100글자를 넘지 않으며: word.length() &gt; 100-&gt; 100글자 이상일 경우 break*/","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"Algorithm","slug":"TIL/Algorithm","permalink":"http://yoursite.com/categories/TIL/Algorithm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"},{"name":"algorism","slug":"algorism","permalink":"http://yoursite.com/tags/algorism/"}]},{"title":"ETC-test","slug":"ETC-test","date":"2019-09-04T05:04:06.000Z","updated":"2019-10-02T10:16:38.424Z","comments":true,"path":"2019/09/04/ETC-test/","link":"","permalink":"http://yoursite.com/2019/09/04/ETC-test/","excerpt":"","text":"","categories":[{"name":"etc","slug":"etc","permalink":"http://yoursite.com/categories/etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-03T13:04:58.334Z","updated":"2019-09-03T13:08:10.424Z","comments":true,"path":"2019/09/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"20190903-personal-study-html","slug":"20190903-personal-study-html","date":"2019-09-03T12:54:57.000Z","updated":"2019-10-02T08:53:40.946Z","comments":true,"path":"2019/09/03/20190903-personal-study-html/","link":"","permalink":"http://yoursite.com/2019/09/03/20190903-personal-study-html/","excerpt":"","text":"20190903-Test-web-page Study파일 구조 style.css1234567891011121314151617181920212223242526272829303132body&#123;overflow: hidden;&#125;.image&#123;position:relative;float: left;height: 200px;width:300px;margin : 2px;border: 1px solid white;z-index:0;&#125;.image-selected&#123; border: 1px solid black;background-color:white;&#125;.image-selected &gt; img&#123;opacity: 0.5;&#125;.image &gt; img&#123;height:100%;&#125;.image-magnified&#123;z-index:1;&#125;.image-magnified &gt; img&#123;height:400px;width:600px;margin-left:-150px;margin-top:-100px;opacity:0.95;&#125; image_list.json1234567891011121314[\"./images/1.jpg\",\"./images/2.jpg\",\"./images/3.jpg\",\"./images/4.jpg\",\"./images/5.jpg\",\"./images/6.jpg\",\"./images/7.jpg\",\"./images/8.jpg\",\"./images/9.jpg\",\"./images/10.jpg\",\"./images/11.jpg\",\"./images/12.jpg\"] index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;title&gt;Select the Gallery&lt;/title&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Show\" onclick=\"slideShow(this)\"&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; script.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var req = new XMLHttpRequest();req.open(\"GET\", \"./json/image_list.json\");req.onreadystatechange = function()&#123;if(this.readyState == 4)&#123;var data = JSON.parse(this.response);for(var i= 0; i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125;div.onmouseover = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000);&#125;div.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125;var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);&#125;&#125;&#125;req.send();function selectAll(btn)&#123;var img = document.getElementsByClassName(\"image\");for(var i=0; i&lt;img.length; i++)&#123;if(btn.value == \"UnSelect All\")&#123;img[i].classList.remove(\"image-selected\");&#125;else&#123;img[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"UnSelect All\")&#123;btn.value = \"Select All\";&#125;else&#123;btn.value = \"UnSelect All\";&#125;&#125;function slideShow(btn)&#123;var img = document.getElementsByClassName(\"image\");var index = 0;img[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;img[index].classList.remove(\"image-magnified\");index ++;if(index &lt; img.length)&#123;img[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝낫습니다.\");&#125;&#125;,1000);&#125; 프로젝트에 images 폴더 추가 프로젝트에 json 폴더 추가 프로젝트에 css 파일 추가 script 파일 생성 html 태그 안에 script 파일 및 css 파일 연결 1234&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\"&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt;&lt;/head&gt; script 파일 작성 시작 1 Ajax 사용하여 비동기방식으로 json 데이터를 요청하고 응답한 값을 가지고 것 임. 123456789101112131415161718192021222324252627var req = new XMLHttpRequest(); // 1. Ajax를 이용하기 위한 객체를 생성req.open(\"GET\",\"./json/image_list.json\"); // 2. 요청방식과 URL 설정// 3. onreadystatechange : 서버로부터 응답시 할 행동을 작성req.onreadystatechange = function()&#123; // 4. 4번 -&gt; 모든 응답이 제대로 받았을 겅우를 의미if(this.readyState == 4)&#123; // 5. 응답데이터(문자열)를 javascript 객체로 변환하고 div태그를 생성하여 데이터를 대입해줍니다.// div 태그의 속성은 class = \"image\" 로 설정합니다.var data = JSON.parse(this.response); for(var i=0;i&lt;data.length;i++)&#123;var div = document.createElement(\"div\");div.setAttribute(\"class\",\"image\");// 6. img 태그를 생성하고 각 데이터를 img태그에 넣습니다. // img 태그는 div태그의 자손으로, div태그는 dody태그의 자손으로 삽입합니다.var img = document.createElement(\"img\");img.src = data[i];div.appendChild(img);document.body.appendChild(div);//밑에서 추가 진행함&#125; &#125; &#125;req.send(); // 요청합니다. script 파일 작성 시작 2 생성된 div 태그에 기능을 추가합니다. 기능은 총 3가지입니다. 클릭 (onclick) 1234567891011121314// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성// 1. 생성된 태그에 클릭 이벤트를 넣어줍니다. // 선택 및 취소 했을 경우 스타일 달리지도록 만듭니다.// 선택시 image-selected , 미선택시 imagediv.setAttribute(\"class\",\"image\");div.onclick = function()&#123;if(this.getAttribute(\"class\").indexOf(\"image-selected\") == -1)&#123;this.setAttribute(\"class\",\"image image-selected\");&#125;else&#123;this.setAttribute(\"class\",\"image\");&#125;&#125; 위 문의 if문과 else 문은 classList 함수를 이용하여 짧게 가능.1234// for문 안의 div.setAttribute(\"class\",\"image\"); 다음 줄부터 작성div.onclick = function()&#123;this.classList.toggle(\"image-selected\");&#125; 마우스 오버 (onmouseover) 123456789// 2. 생성된 태그에 마우스오버 이벤트를 넣어줍니다.// div 위에 마우스가 올라갈 경우 시간만큼 스타일이 달라지도록 만듭니다.// 사용할 css style : image-magnifieddiv.onmouseove = function()&#123;var element = this;this.timerId = setTimeout( function()&#123;element.classList.add(\"image-magnified\");&#125;,1000); //1초&#125; 마우스 아웃 (onmouseout) 12345678// 3. 생성된 태그에 마우스아웃 이벤트를 넣어줍니다.// div 위에 마우스가 빠져나갈 경우 적용된 스타일을 제거하고 시간을 초기화 하도록 만듭니다.// 제거할 css style : image-magnifieddiv.onmouseout = function()&#123;clearTimeout(this.timerId);var element = this;element.classList.remove(\"image-magnified\");&#125; html 파일 안 태그 안에 2개의 버튼을 생성하고 click 이벤트를 연결합니다. 모두 선택 및 해제 기능 각 이미지가 1번씩 크게 보여지는 슬라이드 쇼 기능 123456&lt;body&gt;&lt;input type=\"button\" value=\"Select All\" onclick=\"selectAll(this)\"&gt;&lt;input type=\"button\" value=\"Play Slidshow\" onclick=\"slideShow(this)\"&gt; &lt;!-- 사용될 함수에서 해당 button 객체의 value값을 이용하기 위해 인자로 this를 넘겨줍니다. --&gt;&lt;hr&gt; &lt;!-- 한줄 띄어줍니다. --&gt;&lt;/body&gt; script 파일 작성 : 모두 선택 기능 추가. 1234567891011121314151617function selectAll(btn)&#123;var images = document.getElementsByClassName(\"image\"); //div class명이 image입니다.for(var i=0; i&lt;images.length ; i++)&#123;if(btn.value == \"Unselect All\")&#123;images[i].classList.remove(\"image-selected\");&#125;else&#123;images[i].classList.add(\"image-selected\");&#125;&#125;if(btn.value == \"Unselect All\")&#123;btn.value = \"Selcet All\";&#125;else&#123;btn.value = \"Unselect All\";&#125;&#125; script 파일 작성 : 슬라이드쇼 기능 추가. 12345678910111213141516function slideShow(btn)&#123;var images = document.getElementsByClassName(\"image\");var index = 0;images[index].classList.add(\"image-magnified\");var intervalId = setInterval( function()&#123;images[index].classList.remove(\"image-magnified\");index++;if(index &lt; images.length)&#123;images[index].classList.add(\"image-magnified\");&#125;else&#123;clearInterval(intervalId);alert(\"슬라이드가 끝났습니다.\");&#125;&#125;,1000);","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"20190902-start-git","slug":"20190902-start-git","date":"2019-09-02T12:52:11.000Z","updated":"2019-10-02T08:53:05.685Z","comments":true,"path":"2019/09/02/20190902-start-git/","link":"","permalink":"http://yoursite.com/2019/09/02/20190902-start-git/","excerpt":"","text":"20190902-start-git* git 개발은 항상 끊어서 커밋 해야만 한다. 그리고 영어로 쓰는 것을 습관화들여라! *Git CLI 기본 설정. ( 설정이 완료되있다면 git 시작하기 1 or 2부터 시작 ) * git config –list ( git 설저한 내용 확인 ) git config –global user.name “HYEOK999”. git config –list (위에서 입력한 내용 확인). git config –global user.email “iasg2004@naver.com“. git config –global editor “vim”. git 시작하기1 ( local -&gt; remote ) 가장 중요한 명령어 : 현재 상태 확인 git status 폴더생성 및 폴더 진입 git init git diff git status(현재 상태) 파일 생성 및 내용 작성 git add 파일명.확장자 github 계정 페이지에 접속 후 레파지토리에서 new를 누르고 저장소를 만든다. 저장소 명은 폴더명과 같게끔 설정할것. 만든후 주소 복사. git remote add [origin] 주소복붙 등록 확인 -&gt; git remote git commit 편집모드( i ) 들어가서 첫줄이 제목 (엔터치기 전까지) 다음줄이 내용! commit 제목은 현재형 구나 절로 적는다! / 내용은 자세하게 적는다. feat : 협업 docs : 문서작업 bugfix : 버그를 수정했을 때 hotfix : 빠르게, 급하게 수정했을 때 release : 개발 git push -u [origin] master -u : 로컬 브랜치를 새로 만든 후 원격저장소에 해당 브랜치를 push하고자 할 때 처음 이후의 Git Commit 파일 및 폴더 내용 수정 및 추가 git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용 “ git push [origin] master git 시작하기2 ( remote -&gt; local ) 가장 중요한 명령어 : 현재 상태 확인 git status 저장소 생성 ( public , gitignore:Node , LICENSE:MIT ). 저장소 주소 복사 git clone 주소복붙. 파일 및 폴더 내용 수정 및 추가. git add 파일명.확장자 git commit -m “docs: 제목 [엔터] 내용” git push [origin] master.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"GIT","slug":"TIL/GIT","permalink":"http://yoursite.com/categories/TIL/GIT/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"20190902-study-terminal","slug":"20190902-study-terminal","date":"2019-09-02T12:52:11.000Z","updated":"2019-10-02T08:53:27.970Z","comments":true,"path":"2019/09/02/20190902-study-terminal/","link":"","permalink":"http://yoursite.com/2019/09/02/20190902-study-terminal/","excerpt":"","text":"20190902-study-termianl 기본적인 리눅스 리눅스 : 커널 또는 GNU를 포함한 라오픈 라이브러리와 도구가 포함된 운영체제. 여러종류의 쉘을 제공함. Shell : 운영체제의 커널과 사용자를 이어주는 소프트웨어 CLI . ( Shell 사용할 경우 GUI보다 효율성이 높다. )Kenal : 컴퓨터와 소프트웨어를 이어 주는 시스템소프트웨어 터미널 리눅스(유닉스) 명령어 명령어 의미 예 ctr+c키 명령어 취소 ~ 접속시 나오는 폴더를 의미 ls 현재 폴더에서 접속가능한 폴더 리스트를 나열함. -a 숨긴파일도 표시 -l 파일의 추가정보를 나열하며 한줄씩 표시 cd Change Directory 의 약자. 폴더 이동 .. 상위 폴더를 의미 mkdir MaKe DIRectory 의 약자. 폴더 생성 mv {1} {2} MoVe의 약자.{1}을 {2}로 이동 mv {1} {2} (같은 위치에 있을경우) {1}을 {2}로 이름바꾸기 cp {1} {2} CoPy의 약자. {1}을 {2}로 이동 rm {1} ReMove의 약자. 파일을 삭제. rm -r {1} {1}이 폴더 일 경우. 폴더를 삭제. touch 파일 생성 ( 생성할떄 파일명 앞에 . 을 붙이면 히든파일생성) chmod {권한} {폴더 및 파일} {폴더 및 파일}을 {권한}으로 권한 레벨 변경. chmod 555 study.html Vim 명령어 vi {1} : {1}을 vim으로 열기. (vim은 에디트)ext : 어떠한 모드에서 기본모드로 돌아감. 모드 3가지 ( 기본, I , : )기본 명령어 의미 예 Y 커서가 놓인 줄 복사 P 커서가 놓인 줄 아래에 붙여넣기 dd 커서가 놓인 줄 잘라내기 x 커서놓인 곳 한글자 삭제. i 커서가 놓은 곳 앞에 i 모드 돌입. o 커서가 놓인 줄 아래에 i 모드 돌입. O 커서 놓은 줄 위에 i 모드 돌입. Insert 편집 모드 ( key - i ) 명령어 의미 예 exc키 노멀모드로 돌아감. 명령어 모드 ( key - : ) 명령어 의미 예 q quit의 약자. vim 편집기를 나감. !q 저정하지않고 나감. wq 저장하면서 나감. exc키 가본 모드로 돌아감.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"},{"name":"linux","slug":"TIL/linux","permalink":"http://yoursite.com/categories/TIL/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]},{"title":"post-test","slug":"post-test","date":"2019-09-01T12:28:38.000Z","updated":"2019-10-02T10:16:20.346Z","comments":true,"path":"2019/09/01/post-test/","link":"","permalink":"http://yoursite.com/2019/09/01/post-test/","excerpt":"","text":"SSS","categories":[{"name":"etc","slug":"etc","permalink":"http://yoursite.com/categories/etc/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"coding","slug":"coding","permalink":"http://yoursite.com/tags/coding/"},{"name":"developer","slug":"developer","permalink":"http://yoursite.com/tags/developer/"}]}]}